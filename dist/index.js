/****************************************************************************
 * Copyright 2021 EPAM Systems
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ***************************************************************************/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _inherits = require('@babel/runtime/helpers/inherits');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var assert = require('assert');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var _typeof = require('@babel/runtime/helpers/typeof');
var reactDeviceDetect = require('react-device-detect');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');
var _classPrivateFieldSet = require('@babel/runtime/helpers/classPrivateFieldSet');
var _classPrivateFieldGet = require('@babel/runtime/helpers/classPrivateFieldGet');
var _get = require('@babel/runtime/helpers/get');
var d3 = require('d3');
var _ = require('lodash');
var Raphael = require('raphael');
var svgPath = require('svgpath');
var fp = require('lodash/fp');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var t = require('querystring');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var assert__default = /*#__PURE__*/_interopDefaultLegacy(assert);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);
var _classPrivateFieldSet__default = /*#__PURE__*/_interopDefaultLegacy(_classPrivateFieldSet);
var _classPrivateFieldGet__default = /*#__PURE__*/_interopDefaultLegacy(_classPrivateFieldGet);
var _get__default = /*#__PURE__*/_interopDefaultLegacy(_get);
var ___default = /*#__PURE__*/_interopDefaultLegacy(_);
var Raphael__default = /*#__PURE__*/_interopDefaultLegacy(Raphael);
var svgPath__default = /*#__PURE__*/_interopDefaultLegacy(svgPath);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);
var t__default = /*#__PURE__*/_interopDefaultLegacy(t);

var ElementColor = {
  H: '#000000',
  He: '#89a1a1',
  Li: '#bd77ed',
  Be: '#8fbc00',
  B: '#c18989',
  C: '#000000',
  N: '#304ff7',
  O: '#ff0d0d',
  F: '#78bc42',
  Ne: '#80a2af',
  Na: '#ab5cf2',
  Mg: '#6fcd00',
  Al: '#a99393',
  Si: '#b29478',
  P: '#ff8000',
  S: '#c99a19',
  Cl: '#1fd01f',
  Ar: '#69acba',
  K: '#8f40d4',
  Ca: '#38e900',
  Sc: '#999999',
  Ti: '#979a9e',
  V: '#99999e',
  Cr: '#8a99c7',
  Mn: '#9c7ac7',
  Fe: '#e06633',
  Co: '#d37e8e',
  Ni: '#4ece4e',
  Cu: '#c78033',
  Zn: '#7d80b0',
  Ga: '#bc8b8b',
  Ge: '#668f8f',
  As: '#b87ddd',
  Se: '#e59100',
  Br: '#a62929',
  Kr: '#59b1c9',
  Rb: '#702eb0',
  Sr: '#00ff00',
  Y: '#66afaf',
  Zr: '#71abab',
  Nb: '#67aeb4',
  Mo: '#54b5b5',
  Tc: '#3b9e9e',
  Ru: '#248f8f',
  Rh: '#0a7d8c',
  Pd: '#006985',
  Ag: '#9a9a9a',
  Cd: '#b29764',
  In: '#a67573',
  Sn: '#668080',
  Sb: '#9e63b5',
  Te: '#d47a00',
  I: '#940094',
  Xe: '#429eb0',
  Cs: '#57178f',
  Ba: '#00c900',
  La: '#5caed1',
  Ce: '#9d9d7b',
  Pr: '#8ca581',
  Nd: '#84a984',
  Pm: '#71b18a',
  Sm: '#66b68e',
  Eu: '#4ac298',
  Gd: '#37cb9e',
  Tb: '#28d1a4',
  Dy: '#1bd7a8',
  Ho: '#00e98f',
  Er: '#00e675',
  Tm: '#00d452',
  Yb: '#00bf38',
  Lu: '#00ab24',
  Hf: '#47b3ec',
  Ta: '#4da6ff',
  W: '#2194d6',
  Re: '#267dab',
  Os: '#266696',
  Ir: '#175487',
  Pt: '#9898a3',
  Au: '#c19e1c',
  Hg: '#9797ac',
  Tl: '#a6544d',
  Pb: '#575961',
  Bi: '#9e4fb5',
  Po: '#ab5c00',
  At: '#754f45',
  Rn: '#428296',
  Fr: '#420066',
  Ra: '#007d00',
  Ac: '#6aa2ec',
  Th: '#00baff',
  Pa: '#00a1ff',
  U: '#008fff',
  Np: '#0080ff',
  Pu: '#006bff',
  Am: '#545cf2',
  Cm: '#785ce3',
  Bk: '#8a4fe3',
  Cf: '#a136d4',
  Es: '#b31fd4',
  Fm: '#000000',
  Md: '#000000',
  No: '#000000',
  Lr: '#000000',
  Rf: '#47b3ec',
  Db: '#4da6ff',
  Sg: '#2194d6',
  Bh: '#267dab',
  Hs: '#266696',
  Mt: '#175487',
  Ds: '#9898a3',
  Rg: '#c19e1c',
  Cn: '#9797ac',
  Nh: '#000000',
  Fl: '#000000',
  Mc: '#000000',
  Lv: '#000000',
  Ts: '#000000',
  Og: '#000000'
};

var elementsArray = [{
  number: 1,
  label: 'H',
  period: 1,
  group: 1,
  title: 'Hydrogen',
  state: 'gas',
  origin: 'primordial',
  type: 'other-nonmetal',
  mass: 1.00794
}, {
  number: 2,
  label: 'He',
  period: 1,
  group: 8,
  title: 'Helium',
  state: 'gas',
  origin: 'primordial',
  type: 'noble',
  mass: 4.0026022
}, {
  number: 3,
  label: 'Li',
  period: 2,
  group: 1,
  title: 'Lithium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkali',
  mass: 6.94
}, {
  number: 4,
  label: 'Be',
  period: 2,
  group: 2,
  title: 'Beryllium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkaline-earth',
  mass: 9.01218315
}, {
  number: 5,
  label: 'B',
  period: 2,
  group: 3,
  title: 'Boron',
  state: 'solid',
  origin: 'primordial',
  type: 'metalloid',
  mass: 10.81
}, {
  number: 6,
  label: 'C',
  period: 2,
  group: 4,
  title: 'Carbon',
  state: 'solid',
  origin: 'primordial',
  type: 'other-nonmetal',
  mass: 12.011
}, {
  number: 7,
  label: 'N',
  period: 2,
  group: 5,
  title: 'Nitrogen',
  state: 'gas',
  origin: 'primordial',
  type: 'other-nonmetal',
  mass: 14.007
}, {
  number: 8,
  label: 'O',
  period: 2,
  group: 6,
  leftH: true,
  title: 'Oxygen',
  state: 'gas',
  origin: 'primordial',
  type: 'other-nonmetal',
  mass: 15.999
}, {
  number: 9,
  label: 'F',
  period: 2,
  group: 7,
  leftH: true,
  title: 'Fluorine',
  state: 'gas',
  origin: 'primordial',
  type: 'halogen',
  mass: 18.9984031636
}, {
  number: 10,
  label: 'Ne',
  period: 2,
  group: 8,
  title: 'Neon',
  state: 'gas',
  origin: 'primordial',
  type: 'noble',
  mass: 20.17976
}, {
  number: 11,
  label: 'Na',
  period: 3,
  group: 1,
  title: 'Sodium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkali',
  mass: 22.989769282
}, {
  number: 12,
  label: 'Mg',
  period: 3,
  group: 2,
  title: 'Magnesium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkaline-earth',
  mass: 24.305
}, {
  number: 13,
  label: 'Al',
  period: 3,
  group: 3,
  title: 'Aluminium',
  state: 'solid',
  origin: 'primordial',
  type: 'post-transition',
  mass: 26.98153857
}, {
  number: 14,
  label: 'Si',
  period: 3,
  group: 4,
  title: 'Silicon',
  state: 'solid',
  origin: 'primordial',
  type: 'metalloid',
  mass: 28.085
}, {
  number: 15,
  label: 'P',
  period: 3,
  group: 5,
  title: 'Phosphorus',
  state: 'solid',
  origin: 'primordial',
  type: 'other-nonmetal',
  mass: 30.9737619985
}, {
  number: 16,
  label: 'S',
  period: 3,
  group: 6,
  leftH: true,
  title: 'Sulfur',
  state: 'solid',
  origin: 'primordial',
  type: 'other-nonmetal',
  mass: 32.06
}, {
  number: 17,
  label: 'Cl',
  period: 3,
  group: 7,
  leftH: true,
  title: 'Chlorine',
  state: 'gas',
  origin: 'primordial',
  type: 'halogen',
  mass: 35.45
}, {
  number: 18,
  label: 'Ar',
  period: 3,
  group: 8,
  title: 'Argon',
  state: 'gas',
  origin: 'primordial',
  type: 'noble',
  mass: 39.9481
}, {
  number: 19,
  label: 'K',
  period: 4,
  group: 1,
  title: 'Potassium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkali',
  mass: 39.09831
}, {
  number: 20,
  label: 'Ca',
  period: 4,
  group: 2,
  title: 'Calcium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkaline-earth',
  mass: 40.0784
}, {
  number: 21,
  label: 'Sc',
  period: 4,
  group: 3,
  title: 'Scandium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 44.9559085
}, {
  number: 22,
  label: 'Ti',
  period: 4,
  group: 4,
  title: 'Titanium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 47.8671
}, {
  number: 23,
  label: 'V',
  period: 4,
  group: 5,
  title: 'Vanadium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 50.94151
}, {
  number: 24,
  label: 'Cr',
  period: 4,
  group: 6,
  title: 'Chromium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 51.99616
}, {
  number: 25,
  label: 'Mn',
  period: 4,
  group: 7,
  title: 'Manganese',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 54.9380443
}, {
  number: 26,
  label: 'Fe',
  period: 4,
  group: 8,
  title: 'Iron',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 55.8452
}, {
  number: 27,
  label: 'Co',
  period: 4,
  group: 8,
  title: 'Cobalt',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 58.9331944
}, {
  number: 28,
  label: 'Ni',
  period: 4,
  group: 8,
  title: 'Nickel',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 58.69344
}, {
  number: 29,
  label: 'Cu',
  period: 4,
  group: 1,
  title: 'Copper',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 63.5463
}, {
  number: 30,
  label: 'Zn',
  period: 4,
  group: 2,
  title: 'Zinc',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 65.382
}, {
  number: 31,
  label: 'Ga',
  period: 4,
  group: 3,
  title: 'Gallium',
  state: 'solid',
  origin: 'primordial',
  type: 'post-transition',
  mass: 69.7231
}, {
  number: 32,
  label: 'Ge',
  period: 4,
  group: 4,
  title: 'Germanium',
  state: 'solid',
  origin: 'primordial',
  type: 'metalloid',
  mass: 72.6308
}, {
  number: 33,
  label: 'As',
  period: 4,
  group: 5,
  title: 'Arsenic',
  state: 'solid',
  origin: 'primordial',
  type: 'metalloid',
  mass: 74.9215956
}, {
  number: 34,
  label: 'Se',
  period: 4,
  group: 6,
  leftH: true,
  title: 'Selenium',
  state: 'solid',
  origin: 'primordial',
  type: 'other-nonmetal',
  mass: 78.9718
}, {
  number: 35,
  label: 'Br',
  period: 4,
  group: 7,
  leftH: true,
  title: 'Bromine',
  state: 'liquid',
  origin: 'primordial',
  type: 'halogen',
  mass: 79.904
}, {
  number: 36,
  label: 'Kr',
  period: 4,
  group: 8,
  title: 'Krypton',
  state: 'gas',
  origin: 'primordial',
  type: 'noble',
  mass: 83.7982
}, {
  number: 37,
  label: 'Rb',
  period: 5,
  group: 1,
  title: 'Rubidium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkali',
  mass: 85.46783
}, {
  number: 38,
  label: 'Sr',
  period: 5,
  group: 2,
  title: 'Strontium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkaline-earth',
  mass: 87.621
}, {
  number: 39,
  label: 'Y',
  period: 5,
  group: 3,
  title: 'Yttrium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 88.905842
}, {
  number: 40,
  label: 'Zr',
  period: 5,
  group: 4,
  title: 'Zirconium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 91.2242
}, {
  number: 41,
  label: 'Nb',
  period: 5,
  group: 5,
  title: 'Niobium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 92.906372
}, {
  number: 42,
  label: 'Mo',
  period: 5,
  group: 6,
  title: 'Molybdenum',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 95.951
}, {
  number: 43,
  label: 'Tc',
  period: 5,
  group: 7,
  title: 'Technetium',
  state: 'solid',
  origin: 'decay',
  type: 'transition',
  mass: 98
}, {
  number: 44,
  label: 'Ru',
  period: 5,
  group: 8,
  title: 'Ruthenium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 101.072
}, {
  number: 45,
  label: 'Rh',
  period: 5,
  group: 8,
  title: 'Rhodium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 102.905502
}, {
  number: 46,
  label: 'Pd',
  period: 5,
  group: 8,
  title: 'Palladium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 106.421
}, {
  number: 47,
  label: 'Ag',
  period: 5,
  group: 1,
  title: 'Silver',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 107.86822
}, {
  number: 48,
  label: 'Cd',
  period: 5,
  group: 2,
  title: 'Cadmium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 112.4144
}, {
  number: 49,
  label: 'In',
  period: 5,
  group: 3,
  title: 'Indium',
  state: 'solid',
  origin: 'primordial',
  type: 'post-transition',
  mass: 114.8181
}, {
  number: 50,
  label: 'Sn',
  period: 5,
  group: 4,
  title: 'Tin',
  state: 'solid',
  origin: 'primordial',
  type: 'post-transition',
  mass: 118.7107
}, {
  number: 51,
  label: 'Sb',
  period: 5,
  group: 5,
  title: 'Antimony',
  state: 'solid',
  origin: 'primordial',
  type: 'metalloid',
  mass: 121.7601
}, {
  number: 52,
  label: 'Te',
  period: 5,
  group: 6,
  title: 'Tellurium',
  state: 'solid',
  origin: 'primordial',
  type: 'metalloid',
  mass: 127.603
}, {
  number: 53,
  label: 'I',
  period: 5,
  group: 7,
  leftH: true,
  title: 'Iodine',
  state: 'solid',
  origin: 'primordial',
  type: 'halogen',
  mass: 126.904473
}, {
  number: 54,
  label: 'Xe',
  period: 5,
  group: 8,
  title: 'Xenon',
  state: 'gas',
  origin: 'primordial',
  type: 'noble',
  mass: 131.2936
}, {
  number: 55,
  label: 'Cs',
  period: 6,
  group: 1,
  title: 'Caesium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkali',
  mass: 132.905451966
}, {
  number: 56,
  label: 'Ba',
  period: 6,
  group: 2,
  title: 'Barium',
  state: 'solid',
  origin: 'primordial',
  type: 'alkaline-earth',
  mass: 137.3277
}, {
  number: 57,
  label: 'La',
  period: 6,
  group: 3,
  title: 'Lanthanum',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 138.905477
}, {
  number: 58,
  label: 'Ce',
  period: 6,
  group: 3,
  title: 'Cerium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 140.1161
}, {
  number: 59,
  label: 'Pr',
  period: 6,
  group: 3,
  title: 'Praseodymium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 140.907662
}, {
  number: 60,
  label: 'Nd',
  period: 6,
  group: 3,
  title: 'Neodymium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 144.2423
}, {
  number: 61,
  label: 'Pm',
  period: 6,
  group: 3,
  title: 'Promethium',
  state: 'solid',
  origin: 'decay',
  type: 'lanthanide',
  mass: 145
}, {
  number: 62,
  label: 'Sm',
  period: 6,
  group: 3,
  title: 'Samarium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 150.362
}, {
  number: 63,
  label: 'Eu',
  period: 6,
  group: 3,
  title: 'Europium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 151.9641
}, {
  number: 64,
  label: 'Gd',
  period: 6,
  group: 3,
  title: 'Gadolinium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 157.253
}, {
  number: 65,
  label: 'Tb',
  period: 6,
  group: 3,
  title: 'Terbium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 158.925352
}, {
  number: 66,
  label: 'Dy',
  period: 6,
  group: 3,
  title: 'Dysprosium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 162.5001
}, {
  number: 67,
  label: 'Ho',
  period: 6,
  group: 3,
  title: 'Holmium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 164.930332
}, {
  number: 68,
  label: 'Er',
  period: 6,
  group: 3,
  title: 'Erbium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 167.2593
}, {
  number: 69,
  label: 'Tm',
  period: 6,
  group: 3,
  title: 'Thulium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 168.934222
}, {
  number: 70,
  label: 'Yb',
  period: 6,
  group: 3,
  title: 'Ytterbium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 173.0451
}, {
  number: 71,
  label: 'Lu',
  period: 6,
  group: 3,
  title: 'Lutetium',
  state: 'solid',
  origin: 'primordial',
  type: 'lanthanide',
  mass: 174.96681
}, {
  number: 72,
  label: 'Hf',
  period: 6,
  group: 4,
  title: 'Hafnium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 178.492
}, {
  number: 73,
  label: 'Ta',
  period: 6,
  group: 5,
  title: 'Tantalum',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 180.947882
}, {
  number: 74,
  label: 'W',
  period: 6,
  group: 6,
  title: 'Tungsten',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 183.841
}, {
  number: 75,
  label: 'Re',
  period: 6,
  group: 7,
  title: 'Rhenium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 186.2071
}, {
  number: 76,
  label: 'Os',
  period: 6,
  group: 8,
  title: 'Osmium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 190.233
}, {
  number: 77,
  label: 'Ir',
  period: 6,
  group: 8,
  title: 'Iridium',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 192.2173
}, {
  number: 78,
  label: 'Pt',
  period: 6,
  group: 8,
  title: 'Platinum',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 195.0849
}, {
  number: 79,
  label: 'Au',
  period: 6,
  group: 1,
  title: 'Gold',
  state: 'solid',
  origin: 'primordial',
  type: 'transition',
  mass: 196.9665695
}, {
  number: 80,
  label: 'Hg',
  period: 6,
  group: 2,
  title: 'Mercury',
  state: 'liquid',
  origin: 'primordial',
  type: 'transition',
  mass: 200.5923
}, {
  number: 81,
  label: 'Tl',
  period: 6,
  group: 3,
  title: 'Thallium',
  state: 'solid',
  origin: 'primordial',
  type: 'post-transition',
  mass: 204.38
}, {
  number: 82,
  label: 'Pb',
  period: 6,
  group: 4,
  title: 'Lead',
  state: 'solid',
  origin: 'primordial',
  type: 'post-transition',
  mass: 207.21
}, {
  number: 83,
  label: 'Bi',
  period: 6,
  group: 5,
  title: 'Bismuth',
  state: 'solid',
  origin: 'primordial',
  type: 'post-transition',
  mass: 208.980401
}, {
  number: 84,
  label: 'Po',
  period: 6,
  group: 6,
  title: 'Polonium',
  state: 'solid',
  origin: 'decay',
  type: 'metalloid',
  mass: 209
}, {
  number: 85,
  label: 'At',
  period: 6,
  group: 7,
  title: 'Astatine',
  state: 'solid',
  origin: 'decay',
  type: 'halogen',
  mass: 210
}, {
  number: 86,
  label: 'Rn',
  period: 6,
  group: 8,
  title: 'Radon',
  state: 'gas',
  origin: 'decay',
  type: 'noble',
  mass: 222
}, {
  number: 87,
  label: 'Fr',
  period: 7,
  group: 1,
  title: 'Francium',
  state: 'solid',
  origin: 'decay',
  type: 'alkali',
  mass: 223
}, {
  number: 88,
  label: 'Ra',
  period: 7,
  group: 2,
  title: 'Radium',
  state: 'solid',
  origin: 'decay',
  type: 'alkaline-earth',
  mass: 226
}, {
  number: 89,
  label: 'Ac',
  period: 7,
  group: 3,
  title: 'Actinium',
  state: 'solid',
  origin: 'decay',
  type: 'transition',
  mass: 227
}, {
  number: 90,
  label: 'Th',
  period: 7,
  group: 3,
  title: 'Thorium',
  state: 'solid',
  origin: 'primordial',
  type: 'actinide',
  mass: 232.03774
}, {
  number: 91,
  label: 'Pa',
  period: 7,
  group: 3,
  title: 'Protactinium',
  state: 'solid',
  origin: 'decay',
  type: 'actinide',
  mass: 231.035882
}, {
  number: 92,
  label: 'U',
  period: 7,
  group: 3,
  title: 'Uranium',
  state: 'solid',
  origin: 'primordial',
  type: 'actinide',
  mass: 238.028913
}, {
  number: 93,
  label: 'Np',
  period: 7,
  group: 3,
  title: 'Neptunium',
  state: 'solid',
  origin: 'decay',
  type: 'actinide',
  mass: 237
}, {
  number: 94,
  label: 'Pu',
  period: 7,
  group: 3,
  title: 'Plutonium',
  state: 'solid',
  origin: 'decay',
  type: 'actinide',
  mass: 244
}, {
  number: 95,
  label: 'Am',
  period: 7,
  group: 3,
  title: 'Americium',
  state: 'solid',
  origin: 'synthetic',
  type: 'actinide',
  mass: 243
}, {
  number: 96,
  label: 'Cm',
  period: 7,
  group: 3,
  title: 'Curium',
  state: 'solid',
  origin: 'synthetic',
  type: 'actinide',
  mass: 247
}, {
  number: 97,
  label: 'Bk',
  period: 7,
  group: 3,
  title: 'Berkelium',
  state: 'solid',
  origin: 'synthetic',
  type: 'actinide',
  mass: 247
}, {
  number: 98,
  label: 'Cf',
  period: 7,
  group: 3,
  title: 'Californium',
  state: 'solid',
  origin: 'synthetic',
  type: 'actinide',
  mass: 251
}, {
  number: 99,
  label: 'Es',
  period: 7,
  group: 3,
  title: 'Einsteinium',
  state: 'solid',
  origin: 'synthetic',
  type: 'actinide',
  mass: 252
}, {
  number: 100,
  label: 'Fm',
  period: 7,
  group: 3,
  title: 'Fermium',
  origin: 'synthetic',
  type: 'actinide',
  mass: 257
}, {
  number: 101,
  label: 'Md',
  period: 7,
  group: 3,
  title: 'Mendelevium',
  origin: 'synthetic',
  type: 'actinide',
  mass: 258
}, {
  number: 102,
  label: 'No',
  period: 7,
  group: 3,
  title: 'Nobelium',
  origin: 'synthetic',
  type: 'actinide',
  mass: 259
}, {
  number: 103,
  label: 'Lr',
  period: 7,
  group: 3,
  title: 'Lawrencium',
  origin: 'synthetic',
  type: 'actinide',
  mass: 266
}, {
  number: 104,
  label: 'Rf',
  period: 7,
  group: 4,
  title: 'Rutherfordium',
  origin: 'synthetic',
  type: 'transition',
  mass: 267
}, {
  number: 105,
  label: 'Db',
  period: 7,
  group: 5,
  title: 'Dubnium',
  origin: 'synthetic',
  type: 'transition',
  mass: 268
}, {
  number: 106,
  label: 'Sg',
  period: 7,
  group: 6,
  title: 'Seaborgium',
  origin: 'synthetic',
  type: 'transition',
  mass: 269
}, {
  number: 107,
  label: 'Bh',
  period: 7,
  group: 7,
  title: 'Bohrium',
  origin: 'synthetic',
  type: 'transition',
  mass: 270
}, {
  number: 108,
  label: 'Hs',
  period: 7,
  group: 8,
  title: 'Hassium',
  origin: 'synthetic',
  type: 'transition',
  mass: 269
}, {
  number: 109,
  label: 'Mt',
  period: 7,
  group: 8,
  title: 'Meitnerium',
  origin: 'synthetic',
  type: 'transition',
  mass: 278
}, {
  number: 110,
  label: 'Ds',
  period: 7,
  group: 8,
  title: 'Darmstadtium',
  origin: 'synthetic',
  type: 'transition',
  mass: 281
}, {
  number: 111,
  label: 'Rg',
  period: 7,
  group: 1,
  title: 'Roentgenium',
  origin: 'synthetic',
  type: 'transition',
  mass: 282
}, {
  number: 112,
  label: 'Cn',
  period: 7,
  group: 2,
  title: 'Copernicium',
  origin: 'synthetic',
  type: 'transition',
  mass: 285
}, {
  number: 113,
  label: 'Nh',
  period: 7,
  group: 3,
  title: 'Nihonium',
  origin: 'synthetic',
  type: 'post-transition',
  mass: 286
}, {
  number: 114,
  label: 'Fl',
  period: 7,
  group: 4,
  title: 'Flerovium',
  origin: 'synthetic',
  type: 'post-transition',
  mass: 289
}, {
  number: 115,
  label: 'Mc',
  period: 7,
  group: 5,
  title: 'Moscovium',
  origin: 'synthetic',
  type: 'post-transition',
  mass: 289
}, {
  number: 116,
  label: 'Lv',
  period: 7,
  group: 6,
  title: 'Livermorium',
  origin: 'synthetic',
  type: 'post-transition',
  mass: 293
}, {
  number: 117,
  label: 'Ts',
  period: 7,
  group: 7,
  title: 'Tennessine',
  origin: 'synthetic',
  type: 'halogen',
  mass: 294
}, {
  number: 118,
  label: 'Og',
  period: 7,
  group: 8,
  title: 'Oganesson',
  origin: 'synthetic',
  type: 'noble',
  mass: 294
}];
var elementsMap = elementsArray.reduce(function (acc, element) {
  acc.set(element.label, element);
  acc.set(element.number, element);
  return acc;
}, new Map());
var Elements = {
  get: function get(key) {
    return elementsMap.get(key);
  },
  filter: function filter(predicate) {
    return elementsArray.filter(predicate);
  },
  getAll: function getAll() {
    return [].concat(elementsArray);
  }
};

var Generics = {
  'atoms-gen': {
    title: 'Atom Generics',
    itemSets: [{
      displayName: 'any atom',
      items: [{
        label: 'A',
        description: 'Any atom except hydrogen'
      }, {
        label: 'AH',
        description: 'Any atom, including hydrogen'
      }]
    }, {
      displayName: 'except C or H',
      items: [{
        label: 'Q',
        description: 'Any heteroatom (any atom except C or H)'
      }, {
        label: 'QH',
        description: 'Any atom except C'
      }]
    }, {
      displayName: 'any metal',
      items: [{
        label: 'M',
        description: 'Any metal'
      }, {
        label: 'MH',
        description: 'Any metal or hydrogen'
      }]
    }, {
      displayName: 'any halogen',
      items: [{
        label: 'X',
        description: 'Any halogen'
      }, {
        label: 'XH',
        description: 'Any halogen or hydrogen'
      }]
    }]
  },
  'special-nodes': {
    title: 'Special Nodes',
    itemSets: [{
      items: [{
        label: 'H+',
        description: 'Proton'
      }, {
        label: 'D',
        description: 'Deuterium'
      }, {
        label: 'T',
        description: 'Tritium'
      }, {
        label: 'R',
        description: 'Pseudoatom'
      }, {
        label: 'Pol',
        description: 'Polymer Bead'
      }]
    }]
  },
  'group-gen': {
    title: 'Group Generics',
    itemSets: [{
      items: [{
        label: 'G',
        description: 'Any group'
      }, {
        label: 'GH',
        description: 'Any group or hydrogen'
      }]
    }, {
      items: [{
        label: 'G*',
        description: 'Any group with a ring closure'
      }, {
        label: 'GH*',
        description: 'Any group with a ring closure or hydrogen'
      }]
    }],
    subGroups: {
      'group-acyclic': {
        title: 'Acyclic',
        itemSets: [{
          items: [{
            label: 'ACY',
            description: 'Acyclic group'
          }, {
            label: 'ACH',
            description: 'Acyclic group or hydrogen'
          }]
        }],
        subGroups: {
          'acyclic-carbo': {
            title: 'Acyclic Carbo',
            itemSets: [{
              items: [{
                label: 'ABC',
                description: 'Carbocyclic'
              }, {
                label: 'ABH',
                description: 'Carbocyclic of hydrogen'
              }]
            }, {
              displayName: 'alkynyl',
              items: [{
                label: 'AYL',
                description: 'Alkynyl'
              }, {
                label: 'AYH',
                description: 'Alkynyl or hydrogen'
              }]
            }, {
              displayName: 'alkyl',
              items: [{
                label: 'ALK',
                description: 'Alkyl'
              }, {
                label: 'ALH',
                description: 'Alkyl or hydrogen'
              }]
            }, {
              displayName: 'alkenyl',
              items: [{
                label: 'AEL',
                description: 'Alkenyl'
              }, {
                label: 'AEH',
                description: 'Alkenyl or hydrogen'
              }]
            }]
          },
          'acyclic-hetero': {
            title: 'Acyclic Hetero',
            itemSets: [{
              items: [{
                label: 'AHC',
                description: 'Heteroacyclic'
              }, {
                label: 'AHH',
                description: 'Heterocyclic or hydrogen'
              }]
            }, {
              items: [{
                label: 'AOX',
                description: 'Alkoxy'
              }, {
                label: 'AOH',
                description: 'Alkoxy or hydrogen'
              }]
            }]
          }
        }
      },
      'group-cyclic': {
        title: 'Cyclic',
        itemSets: [{
          items: [{
            label: 'CYC',
            description: 'Cyclic group'
          }, {
            label: 'CYH',
            description: 'Cyclic group or hydrogen'
          }]
        }, {
          displayName: 'no carbon',
          items: [{
            label: 'CXX',
            description: 'Cyclic group with no Carbon atoms'
          }, {
            label: 'CXH',
            description: 'Cyclic group with no Carbon atoms or hydrogen'
          }]
        }],
        subGroups: {
          'cyclic-carbo': {
            title: 'Cyclic Carbo',
            itemSets: [{
              items: [{
                label: 'CBC',
                description: 'Carbocyclic derivatives'
              }, {
                label: 'CBH',
                description: 'Carbocyclic derivatives or hydrogen'
              }]
            }, {
              displayName: 'aryl',
              items: [{
                label: 'ARY',
                description: 'Any aryl group'
              }, {
                label: 'ARH',
                description: 'Any aryl group or hydrogen'
              }]
            }, {
              displayName: 'cycloalkyl',
              items: [{
                label: 'CAL',
                description: 'Any cycloalkyl group'
              }, {
                label: 'CAH',
                description: 'Any cycloalkyl group or hydrogen'
              }]
            }, {
              displayName: 'cycloalkenyl',
              items: [{
                label: 'CEL',
                description: 'Any cyloalkenyl group'
              }, {
                label: 'CEH',
                description: 'Any cyloalkenyl group or hydrogen'
              }]
            }]
          },
          'cyclic-hetero': {
            title: 'Cyclic Hetero',
            itemSets: [{
              items: [{
                label: 'CHC',
                description: 'Heterocyclic group'
              }, {
                label: 'CHH',
                description: 'Heterocyclic group or hydrogen'
              }]
            }, {
              displayName: 'hetero aryl',
              items: [{
                label: 'HAR',
                description: 'Heteroaryl group'
              }, {
                label: 'HAH',
                description: 'Heteroaryl group or hydrogen'
              }]
            }]
          }
        }
      }
    }
  }
};
function getGenericsList(generics) {
  var _generics$;
  if (Array.isArray(generics) && !((_generics$ = generics[0]) !== null && _generics$ !== void 0 && _generics$.items)) {
    return generics.map(function (item) {
      return item.label;
    });
  } else {
    var result = [];
    for (var _i = 0, _Object$values = Object.values(generics); _i < _Object$values.length; _i++) {
      var subGroup = _Object$values[_i];
      if (typeof generics === 'string') continue;
      result = [].concat(_toConsumableArray__default["default"](result), _toConsumableArray__default["default"](getGenericsList(subGroup)));
    }
    return result;
  }
}
var genericsList = getGenericsList(Generics);

function _createForOfIteratorHelper$a(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$a(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$a(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$a(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen); }
function _arrayLikeToArray$a(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var AtomList = function () {
  function AtomList(params) {
    _classCallCheck__default["default"](this, AtomList);
    this.notList = params.notList;
    this.ids = params.ids;
  }
  _createClass__default["default"](AtomList, [{
    key: "labelList",
    value: function labelList() {
      var labels = [];
      var _iterator = _createForOfIteratorHelper$a(this.ids),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var id = _step.value;
          var currenElement = Elements.get(id);
          currenElement && labels.push(currenElement.label);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return labels;
    }
  }, {
    key: "label",
    value: function label() {
      var label = '[' + this.labelList().join(',') + ']';
      if (this.notList) {
        label = '!' + label;
      }
      return label;
    }
  }, {
    key: "equals",
    value: function equals(atomList) {
      return this.notList === atomList.notList && (this.ids || []).sort().toString() === (atomList.ids || []).sort().toString();
    }
  }]);
  return AtomList;
}();

function ifDef(target, key, value, defaultValue) {
  if (value !== undefined && value !== null && value !== defaultValue && !(Array.isArray(value) && value.length === 0)) {
    target[key] = value;
  }
}

function tfx(value) {
  var parsedValue;
  if (typeof value === 'number') {
    parsedValue = value;
  } else {
    parsedValue = parseFloat(value);
  }
  return parsedValue.toFixed(8);
}

exports.LogLevel = void 0;
(function (LogLevel) {
  LogLevel[LogLevel["ERROR"] = 0] = "ERROR";
  LogLevel[LogLevel["WARN"] = 1] = "WARN";
  LogLevel[LogLevel["INFO"] = 2] = "INFO";
  LogLevel[LogLevel["LOG"] = 3] = "LOG";
})(exports.LogLevel || (exports.LogLevel = {}));
var KetcherLogger = function () {
  function KetcherLogger() {
    _classCallCheck__default["default"](this, KetcherLogger);
  }
  _createClass__default["default"](KetcherLogger, null, [{
    key: "settings",
    get: function get() {
      var _window;
      if (!((_window = window) !== null && _window !== void 0 && _window.ketcher)) {
        throw new Error('Ketcher needs to be initialized before KetcherLogger is used');
      }
      return window.ketcher.logging;
    },
    set: function set(newSettings) {
      for (var _i = 0, _Object$entries = Object.entries(newSettings); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray__default["default"](_Object$entries[_i], 2),
          settingName = _Object$entries$_i[0],
          settingValue = _Object$entries$_i[1];
        this.settings[settingName] = settingValue;
      }
    }
  }, {
    key: "log",
    value: function log() {
      if (!this.isMinimumLogLevel(exports.LogLevel.LOG)) {
        return;
      }
      var showTrace = this.settings.showTrace;
      for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
        messages[_key] = arguments[_key];
      }
      if (showTrace) {
        window.console.trace(messages);
      } else {
        window.console.log(messages);
      }
    }
  }, {
    key: "info",
    value: function info() {
      if (!this.isMinimumLogLevel(exports.LogLevel.INFO)) {
        return;
      }
      var showTrace = this.settings.showTrace;
      for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        messages[_key2] = arguments[_key2];
      }
      if (showTrace) {
        window.console.trace(messages);
      } else {
        window.console.info(messages);
      }
    }
  }, {
    key: "warn",
    value: function warn() {
      if (!this.isMinimumLogLevel(exports.LogLevel.WARN)) {
        return;
      }
      for (var _len3 = arguments.length, warnings = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        warnings[_key3] = arguments[_key3];
      }
      window.console.warn(warnings);
    }
  }, {
    key: "error",
    value: function error() {
      if (!this.isMinimumLogLevel(exports.LogLevel.ERROR)) {
        return;
      }
      for (var _len4 = arguments.length, errors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        errors[_key4] = arguments[_key4];
      }
      window.console.error(errors);
    }
  }, {
    key: "isMinimumLogLevel",
    value: function isMinimumLogLevel(minimumLevel) {
      var _this$settings = this.settings,
        enabled = _this$settings.enabled,
        level = _this$settings.level;
      if (!enabled || level == null) {
        return false;
      }
      return level >= minimumLevel;
    }
  }]);
  return KetcherLogger;
}();

exports.KetcherAsyncEvents = void 0;
(function (KetcherAsyncEvents) {
  KetcherAsyncEvents["LOADING"] = "LOADING";
  KetcherAsyncEvents["SUCCESS"] = "SUCCESS";
  KetcherAsyncEvents["FAILURE"] = "FAILURE";
})(exports.KetcherAsyncEvents || (exports.KetcherAsyncEvents = {}));
var runAsyncAction = function () {
  var _ref = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee(action, eventEmitter) {
    var res;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          eventEmitter.emit(exports.KetcherAsyncEvents.LOADING);
          _context.prev = 1;
          _context.next = 4;
          return action();
        case 4:
          res = _context.sent;
          eventEmitter.emit(exports.KetcherAsyncEvents.SUCCESS);
          return _context.abrupt("return", res);
        case 9:
          _context.prev = 9;
          _context.t0 = _context["catch"](1);
          KetcherLogger.error('runAsyncAction.ts::runAsyncAction', _context.t0);
          eventEmitter.emit(exports.KetcherAsyncEvents.FAILURE);
          return _context.abrupt("return", undefined);
        case 14:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 9]]);
  }));
  return function runAsyncAction(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

function b64toBlob(b64Data) {
  var contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var sliceSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 512;
  var byteCharacters = window.atob(b64Data);
  var byteArrays = [];
  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);
    var byteNumbers = new Array(slice.length);
    for (var i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }
    var byteArray = new Uint8Array(byteNumbers);
    byteArrays.push(byteArray);
  }
  var blob = new Blob(byteArrays, {
    type: contentType
  });
  return blob;
}

function notifyRequestCompleted() {
  var event = new Event('requestCompleted');
  window.dispatchEvent(event);
}

function ownKeys$s(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$s(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$s(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$s(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var KETCHER_SAVED_SETTINGS_KEY = 'ketcher_editor_saved_settings';
var KETCHER_SAVED_OPTIONS_KEY = 'ketcher-opts';
var SettingsManager = function () {
  function SettingsManager() {
    _classCallCheck__default["default"](this, SettingsManager);
  }
  _createClass__default["default"](SettingsManager, null, [{
    key: "getSettings",
    value: function getSettings() {
      try {
        return JSON.parse(localStorage.getItem(KETCHER_SAVED_SETTINGS_KEY) || '{}');
      } catch (e) {
        KetcherLogger.error('settingsManager.ts::SettingsManager::getSettings', e);
        return {};
      }
    }
  }, {
    key: "saveSettings",
    value: function saveSettings(settings) {
      if (!settings) {
        return;
      }
      localStorage.setItem(KETCHER_SAVED_SETTINGS_KEY, JSON.stringify(settings));
    }
  }, {
    key: "getOptions",
    value: function getOptions() {
      try {
        return JSON.parse(localStorage.getItem(KETCHER_SAVED_OPTIONS_KEY) || '{}');
      } catch (e) {
        KetcherLogger.error('SettingsManager.ts::SettingsManager::getOptions', e);
        return {};
      }
    }
  }, {
    key: "saveOptions",
    value: function saveOptions(options) {
      if (!options) {
        return;
      }
      localStorage.setItem(KETCHER_SAVED_OPTIONS_KEY, JSON.stringify(options));
    }
  }, {
    key: "selectionTool",
    get: function get() {
      var _this$getSettings = this.getSettings(),
        selectionTool = _this$getSettings.selectionTool;
      return selectionTool;
    },
    set: function set(selectionTool) {
      var settings = this.getSettings();
      this.saveSettings(_objectSpread$s(_objectSpread$s({}, settings), {}, {
        selectionTool: selectionTool
      }));
    }
  }, {
    key: "disableCustomQuery",
    get: function get() {
      return this._disableCustomQuery;
    },
    set: function set(disableCustomQuery) {
      this._disableCustomQuery = disableCustomQuery;
    }
  }, {
    key: "ignoreChiralFlag",
    get: function get() {
      var _this$getOptions = this.getOptions(),
        ignoreChiralFlag = _this$getOptions.ignoreChiralFlag;
      return ignoreChiralFlag;
    },
    set: function set(ignoreChiralFlag) {
      var options = this.getOptions();
      this.saveOptions(_objectSpread$s(_objectSpread$s({}, options), {}, {
        ignoreChiralFlag: ignoreChiralFlag
      }));
    }
  }]);
  return SettingsManager;
}();

var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\""
};

var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

// Fill in the digit keys
for (var i$1 = 0; i$1 < 10; i$1++) base[48 + i$1] = base[96 + i$1] = String(i$1);

// The function keys
for (var i$1 = 1; i$1 <= 24; i$1++) base[i$1 + 111] = "F" + i$1;

// And the alphabetic keys
for (var i$1 = 65; i$1 <= 90; i$1++) {
  base[i$1] = String.fromCharCode(i$1 + 32);
  shift[i$1] = String.fromCharCode(i$1);
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

function keyName(event) {
  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.
  // On IE, shift effect is never included in `.key`.
  var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||
      ie && event.shiftKey && event.key && event.key.length == 1 ||
      event.key == "Unidentified";
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name
}

var mac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  var parts = name.split(/\+(?!$)/);
  var result = parts[parts.length - 1];
  if (result === 'Space') result = ' ';
  var alt;
  var ctrl;
  var shift;
  var meta;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {
      if (mac) meta = true;else ctrl = true;
    } else throw new Error('Unrecognized modifier name: ' + mod);
  }
  if (alt) result = 'Alt+' + result;
  if (ctrl) result = 'Ctrl+' + result;
  if (meta) result = 'Meta+' + result;
  if (shift) result = 'Shift+' + result;
  return result;
}
function normalizeKeyMap(map) {
  var copy = Object.create(null);
  Object.keys(map).forEach(function (prop) {
    copy[normalizeKeyName(prop)] = map[prop];
  });
  return copy;
}
function modifiers(name, event, shift) {
  if (event.altKey) name = 'Alt+' + name;
  if (event.ctrlKey) name = 'Ctrl+' + name;
  if (event.metaKey) name = 'Meta+' + name;
  if (shift !== false && event.shiftKey) name = 'Shift+' + name;
  return name;
}
function rusToEng(name, event) {
  return name.replace(/[а-я]/, base[event.keyCode]).replace(/[А-Я]/, shift[event.keyCode]);
}
function normalizeKeyEvent(event) {
  var base$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var name = rusToEng(keyName(event), event);
  var isChar = name.length === 1 && name !== ' ';
  return isChar && !base$1 ? modifiers(name, event, !isChar) : modifiers(base[event.keyCode], event, true);
}
function isControlKey(event) {
  return mac ? event.metaKey : event.ctrlKey;
}
function keyNorm(obj) {
  if (obj instanceof KeyboardEvent) {
    return normalizeKeyEvent(obj);
  }
  return _typeof__default["default"](obj) === 'object' ? normalizeKeyMap(obj) : normalizeKeyName(obj);
}
function setHotKey(key, actName, hotKeys) {
  if (Array.isArray(hotKeys[key])) hotKeys[key].push(actName);else hotKeys[key] = [actName];
}
function initHotKeys(actions) {
  var hotKeys = {};
  var act;
  Object.keys(actions).forEach(function (actName) {
    act = actions[actName];
    if (!act.shortcut) return;
    if (Array.isArray(act.shortcut)) {
      act.shortcut.forEach(function (key) {
        setHotKey(key, actName, hotKeys);
      });
    } else {
      setHotKey(act.shortcut, actName, hotKeys);
    }
  });
  return keyNorm(hotKeys);
}
function lookup(map, event) {
  var name = rusToEng(keyName(event), event);
  if (name === 'Add') name = '+';
  if (name === 'Subtract') name = '-';
  var isChar = name.length === 1 && name !== ' ';
  var res = map[modifiers(name, event, !isChar)];
  var baseName;
  if (event.shiftKey && isChar && (baseName = base[event.keyCode])) res = map[modifiers(baseName, event, true)] || res;
  return res;
}
keyNorm.lookup = lookup;

var shortcutAliasMap = {
  Escape: 'Esc',
  Delete: 'Del',
  Mod: reactDeviceDetect.isMacOs ? '⌘' : 'Ctrl'
};
function shortcutStr(shortcut) {
  if (!shortcut) {
    return '';
  }
  var shortcutKey = Array.isArray(shortcut) ? shortcut[0] : shortcut;
  return shortcutKey.replace(/(\b[a-z]\b$|Mod|Escape|Delete)/g, function (key) {
    return shortcutAliasMap[key] || key.toUpperCase();
  });
}
var generateMenuShortcuts = function generateMenuShortcuts(obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    var _obj$key;
    if ((_obj$key = obj[key]) !== null && _obj$key !== void 0 && _obj$key.shortcut) {
      var shortcut = obj[key].shortcut;
      var processedShortcut = shortcutStr(shortcut);
      acc[key] = processedShortcut;
    }
    return acc;
  }, {});
};

var _Vec;
var Vec2 = function () {
  function Vec2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _classCallCheck__default["default"](this, Vec2);
    if (args.length === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    } else if (arguments.length === 1) {
      this.x = parseFloat(args[0].x || 0);
      this.y = parseFloat(args[0].y || 0);
      this.z = parseFloat(args[0].z || 0);
    } else if (arguments.length === 2) {
      this.x = parseFloat(args[0] || 0);
      this.y = parseFloat(args[1] || 0);
      this.z = 0;
    } else if (arguments.length === 3) {
      this.x = parseFloat(args[0]);
      this.y = parseFloat(args[1]);
      this.z = parseFloat(args[2]);
    } else {
      throw new Error('Vec2(): invalid arguments');
    }
  }
  _createClass__default["default"](Vec2, [{
    key: "length",
    value: function length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
  }, {
    key: "equals",
    value: function equals(v) {
      return this.x === v.x && this.y === v.y && this.z === v.z;
    }
  }, {
    key: "add",
    value: function add(v) {
      return new Vec2(this.x + v.x, this.y + v.y, this.z + v.z);
    }
  }, {
    key: "add_",
    value: function add_(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
    }
  }, {
    key: "get_xy0",
    value: function get_xy0() {
      return new Vec2(this.x, this.y);
    }
  }, {
    key: "sub",
    value: function sub(v) {
      return new Vec2(this.x - v.x, this.y - v.y, this.z - v.z);
    }
  }, {
    key: "scaled",
    value: function scaled(s) {
      return new Vec2(this.x * s, this.y * s, this.z * s);
    }
  }, {
    key: "negated",
    value: function negated() {
      return new Vec2(-this.x, -this.y, -this.z);
    }
  }, {
    key: "yComplement",
    value: function yComplement(y1) {
      y1 = y1 || 0;
      return new Vec2(this.x, y1 - this.y, this.z);
    }
  }, {
    key: "addScaled",
    value: function addScaled(v, f) {
      return new Vec2(this.x + v.x * f, this.y + v.y * f, this.z + v.z * f);
    }
  }, {
    key: "normalized",
    value: function normalized() {
      return this.scaled(1 / this.length());
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var l = this.length();
      if (l < 0.000001) return false;
      this.x /= l;
      this.y /= l;
      return true;
    }
  }, {
    key: "turnLeft",
    value: function turnLeft() {
      return new Vec2(-this.y, this.x, this.z);
    }
  }, {
    key: "coordStr",
    value: function coordStr() {
      return this.x.toString() + ' , ' + this.y.toString();
    }
  }, {
    key: "toString",
    value: function toString() {
      return '(' + this.x.toFixed(2) + ',' + this.y.toFixed(2) + ')';
    }
  }, {
    key: "max",
    value: function max(v) {
      assert__default["default"](v != null);
      return Vec2.max(this, v);
    }
  }, {
    key: "min",
    value: function min(v) {
      return Vec2.min(this, v);
    }
  }, {
    key: "ceil",
    value: function ceil() {
      return new Vec2(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));
    }
  }, {
    key: "floor",
    value: function floor() {
      return new Vec2(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));
    }
  }, {
    key: "rotate",
    value: function rotate(angle) {
      var sin = Math.sin(angle);
      var cos = Math.cos(angle);
      return this.rotateSC(sin, cos);
    }
  }, {
    key: "rotateSC",
    value: function rotateSC(sin, cos) {
      assert__default["default"](sin === 0 || !!sin);
      assert__default["default"](cos === 0 || !!cos);
      return new Vec2(this.x * cos - this.y * sin, this.x * sin + this.y * cos, this.z);
    }
  }, {
    key: "rotateAroundOrigin",
    value: function rotateAroundOrigin(angleInDegrees, origin) {
      var angleInRadians = angleInDegrees * Math.PI / 180;
      var offsetX = this.x - origin.x;
      var offsetY = this.y - origin.y;
      var rotatedX = Math.cos(angleInRadians) * offsetX - Math.sin(angleInRadians) * offsetY;
      var rotatedY = Math.sin(angleInRadians) * offsetX + Math.cos(angleInRadians) * offsetY;
      var x = rotatedX + origin.x;
      var y = rotatedY + origin.y;
      return new Vec2(Number(tfx(x)), Number(tfx(y)), this.z || 0);
    }
  }, {
    key: "isInsidePolygon",
    value: function isInsidePolygon(points) {
      var x = this.x,
        y = this.y;
      var inside = false;
      for (var i = 0, j = points.length - 1; i < points.length; j = i++) {
        var xi = points[i].x || 0;
        var yi = points[i].y || 0;
        var xj = points[j].x || 0;
        var yj = points[j].y || 0;
        var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        if (intersect) inside = !inside;
      }
      return inside;
    }
  }, {
    key: "oxAngle",
    value: function oxAngle() {
      return Math.atan2(this.y, this.x);
    }
  }], [{
    key: "dist",
    value: function dist(a, b) {
      return Vec2.diff(a, b).length();
    }
  }, {
    key: "max",
    value: function max(v1, v2) {
      return new Vec2(Math.max(v1.x, v2.x), Math.max(v1.y, v2.y), Math.max(v1.z, v2.z));
    }
  }, {
    key: "min",
    value: function min(v1, v2) {
      return new Vec2(Math.min(v1.x, v2.x), Math.min(v1.y, v2.y), Math.min(v1.z, v2.z));
    }
  }, {
    key: "sum",
    value: function sum(v1, v2) {
      return new Vec2(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
    }
  }, {
    key: "dot",
    value: function dot(v1, v2) {
      return v1.x * v2.x + v1.y * v2.y;
    }
  }, {
    key: "cross",
    value: function cross(v1, v2) {
      return v1.x * v2.y - v1.y * v2.x;
    }
  }, {
    key: "angle",
    value: function angle(v1, v2) {
      return Math.atan2(Vec2.cross(v1, v2), Vec2.dot(v1, v2));
    }
  }, {
    key: "diff",
    value: function diff(v1, v2) {
      return new Vec2(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
    }
  }, {
    key: "lc",
    value: function lc() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var v = new Vec2();
      for (var i = 0; i < arguments.length / 2; ++i) {
        v = v.addScaled(args[2 * i], args[2 * i + 1]);
      }
      return v;
    }
  }, {
    key: "lc2",
    value: function lc2(v1, f1, v2, f2) {
      return new Vec2(v1.x * f1 + v2.x * f2, v1.y * f1 + v2.y * f2, v1.z * f1 + v2.z * f2);
    }
  }, {
    key: "centre",
    value: function centre(v1, v2) {
      return Vec2.lc2(v1, 0.5, v2, 0.5);
    }
  }, {
    key: "getLinePoint",
    value: function getLinePoint(lineStart, lineEnd, length) {
      var difference = lineStart.sub(lineEnd);
      var distance = difference.length();
      var ratio = length / distance;
      return new Vec2(lineStart.x + difference.x * ratio, lineStart.y + difference.y * ratio);
    }
  }, {
    key: "crossProduct",
    value: function crossProduct(v1, v2) {
      return v1.x * v2.y - v1.y * v2.x;
    }
  }, {
    key: "radiansToDegrees",
    value: function radiansToDegrees(radians) {
      return radians * (180 / Math.PI);
    }
  }, {
    key: "degrees_to_radians",
    value: function degrees_to_radians(degrees) {
      return degrees * Math.PI / 180;
    }
  }, {
    key: "oxAngleForVector",
    value: function oxAngleForVector(v1, v2) {
      return Math.atan2(v2.y - v1.y, v2.x - v1.x);
    }
  }, {
    key: "findSecondPoint",
    value: function findSecondPoint(startPoint, lineLength, lineAngleRadians) {
      var cos = Math.cos(lineAngleRadians);
      var sin = Math.sin(lineAngleRadians);
      var deltaX = lineLength * cos;
      var deltaY = lineLength * sin;
      var endPoint = {
        x: startPoint.x + deltaX,
        y: startPoint.y + deltaY
      };
      return endPoint;
    }
  }]);
  return Vec2;
}();
_Vec = Vec2;
_defineProperty__default["default"](Vec2, "ZERO", new _Vec(0, 0));
_defineProperty__default["default"](Vec2, "UNIT", new _Vec(1, 1));

function _createForOfIteratorHelper$9(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }
function _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _callSuper$1s(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1s() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1s() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1s = function _isNativeReflectConstruct() { return !!t; })(); }
var Pile = function (_Set) {
  _inherits__default["default"](Pile, _Set);
  function Pile() {
    _classCallCheck__default["default"](this, Pile);
    return _callSuper$1s(this, Pile, arguments);
  }
  _createClass__default["default"](Pile, [{
    key: "find",
    value:
    function find(predicate) {
      var _iterator = _createForOfIteratorHelper$9(this),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          if (predicate(item)) return item;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return null;
    }
  }, {
    key: "equals",
    value: function equals(setB) {
      return this.isSuperset(setB) && setB.isSuperset(this);
    }
  }, {
    key: "isSuperset",
    value: function isSuperset(subset) {
      var _iterator2 = _createForOfIteratorHelper$9(subset),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var item = _step2.value;
          if (!this.has(item)) return false;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return true;
    }
  }, {
    key: "filter",
    value: function filter(expression) {
      return new Pile(Array.from(this).filter(expression));
    }
  }, {
    key: "union",
    value: function union(setB) {
      var union = new Pile(this);
      var _iterator3 = _createForOfIteratorHelper$9(setB),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var item = _step3.value;
          union.add(item);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return union;
    }
  }, {
    key: "intersection",
    value: function intersection(setB) {
      var thisSet = new Pile(this);
      return new Pile(_toConsumableArray__default["default"](thisSet).filter(function (item) {
        return setB.has(item);
      }));
    }
  }], [{
    key: "unionIntersections",
    value: function unionIntersections(sets) {
      var unionized = false;
      var setsToReturn = sets.reduce(function (prevSets, curSet) {
        var isCurSetMerged = false;
        var newSets = prevSets.map(function (set) {
          var intersec = set.intersection(curSet);
          if (intersec.size > 0) {
            unionized = true;
            isCurSetMerged = true;
            return set.union(curSet);
          }
          return set;
        });
        if (!isCurSetMerged) newSets.push(curSet);
        return newSets;
      }, new Array());
      return unionized ? Pile.unionIntersections(setsToReturn) : setsToReturn;
    }
  }]);
  return Pile;
}( _wrapNativeSuper__default["default"](Set));

var INVALID = 'invalid';
var BaseMicromoleculeEntity = function () {
  function BaseMicromoleculeEntity(initiallySelected) {
    _classCallCheck__default["default"](this, BaseMicromoleculeEntity);
    this.initiallySelected = initiallySelected;
  }
  _createClass__default["default"](BaseMicromoleculeEntity, [{
    key: "getInitiallySelected",
    value: function getInitiallySelected() {
      if (this.initiallySelected === INVALID) {
        throw new Error('this field is used only for serialization/deserialization');
      }
      return this.initiallySelected;
    }
  }, {
    key: "setInitiallySelected",
    value: function setInitiallySelected(value) {
      if (this.initiallySelected === INVALID) {
        throw new Error('this field is used only for serialization/deserialization');
      }
      this.initiallySelected = value;
    }
  }, {
    key: "resetInitiallySelected",
    value: function resetInitiallySelected(invalidate) {
      this.initiallySelected = invalidate ? INVALID : undefined;
    }
  }]);
  return BaseMicromoleculeEntity;
}();

function _createForOfIteratorHelper$8(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }
function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _callSuper$1r(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1r() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1r() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1r = function _isNativeReflectConstruct() { return !!t; })(); }
exports.AttachmentPoints = void 0;
(function (AttachmentPoints) {
  AttachmentPoints[AttachmentPoints["None"] = 0] = "None";
  AttachmentPoints[AttachmentPoints["FirstSideOnly"] = 1] = "FirstSideOnly";
  AttachmentPoints[AttachmentPoints["SecondSideOnly"] = 2] = "SecondSideOnly";
  AttachmentPoints[AttachmentPoints["BothSides"] = 3] = "BothSides";
})(exports.AttachmentPoints || (exports.AttachmentPoints = {}));
exports.StereoLabel = void 0;
(function (StereoLabel) {
  StereoLabel["Abs"] = "abs";
  StereoLabel["And"] = "&";
  StereoLabel["Or"] = "or";
})(exports.StereoLabel || (exports.StereoLabel = {}));
var CIP$1;
(function (CIP) {
  CIP["S"] = "S";
  CIP["R"] = "R";
  CIP["s"] = "s";
  CIP["r"] = "r";
})(CIP$1 || (CIP$1 = {}));
var Atom = function (_BaseMicromoleculeEnt) {
  _inherits__default["default"](Atom, _BaseMicromoleculeEnt);
  function Atom(attributes) {
    var _this;
    _classCallCheck__default["default"](this, Atom);
    _this = _callSuper$1r(this, Atom, [attributes === null || attributes === void 0 ? void 0 : attributes.initiallySelected]);
    _this.label = attributes.label;
    _this.fragment = getValueOrDefault(attributes.fragment, -1);
    _this.alias = getValueOrDefault(attributes.alias, Atom.attrlist.alias);
    _this.isotope = getValueOrDefault(attributes.isotope, Atom.attrlist.isotope);
    _this.radical = getValueOrDefault(attributes.radical, Atom.attrlist.radical);
    _this.cip = getValueOrDefault(attributes.cip, Atom.attrlist.cip);
    _this.charge = getValueOrDefault(attributes.charge, Atom.attrlist.charge);
    _this.rglabel = getValueOrDefault(attributes.rglabel, Atom.attrlist.rglabel);
    _this.attachmentPoints = getValueOrDefault(attributes.attachmentPoints, Atom.attrlist.attachmentPoints);
    _this.implicitHCount = getValueOrDefault(attributes.implicitHCount, null);
    _this.explicitValence = getValueOrDefault(attributes.explicitValence, Atom.attrlist.explicitValence);
    _this.isPreview = getValueOrDefault(attributes.isPreview, Atom.attrlist.isPreview);
    _this.valence = 0;
    _this.implicitH = attributes.implicitHCount || attributes.implicitH || 0;
    _this.pp = attributes.pp ? new Vec2(attributes.pp) : new Vec2();
    _this.sgs = new Pile();
    _this.ringBondCount = getValueOrDefault(attributes.ringBondCount, Atom.attrlist.ringBondCount);
    _this.substitutionCount = getValueOrDefault(attributes.substitutionCount, Atom.attrlist.substitutionCount);
    _this.unsaturatedAtom = getValueOrDefault(attributes.unsaturatedAtom, Atom.attrlist.unsaturatedAtom);
    _this.hCount = getValueOrDefault(attributes.hCount, Atom.attrlist.hCount);
    _this.queryProperties = {};
    for (var property in Atom.attrlist.queryProperties) {
      var _attributes$queryProp;
      _this.queryProperties[property] = getValueOrDefault((_attributes$queryProp = attributes.queryProperties) === null || _attributes$queryProp === void 0 ? void 0 : _attributes$queryProp[property], Atom.attrlist.queryProperties[property]);
    }
    _this.aam = getValueOrDefault(attributes.aam, Atom.attrlist.aam);
    _this.invRet = getValueOrDefault(attributes.invRet, Atom.attrlist.invRet);
    _this.exactChangeFlag = getValueOrDefault(attributes.exactChangeFlag, Atom.attrlist.exactChangeFlag);
    _this.rxnFragmentType = getValueOrDefault(attributes.rxnFragmentType, -1);
    _this.stereoLabel = getValueOrDefault(attributes.stereoLabel, Atom.attrlist.stereoLabel);
    _this.stereoParity = getValueOrDefault(attributes.stereoParity, Atom.attrlist.stereoParity);
    _this.atomList = attributes.atomList ? new AtomList(attributes.atomList) : null;
    _this.neighbors = [];
    _this.badConn = false;
    Object.defineProperty(_assertThisInitialized__default["default"](_this), 'pseudo', {
      enumerable: true,
      get: function get() {
        return getPseudo(this.label);
      },
      set: function set(value) {
        if (isCorrectPseudo(value)) {
          this.label = value;
        }
      }
    });
    return _this;
  }
  _createClass__default["default"](Atom, [{
    key: "attpnt",
    get:
    function get() {
      return this.attachmentPoints;
    }
  }, {
    key: "isRGroupAttachmentPointEditDisabled",
    get: function get() {
      return this.label === 'R#' && this.rglabel !== null;
    }
  }, {
    key: "setRGAttachmentPointForDisplayPurpose",
    value: function setRGAttachmentPointForDisplayPurpose() {
      this.attachmentPoints = exports.AttachmentPoints.FirstSideOnly;
    }
  }, {
    key: "clone",
    value: function clone(fidMap) {
      var ret = new Atom(this);
      if (fidMap && fidMap.has(this.fragment)) {
        ret.fragment = fidMap.get(this.fragment);
      }
      return ret;
    }
  }, {
    key: "isQuery",
    value: function isQuery() {
      var queryProperties = this.queryProperties;
      var isAnyAtom = this.label === 'A';
      var isAnyMetal = this.label === 'M' || this.label === 'MH';
      var isAnyHalogen = this.label === 'X' || this.label === 'XH';
      var isAnyGroup = this.label === 'G' || this.label === 'G*' || this.label === 'GH' || this.label === 'GH*';
      return Boolean(this.substitutionCount !== 0 || this.unsaturatedAtom !== 0 || this.ringBondCount !== 0 || isAnyAtom || isAnyMetal || isAnyHalogen || isAnyGroup || this.hCount !== 0 || this.atomList !== null || Object.values(queryProperties).some(function (value) {
        return value;
      }));
    }
  }, {
    key: "pureHydrogen",
    value: function pureHydrogen() {
      return this.label === 'H' && this.isotope === 0;
    }
  }, {
    key: "isPlainCarbon",
    value: function isPlainCarbon() {
      return this.label === 'C' && this.isotope === null && this.radical === 0 && this.charge === null && this.explicitValence < 0 && this.ringBondCount === 0 && this.substitutionCount === 0 && this.unsaturatedAtom === 0 && this.hCount === 0 && !this.atomList;
    }
  }, {
    key: "isPseudo",
    value: function isPseudo() {
      return !this.atomList && !this.rglabel && !Elements.get(this.label);
    }
  }, {
    key: "hasRxnProps",
    value: function hasRxnProps() {
      return !!(this.invRet || this.exactChangeFlag || this.attachmentPoints !== null || this.aam);
    }
  }, {
    key: "calcValence",
    value: function calcValence(connectionCount) {
      var label = this.label;
      var charge = this.charge || 0;
      if (this.isQuery() || this.attachmentPoints) {
        this.implicitH = 0;
        return true;
      }
      var element = Elements.get(label);
      var groupno = element === null || element === void 0 ? void 0 : element.group;
      var radicalCount = radicalElectrons(this.radical);
      var valence = connectionCount;
      var hydrogenCount = 0;
      var absCharge = Math.abs(charge);
      if (groupno === undefined) {
        if (label === 'D' || label === 'T') {
          valence = 1;
          hydrogenCount = 1 - radicalCount - connectionCount - absCharge;
        } else {
          this.implicitH = 0;
          return true;
        }
      } else if (groupno === 1) {
        if (label === 'H' || label === 'Li' || label === 'Na' || label === 'K' || label === 'Rb' || label === 'Cs' || label === 'Fr') {
          valence = 1;
          hydrogenCount = 1 - radicalCount - connectionCount - absCharge;
        }
      } else if (groupno === 2) {
        if (connectionCount + radicalCount + absCharge === 2 || connectionCount + radicalCount + absCharge === 0) {
          valence = 2;
        } else hydrogenCount = -1;
      } else if (groupno === 3) {
        if (label === 'B' || label === 'Al' || label === 'Ga' || label === 'In') {
          if (charge === -1) {
            valence = 4;
            hydrogenCount = 4 - radicalCount - connectionCount;
          } else {
            valence = 3;
            hydrogenCount = 3 - radicalCount - connectionCount - absCharge;
          }
        } else if (label === 'Tl') {
          if (charge === -1) {
            if (radicalCount + connectionCount <= 2) {
              valence = 2;
              hydrogenCount = 2 - radicalCount - connectionCount;
            } else {
              valence = 4;
              hydrogenCount = 4 - radicalCount - connectionCount;
            }
          } else if (charge === -2) {
            if (radicalCount + connectionCount <= 3) {
              valence = 3;
              hydrogenCount = 3 - radicalCount - connectionCount;
            } else {
              valence = 5;
              hydrogenCount = 5 - radicalCount - connectionCount;
            }
          } else if (radicalCount + connectionCount + absCharge <= 1) {
            valence = 1;
            hydrogenCount = 1 - radicalCount - connectionCount - absCharge;
          } else {
            valence = 3;
            hydrogenCount = 3 - radicalCount - connectionCount - absCharge;
          }
        }
      } else if (groupno === 4) {
        if (label === 'C' || label === 'Si' || label === 'Ge') {
          valence = 4;
          hydrogenCount = 4 - radicalCount - connectionCount - absCharge;
        } else if (label === 'Sn' || label === 'Pb') {
          if (connectionCount + radicalCount + absCharge <= 2) {
            valence = 2;
            hydrogenCount = 2 - radicalCount - connectionCount - absCharge;
          } else {
            valence = 4;
            hydrogenCount = 4 - radicalCount - connectionCount - absCharge;
          }
        }
      } else if (groupno === 5) {
        if (label === 'N' || label === 'P') {
          if (charge === 1) {
            valence = 4;
            hydrogenCount = 4 - radicalCount - connectionCount;
          } else if (charge === 2) {
            valence = 3;
            hydrogenCount = 3 - radicalCount - connectionCount;
          } else if (label === 'N' || radicalCount + connectionCount + absCharge <= 3) {
            valence = 3;
            hydrogenCount = 3 - radicalCount - connectionCount - absCharge;
          } else {
            valence = 5;
            hydrogenCount = 5 - radicalCount - connectionCount - absCharge;
          }
        } else if (label === 'Bi' || label === 'Sb' || label === 'As') {
          if (charge === 1) {
            if (radicalCount + connectionCount <= 2 && label !== 'As') {
              valence = 2;
              hydrogenCount = 2 - radicalCount - connectionCount;
            } else {
              valence = 4;
              hydrogenCount = 4 - radicalCount - connectionCount;
            }
          } else if (charge === 2) {
            valence = 3;
            hydrogenCount = 3 - radicalCount - connectionCount;
          } else if (radicalCount + connectionCount <= 3) {
            valence = 3;
            hydrogenCount = 3 - radicalCount - connectionCount - absCharge;
          } else {
            valence = 5;
            hydrogenCount = 5 - radicalCount - connectionCount - absCharge;
          }
        }
      } else if (groupno === 6) {
        if (label === 'O') {
          if (charge >= 1) {
            valence = 3;
            hydrogenCount = 3 - radicalCount - connectionCount;
          } else {
            valence = 2;
            hydrogenCount = 2 - radicalCount - connectionCount - absCharge;
          }
        } else if (label === 'S' || label === 'Se' || label === 'Po') {
          if (charge === 1) {
            if (connectionCount <= 3) {
              valence = 3;
              hydrogenCount = 3 - radicalCount - connectionCount;
            } else {
              valence = 5;
              hydrogenCount = 5 - radicalCount - connectionCount;
            }
          } else if (connectionCount + radicalCount + absCharge <= 2) {
            valence = 2;
            hydrogenCount = 2 - radicalCount - connectionCount - absCharge;
          } else if (connectionCount + radicalCount + absCharge <= 4) {
            valence = 4;
            hydrogenCount = 4 - radicalCount - connectionCount - absCharge;
          } else {
            valence = 6;
            hydrogenCount = 6 - radicalCount - connectionCount - absCharge;
          }
        } else if (label === 'Te') {
          if (charge === -1) {
            if (connectionCount <= 2) {
              valence = 2;
              hydrogenCount = 2 - radicalCount - connectionCount - absCharge;
            }
          } else if (charge === 0 || charge === 2) {
            if (connectionCount <= 2) {
              valence = 2;
              hydrogenCount = 2 - radicalCount - connectionCount - absCharge;
            } else if (connectionCount <= 4) {
              valence = 4;
              hydrogenCount = 4 - radicalCount - connectionCount - absCharge;
            } else if (charge === 0 && connectionCount <= 6) {
              valence = 6;
              hydrogenCount = 6 - radicalCount - connectionCount - absCharge;
            } else {
              hydrogenCount = -1;
            }
          }
        }
      } else if (groupno === 7) {
        if (label === 'F') {
          valence = 1;
          hydrogenCount = 1 - radicalCount - connectionCount - absCharge;
        } else if (label === 'Cl' || label === 'Br' || label === 'I' || label === 'At') {
          if (charge === 1) {
            if (connectionCount <= 2) {
              valence = 2;
              hydrogenCount = 2 - radicalCount - connectionCount;
            } else if (connectionCount === 3 || connectionCount === 5 || connectionCount >= 7) {
              hydrogenCount = -1;
            }
          } else if (charge === 0) {
            if (connectionCount <= 1) {
              valence = 1;
              hydrogenCount = 1 - radicalCount - connectionCount;
            } else if (connectionCount === 2 || connectionCount === 4 || connectionCount === 6) {
              if (radicalCount === 1) {
                valence = connectionCount;
                hydrogenCount = 0;
              } else {
                hydrogenCount = -1;
              }
            } else if (connectionCount > 7) {
              hydrogenCount = -1;
            }
          }
        }
      } else if (groupno === 8) {
        if (connectionCount + radicalCount + absCharge === 0) valence = 1;else hydrogenCount = -1;
      }
      if (Atom.isHeteroAtom(label) && this.implicitHCount !== null) {
        hydrogenCount = this.implicitHCount;
      }
      this.valence = valence;
      this.implicitH = hydrogenCount;
      if (this.implicitH < 0) {
        this.valence = connectionCount;
        this.implicitH = 0;
        this.badConn = true;
        return false;
      }
      return true;
    }
  }, {
    key: "calcValenceMinusHyd",
    value: function calcValenceMinusHyd(conn) {
      var charge = this.charge || 0;
      var label = this.label;
      var element = Elements.get(this.label);
      if (!element) {
        this.implicitH = 0;
        return 0;
      }
      var groupno = element.group;
      var rad = radicalElectrons(this.radical);
      if (groupno === 3) {
        if (label === 'B' || label === 'Al' || label === 'Ga' || label === 'In') {
          if (charge === -1) {
            if (rad + conn <= 4) return rad + conn;
          }
        }
      } else if (groupno === 5) {
        if (label === 'N' || label === 'P') {
          if (charge === 1) return rad + conn;
          if (charge === 2) return rad + conn;
        } else if (label === 'Sb' || label === 'Bi' || label === 'As') {
          if (charge === 1) return rad + conn;else if (charge === 2) return rad + conn;
        }
      } else if (groupno === 6) {
        if (label === 'O') {
          if (charge >= 1) return rad + conn;
        } else if (label === 'S' || label === 'Se' || label === 'Po') {
          if (charge === 1) return rad + conn;
        }
      } else if (groupno === 7) {
        if (label === 'Cl' || label === 'Br' || label === 'I' || label === 'At') {
          if (charge === 1) return rad + conn;
        }
      }
      return rad + conn + Math.abs(charge);
    }
  }], [{
    key: "getConnectedBondIds",
    value: function getConnectedBondIds(struct, atomId) {
      var result = [];
      var _iterator = _createForOfIteratorHelper$8(struct.bonds.entries()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray__default["default"](_step.value, 2),
            bondId = _step$value[0],
            bond = _step$value[1];
          if (bond.begin === atomId || bond.end === atomId) {
            result.push(bondId);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return result;
    }
  }, {
    key: "getAttrHash",
    value: function getAttrHash(atom) {
      var attrs = {};
      for (var attr in Atom.attrlist) {
        if (typeof atom[attr] !== 'undefined') attrs[attr] = atom[attr];
      }
      return attrs;
    }
  }, {
    key: "attrGetDefault",
    value: function attrGetDefault(attr) {
      if (attr in Atom.attrlist) {
        return Atom.attrlist[attr];
      }
    }
  }, {
    key: "isHeteroAtom",
    value: function isHeteroAtom(label) {
      return label !== 'C' && label !== 'H';
    }
  }, {
    key: "isInAromatizedRing",
    value: function isInAromatizedRing(struct, atomId) {
      var atom = struct.atoms.get(atomId);
      if (atom && Atom.isHeteroAtom(atom.label)) {
        var _iterator2 = _createForOfIteratorHelper$8(struct.loops),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray__default["default"](_step2.value, 2),
              _ = _step2$value[0],
              loop = _step2$value[1];
            var halfBondIds = loop.hbs;
            if (loop.aromatic) {
              var _iterator3 = _createForOfIteratorHelper$8(halfBondIds),
                _step3;
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var halfBondId = _step3.value;
                  var halfBond = struct.halfBonds.get(halfBondId);
                  if (!halfBond) return false;
                  var begin = halfBond.begin,
                    end = halfBond.end;
                  if (begin === atomId || end === atomId) {
                    return true;
                  }
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return false;
    }
  }]);
  return Atom;
}(BaseMicromoleculeEntity);
_defineProperty__default["default"](Atom, "PATTERN", {
  RADICAL: {
    NONE: 0,
    SINGLET: 1,
    DOUPLET: 2,
    TRIPLET: 3
  },
  STEREO_PARITY: {
    NONE: 0,
    ODD: 1,
    EVEN: 2,
    EITHER: 3
  }
});
_defineProperty__default["default"](Atom, "attrlist", {
  alias: null,
  label: 'C',
  isotope: null,
  radical: 0,
  cip: null,
  charge: null,
  explicitValence: -1,
  ringBondCount: 0,
  substitutionCount: 0,
  unsaturatedAtom: 0,
  hCount: 0,
  queryProperties: {
    aromaticity: null,
    ringMembership: null,
    ringSize: null,
    connectivity: null,
    chirality: null,
    customQuery: null
  },
  atomList: null,
  invRet: 0,
  exactChangeFlag: 0,
  rglabel: null,
  attachmentPoints: null,
  aam: 0,
  isPreview: false,
  stereoLabel: null,
  stereoParity: 0,
  implicitHCount: null
});
function radicalElectrons(radical) {
  radical -= 0;
  if (radical === Atom.PATTERN.RADICAL.DOUPLET) return 1;else if (radical === Atom.PATTERN.RADICAL.SINGLET || radical === Atom.PATTERN.RADICAL.TRIPLET) {
    return 2;
  } else {
    return 0;
  }
}
function getValueOrDefault(value, defaultValue) {
  return typeof value !== 'undefined' ? value : defaultValue;
}
function isCorrectPseudo(label) {
  return !Elements.get(label) && label !== 'L' && label !== 'L#' && label !== 'R#';
}
function getPseudo(label) {
  return isCorrectPseudo(label) ? label : '';
}

var _Bond;
function _callSuper$1q(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1q() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1q() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1q = function _isNativeReflectConstruct() { return !!t; })(); }
var CIP;
(function (CIP) {
  CIP["E"] = "E";
  CIP["Z"] = "Z";
  CIP["M"] = "M";
  CIP["P"] = "P";
})(CIP || (CIP = {}));
var Bond = function (_BaseMicromoleculeEnt) {
  _inherits__default["default"](Bond, _BaseMicromoleculeEnt);
  function Bond(attributes) {
    var _attributes$cip;
    var _this;
    _classCallCheck__default["default"](this, Bond);
    _this = _callSuper$1q(this, Bond, [attributes.initiallySelected]);
    _this.begin = attributes.begin;
    _this.end = attributes.end;
    _this.type = attributes.type;
    _this.xxx = attributes.xxx || '';
    _this.stereo = Bond.PATTERN.STEREO.NONE;
    _this.topology = Bond.PATTERN.TOPOLOGY.EITHER;
    _this.customQuery = null;
    _this.reactingCenterStatus = 0;
    _this.cip = (_attributes$cip = attributes.cip) !== null && _attributes$cip !== void 0 ? _attributes$cip : null;
    _this.len = 0;
    _this.sb = 0;
    _this.sa = 0;
    _this.angle = 0;
    _this.isPreview = false;
    if (attributes.stereo) _this.stereo = attributes.stereo;
    if (attributes.topology) _this.topology = attributes.topology;
    if (attributes.customQuery) {
      _this.customQuery = attributes.customQuery;
      _this.type = Bond.PATTERN.TYPE.ANY;
      _this.reactingCenterStatus = null;
      _this.topology = null;
    }
    if (attributes.reactingCenterStatus) {
      _this.reactingCenterStatus = attributes.reactingCenterStatus;
    }
    _this.center = new Vec2();
    return _this;
  }
  _createClass__default["default"](Bond, [{
    key: "isQuery",
    value: function isQuery() {
      var TYPES = Bond.PATTERN.TYPE;
      var QUERY_BOND_TYPES = [TYPES.ANY, TYPES.SINGLE_OR_DOUBLE, TYPES.SINGLE_OR_AROMATIC, TYPES.DOUBLE_OR_AROMATIC, TYPES.AROMATIC];
      return this.customQuery !== null || QUERY_BOND_TYPES.includes(this.type) || TYPES.SINGLE === this.type && this.stereo === Bond.PATTERN.STEREO.EITHER;
    }
  }, {
    key: "hasRxnProps",
    value: function hasRxnProps() {
      return !!this.reactingCenterStatus;
    }
  }, {
    key: "getCenter",
    value: function getCenter(struct) {
      var p1 = struct.atoms.get(this.begin).pp;
      var p2 = struct.atoms.get(this.end).pp;
      return Vec2.lc2(p1, 0.5, p2, 0.5);
    }
  }, {
    key: "getDir",
    value: function getDir(struct) {
      var p1 = struct.atoms.get(this.begin).pp;
      var p2 = struct.atoms.get(this.end).pp;
      return p2.sub(p1).normalized();
    }
  }, {
    key: "clone",
    value: function clone(aidMap) {
      var cp = new Bond(this);
      if (aidMap) {
        cp.begin = aidMap.get(cp.begin);
        cp.end = aidMap.get(cp.end);
      }
      return cp;
    }
  }, {
    key: "getAttachedSGroups",
    value: function getAttachedSGroups(struct) {
      var _struct$atoms$get, _struct$atoms$get2;
      var sGroupsWithBeginAtom = ((_struct$atoms$get = struct.atoms.get(this.begin)) === null || _struct$atoms$get === void 0 ? void 0 : _struct$atoms$get.sgs) || new Pile();
      var sGroupsWithEndAtom = ((_struct$atoms$get2 = struct.atoms.get(this.end)) === null || _struct$atoms$get2 === void 0 ? void 0 : _struct$atoms$get2.sgs) || new Pile();
      return sGroupsWithBeginAtom === null || sGroupsWithBeginAtom === void 0 ? void 0 : sGroupsWithBeginAtom.intersection(sGroupsWithEndAtom);
    }
  }], [{
    key: "getAttrHash",
    value: function getAttrHash(bond) {
      var attrs = {};
      for (var attr in Bond.attrlist) {
        if (bond[attr] || attr === 'stereo') {
          attrs[attr] = bond[attr];
        }
      }
      return attrs;
    }
  }, {
    key: "getBondNeighbourIds",
    value: function getBondNeighbourIds(struct, bondId) {
      var bond = struct.bonds.get(bondId);
      var begin = bond.begin,
        end = bond.end;
      var beginBondIds = Atom.getConnectedBondIds(struct, begin).filter(function (id) {
        return id !== bondId;
      });
      var endBondIds = Atom.getConnectedBondIds(struct, end).filter(function (id) {
        return id !== bondId;
      });
      return {
        beginBondIds: beginBondIds,
        endBondIds: endBondIds
      };
    }
  }, {
    key: "getFusingConditions",
    value: function getFusingConditions(bond, bondBegin, bondEnd) {
      var _this$PATTERN$TYPE = this.PATTERN.TYPE,
        DOUBLE = _this$PATTERN$TYPE.DOUBLE,
        SINGLE = _this$PATTERN$TYPE.SINGLE;
      var isFusingToDoubleBond = bondBegin.type === SINGLE && bond.type === DOUBLE && bondEnd.type === SINGLE;
      var isFusingToSingleBond = bondBegin.type === DOUBLE && bond.type === SINGLE && bondEnd.type === DOUBLE;
      var isFusingDoubleSingleSingle = bondBegin.type === DOUBLE && bond.type === SINGLE && bondEnd.type === SINGLE;
      var isFusingSingleSingleDouble = bondBegin.type === SINGLE && bond.type === SINGLE && bondEnd.type === DOUBLE;
      var isAllSingle = bondBegin.type === SINGLE && bond.type === SINGLE && bondEnd.type === SINGLE;
      return {
        isFusingToSingleBond: isFusingToSingleBond,
        isFusingToDoubleBond: isFusingToDoubleBond,
        isFusingDoubleSingleSingle: isFusingDoubleSingleSingle,
        isFusingSingleSingleDouble: isFusingSingleSingleDouble,
        isAllSingle: isAllSingle
      };
    }
  }, {
    key: "getBenzeneConnectingBondType",
    value: function getBenzeneConnectingBondType(bond, bondBegin, bondEnd) {
      var _this$PATTERN$TYPE2 = this.PATTERN.TYPE,
        DOUBLE = _this$PATTERN$TYPE2.DOUBLE,
        SINGLE = _this$PATTERN$TYPE2.SINGLE;
      var _Bond$getFusingCondit = Bond.getFusingConditions(bond, bondBegin, bondEnd),
        isFusingToSingleBond = _Bond$getFusingCondit.isFusingToSingleBond,
        isFusingToDoubleBond = _Bond$getFusingCondit.isFusingToDoubleBond;
      if (isFusingToDoubleBond) {
        return DOUBLE;
      } else if (isFusingToSingleBond) {
        return SINGLE;
      }
      return null;
    }
  }, {
    key: "getCyclopentadieneFusingBondType",
    value: function getCyclopentadieneFusingBondType(bond, bondBegin, bondEnd) {
      var _this$PATTERN$TYPE3 = this.PATTERN.TYPE,
        DOUBLE = _this$PATTERN$TYPE3.DOUBLE,
        SINGLE = _this$PATTERN$TYPE3.SINGLE;
      var _Bond$getFusingCondit2 = Bond.getFusingConditions(bond, bondBegin, bondEnd),
        isFusingToSingleBond = _Bond$getFusingCondit2.isFusingToSingleBond,
        isFusingToDoubleBond = _Bond$getFusingCondit2.isFusingToDoubleBond,
        isFusingDoubleSingleSingle = _Bond$getFusingCondit2.isFusingDoubleSingleSingle,
        isAllSingle = _Bond$getFusingCondit2.isAllSingle;
      if (isFusingToDoubleBond) {
        return DOUBLE;
      } else if (isFusingToSingleBond || isAllSingle || isFusingDoubleSingleSingle) {
        return SINGLE;
      }
      return null;
    }
  }, {
    key: "getCyclopentadieneDoubleBondIndexes",
    value: function getCyclopentadieneDoubleBondIndexes(bond, bondBegin, bondEnd) {
      var _Bond$getFusingCondit3 = Bond.getFusingConditions(bond, bondBegin, bondEnd),
        isFusingToSingleBond = _Bond$getFusingCondit3.isFusingToSingleBond,
        isFusingToDoubleBond = _Bond$getFusingCondit3.isFusingToDoubleBond,
        isFusingDoubleSingleSingle = _Bond$getFusingCondit3.isFusingDoubleSingleSingle;
      if (isFusingToSingleBond || isFusingToDoubleBond) {
        return [3];
      }
      if (isFusingDoubleSingleSingle) {
        return [2, 4];
      }
      return [1, 3];
    }
  }, {
    key: "attrGetDefault",
    value: function attrGetDefault(attr) {
      if (attr in Bond.attrlist) {
        return Bond.attrlist[attr];
      }
    }
  }]);
  return Bond;
}(BaseMicromoleculeEntity);
_Bond = Bond;
_defineProperty__default["default"](Bond, "PATTERN", {
  TYPE: {
    SINGLE: 1,
    DOUBLE: 2,
    TRIPLE: 3,
    AROMATIC: 4,
    SINGLE_OR_DOUBLE: 5,
    SINGLE_OR_AROMATIC: 6,
    DOUBLE_OR_AROMATIC: 7,
    ANY: 8,
    DATIVE: 9,
    HYDROGEN: 10
  },
  STEREO: {
    NONE: 0,
    UP: 1,
    EITHER: 4,
    DOWN: 6,
    CIS_TRANS: 3
  },
  TOPOLOGY: {
    EITHER: 0,
    RING: 1,
    CHAIN: 2
  },
  REACTING_CENTER: {
    NOT_CENTER: -1,
    UNMARKED: 0,
    CENTER: 1,
    UNCHANGED: 2,
    MADE_OR_BROKEN: 4,
    ORDER_CHANGED: 8,
    MADE_OR_BROKEN_AND_CHANGED: 12
  }
});
_defineProperty__default["default"](Bond, "attrlist", {
  type: _Bond.PATTERN.TYPE.SINGLE,
  stereo: _Bond.PATTERN.STEREO.NONE,
  topology: _Bond.PATTERN.TOPOLOGY.EITHER,
  reactingCenterStatus: _Bond.PATTERN.REACTING_CENTER.UNMARKED,
  cip: null,
  customQuery: null
});

function _classPrivateFieldInitSpec$e(obj, privateMap, value) { _checkPrivateRedeclaration$e(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$e(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
exports.StereoFlag = void 0;
(function (StereoFlag) {
  StereoFlag["Mixed"] = "MIXED";
  StereoFlag["Abs"] = "ABS";
  StereoFlag["And"] = "AND";
  StereoFlag["Or"] = "OR";
})(exports.StereoFlag || (exports.StereoFlag = {}));
function calcStereoFlag(struct, stereoAids) {
  if (!stereoAids || stereoAids.length === 0) return undefined;
  var filteredStereoAtoms = stereoAids.map(function (aid) {
    return struct.atoms.get(aid);
  }).filter(function (atom) {
    return atom === null || atom === void 0 ? void 0 : atom.stereoLabel;
  });
  if (!filteredStereoAtoms.length) return undefined;
  var atom = filteredStereoAtoms[0];
  var stereoLabel = atom.stereoLabel;
  var hasAnotherLabel = filteredStereoAtoms.some(function (atom) {
    return (atom === null || atom === void 0 ? void 0 : atom.stereoLabel) !== stereoLabel;
  });
  var stereoFlag;
  if (hasAnotherLabel) {
    stereoFlag = exports.StereoFlag.Mixed;
  } else {
    var _stereoLabel$match;
    var label = (_stereoLabel$match = stereoLabel.match(/\D+/g)) === null || _stereoLabel$match === void 0 ? void 0 : _stereoLabel$match[0];
    switch (label) {
      case exports.StereoLabel.Abs:
        {
          stereoFlag = exports.StereoFlag.Abs;
          break;
        }
      case exports.StereoLabel.And:
        {
          stereoFlag = exports.StereoFlag.And;
          break;
        }
      case exports.StereoLabel.Or:
        {
          stereoFlag = exports.StereoFlag.Or;
          break;
        }
      default:
        {
          throw new Error("Unsupported stereo label: ".concat(label, "."));
        }
    }
  }
  return stereoFlag;
}
var _enhancedStereoFlag = new WeakMap();
var _stereoAtoms = new WeakMap();
var Fragment = function () {
  function Fragment() {
    var stereoAtoms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var stereoFlagPosition = arguments.length > 1 ? arguments[1] : undefined;
    var properties = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck__default["default"](this, Fragment);
    _classPrivateFieldInitSpec$e(this, _enhancedStereoFlag, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$e(this, _stereoAtoms, {
      writable: true,
      value: void 0
    });
    if (stereoFlagPosition) {
      this.stereoFlagPosition = new Vec2(stereoFlagPosition);
    }
    if (properties) {
      this.properties = properties;
    }
    _classPrivateFieldSet__default["default"](this, _stereoAtoms, stereoAtoms);
  }
  _createClass__default["default"](Fragment, [{
    key: "stereoAtoms",
    get: function get() {
      return _toConsumableArray__default["default"](_classPrivateFieldGet__default["default"](this, _stereoAtoms));
    }
  }, {
    key: "enhancedStereoFlag",
    get: function get() {
      return _classPrivateFieldGet__default["default"](this, _enhancedStereoFlag);
    }
  }, {
    key: "clone",
    value: function clone(aidMap) {
      var stereoAtoms = _classPrivateFieldGet__default["default"](this, _stereoAtoms).map(function (aid) {
        return aidMap.get(aid);
      });
      var fr = new Fragment(stereoAtoms, this.stereoFlagPosition, this.properties);
      _classPrivateFieldSet__default["default"](fr, _enhancedStereoFlag, _classPrivateFieldGet__default["default"](this, _enhancedStereoFlag));
      return fr;
    }
  }, {
    key: "updateStereoFlag",
    value: function updateStereoFlag(struct) {
      _classPrivateFieldSet__default["default"](this, _enhancedStereoFlag, calcStereoFlag(struct, this.stereoAtoms));
      return _classPrivateFieldGet__default["default"](this, _enhancedStereoFlag);
    }
  }, {
    key: "updateStereoAtom",
    value: function updateStereoAtom(struct, aid, frId, isAdd) {
      var _struct$atoms$get;
      if (isAdd && !_classPrivateFieldGet__default["default"](this, _stereoAtoms).includes(aid)) _classPrivateFieldGet__default["default"](this, _stereoAtoms).push(aid);
      if (!isAdd && (((_struct$atoms$get = struct.atoms.get(aid)) === null || _struct$atoms$get === void 0 ? void 0 : _struct$atoms$get.fragment) !== frId || !Array.from(struct.bonds.values()).filter(function (bond) {
        return bond.stereo && bond.type !== Bond.PATTERN.TYPE.DOUBLE;
      }).some(function (bond) {
        return bond.begin === aid;
      }))) {
        _classPrivateFieldSet__default["default"](this, _stereoAtoms, this.stereoAtoms.filter(function (item) {
          return item !== aid;
        }));
      }
      _classPrivateFieldSet__default["default"](this, _enhancedStereoFlag, calcStereoFlag(struct, this.stereoAtoms));
    }
  }, {
    key: "addStereoAtom",
    value: function addStereoAtom(atomId) {
      if (!_classPrivateFieldGet__default["default"](this, _stereoAtoms).includes(atomId)) {
        this.stereoAtoms.push(atomId);
        return true;
      }
      return false;
    }
  }, {
    key: "deleteStereoAtom",
    value: function deleteStereoAtom(struct, fragmentId, atomId) {
      var _struct$atoms$get2;
      if (((_struct$atoms$get2 = struct.atoms.get(atomId)) === null || _struct$atoms$get2 === void 0 ? void 0 : _struct$atoms$get2.fragment) !== fragmentId || !Array.from(struct.bonds.values()).filter(function (bond) {
        return bond.stereo && bond.type !== Bond.PATTERN.TYPE.DOUBLE;
      }).some(function (bond) {
        return bond.begin === atomId;
      })) {
        _classPrivateFieldSet__default["default"](this, _stereoAtoms, _classPrivateFieldGet__default["default"](this, _stereoAtoms).filter(function (item) {
          return item !== atomId;
        }));
        return true;
      }
      return false;
    }
  }], [{
    key: "getDefaultStereoFlagPosition",
    value: function getDefaultStereoFlagPosition(struct, fragmentId) {
      var fragment = struct.getFragment(fragmentId);
      if (!fragment) return undefined;
      var bb = fragment.getCoordBoundingBox();
      return new Vec2(bb.max.x, bb.min.y - 1);
    }
  }]);
  return Fragment;
}();

function canvasToModel(point, options) {
  return point.scaled(1 / options.microModeScale);
}
function modelToCanvas(vector, options) {
  return vector.scaled(options.microModeScale);
}
var Scale = {
  canvasToModel: canvasToModel,
  modelToCanvas: modelToCanvas
};

function isCorrectStereoCenter(bond, beginNeighs, endNeighs, struct) {
  var beginAtom = struct.atoms.get(bond.begin);
  var EndAtomNeigh = NaN;
  if ((endNeighs === null || endNeighs === void 0 ? void 0 : endNeighs.length) === 2) {
    EndAtomNeigh = endNeighs[0].aid === bond.begin ? endNeighs[1].aid : endNeighs[0].aid;
  }
  if (bond.stereo > 0) {
    var _struct$atomGetNeighb;
    if ((endNeighs === null || endNeighs === void 0 ? void 0 : endNeighs.length) === 1 && (beginNeighs === null || beginNeighs === void 0 ? void 0 : beginNeighs.length) === 2 && Number(beginAtom === null || beginAtom === void 0 ? void 0 : beginAtom.implicitH) % 2 === 0) {
      return false;
    }
    if ((endNeighs === null || endNeighs === void 0 ? void 0 : endNeighs.length) === 2 && (beginNeighs === null || beginNeighs === void 0 ? void 0 : beginNeighs.length) === 2 && Number(beginAtom === null || beginAtom === void 0 ? void 0 : beginAtom.implicitH) % 2 === 0 && ((_struct$atomGetNeighb = struct.atomGetNeighbors(EndAtomNeigh)) === null || _struct$atomGetNeighb === void 0 ? void 0 : _struct$atomGetNeighb.length) === 1) {
      return false;
    }
    if ((beginNeighs === null || beginNeighs === void 0 ? void 0 : beginNeighs.length) === 1) {
      return false;
    }
    return true;
  } else {
    return false;
  }
}
var StereoValidator = {
  isCorrectStereoCenter: isCorrectStereoCenter
};

var FunctionalGroupsProvider = function () {
  function FunctionalGroupsProvider() {
    _classCallCheck__default["default"](this, FunctionalGroupsProvider);
    this.functionalGroupsList = [];
  }
  _createClass__default["default"](FunctionalGroupsProvider, [{
    key: "getFunctionalGroupsList",
    value: function getFunctionalGroupsList() {
      return this.functionalGroupsList;
    }
  }, {
    key: "setFunctionalGroupsList",
    value: function setFunctionalGroupsList(list) {
      this.functionalGroupsList = list;
    }
  }, {
    key: "addToFunctionalGroupsList",
    value: function addToFunctionalGroupsList(list) {
      this.functionalGroupsList = [].concat(_toConsumableArray__default["default"](this.functionalGroupsList), _toConsumableArray__default["default"](list));
    }
  }], [{
    key: "getInstance",
    value: function getInstance() {
      if (!FunctionalGroupsProvider.instance) {
        FunctionalGroupsProvider.instance = new FunctionalGroupsProvider();
      }
      return FunctionalGroupsProvider.instance;
    }
  }]);
  return FunctionalGroupsProvider;
}();

var SaltsAndSolventsProvider = function () {
  function SaltsAndSolventsProvider() {
    _classCallCheck__default["default"](this, SaltsAndSolventsProvider);
    this.saltsAndSolventsList = [];
  }
  _createClass__default["default"](SaltsAndSolventsProvider, [{
    key: "getSaltsAndSolventsList",
    value: function getSaltsAndSolventsList() {
      return this.saltsAndSolventsList;
    }
  }, {
    key: "setSaltsAndSolventsList",
    value: function setSaltsAndSolventsList(list) {
      this.saltsAndSolventsList = list;
    }
  }], [{
    key: "getInstance",
    value: function getInstance() {
      if (!SaltsAndSolventsProvider.instance) {
        SaltsAndSolventsProvider.instance = new SaltsAndSolventsProvider();
      }
      return SaltsAndSolventsProvider.instance;
    }
  }]);
  return SaltsAndSolventsProvider;
}();

function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }
function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }
var Box2Abs = function () {
  function Box2Abs() {
    _classCallCheck__default["default"](this, Box2Abs);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && 'min' in args[0] && 'max' in args[0]) {
      this.p0 = args[0].min;
      this.p1 = args[0].max;
    }
    if (args.length === 2) {
      this.p0 = args[0];
      this.p1 = args[1];
    } else if (args.length === 4) {
      this.p0 = new Vec2(args[0], args[1]);
      this.p1 = new Vec2(args[2], args[3]);
    } else if (args.length === 0) {
      this.p0 = new Vec2();
      this.p1 = new Vec2();
    } else {
      throw new Error('Box2Abs constructor only accepts 4 numbers or 2 vectors or no args!');
    }
  }
  _createClass__default["default"](Box2Abs, [{
    key: "toString",
    value: function toString() {
      return this.p0.toString() + ' ' + this.p1.toString();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Box2Abs(this.p0, this.p1);
    }
  }, {
    key: "extend",
    value: function extend(lp, rb) {
      rb = rb || lp;
      return new Box2Abs(this.p0.sub(lp), this.p1.add(rb));
    }
  }, {
    key: "include",
    value: function include(p) {
      assert__default["default"](p != null);
      return new Box2Abs(this.p0.min(p), this.p1.max(p));
    }
  }, {
    key: "contains",
    value: function contains(p) {
      var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
      assert__default["default"](p != null);
      return p.x >= this.p0.x - ext && p.x <= this.p1.x + ext && p.y >= this.p0.y - ext && p.y <= this.p1.y + ext;
    }
  }, {
    key: "translate",
    value: function translate(d) {
      return new Box2Abs(this.p0.add(d), this.p1.add(d));
    }
  }, {
    key: "transform",
    value: function transform(f, options) {
      assert__default["default"](typeof f === 'function');
      return new Box2Abs(f(this.p0, options), f(this.p1, options));
    }
  }, {
    key: "sz",
    value: function sz() {
      return this.p1.sub(this.p0);
    }
  }, {
    key: "centre",
    value: function centre() {
      return Vec2.centre(this.p0, this.p1);
    }
  }, {
    key: "pos",
    value: function pos() {
      return this.p0;
    }
  }, {
    key: "hasZeroArea",
    value: function hasZeroArea() {
      var size = this.sz();
      return size.x === 0 && size.y === 0;
    }
  }], [{
    key: "fromRelBox",
    value: function fromRelBox(relBox) {
      return new Box2Abs(relBox.x, relBox.y, relBox.x + relBox.width, relBox.y + relBox.height);
    }
  }, {
    key: "union",
    value: function union(b1, b2) {
      return new Box2Abs(Vec2.min(b1.p0, b2.p0), Vec2.max(b1.p1, b2.p1));
    }
  }, {
    key: "segmentIntersection",
    value: function segmentIntersection(a, b, c, d) {
      var dc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);
      var dd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);
      var da = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);
      var db = (c.x - b.x) * (d.y - b.y) - (c.y - b.y) * (d.x - b.x);
      if (dc === 0 && dd === 0 && da === 0 && db === 0) {
        return _classStaticPrivateMethodGet(Box2Abs, Box2Abs, _isPointOnSegment).call(Box2Abs, a, b, c) || _classStaticPrivateMethodGet(Box2Abs, Box2Abs, _isPointOnSegment).call(Box2Abs, a, b, d) || _classStaticPrivateMethodGet(Box2Abs, Box2Abs, _isPointOnSegment).call(Box2Abs, c, d, a) || _classStaticPrivateMethodGet(Box2Abs, Box2Abs, _isPointOnSegment).call(Box2Abs, c, d, b);
      } else return dc * dd < 0 && da * db < 0;
    }
  }]);
  return Box2Abs;
}();
function _isPointOnSegment(segPointA, segPointB, point) {
  var minX = Math.min(segPointA.x, segPointB.x);
  var maxX = Math.max(segPointA.x, segPointB.x);
  var minY = Math.min(segPointA.y, segPointB.y);
  var maxY = Math.max(segPointA.y, segPointB.y);
  return point.x >= minX && point.x <= maxX && point.y >= minY && point.y <= maxY;
}

var SgContexts = {
  Fragment: 'Fragment',
  Multifragment: 'Multifragment',
  Bond: 'Bond',
  Atom: 'Atom',
  Group: 'Group'
};
var selectionKeys = ['atoms', 'bonds', 'frags', 'sgroups', 'rgroups', 'rgroupAttachmentPoints', 'rxnArrows', 'rxnPluses', 'simpleObjects', 'texts'];
var defaultBondThickness = 2;
exports.MonomerGroups = void 0;
(function (MonomerGroups) {
  MonomerGroups["SUGARS"] = "Sugars";
  MonomerGroups["BASES"] = "Bases";
  MonomerGroups["PHOSPHATES"] = "Phosphates";
})(exports.MonomerGroups || (exports.MonomerGroups = {}));
exports.MonomerGroupCodes = void 0;
(function (MonomerGroupCodes) {
  MonomerGroupCodes["R"] = "R";
  MonomerGroupCodes["A"] = "A";
  MonomerGroupCodes["C"] = "C";
  MonomerGroupCodes["G"] = "G";
  MonomerGroupCodes["T"] = "T";
  MonomerGroupCodes["U"] = "U";
  MonomerGroupCodes["X"] = "X";
  MonomerGroupCodes["P"] = "P";
})(exports.MonomerGroupCodes || (exports.MonomerGroupCodes = {}));
var MonomerCodeToGroup = {
  R: exports.MonomerGroups.SUGARS,
  A: exports.MonomerGroups.BASES,
  C: exports.MonomerGroups.BASES,
  G: exports.MonomerGroups.BASES,
  T: exports.MonomerGroups.BASES,
  U: exports.MonomerGroups.BASES,
  X: exports.MonomerGroups.BASES,
  P: exports.MonomerGroups.PHOSPHATES
};

function _createForOfIteratorHelper$7(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }
function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var SGroupBracketParams = _createClass__default["default"](function SGroupBracketParams(c, d, w, h) {
  _classCallCheck__default["default"](this, SGroupBracketParams);
  this.c = c;
  this.d = d;
  this.n = d.rotateSC(1, 0);
  this.w = w;
  this.h = h;
});
var SGroup = function () {
  function SGroup(type) {
    _classCallCheck__default["default"](this, SGroup);
    this.type = type;
    this.id = -1;
    this.label = -1;
    this.bracketBox = null;
    this.bracketDirection = new Vec2(1, 0);
    this.areas = [];
    this.hover = false;
    this.hovering = null;
    this.selected = false;
    this.selectionPlate = null;
    this.atoms = [];
    this.patoms = [];
    this.bonds = [];
    this.xBonds = [];
    this.neiAtoms = [];
    this.attachmentPoints = [];
    this.pp = null;
    this.data = {
      mul: 1,
      connectivity: 'ht',
      name: '',
      subscript: 'n',
      expanded: undefined,
      attached: false,
      absolute: true,
      showUnits: false,
      nCharsToDisplay: -1,
      tagChar: '',
      daspPos: 1,
      fieldType: 'F',
      fieldName: '',
      fieldValue: '',
      units: '',
      query: '',
      queryOp: ''
    };
  }
  _createClass__default["default"](SGroup, [{
    key: "getAttr",
    value: function getAttr(attr) {
      return this.data[attr];
    }
  }, {
    key: "setFunctionalGroup",
    value: function setFunctionalGroup(functionalGroup) {
      this.functionalGroup = functionalGroup;
    }
  }, {
    key: "getAttrs",
    value: function getAttrs() {
      var _this = this;
      var attrs = {};
      Object.keys(this.data).forEach(function (attr) {
        attrs[attr] = _this.data[attr];
      });
      return attrs;
    }
  }, {
    key: "setAttr",
    value: function setAttr(attr, value) {
      var oldValue = this.data[attr];
      this.data[attr] = value;
      return oldValue;
    }
  }, {
    key: "checkAttr",
    value: function checkAttr(attr, value) {
      return this.data[attr] === value;
    }
  }, {
    key: "updateOffset",
    value: function updateOffset(offset) {
      this.pp = Vec2.sum(this.bracketBox.p1, offset);
    }
  }, {
    key: "isExpanded",
    value: function isExpanded() {
      if (SGroup.isSuperAtom(this)) {
        return Boolean(this.data.expanded);
      } else {
        return true;
      }
    }
  }, {
    key: "isContracted",
    value: function isContracted() {
      return !this.isExpanded();
    }
  }, {
    key: "calculatePP",
    value: function calculatePP(struct) {
      var topLeftPoint;
      var isAtomContext = this.data.context === SgContexts.Atom;
      var isBondContent = this.data.context === SgContexts.Bond;
      if (isAtomContext || isBondContent) {
        var contentBoxes = [];
        var contentBB = null;
        this.atoms.forEach(function (aid) {
          var atom = struct.atoms.get(aid);
          var pos = new Vec2(atom.pp);
          var ext = new Vec2(0.05 * 3, 0.05 * 3);
          var bba = new Box2Abs(pos, pos).extend(ext, ext);
          contentBoxes.push(bba);
        });
        contentBoxes.forEach(function (bba) {
          var bbb = null;
          [bba.p0.x, bba.p1.x].forEach(function (x) {
            [bba.p0.y, bba.p1.y].forEach(function (y) {
              var v = new Vec2(x, y);
              bbb = !bbb ? new Box2Abs(v, v) : bbb.include(v);
            });
          });
          contentBB = !contentBB ? bbb : Box2Abs.union(contentBB, bbb);
        });
        topLeftPoint = isBondContent ? contentBB.centre() : contentBB.p0;
      } else {
        topLeftPoint = this.bracketBox.p1.add(new Vec2(0.5, 0.5));
      }
      var sgroups = Array.from(struct.sgroups.values());
      for (var i = 0; i < struct.sgroups.size; ++i) {
        if (!descriptorIntersects(sgroups, topLeftPoint)) break;
        topLeftPoint = topLeftPoint.add(new Vec2(0, 0.5));
      }
      if (this.data.fieldName === 'INDIGO_CIP_DESC') {
        if (this.atoms.length === 1) {
          var _struct$atoms$get;
          var sAtom = this.atoms[0];
          var sAtomPP = (_struct$atoms$get = struct.atoms.get(sAtom)) === null || _struct$atoms$get === void 0 ? void 0 : _struct$atoms$get.pp;
          if (sAtomPP) {
            topLeftPoint = sAtomPP;
          }
        } else {
          topLeftPoint = SGroup.getMassCentre(struct, this.atoms);
        }
      }
      this.pp = topLeftPoint;
    }
  }, {
    key: "isGroupAttached",
    value: function isGroupAttached(struct) {
      return this.getConnectionPointsCount(struct) >= 1;
    }
  }, {
    key: "addAttachmentPoint",
    value: function addAttachmentPoint(attachmentPoint) {
      var isAttachmentPointAlreadyExist = this.attachmentPoints.some(function (_ref) {
        var atomId = _ref.atomId;
        return attachmentPoint.atomId === atomId;
      });
      if (isAttachmentPointAlreadyExist) {
        throw new Error('The same attachment point cannot be added to an S-group more than once');
      }
      this.attachmentPoints.push(attachmentPoint);
    }
  }, {
    key: "addAttachmentPoints",
    value: function addAttachmentPoints(attachmentPoints) {
      var _iterator = _createForOfIteratorHelper$7(attachmentPoints),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var attachmentPoint = _step.value;
          this.addAttachmentPoint(attachmentPoint);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "removeAttachmentPoint",
    value: function removeAttachmentPoint(attachmentPointAtomId) {
      var index = this.attachmentPoints.findIndex(function (_ref2) {
        var atomId = _ref2.atomId;
        return attachmentPointAtomId === atomId;
      });
      if (index !== -1) {
        this.attachmentPoints.splice(index, 1);
        return true;
      }
      return false;
    }
  }, {
    key: "getAttachmentPoints",
    value: function getAttachmentPoints() {
      return this.attachmentPoints;
    }
  }, {
    key: "getConnectionPointsCount",
    value: function getConnectionPointsCount(struct) {
      var connectionAtoms = new Set();
      var _iterator2 = _createForOfIteratorHelper$7(this.atoms),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _struct$atomGetNeighb;
          var atomId = _step2.value;
          var neighbors = (_struct$atomGetNeighb = struct.atomGetNeighbors(atomId)) !== null && _struct$atomGetNeighb !== void 0 ? _struct$atomGetNeighb : [];
          var _iterator3 = _createForOfIteratorHelper$7(neighbors),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var aid = _step3.value.aid;
              if (!this.atoms.includes(aid)) {
                connectionAtoms.add(atomId);
                break;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return connectionAtoms.size;
    }
  }, {
    key: "isNotContractible",
    value: function isNotContractible(struct) {
      return this.getConnectionPointsCount(struct) > 1;
    }
  }, {
    key: "getAttachmentAtomId",
    value: function getAttachmentAtomId() {
      var _this$attachmentPoint;
      return (_this$attachmentPoint = this.attachmentPoints[0]) === null || _this$attachmentPoint === void 0 ? void 0 : _this$attachmentPoint.atomId;
    }
  }, {
    key: "getContractedPosition",
    value: function getContractedPosition(struct) {
      var _this$attachmentPoint2;
      var atomId = (_this$attachmentPoint2 = this.attachmentPoints[0]) === null || _this$attachmentPoint2 === void 0 ? void 0 : _this$attachmentPoint2.atomId;
      var representAtom = struct.atoms.get(atomId);
      if (!representAtom) {
        atomId = this.atoms[0];
        representAtom = struct.atoms.get(this.atoms[0]);
      }
      assert__default["default"](representAtom != null);
      return {
        atomId: atomId,
        position: representAtom.pp
      };
    }
  }, {
    key: "cloneAttachmentPoints",
    value: function cloneAttachmentPoints(atomIdMap) {
      return this.attachmentPoints.map(function (point) {
        return point.clone(atomIdMap);
      });
    }
  }], [{
    key: "getOffset",
    value: function getOffset(sgroup) {
      if (!(sgroup !== null && sgroup !== void 0 && sgroup.pp) || !sgroup.bracketBox) return null;
      return Vec2.diff(sgroup.pp, sgroup.bracketBox.p1);
    }
  }, {
    key: "isSaltOrSolvent",
    value: function isSaltOrSolvent(moleculeName) {
      var saltsAndSolventsProvider = SaltsAndSolventsProvider.getInstance();
      var saltsAndSolvents = saltsAndSolventsProvider.getSaltsAndSolventsList();
      return saltsAndSolvents.some(function (_ref3) {
        var name = _ref3.name,
          abbreviation = _ref3.abbreviation;
        return name === moleculeName || moleculeName === abbreviation;
      });
    }
  }, {
    key: "isAtomInSaltOrSolvent",
    value: function isAtomInSaltOrSolvent(atomId, sgroupsOnCanvas) {
      var _this2 = this;
      var onlySaltsOrSolvents = sgroupsOnCanvas.filter(function (sgroup) {
        return _this2.isSaltOrSolvent(sgroup.data.name);
      });
      return onlySaltsOrSolvents.some(function (_ref4) {
        var atoms = _ref4.atoms;
        return atoms.some(function (atomIdInSaltOrSolvent) {
          return atomIdInSaltOrSolvent === atomId;
        });
      });
    }
  }, {
    key: "isBondInSaltOrSolvent",
    value: function isBondInSaltOrSolvent(bondId, sgroupsOnCanvas) {
      var _this3 = this;
      var onlySaltsOrSolvents = sgroupsOnCanvas.filter(function (sgroup) {
        return _this3.isSaltOrSolvent(sgroup.data.name);
      });
      return onlySaltsOrSolvents.some(function (_ref5) {
        var bonds = _ref5.bonds;
        return bonds.some(function (bondIdInSaltOrSolvent) {
          return bondIdInSaltOrSolvent === bondId;
        });
      });
    }
  }, {
    key: "filterAtoms",
    value: function filterAtoms(atoms, map) {
      var newAtoms = [];
      for (var i = 0; i < atoms.length; ++i) {
        var aid = atoms[i];
        if (typeof map[aid] !== 'number') newAtoms.push(aid);else if (map[aid] >= 0) newAtoms.push(map[aid]);else newAtoms.push(-1);
      }
      return newAtoms;
    }
  }, {
    key: "removeNegative",
    value: function removeNegative(atoms) {
      var newAtoms = [];
      for (var j = 0; j < atoms.length; ++j) {
        if (atoms[j] >= 0) newAtoms.push(atoms[j]);
      }
      return newAtoms;
    }
  }, {
    key: "filter",
    value: function filter(_mol, sg, atomMap) {
      sg.atoms = SGroup.removeNegative(SGroup.filterAtoms(sg.atoms, atomMap));
    }
  }, {
    key: "clone",
    value: function clone(sgroup, aidMap) {
      var cp = new SGroup(sgroup.type);
      Object.keys(sgroup.data).forEach(function (field) {
        cp.data[field] = sgroup.data[field];
      });
      cp.atoms = sgroup.atoms.map(function (elem) {
        return aidMap.get(elem);
      });
      cp.pp = sgroup.pp;
      cp.bracketBox = sgroup.bracketBox;
      cp.patoms = null;
      cp.bonds = null;
      cp.allAtoms = sgroup.allAtoms;
      cp.data.expanded = sgroup.data.expanded;
      cp.addAttachmentPoints(sgroup.cloneAttachmentPoints(aidMap));
      return cp;
    }
  }, {
    key: "addAtom",
    value: function addAtom(sgroup, aid, struct) {
      sgroup.atoms.push(aid);
      if (sgroup.isNotContractible(struct)) {
        sgroup.setAttr('expanded', true);
      }
    }
  }, {
    key: "removeAtom",
    value: function removeAtom(sgroup, aid) {
      if (!sgroup) {
        return;
      }
      for (var i = 0; i < sgroup.atoms.length; ++i) {
        if (sgroup.atoms[i] === aid) {
          sgroup.atoms.splice(i, 1);
          return;
        }
      }
    }
  }, {
    key: "getCrossBonds",
    value: function getCrossBonds(mol, parentAtomSet) {
      var crossBonds = {};
      mol.bonds.forEach(function (bond, bid) {
        if (parentAtomSet.has(bond.begin) && !parentAtomSet.has(bond.end)) {
          if (!crossBonds[bond.begin]) {
            crossBonds[bond.begin] = [];
          }
          crossBonds[bond.begin].push(bid);
        } else if (parentAtomSet.has(bond.end) && !parentAtomSet.has(bond.begin)) {
          if (!crossBonds[bond.end]) {
            crossBonds[bond.end] = [];
          }
          crossBonds[bond.end].push(bid);
        }
      });
      return crossBonds;
    }
  }, {
    key: "bracketPos",
    value: function bracketPos(sGroup, mol, crossBondsPerAtom, remol, render) {
      var BORDER_EXT = new Vec2(0.05 * 3, 0.05 * 3);
      var PADDING_VECTOR = new Vec2(0.2, 0.4);
      var atoms = sGroup.atoms;
      var crossBonds = crossBondsPerAtom ? Object.values(crossBondsPerAtom).flat() : null;
      if (!crossBonds || crossBonds.length !== 2) {
        sGroup.bracketDirection = new Vec2(1, 0);
      } else {
        var p1 = mol.bonds.get(crossBonds[0]).getCenter(mol);
        var p2 = mol.bonds.get(crossBonds[1]).getCenter(mol);
        sGroup.bracketDirection = Vec2.diff(p2, p1).normalized();
      }
      var d = sGroup.bracketDirection;
      var braketBox = null;
      var contentBoxes = [];
      var getAtom = function getAtom(aid) {
        if (remol && render) {
          return remol.atoms.get(aid);
        }
        return mol.atoms.get(aid);
      };
      atoms.forEach(function (aid) {
        var atom = getAtom(aid);
        var position;
        var structBoundingBox;
        if ('getVBoxObj' in atom && render) {
          structBoundingBox = atom.getVBoxObj(render);
        } else {
          position = new Vec2(atom.pp);
          structBoundingBox = new Box2Abs(position, position);
        }
        contentBoxes.push(structBoundingBox.extend(BORDER_EXT, BORDER_EXT));
      });
      contentBoxes.forEach(function (bba) {
        var bbb = null;
        [bba.p0.x, bba.p1.x].forEach(function (x) {
          [bba.p0.y, bba.p1.y].forEach(function (y) {
            var v = new Vec2(x, y);
            var p = new Vec2(Vec2.dot(v, d), Vec2.dot(v, d.rotateSC(1, 0)));
            bbb = !bbb ? new Box2Abs(p, p) : bbb.include(p);
          });
        });
        braketBox = !braketBox ? bbb : Box2Abs.union(braketBox, bbb);
      });
      if (!render) render = window.ketcher.editor.render;
      var attachmentPointsVBox = render.ctab.getRGroupAttachmentPointsVBoxByAtomIds(atoms);
      attachmentPointsVBox = attachmentPointsVBox ? attachmentPointsVBox.extend(BORDER_EXT, BORDER_EXT) : attachmentPointsVBox;
      braketBox = attachmentPointsVBox && braketBox ? Box2Abs.union(braketBox, attachmentPointsVBox) : braketBox;
      if (braketBox) braketBox = braketBox.extend(PADDING_VECTOR, PADDING_VECTOR);
      sGroup.bracketBox = braketBox;
    }
  }, {
    key: "getBracketParameters",
    value: function getBracketParameters(mol, crossBondsPerAtom, atomSet, bb, d, n) {
      var brackets = [];
      var crossBondsPerAtomValues = Object.values(crossBondsPerAtom);
      var crossBonds = crossBondsPerAtomValues.flat();
      if (crossBonds.length < 2) {
        (function () {
          d = d || new Vec2(1, 0);
          n = n || d.rotateSC(1, 0);
          var bracketWidth = Math.min(0.25, bb.sz().x * 0.3);
          var cl = Vec2.lc2(d, bb.p0.x, n, 0.5 * (bb.p0.y + bb.p1.y));
          var cr = Vec2.lc2(d, bb.p1.x, n, 0.5 * (bb.p0.y + bb.p1.y));
          var bracketHeight = bb.sz().y;
          brackets.push(new SGroupBracketParams(cl, d.negated(), bracketWidth, bracketHeight), new SGroupBracketParams(cr, d, bracketWidth, bracketHeight));
        })();
      } else if (crossBonds.length === 2 && crossBondsPerAtomValues.length === 2) {
        (function () {
          var b1 = mol.bonds.get(crossBonds[0]);
          var b2 = mol.bonds.get(crossBonds[1]);
          var cl0 = b1.getCenter(mol);
          var cr0 = b2.getCenter(mol);
          var dr = Vec2.diff(cr0, cl0).normalized();
          var dl = dr.negated();
          var bracketWidth = 0.25;
          var bracketHeight = 1.5;
          brackets.push(new SGroupBracketParams(cl0.addScaled(dl, 0), dl, bracketWidth, bracketHeight), new SGroupBracketParams(cr0.addScaled(dr, 0), dr, bracketWidth, bracketHeight));
        })();
      } else {
        (function () {
          for (var i = 0; i < crossBonds.length; ++i) {
            var b = mol.bonds.get(crossBonds[i]);
            var c = b.getCenter(mol);
            var _d = atomSet.has(b.begin) ? b.getDir(mol) : b.getDir(mol).negated();
            brackets.push(new SGroupBracketParams(c, _d, 0.2, 1.0));
          }
        })();
      }
      return brackets;
    }
  }, {
    key: "getObjBBox",
    value: function getObjBBox(atoms, mol) {
      var a0 = mol.atoms.get(atoms[0]).pp;
      var bb = new Box2Abs(a0, a0);
      for (var i = 1; i < atoms.length; ++i) {
        var aid = atoms[i];
        var atom = mol.atoms.get(aid);
        var p = atom.pp;
        bb = bb.include(p);
      }
      return bb;
    }
  }, {
    key: "getAtoms",
    value: function getAtoms(mol, sg) {
      if (!sg.allAtoms) return sg.atoms;
      var atoms = [];
      mol.atoms.forEach(function (_atom, aid) {
        atoms.push(aid);
      });
      return atoms;
    }
  }, {
    key: "getBonds",
    value: function getBonds(mol, sg) {
      var atoms = SGroup.getAtoms(mol, sg);
      var bonds = [];
      mol.bonds.forEach(function (bond, bid) {
        if (atoms.indexOf(bond.begin) >= 0 && atoms.indexOf(bond.end) >= 0) {
          bonds.push(bid);
        }
      });
      return bonds;
    }
  }, {
    key: "prepareMulForSaving",
    value: function prepareMulForSaving(sgroup, mol) {
      sgroup.atoms.sort(function (a, b) {
        return a - b;
      });
      sgroup.atomSet = new Pile(sgroup.atoms);
      sgroup.parentAtomSet = new Pile(sgroup.atomSet);
      var inBonds = [];
      var xBonds = [];
      mol.bonds.forEach(function (bond, bid) {
        if (sgroup.parentAtomSet.has(bond.begin) && sgroup.parentAtomSet.has(bond.end)) {
          inBonds.push(bid);
        } else if (sgroup.parentAtomSet.has(bond.begin) || sgroup.parentAtomSet.has(bond.end)) {
          xBonds.push(bid);
        }
      });
      if (xBonds.length !== 0 && xBonds.length !== 2) {
        throw Error('Unsupported cross-bonds number');
      }
      var xAtom1 = -1;
      var xAtom2 = -1;
      var crossBond = null;
      if (xBonds.length === 2) {
        var bond1 = mol.bonds.get(xBonds[0]);
        xAtom1 = sgroup.parentAtomSet.has(bond1.begin) ? bond1.begin : bond1.end;
        var bond2 = mol.bonds.get(xBonds[1]);
        xAtom2 = sgroup.parentAtomSet.has(bond2.begin) ? bond2.begin : bond2.end;
        crossBond = bond2;
      }
      var tailAtom = xAtom2;
      var newAtoms = [];
      var _loop = function _loop() {
        var amap = {};
        sgroup.atoms.forEach(function (aid) {
          var atom = mol.atoms.get(aid);
          var aid2 = mol.atoms.add(new Atom(atom));
          newAtoms.push(aid2);
          sgroup.atomSet.add(aid2);
          amap[aid] = aid2;
        });
        inBonds.forEach(function (bid) {
          var bond = mol.bonds.get(bid);
          var newBond = new Bond(bond);
          newBond.begin = amap[newBond.begin];
          newBond.end = amap[newBond.end];
          mol.bonds.add(newBond);
        });
        if (crossBond !== null) {
          var newCrossBond = new Bond(crossBond);
          newCrossBond.begin = tailAtom;
          newCrossBond.end = amap[xAtom1];
          mol.bonds.add(newCrossBond);
          tailAtom = amap[xAtom2];
        }
      };
      for (var j = 0; j < sgroup.data.mul - 1; j++) {
        _loop();
      }
      if (tailAtom >= 0) {
        var xBond2 = mol.bonds.get(xBonds[1]);
        if (xBond2.begin === xAtom2) xBond2.begin = tailAtom;else xBond2.end = tailAtom;
      }
      sgroup.bonds = xBonds;
      newAtoms.forEach(function (aid) {
        mol.sGroupForest.getPathToRoot(sgroup.id).reverse().forEach(function (sgid) {
          mol.atomAddToSGroup(sgid, aid);
        });
      });
    }
  }, {
    key: "getMassCentre",
    value: function getMassCentre(mol, atoms) {
      var c = new Vec2();
      for (var i = 0; i < atoms.length; ++i) {
        c = c.addScaled(mol.atoms.get(atoms[i]).pp, 1.0 / atoms.length);
      }
      return c;
    }
  }, {
    key: "isBondInContractedSGroup",
    value: function isBondInContractedSGroup(bond, sGroups) {
      return _toConsumableArray__default["default"](sGroups.values()).some(function (sGroupOrReSGroup) {
        var sGroup = 'item' in sGroupOrReSGroup ? sGroupOrReSGroup.item : sGroupOrReSGroup;
        var atomsInSGroup = sGroup === null || sGroup === void 0 ? void 0 : sGroup.atoms;
        return (sGroup === null || sGroup === void 0 ? void 0 : sGroup.isContracted()) && atomsInSGroup.includes(bond === null || bond === void 0 ? void 0 : bond.begin) && atomsInSGroup.includes(bond === null || bond === void 0 ? void 0 : bond.end);
      });
    }
  }, {
    key: "isSuperAtom",
    value: function isSuperAtom(sGroup) {
      if (!sGroup) {
        return false;
      }
      return (sGroup === null || sGroup === void 0 ? void 0 : sGroup.type) === SGroup.TYPES.SUP;
    }
  }, {
    key: "isDataSGroup",
    value: function isDataSGroup(sGroup) {
      return sGroup.type === SGroup.TYPES.DAT;
    }
  }, {
    key: "isQuerySGroup",
    value: function isQuerySGroup(sGroup) {
      return sGroup.type === SGroup.TYPES.queryComponent;
    }
  }, {
    key: "isSRUSGroup",
    value: function isSRUSGroup(sGroup) {
      return sGroup.type === SGroup.TYPES.SRU;
    }
  }, {
    key: "isMulSGroup",
    value: function isMulSGroup(sGroup) {
      return sGroup.type === SGroup.TYPES.MUL;
    }
  }]);
  return SGroup;
}();
_defineProperty__default["default"](SGroup, "TYPES", {
  SUP: 'SUP',
  MUL: 'MUL',
  SRU: 'SRU',
  MON: 'MON',
  MER: 'MER',
  COP: 'COP',
  CRO: 'CRO',
  MOD: 'MOD',
  GRA: 'GRA',
  COM: 'COM',
  MIX: 'MIX',
  FOR: 'FOR',
  DAT: 'DAT',
  ANY: 'ANY',
  GEN: 'GEN',
  queryComponent: 'queryComponent'
});
_defineProperty__default["default"](SGroup, "isAtomInContractedSGroup", function (atom, sGroups) {
  var contractedSGroup = [];
  sGroups.forEach(function (sGroupOrReSGroup) {
    var sGroup = 'item' in sGroupOrReSGroup ? sGroupOrReSGroup.item : sGroupOrReSGroup;
    if (sGroup.isContracted()) {
      contractedSGroup.push(sGroup.id);
    }
  });
  return contractedSGroup.some(function (sg) {
    return atom.sgs.has(sg);
  });
});
function descriptorIntersects(sgroups, topLeftPoint) {
  return sgroups.some(function (sg) {
    if (!sg.pp) return false;
    var sgBottomRightPoint = sg.pp.add(new Vec2(0.5, 0.5));
    var bottomRightPoint = topLeftPoint.add(new Vec2(0.5, 0.5));
    return Box2Abs.segmentIntersection(sg.pp, sgBottomRightPoint, topLeftPoint, bottomRightPoint);
  });
}

function _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }
function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classPrivateFieldInitSpec$d(obj, privateMap, value) { _checkPrivateRedeclaration$d(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$d(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _sgroup = new WeakMap();
var FunctionalGroup = function () {
  function FunctionalGroup(sgroup) {
    _classCallCheck__default["default"](this, FunctionalGroup);
    _classPrivateFieldInitSpec$d(this, _sgroup, {
      writable: true,
      value: void 0
    });
    assert__default["default"](sgroup != null);
    _classPrivateFieldSet__default["default"](this, _sgroup, sgroup);
    sgroup.setFunctionalGroup(this);
  }
  _createClass__default["default"](FunctionalGroup, [{
    key: "name",
    get: function get() {
      return _classPrivateFieldGet__default["default"](this, _sgroup).data.name;
    }
  }, {
    key: "relatedSGroupId",
    get: function get() {
      return _classPrivateFieldGet__default["default"](this, _sgroup).id;
    }
  }, {
    key: "isExpanded",
    get: function get() {
      return _classPrivateFieldGet__default["default"](this, _sgroup).data.expanded;
    }
  }, {
    key: "relatedSGroup",
    get: function get() {
      return _classPrivateFieldGet__default["default"](this, _sgroup);
    }
  }], [{
    key: "isFunctionalGroup",
    value: function isFunctionalGroup(sgroup) {
      var provider = FunctionalGroupsProvider.getInstance();
      var functionalGroups = provider.getFunctionalGroupsList();
      var name = sgroup.data.name,
        type = sgroup.type;
      return type === 'SUP' && (functionalGroups.some(function (type) {
        return type.name === name;
      }) || SGroup.isSaltOrSolvent(name));
    }
  }, {
    key: "atomsInFunctionalGroup",
    value: function atomsInFunctionalGroup(functionalGroups, atom) {
      if (functionalGroups.size === 0) {
        return null;
      }
      var _iterator = _createForOfIteratorHelper$6(functionalGroups.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var fg = _step.value;
          if (fg.relatedSGroup.atoms.includes(atom)) return atom;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return null;
    }
  }, {
    key: "bondsInFunctionalGroup",
    value: function bondsInFunctionalGroup(molecule, functionalGroups, bond) {
      if (functionalGroups.size === 0) {
        return null;
      }
      var _iterator2 = _createForOfIteratorHelper$6(functionalGroups.values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var fg = _step2.value;
          var bonds = SGroup.getBonds(molecule, fg.relatedSGroup);
          if (bonds.includes(bond)) return bond;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return null;
    }
  }, {
    key: "isRGroupAttachmentPointInsideFunctionalGroup",
    value: function isRGroupAttachmentPointInsideFunctionalGroup(molecule, id) {
      var rgroupAttachmentPoint = molecule.rgroupAttachmentPoints.get(id);
      assert__default["default"](rgroupAttachmentPoint != null);
      var attachedAtom = rgroupAttachmentPoint.atomId;
      return FunctionalGroup.atomsInFunctionalGroup(molecule.functionalGroups, attachedAtom);
    }
  }, {
    key: "findFunctionalGroupByAtom",
    value: function findFunctionalGroupByAtom(functionalGroups, atomId, isFunctionalGroupReturned) {
      var _iterator3 = _createForOfIteratorHelper$6(functionalGroups.values()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var fg = _step3.value;
          if (fg.relatedSGroup.atoms.includes(atomId)) return isFunctionalGroupReturned ? fg : fg.relatedSGroupId;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return null;
    }
  }, {
    key: "findFunctionalGroupByBond",
    value: function findFunctionalGroupByBond(molecule, functionalGroups, bondId, isFunctionalGroupReturned) {
      var _iterator4 = _createForOfIteratorHelper$6(functionalGroups.values()),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var fg = _step4.value;
          var bonds = SGroup.getBonds(molecule, fg.relatedSGroup);
          if (bonds.includes(bondId)) {
            return isFunctionalGroupReturned ? fg : fg.relatedSGroupId;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return null;
    }
  }, {
    key: "findFunctionalGroupBySGroup",
    value: function findFunctionalGroupBySGroup(functionalGroups, sGroup) {
      var key = functionalGroups.find(function (_, functionalGroup) {
        return functionalGroup.relatedSGroupId === (sGroup === null || sGroup === void 0 ? void 0 : sGroup.id);
      });
      return key !== null ? functionalGroups.get(key) : undefined;
    }
  }, {
    key: "clone",
    value: function clone(functionalGroup) {
      return new FunctionalGroup(_classPrivateFieldGet__default["default"](functionalGroup, _sgroup));
    }
  }, {
    key: "isAtomInContractedFunctionalGroup",
    value: function isAtomInContractedFunctionalGroup(atom, sgroups, functionalGroups, sgroupsFromReStruct) {
      var contractedFunctionalGroups = [];
      if (sgroupsFromReStruct) {
        sgroups.forEach(function (sg) {
          if (FunctionalGroup.isContractedFunctionalGroup(sg.item, functionalGroups)) {
            contractedFunctionalGroups.push(sg.item.id);
          }
        });
      } else {
        sgroups.forEach(function (sg) {
          if (FunctionalGroup.isContractedFunctionalGroup(sg, functionalGroups)) {
            contractedFunctionalGroups.push(sg.id);
          }
        });
      }
      return contractedFunctionalGroups.some(function (sg) {
        return atom.sgs.has(sg);
      });
    }
  }, {
    key: "isBondInContractedFunctionalGroup",
    value: function isBondInContractedFunctionalGroup(bond, sGroups, functionalGroups) {
      return _toConsumableArray__default["default"](sGroups.values()).some(function (_sGroup) {
        var sGroup = 'item' in _sGroup ? _sGroup === null || _sGroup === void 0 ? void 0 : _sGroup.item : _sGroup;
        var atomsInSGroup = sGroup === null || sGroup === void 0 ? void 0 : sGroup.atoms;
        var isContracted = FunctionalGroup.isContractedFunctionalGroup(sGroup, functionalGroups);
        return isContracted && atomsInSGroup.includes(bond.begin) && atomsInSGroup.includes(bond.end);
      });
    }
  }, {
    key: "isHalfBondInContractedFunctionalGroup",
    value: function isHalfBondInContractedFunctionalGroup(halfBond, struct) {
      var bond = struct.bonds.get(halfBond.bid);
      assert__default["default"](bond != null);
      return this.isBondInContractedFunctionalGroup(bond, struct.sgroups, struct.functionalGroups);
    }
  }, {
    key: "isContractedFunctionalGroup",
    value: function isContractedFunctionalGroup(sgroup, functionalGroups) {
      var isFunctionalGroup = false;
      var expanded = false;
      if (sgroup instanceof SGroup) {
        if (sgroup.functionalGroup) {
          isFunctionalGroup = true;
          expanded = sgroup.functionalGroup.isExpanded;
        }
      } else {
        functionalGroups.forEach(function (fg) {
          if (fg.relatedSGroupId === sgroup) {
            isFunctionalGroup = true;
            expanded = fg.isExpanded;
          }
        });
      }
      return !expanded && isFunctionalGroup;
    }
  }]);
  return FunctionalGroup;
}();

var HalfBond = _createClass__default["default"](function HalfBond(begin, end, bid) {
  _classCallCheck__default["default"](this, HalfBond);
  assert__default["default"](arguments.length === 3, 'Invalid parameter number.');
  this.begin = begin;
  this.end = end;
  this.bid = bid;
  this.dir = new Vec2();
  this.norm = new Vec2();
  this.ang = 0;
  this.p = new Vec2();
  this.loop = -1;
  this.contra = -1;
  this.next = -1;
  this.leftSin = 0;
  this.leftCos = 0;
  this.leftNeighbor = 0;
  this.rightSin = 0;
  this.rightCos = 0;
  this.rightNeighbor = 0;
});

var Loop = _createClass__default["default"](function Loop(hbs, struct, isConvex) {
  var _this = this;
  _classCallCheck__default["default"](this, Loop);
  this.hbs = hbs;
  this.dblBonds = 0;
  this.aromatic = true;
  this.convex = isConvex || false;
  hbs.forEach(function (hb) {
    var bond = struct.bonds.get(struct.halfBonds.get(hb).bid);
    if (bond.type !== Bond.PATTERN.TYPE.AROMATIC) _this.aromatic = false;
    if (bond.type === Bond.PATTERN.TYPE.DOUBLE) _this.dblBonds++;
  });
});

var RGroup = function () {
  function RGroup(atrributes) {
    _classCallCheck__default["default"](this, RGroup);
    this.frags = new Pile();
    this.resth = (atrributes === null || atrributes === void 0 ? void 0 : atrributes.resth) || false;
    this.range = (atrributes === null || atrributes === void 0 ? void 0 : atrributes.range) || '';
    this.ifthen = (atrributes === null || atrributes === void 0 ? void 0 : atrributes.ifthen) || 0;
    this.index = (atrributes === null || atrributes === void 0 ? void 0 : atrributes.index) || -1;
  }
  _createClass__default["default"](RGroup, [{
    key: "getAttrs",
    value: function getAttrs() {
      return {
        resth: this.resth,
        range: this.range,
        ifthen: this.ifthen,
        index: this.index
      };
    }
  }, {
    key: "clone",
    value: function clone(fidMap) {
      var ret = new RGroup(this);
      this.frags.forEach(function (fid) {
        if (!fidMap || fidMap.has(fid)) {
          ret.frags.add(fidMap ? fidMap.get(fid) : fid);
        }
      });
      return ret;
    }
  }], [{
    key: "findRGroupByFragment",
    value: function findRGroupByFragment(rgroups, frid) {
      return rgroups.find(function (_rgid, rgroup) {
        return rgroup.frags.has(frid);
      });
    }
  }]);
  return RGroup;
}();

function _callSuper$1p(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1p() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1p() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1p = function _isNativeReflectConstruct() { return !!t; })(); }
var RGroupAttachmentPoint = function (_BaseMicromoleculeEnt) {
  _inherits__default["default"](RGroupAttachmentPoint, _BaseMicromoleculeEnt);
  function RGroupAttachmentPoint(atomId, type, initiallySelected) {
    var _this;
    _classCallCheck__default["default"](this, RGroupAttachmentPoint);
    _this = _callSuper$1p(this, RGroupAttachmentPoint, [initiallySelected]);
    _this.atomId = atomId;
    _this.type = type;
    return _this;
  }
  _createClass__default["default"](RGroupAttachmentPoint, [{
    key: "clone",
    value: function clone(atomToNewAtom) {
      var newAtomId = atomToNewAtom === null || atomToNewAtom === void 0 ? void 0 : atomToNewAtom.get(this.atomId);
      return new RGroupAttachmentPoint(newAtomId !== null && newAtomId !== void 0 ? newAtomId : this.atomId, this.type, this.initiallySelected);
    }
  }]);
  return RGroupAttachmentPoint;
}(BaseMicromoleculeEntity);

function _callSuper$1o(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1o() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1o() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1o = function _isNativeReflectConstruct() { return !!t; })(); }
exports.RxnArrowMode = void 0;
(function (RxnArrowMode) {
  RxnArrowMode["OpenAngle"] = "open-angle";
  RxnArrowMode["FilledTriangle"] = "filled-triangle";
  RxnArrowMode["FilledBow"] = "filled-bow";
  RxnArrowMode["DashedOpenAngle"] = "dashed-open-angle";
  RxnArrowMode["Failed"] = "failed";
  RxnArrowMode["BothEndsFilledTriangle"] = "both-ends-filled-triangle";
  RxnArrowMode["EquilibriumFilledTriangle"] = "equilibrium-filled-triangle";
  RxnArrowMode["EquilibriumFilledHalfBow"] = "equilibrium-filled-half-bow";
  RxnArrowMode["EquilibriumOpenAngle"] = "equilibrium-open-angle";
  RxnArrowMode["UnbalancedEquilibriumFilledHalfBow"] = "unbalanced-equilibrium-filled-half-bow";
  RxnArrowMode["UnbalancedEquilibriumOpenHalfAngle"] = "unbalanced-equilibrium-open-half-angle";
  RxnArrowMode["UnbalancedEquilibriumLargeFilledHalfBow"] = "unbalanced-equilibrium-large-filled-half-bow";
  RxnArrowMode["UnbalancedEquilibriumFilledHalfTriangle"] = "unbalanced-equilibrium-filled-half-triangle";
  RxnArrowMode["EllipticalArcFilledBow"] = "elliptical-arc-arrow-filled-bow";
  RxnArrowMode["EllipticalArcFilledTriangle"] = "elliptical-arc-arrow-filled-triangle";
  RxnArrowMode["EllipticalArcOpenAngle"] = "elliptical-arc-arrow-open-angle";
  RxnArrowMode["EllipticalArcOpenHalfAngle"] = "elliptical-arc-arrow-open-half-angle";
})(exports.RxnArrowMode || (exports.RxnArrowMode = {}));
var RxnArrow = function (_BaseMicromoleculeEnt) {
  _inherits__default["default"](RxnArrow, _BaseMicromoleculeEnt);
  function RxnArrow(attributes) {
    var _this;
    _classCallCheck__default["default"](this, RxnArrow);
    _this = _callSuper$1o(this, RxnArrow, [attributes === null || attributes === void 0 ? void 0 : attributes.initiallySelected]);
    _this.pos = [];
    if (attributes.pos) {
      for (var i = 0; i < attributes.pos.length; i++) {
        var currentP = attributes.pos[i];
        _this.pos[i] = currentP ? new Vec2(attributes.pos[i]) : new Vec2();
      }
    }
    _this.mode = attributes.mode;
    var defaultHeight = 2;
    if (RxnArrow.isElliptical(_assertThisInitialized__default["default"](_this))) {
      var _attributes$height;
      _this.height = (_attributes$height = attributes.height) !== null && _attributes$height !== void 0 ? _attributes$height : defaultHeight;
    }
    return _this;
  }
  _createClass__default["default"](RxnArrow, [{
    key: "clone",
    value: function clone() {
      return new RxnArrow(this);
    }
  }, {
    key: "center",
    value: function center() {
      return Vec2.centre(this.pos[0], this.pos[1]);
    }
  }], [{
    key: "isElliptical",
    value: function isElliptical(arrow) {
      return [exports.RxnArrowMode.EllipticalArcFilledBow, exports.RxnArrowMode.EllipticalArcFilledTriangle, exports.RxnArrowMode.EllipticalArcOpenHalfAngle, exports.RxnArrowMode.EllipticalArcOpenAngle].includes(arrow.mode);
    }
  }]);
  return RxnArrow;
}(BaseMicromoleculeEntity);

function _callSuper$1n(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1n() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1n() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1n = function _isNativeReflectConstruct() { return !!t; })(); }
var RxnPlus = function (_BaseMicromoleculeEnt) {
  _inherits__default["default"](RxnPlus, _BaseMicromoleculeEnt);
  function RxnPlus(attributes) {
    var _this;
    _classCallCheck__default["default"](this, RxnPlus);
    _this = _callSuper$1n(this, RxnPlus, [attributes === null || attributes === void 0 ? void 0 : attributes.initiallySelected]);
    _this.pp = attributes !== null && attributes !== void 0 && attributes.pp ? new Vec2(attributes.pp) : new Vec2();
    return _this;
  }
  _createClass__default["default"](RxnPlus, [{
    key: "clone",
    value: function clone() {
      return new RxnPlus(this);
    }
  }]);
  return RxnPlus;
}(BaseMicromoleculeEntity);

var SGroupForest = function () {
  function SGroupForest() {
    _classCallCheck__default["default"](this, SGroupForest);
    this.parent = new Map();
    this.children = new Map();
    this.children.set(-1, []);
    this.atomSets = new Map();
  }
  _createClass__default["default"](SGroupForest, [{
    key: "getSGroupsBFS",
    value: function getSGroupsBFS() {
      var order = [];
      var queue = Array.from(this.children.get(-1));
      while (queue.length > 0) {
        var id = queue.shift();
        if (typeof id !== 'number') {
          break;
        }
        var children = this.children.get(id);
        if (typeof children === 'undefined') {
          break;
        }
        children.forEach(function (id) {
          queue.push(id);
        });
        order.push(id);
      }
      return order;
    }
  }, {
    key: "getAtomSetRelations",
    value: function getAtomSetRelations(newId, atoms) {
      var _this = this;
      var isStrictSuperset = new Map();
      var isSubset = new Map();
      this.atomSets["delete"](newId);
      this.atomSets.forEach(function (atomSet, id) {
        isSubset.set(id, atomSet.isSuperset(atoms));
        isStrictSuperset.set(id, atoms.isSuperset(atomSet) && !atomSet.equals(atoms));
      });
      var parents = Array.from(this.atomSets.keys()).filter(function (sgid) {
        if (!isSubset.get(sgid)) {
          return false;
        }
        var childs = _this.children.get(sgid);
        return childs && childs.findIndex(function (childId) {
          return isSubset.get(childId);
        }) < 0;
      });
      var children = Array.from(this.atomSets.keys()).filter(function (id) {
        return isStrictSuperset.get(id) && !isStrictSuperset.get(_this.parent.get(id));
      });
      return {
        children: children,
        parent: parents.length === 0 ? -1 : parents[0]
      };
    }
  }, {
    key: "getPathToRoot",
    value: function getPathToRoot(sgid) {
      var path = [];
      for (var id = sgid; id >= 0; id = this.parent.get(id)) {
        path.push(id);
      }
      return path;
    }
  }, {
    key: "insert",
    value: function insert(_ref, parent, children) {
      var _this2 = this,
        _this$children$get;
      var id = _ref.id,
        atoms = _ref.atoms;
      assert__default["default"](!this.parent.has(id), 'sgid already present in the forest');
      assert__default["default"](!this.children.has(id), 'sgid already present in the forest');
      if (!parent || !children) {
        var guess = this.getAtomSetRelations(id, new Pile(atoms));
        parent = guess.parent;
        children = guess.children;
      }
      children.forEach(function (childId) {
        _this2.resetParentLink(childId, id);
      });
      this.children.set(id, children.filter(function (id) {
        return _this2.parent.get(id);
      }));
      this.parent.set(id, parent);
      (_this$children$get = this.children.get(parent)) === null || _this$children$get === void 0 || _this$children$get.push(id);
      this.atomSets.set(id, new Pile(atoms));
      return {
        parent: parent,
        children: children
      };
    }
  }, {
    key: "resetParentLink",
    value: function resetParentLink(childId, id) {
      var parentId = this.parent.get(childId);
      if (typeof parentId === 'undefined') {
        return;
      }
      var childs = this.children.get(parentId);
      if (!childs) {
        return;
      }
      var childIndex = childs.indexOf(childId);
      childs.splice(childIndex, 1);
      this.parent.set(childId, id);
    }
  }, {
    key: "remove",
    value: function remove(id) {
      var _this$children$get2,
        _this3 = this;
      try {
        assert__default["default"](this.parent.has(id), 'sgid is not in the forest');
        assert__default["default"](this.children.has(id), 'sgid is not in the forest');
      } catch (e) {
        KetcherLogger.error('sgroupForest.ts::SGroupForest::remove', e);
      }
      var parentId = this.parent.get(id);
      var childs = this.children.get(parentId);
      if (!parentId || !childs) return;
      (_this$children$get2 = this.children.get(id)) === null || _this$children$get2 === void 0 || _this$children$get2.forEach(function (childId) {
        var _this3$children$get;
        _this3.parent.set(childId, parentId);
        (_this3$children$get = _this3.children.get(parentId)) === null || _this3$children$get === void 0 || _this3$children$get.push(childId);
      });
      var i = childs.indexOf(id);
      childs.splice(i, 1);
      this.children["delete"](id);
      this.parent["delete"](id);
      this.atomSets["delete"](id);
    }
  }]);
  return SGroupForest;
}();
function checkOverlapping(struct) {
  var atoms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var sGroupType = arguments.length > 2 ? arguments[2] : undefined;
  var searchFunction = {
    common: function common(sid) {
      var sg = struct.sgroups.get(sid);
      if ((sg === null || sg === void 0 ? void 0 : sg.type) === 'DAT') return false;
      var sgAtoms = SGroup.getAtoms(struct, sg);
      return sgAtoms.length < atoms.length ? sgAtoms.findIndex(function (aid) {
        return atoms.indexOf(aid) === -1;
      }) >= 0 : atoms.findIndex(function (aid) {
        return sgAtoms.indexOf(aid) === -1;
      }) >= 0;
    },
    queryComponent: function queryComponent(sid) {
      var sg = struct.sgroups.get(sid);
      if ((sg === null || sg === void 0 ? void 0 : sg.type) !== 'queryComponent') return false;
      var sgAtoms = SGroup.getAtoms(struct, sg);
      return atoms.some(function (aid) {
        return sgAtoms.includes(aid);
      });
    }
  };
  var sgroups = atoms.reduce(function (res, aid) {
    var atom = struct.atoms.get(aid);
    return atom ? res.union(atom.sgs) : res;
  }, new Pile());
  return Array.from(sgroups).some(searchFunction[sGroupType]);
}

function _callSuper$1m(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1m() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1m() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1m = function _isNativeReflectConstruct() { return !!t; })(); }
exports.SimpleObjectMode = void 0;
(function (SimpleObjectMode) {
  SimpleObjectMode["ellipse"] = "ellipse";
  SimpleObjectMode["rectangle"] = "rectangle";
  SimpleObjectMode["line"] = "line";
})(exports.SimpleObjectMode || (exports.SimpleObjectMode = {}));
var SimpleObject = function (_BaseMicromoleculeEnt) {
  _inherits__default["default"](SimpleObject, _BaseMicromoleculeEnt);
  function SimpleObject(attributes) {
    var _this;
    _classCallCheck__default["default"](this, SimpleObject);
    _this = _callSuper$1m(this, SimpleObject, [attributes === null || attributes === void 0 ? void 0 : attributes.initiallySelected]);
    _this.pos = [];
    if (attributes !== null && attributes !== void 0 && attributes.pos) {
      for (var i = 0; i < attributes.pos.length; i++) {
        var currentP = attributes.pos[i];
        _this.pos[i] = currentP ? new Vec2(attributes.pos[i]) : new Vec2();
      }
    }
    _this.mode = (attributes === null || attributes === void 0 ? void 0 : attributes.mode) || exports.SimpleObjectMode.line;
    return _this;
  }
  _createClass__default["default"](SimpleObject, [{
    key: "clone",
    value: function clone() {
      return new SimpleObject(this);
    }
  }, {
    key: "center",
    value: function center() {
      switch (this.mode) {
        case exports.SimpleObjectMode.rectangle:
          {
            return Vec2.centre(this.pos[0], this.pos[1]);
          }
        default:
          return this.pos[0];
      }
    }
  }]);
  return SimpleObject;
}(BaseMicromoleculeEntity);

function _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }
function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _callSuper$1l(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1l() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1l() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1l = function _isNativeReflectConstruct() { return !!t; })(); }
var Pool = function (_Map) {
  _inherits__default["default"](Pool, _Map);
  function Pool() {
    var _this;
    _classCallCheck__default["default"](this, Pool);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _callSuper$1l(this, Pool, [].concat(args));
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "nextId", 0);
    return _this;
  }
  _createClass__default["default"](Pool, [{
    key: "add",
    value: function add(item) {
      var id = this.nextId++;
      _get__default["default"](_getPrototypeOf__default["default"](Pool.prototype), "set", this).call(this, id, item);
      return id;
    }
  }, {
    key: "newId",
    value: function newId() {
      return this.nextId++;
    }
  }, {
    key: "keyOf",
    value: function keyOf(item) {
      var _iterator = _createForOfIteratorHelper$5(this.entries()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray__default["default"](_step.value, 2),
            key = _step$value[0],
            value = _step$value[1];
          if (value === item) return key;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return null;
    }
  }, {
    key: "find",
    value: function find(predicate) {
      var _iterator2 = _createForOfIteratorHelper$5(this.entries()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _slicedToArray__default["default"](_step2.value, 2),
            key = _step2$value[0],
            value = _step2$value[1];
          if (predicate(key, value)) return key;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return null;
    }
  }, {
    key: "filter",
    value: function filter(predicate) {
      return new Pool(Array.from(this).filter(function (_ref) {
        var _ref2 = _slicedToArray__default["default"](_ref, 2),
          key = _ref2[0],
          value = _ref2[1];
        return predicate(key, value);
      }));
    }
  }, {
    key: "some",
    value: function some(predicate) {
      var _iterator3 = _createForOfIteratorHelper$5(this.values()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var value = _step3.value;
          if (predicate(value)) {
            return true;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return false;
    }
  }, {
    key: "changeInitiallySelectedPropertiesForPool",
    value: function changeInitiallySelectedPropertiesForPool(invalidate) {
      var _this2 = this;
      this.forEach(function (value, key) {
        if (typeof value.resetInitiallySelected === 'function') {
          value.resetInitiallySelected(invalidate);
          _this2.set(key, value);
        }
      });
    }
  }]);
  return Pool;
}( _wrapNativeSuper__default["default"](Map));

function _callSuper$1k(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1k() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1k() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1k = function _isNativeReflectConstruct() { return !!t; })(); }
var MonomerMicromolecule = function (_SGroup) {
  _inherits__default["default"](MonomerMicromolecule, _SGroup);
  function MonomerMicromolecule(type, monomer) {
    var _this;
    _classCallCheck__default["default"](this, MonomerMicromolecule);
    _this = _callSuper$1k(this, MonomerMicromolecule, [type]);
    _this.monomer = monomer;
    _this.data.absolute = false;
    _this.data.attached = false;
    return _this;
  }
  _createClass__default["default"](MonomerMicromolecule, [{
    key: "getContractedPosition",
    value: function getContractedPosition(struct) {
      assert__default["default"](this.pp);
      var sgroupContractedPosition = _get__default["default"](_getPrototypeOf__default["default"](MonomerMicromolecule.prototype), "getContractedPosition", this).call(this, struct);
      return {
        position: this.pp,
        atomId: sgroupContractedPosition.atomId
      };
    }
  }], [{
    key: "clone",
    value: function clone(monomerMicromolecule) {
      var monomerMicromoleculeClone = new MonomerMicromolecule(monomerMicromolecule.type, monomerMicromolecule.monomer);
      monomerMicromoleculeClone.pp = monomerMicromolecule.pp;
      monomerMicromoleculeClone.atoms = monomerMicromolecule.atoms;
      return monomerMicromoleculeClone;
    }
  }]);
  return MonomerMicromolecule;
}(SGroup);

function arrayAddIfMissing(array, item) {
  for (var i = 0; i < array.length; ++i) {
    if (array[i] === item) return false;
  }
  array.push(item);
  return true;
}
var Struct = function () {
  function Struct() {
    _classCallCheck__default["default"](this, Struct);
    this.atoms = new Pool();
    this.bonds = new Pool();
    this.sgroups = new Pool();
    this.halfBonds = new Pool();
    this.loops = new Pool();
    this.isReaction = false;
    this.rxnArrows = new Pool();
    this.rxnPluses = new Pool();
    this.frags = new Pool();
    this.rgroups = new Pool();
    this.rgroupAttachmentPoints = new Pool();
    this.name = '';
    this.abbreviation = '';
    this.sGroupForest = new SGroupForest();
    this.simpleObjects = new Pool();
    this.texts = new Pool();
    this.functionalGroups = new Pool();
    this.highlights = new Pool();
  }
  _createClass__default["default"](Struct, [{
    key: "hasRxnProps",
    value: function hasRxnProps() {
      return !!(this.atoms.find(function (_aid, atom) {
        return atom.hasRxnProps();
      }) || this.bonds.find(function (_bid, bond) {
        return bond.hasRxnProps();
      }));
    }
  }, {
    key: "hasRxnArrow",
    value: function hasRxnArrow() {
      return this.rxnArrows.size >= 1;
    }
  }, {
    key: "hasRxnPluses",
    value: function hasRxnPluses() {
      return this.rxnPluses.size > 0;
    }
  }, {
    key: "isRxn",
    value: function isRxn() {
      return this.hasRxnArrow() || this.hasRxnPluses();
    }
  }, {
    key: "isBlank",
    value: function isBlank() {
      return this.atoms.size === 0 && this.rxnArrows.size === 0 && this.rxnPluses.size === 0 && this.simpleObjects.size === 0 && this.texts.size === 0;
    }
  }, {
    key: "isSingleGroup",
    value: function isSingleGroup() {
      if (!this.sgroups.size || this.sgroups.size > 1) return false;
      var sgroup = this.sgroups.values().next().value;
      return this.atoms.size === sgroup.atoms.length;
    }
  }, {
    key: "clone",
    value: function clone(atomSet, bondSet, dropRxnSymbols, aidMap, simpleObjectsSet, textsSet, rgroupAttachmentPointSet, bidMap) {
      return this.mergeInto(new Struct(), atomSet, bondSet, dropRxnSymbols, false, aidMap, simpleObjectsSet, textsSet, rgroupAttachmentPointSet, bidMap);
    }
  }, {
    key: "getScaffold",
    value: function getScaffold() {
      var _this = this;
      var atomSet = new Pile();
      this.atoms.forEach(function (_atom, aid) {
        atomSet.add(aid);
      });
      this.rgroups.forEach(function (rg) {
        rg.frags.forEach(function (_fnum, fid) {
          _this.atoms.forEach(function (atom, aid) {
            if (atom.fragment === fid) atomSet["delete"](aid);
          });
        });
      });
      return this.clone(atomSet);
    }
  }, {
    key: "getFragmentIds",
    value: function getFragmentIds(_fid) {
      var atomSet = new Pile();
      var fid = Array.isArray(_fid) ? _fid : [_fid];
      this.atoms.forEach(function (atom, aid) {
        if (fid.includes(atom.fragment)) atomSet.add(aid);
      });
      return atomSet;
    }
  }, {
    key: "getFragment",
    value: function getFragment(fid) {
      var copyNonFragmentObjects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return this.clone(this.getFragmentIds(fid), null, true, undefined, copyNonFragmentObjects ? undefined : new Pile(), copyNonFragmentObjects ? undefined : new Pile(), copyNonFragmentObjects ? undefined : new Pile());
    }
  }, {
    key: "mergeInto",
    value: function mergeInto(cp, atomSet, bondSet, dropRxnSymbols, keepAllRGroups, aidMap, simpleObjectsSet, textsSet, rgroupAttachmentPointSet, bidMapEntity) {
      var _this2 = this;
      atomSet = atomSet || new Pile(this.atoms.keys());
      bondSet = bondSet || new Pile(this.bonds.keys());
      simpleObjectsSet = simpleObjectsSet || new Pile(this.simpleObjects.keys());
      textsSet = textsSet || new Pile(this.texts.keys());
      rgroupAttachmentPointSet = rgroupAttachmentPointSet || new Pile(this.rgroupAttachmentPoints.keys());
      aidMap = aidMap || new Map();
      var bidMap = bidMapEntity || new Map();
      bondSet = bondSet.filter(function (bid) {
        var bond = _this2.bonds.get(bid);
        return atomSet.has(bond.begin) && atomSet.has(bond.end);
      });
      var fidMask = new Pile();
      this.atoms.forEach(function (atom, aid) {
        if (atomSet.has(aid)) fidMask.add(atom.fragment);
      });
      var fidMap = new Map();
      this.frags.forEach(function (_frag, fid) {
        if (fidMask.has(fid)) fidMap.set(fid, cp.frags.add(null));
      });
      var rgroupsIds = [];
      this.rgroups.forEach(function (rgroup, rgid) {
        var keepGroup = keepAllRGroups;
        if (!keepGroup) {
          rgroup.frags.forEach(function (_fnum, fid) {
            rgroupsIds.push(fid);
            if (fidMask.has(fid)) keepGroup = true;
          });
          if (!keepGroup) return;
        }
        var rg = cp.rgroups.get(rgid);
        if (rg) {
          rgroup.frags.forEach(function (_fnum, fid) {
            rgroupsIds.push(fid);
            if (fidMask.has(fid)) rg.frags.add(fidMap.get(fid));
          });
        } else {
          cp.rgroups.set(rgid, rgroup.clone(fidMap));
        }
      });
      this.atoms.forEach(function (atom, aid) {
        if (atomSet.has(aid) && rgroupsIds.indexOf(atom.fragment) === -1) {
          aidMap.set(aid, cp.atoms.add(atom.clone(fidMap)));
        }
      });
      this.atoms.forEach(function (atom, aid) {
        if (atomSet.has(aid) && rgroupsIds.indexOf(atom.fragment) !== -1) {
          aidMap.set(aid, cp.atoms.add(atom.clone(fidMap)));
        }
      });
      fidMap.forEach(function (newfid, oldfid) {
        var fragment = _this2.frags.get(oldfid);
        if (fragment && fragment instanceof Fragment) {
          cp.frags.set(newfid, _this2.frags.get(oldfid).clone(aidMap));
        }
      });
      this.bonds.forEach(function (bond, bid) {
        if (bondSet.has(bid)) bidMap.set(bid, cp.bonds.add(bond.clone(aidMap)));
      });
      var sgroupIdMap = {};
      this.sgroups.forEach(function (sg, sgroupId) {
        if (sg.atoms.some(function (aid) {
          return !atomSet.has(aid);
        })) return;
        var oldSgroup = sg;
        sg = oldSgroup instanceof MonomerMicromolecule ? MonomerMicromolecule.clone(oldSgroup) : SGroup.clone(sg, aidMap);
        var id = cp.sgroups.add(sg);
        sg.id = id;
        sgroupIdMap[sgroupId] = id;
        sg.atoms.forEach(function (aid) {
          var atom = cp.atoms.get(aid);
          if (atom) {
            atom.sgs.add(id);
          }
        });
        if (sg.type === 'DAT') cp.sGroupForest.insert(sg, -1, []);else cp.sGroupForest.insert(sg);
      });
      this.functionalGroups.forEach(function (fg) {
        if (fg.relatedSGroup.atoms.some(function (aid) {
          return !atomSet.has(aid);
        })) return;
        var sgroup = cp.sgroups.get(sgroupIdMap[fg.relatedSGroupId]);
        fg = sgroup ? new FunctionalGroup(sgroup) : FunctionalGroup.clone(fg);
        cp.functionalGroups.add(fg);
      });
      simpleObjectsSet.forEach(function (soid) {
        cp.simpleObjects.add(_this2.simpleObjects.get(soid).clone());
      });
      textsSet.forEach(function (id) {
        cp.texts.add(_this2.texts.get(id).clone());
      });
      rgroupAttachmentPointSet.forEach(function (id) {
        var rgroupAttachmentPoint = _this2.rgroupAttachmentPoints.get(id);
        assert__default["default"](rgroupAttachmentPoint != null);
        cp.rgroupAttachmentPoints.add(rgroupAttachmentPoint.clone(aidMap));
      });
      if (!dropRxnSymbols) {
        cp.isReaction = this.isReaction;
        this.rxnArrows.forEach(function (item) {
          cp.rxnArrows.add(item.clone());
        });
        this.rxnPluses.forEach(function (item) {
          cp.rxnPluses.add(item.clone());
        });
      }
      cp.name = this.name;
      return cp;
    }
  }, {
    key: "prepareLoopStructure",
    value: function prepareLoopStructure() {
      this.initHalfBonds();
      this.initNeighbors();
      this.updateHalfBonds(Array.from(this.atoms.keys()));
      this.sortNeighbors(Array.from(this.atoms.keys()));
      this.findLoops();
    }
  }, {
    key: "atomAddToSGroup",
    value: function atomAddToSGroup(sgid, aid) {
      SGroup.addAtom(this.sgroups.get(sgid), aid, this);
      this.atoms.get(aid).sgs.add(sgid);
    }
  }, {
    key: "calcConn",
    value: function calcConn(atom) {
      var conn = 0;
      for (var i = 0; i < atom.neighbors.length; ++i) {
        var hb = this.halfBonds.get(atom.neighbors[i]);
        var bond = this.bonds.get(hb.bid);
        switch (bond.type) {
          case Bond.PATTERN.TYPE.SINGLE:
            conn += 1;
            break;
          case Bond.PATTERN.TYPE.DOUBLE:
            conn += 2;
            break;
          case Bond.PATTERN.TYPE.TRIPLE:
            conn += 3;
            break;
          case Bond.PATTERN.TYPE.DATIVE:
            break;
          case Bond.PATTERN.TYPE.HYDROGEN:
            break;
          case Bond.PATTERN.TYPE.AROMATIC:
            if (atom.neighbors.length === 1) return [-1, true];
            return [atom.neighbors.length, true];
          default:
            return [-1, false];
        }
      }
      return [conn, false];
    }
  }, {
    key: "findBondId",
    value: function findBondId(begin, end) {
      return this.bonds.find(function (_bid, bond) {
        return bond.begin === begin && bond.end === end || bond.begin === end && bond.end === begin;
      });
    }
  }, {
    key: "initNeighbors",
    value: function initNeighbors() {
      var _this3 = this;
      this.atoms.forEach(function (atom) {
        atom.neighbors = [];
      });
      this.bonds.forEach(function (bond) {
        var a1 = _this3.atoms.get(bond.begin);
        var a2 = _this3.atoms.get(bond.end);
        a1.neighbors.push(bond.hb1);
        a2.neighbors.push(bond.hb2);
      });
    }
  }, {
    key: "bondInitHalfBonds",
    value: function bondInitHalfBonds(bid, bond) {
      bond = bond || this.bonds.get(bid);
      bond.hb1 = 2 * bid;
      bond.hb2 = 2 * bid + 1;
      this.halfBonds.set(bond.hb1, new HalfBond(bond.begin, bond.end, bid));
      this.halfBonds.set(bond.hb2, new HalfBond(bond.end, bond.begin, bid));
      var hb1 = this.halfBonds.get(bond.hb1);
      var hb2 = this.halfBonds.get(bond.hb2);
      hb1.contra = bond.hb2;
      hb2.contra = bond.hb1;
    }
  }, {
    key: "halfBondUpdate",
    value: function halfBondUpdate(halfBondId) {
      var halfBond = this.halfBonds.get(halfBondId);
      var sgroup1 = this.getGroupFromAtomId(halfBond.begin);
      var sgroup2 = this.getGroupFromAtomId(halfBond.end);
      var startCoords = sgroup1 instanceof MonomerMicromolecule ? sgroup1.pp : this.atoms.get(halfBond.begin).pp;
      var endCoords = sgroup2 instanceof MonomerMicromolecule ? sgroup2.pp : this.atoms.get(halfBond.end).pp;
      var coordsDifference = Vec2.diff(endCoords, startCoords).normalized();
      halfBond.dir = Vec2.dist(endCoords, startCoords) > 1e-4 ? coordsDifference : new Vec2(1, 0);
      halfBond.norm = halfBond.dir.turnLeft();
      halfBond.ang = halfBond.dir.oxAngle();
      if (halfBond.loop < 0) halfBond.loop = -1;
    }
  }, {
    key: "initHalfBonds",
    value: function initHalfBonds() {
      var _this4 = this;
      this.halfBonds.clear();
      this.bonds.forEach(function (bond, bid) {
        _this4.bondInitHalfBonds(bid, bond);
      });
    }
  }, {
    key: "setHbNext",
    value: function setHbNext(hbid, next) {
      this.halfBonds.get(this.halfBonds.get(hbid).contra).next = next;
    }
  }, {
    key: "halfBondSetAngle",
    value: function halfBondSetAngle(hbid, left) {
      var hb = this.halfBonds.get(hbid);
      var hbl = this.halfBonds.get(left);
      hbl.rightCos = Vec2.dot(hbl.dir, hb.dir);
      hb.leftCos = Vec2.dot(hbl.dir, hb.dir);
      hbl.rightSin = Vec2.cross(hbl.dir, hb.dir);
      hb.leftSin = Vec2.cross(hbl.dir, hb.dir);
      hb.leftNeighbor = left;
      hbl.rightNeighbor = hbid;
    }
  }, {
    key: "atomAddNeighbor",
    value: function atomAddNeighbor(hbid) {
      var hb = this.halfBonds.get(hbid);
      var atom = this.atoms.get(hb.begin);
      var i;
      for (i = 0; i < atom.neighbors.length; ++i) {
        if (this.halfBonds.get(atom.neighbors[i]).ang > hb.ang) break;
      }
      atom.neighbors.splice(i, 0, hbid);
      var ir = atom.neighbors[(i + 1) % atom.neighbors.length];
      var il = atom.neighbors[(i + atom.neighbors.length - 1) % atom.neighbors.length];
      this.setHbNext(il, hbid);
      this.setHbNext(hbid, ir);
      this.halfBondSetAngle(hbid, il);
      this.halfBondSetAngle(ir, hbid);
    }
  }, {
    key: "atomSortNeighbors",
    value: function atomSortNeighbors(aid) {
      var _this5 = this;
      var atom = this.atoms.get(aid);
      var halfBonds = this.halfBonds;
      atom.neighbors.sort(function (nei, nei2) {
        return halfBonds.get(nei).ang - halfBonds.get(nei2).ang;
      }).forEach(function (nei, i) {
        var nextNei = atom.neighbors[(i + 1) % atom.neighbors.length];
        _this5.halfBonds.get(_this5.halfBonds.get(nei).contra).next = nextNei;
        _this5.halfBondSetAngle(nextNei, nei);
      });
    }
  }, {
    key: "sortNeighbors",
    value: function sortNeighbors(list) {
      var _this6 = this;
      if (!list) {
        this.atoms.forEach(function (_atom, aid) {
          _this6.atomSortNeighbors(aid);
        });
      } else {
        list.forEach(function (aid) {
          _this6.atomSortNeighbors(aid);
        });
      }
    }
  }, {
    key: "atomUpdateHalfBonds",
    value: function atomUpdateHalfBonds(atomId) {
      var _this7 = this;
      this.atoms.get(atomId).neighbors.forEach(function (hbid) {
        _this7.halfBondUpdate(hbid);
        _this7.halfBondUpdate(_this7.halfBonds.get(hbid).contra);
      });
    }
  }, {
    key: "updateHalfBonds",
    value: function updateHalfBonds(list) {
      var _this8 = this;
      if (!list) {
        this.atoms.forEach(function (_atom, atomId) {
          _this8.atomUpdateHalfBonds(atomId);
        });
      } else {
        list.forEach(function (atomId) {
          _this8.atomUpdateHalfBonds(atomId);
        });
      }
    }
  }, {
    key: "sGroupsRecalcCrossBonds",
    value: function sGroupsRecalcCrossBonds() {
      var _this9 = this;
      this.sgroups.forEach(function (sg) {
        sg.xBonds = [];
        sg.neiAtoms = [];
      });
      this.bonds.forEach(function (bond, bid) {
        var a1 = _this9.atoms.get(bond.begin);
        var a2 = _this9.atoms.get(bond.end);
        a1.sgs.forEach(function (sgid) {
          if (!a2.sgs.has(sgid)) {
            var sg = _this9.sgroups.get(sgid);
            sg.xBonds.push(bid);
            arrayAddIfMissing(sg.neiAtoms, bond.end);
          }
        });
        a2.sgs.forEach(function (sgid) {
          if (!a1.sgs.has(sgid)) {
            var sg = _this9.sgroups.get(sgid);
            sg.xBonds.push(bid);
            arrayAddIfMissing(sg.neiAtoms, bond.begin);
          }
        });
      });
    }
  }, {
    key: "sGroupDelete",
    value: function sGroupDelete(sgid) {
      var _this10 = this;
      this.sgroups.get(sgid).atoms.forEach(function (atom) {
        _this10.atoms.get(atom).sgs["delete"](sgid);
      });
      this.sGroupForest.remove(sgid);
      this.sgroups["delete"](sgid);
    }
  }, {
    key: "atomSetPos",
    value: function atomSetPos(id, pp) {
      var item = this.atoms.get(id);
      item.pp = pp;
    }
  }, {
    key: "rxnPlusSetPos",
    value: function rxnPlusSetPos(id, pp) {
      var item = this.rxnPluses.get(id);
      item.pp = pp;
    }
  }, {
    key: "rxnArrowSetPos",
    value: function rxnArrowSetPos(id, pos) {
      var item = this.rxnArrows.get(id);
      if (item) {
        item.pos = pos;
      }
    }
  }, {
    key: "simpleObjectSetPos",
    value: function simpleObjectSetPos(id, pos) {
      var item = this.simpleObjects.get(id);
      item.pos = pos;
    }
  }, {
    key: "textSetPosition",
    value: function textSetPosition(id, position) {
      var item = this.texts.get(id);
      if (item) {
        item.position = position;
      }
    }
  }, {
    key: "getCoordBoundingBox",
    value: function getCoordBoundingBox(atomSet) {
      var bb = null;
      function extend(pp) {
        if (!bb) {
          bb = {
            min: pp,
            max: pp
          };
        } else {
          if (pp instanceof Array) {
            pp.forEach(function (vec) {
              bb.min = Vec2.min(bb.min, vec);
              bb.max = Vec2.max(bb.max, vec);
            });
          } else {
            bb.min = Vec2.min(bb.min, pp);
            bb.max = Vec2.max(bb.max, pp);
          }
        }
      }
      var global = !atomSet || atomSet.size === 0;
      this.atoms.forEach(function (atom, aid) {
        if (global || atomSet.has(aid)) extend(atom.pp);
      });
      if (global) {
        this.rxnPluses.forEach(function (item) {
          extend(item.pp);
        });
        this.rxnArrows.forEach(function (item) {
          extend(item.pos);
        });
        this.simpleObjects.forEach(function (item) {
          extend(item.pos);
        });
        this.texts.forEach(function (item) {
          extend(item.position);
        });
      }
      if (!bb && global) {
        bb = {
          min: new Vec2(0, 0),
          max: new Vec2(1, 1)
        };
      }
      return bb;
    }
  }, {
    key: "getCoordBoundingBoxObj",
    value: function getCoordBoundingBoxObj() {
      var bb = null;
      function extend(pp) {
        if (!bb) {
          bb = {
            min: new Vec2(pp),
            max: new Vec2(pp)
          };
        } else {
          bb.min = Vec2.min(bb.min, pp);
          bb.max = Vec2.max(bb.max, pp);
        }
      }
      this.atoms.forEach(function (atom) {
        extend(atom.pp);
      });
      return bb;
    }
  }, {
    key: "getBondLengthData",
    value: function getBondLengthData() {
      var _this11 = this;
      var totalLength = 0;
      var cnt = 0;
      this.bonds.forEach(function (bond) {
        totalLength += Vec2.dist(_this11.atoms.get(bond.begin).pp, _this11.atoms.get(bond.end).pp);
        cnt++;
      });
      return {
        cnt: cnt,
        totalLength: totalLength
      };
    }
  }, {
    key: "getAvgBondLength",
    value: function getAvgBondLength() {
      var bld = this.getBondLengthData();
      return bld.cnt > 0 ? bld.totalLength / bld.cnt : -1;
    }
  }, {
    key: "getAvgClosestAtomDistance",
    value: function getAvgClosestAtomDistance() {
      var totalDist = 0;
      var minDist;
      var dist = 0;
      var keys = Array.from(this.atoms.keys());
      var k;
      var j;
      for (k = 0; k < keys.length; ++k) {
        minDist = -1;
        for (j = 0; j < keys.length; ++j) {
          if (j === k) continue;
          dist = Vec2.dist(this.atoms.get(keys[j]).pp, this.atoms.get(keys[k]).pp);
          if (minDist < 0 || minDist > dist) minDist = dist;
        }
        totalDist += minDist;
      }
      return keys.length > 0 ? totalDist / keys.length : -1;
    }
  }, {
    key: "checkBondExists",
    value: function checkBondExists(begin, end) {
      var key = this.bonds.find(function (_bid, bond) {
        return bond.begin === begin && bond.end === end || bond.end === begin && bond.begin === end;
      });
      return key !== undefined;
    }
  }, {
    key: "findConnectedComponent",
    value: function findConnectedComponent(firstaid) {
      var _this12 = this;
      var list = [firstaid];
      var ids = new Pile();
      while (list.length > 0) {
        var aid = list.pop();
        ids.add(aid);
        var atom = this.atoms.get(aid);
        atom.neighbors.forEach(function (nei) {
          var neiId = _this12.halfBonds.get(nei).end;
          if (!ids.has(neiId)) list.push(neiId);
        });
      }
      return ids;
    }
  }, {
    key: "findConnectedComponents",
    value: function findConnectedComponents(discardExistingFragments) {
      var _this13 = this;
      if (!this.halfBonds.size) {
        this.initHalfBonds();
        this.initNeighbors();
        this.updateHalfBonds(Array.from(this.atoms.keys()));
        this.sortNeighbors(Array.from(this.atoms.keys()));
      }
      var addedAtoms = new Pile();
      var components = [];
      this.atoms.forEach(function (atom, aid) {
        if ((discardExistingFragments || atom.fragment < 0) && !addedAtoms.has(aid)) {
          var component = _this13.findConnectedComponent(aid);
          components.push(component);
          addedAtoms = addedAtoms.union(component);
        }
      });
      return components;
    }
  }, {
    key: "markFragment",
    value: function markFragment(idSet, properties) {
      var _this14 = this;
      var frag = new Fragment([], undefined, properties);
      var fid = this.frags.add(frag);
      idSet.forEach(function (aid) {
        var atom = _this14.atoms.get(aid);
        if (atom.stereoLabel) frag.updateStereoAtom(_this14, aid, fid, true);
        atom.fragment = fid;
      });
    }
  }, {
    key: "markFragments",
    value: function markFragments(properties) {
      var _this15 = this;
      var components = this.findConnectedComponents();
      components.forEach(function (comp) {
        var _comp = _slicedToArray__default["default"](comp, 1),
          firstAtom = _comp[0];
        var sgroup = _this15.getGroupFromAtomId(firstAtom);
        if (sgroup instanceof MonomerMicromolecule) {
          return;
        }
        _this15.markFragment(comp, properties);
      });
    }
  }, {
    key: "scale",
    value: function scale(_scale) {
      if (_scale === 1) return;
      this.atoms.forEach(function (atom) {
        atom.pp = atom.pp.scaled(_scale);
      });
      this.rxnPluses.forEach(function (item) {
        item.pp = item.pp.scaled(_scale);
      });
      this.rxnArrows.forEach(function (item) {
        item.pos = item.pos.map(function (p) {
          return p.scaled(_scale);
        });
      });
      this.sgroups.forEach(function (item) {
        if (item instanceof MonomerMicromolecule) {
          return;
        }
        item.pp = item.pp ? item.pp.scaled(_scale) : null;
      });
      this.texts.forEach(function (item) {
        item.pos = item.pos.map(function (p) {
          return p.scaled(_scale);
        });
        item.position = item.position.scaled(_scale);
      });
      this.simpleObjects.forEach(function (simpleObjects) {
        simpleObjects.pos = simpleObjects.pos.map(function (p) {
          return p.scaled(_scale);
        });
      });
    }
  }, {
    key: "rescale",
    value: function rescale() {
      var avg = this.getAvgBondLength();
      if (avg <= 0) {
        return;
      }
      if (avg < 1e-3) avg = 1;
      var scale = 1 / avg;
      this.scale(scale);
    }
  }, {
    key: "loopHasSelfIntersections",
    value: function loopHasSelfIntersections(hbs) {
      for (var i = 0; i < hbs.length; ++i) {
        var hbi = this.halfBonds.get(hbs[i]);
        var ai = this.atoms.get(hbi.begin).pp;
        var bi = this.atoms.get(hbi.end).pp;
        var set = new Pile([hbi.begin, hbi.end]);
        for (var j = i + 2; j < hbs.length; ++j) {
          var hbj = this.halfBonds.get(hbs[j]);
          if (set.has(hbj.begin) || set.has(hbj.end)) continue;
          var aj = this.atoms.get(hbj.begin).pp;
          var bj = this.atoms.get(hbj.end).pp;
          if (Box2Abs.segmentIntersection(ai, bi, aj, bj)) return true;
        }
      }
      return false;
    }
  }, {
    key: "partitionLoop",
    value: function partitionLoop(loop) {
      var subloops = [];
      var continueFlag = true;
      while (continueFlag) {
        var atomToHalfBond = {};
        continueFlag = false;
        for (var l = 0; l < loop.length; ++l) {
          var hbid = loop[l];
          var aid1 = this.halfBonds.get(hbid).begin;
          var aid2 = this.halfBonds.get(hbid).end;
          if (aid2 in atomToHalfBond) {
            var s = atomToHalfBond[aid2];
            var subloop = loop.slice(s, l + 1);
            subloops.push(subloop);
            if (l < loop.length) {
              loop.splice(s, l - s + 1);
            }
            continueFlag = true;
            break;
          }
          atomToHalfBond[aid1] = l;
        }
        if (!continueFlag) subloops.push(loop);
      }
      return subloops;
    }
  }, {
    key: "halfBondAngle",
    value: function halfBondAngle(hbid1, hbid2) {
      var hba = this.halfBonds.get(hbid1);
      var hbb = this.halfBonds.get(hbid2);
      return Math.atan2(Vec2.cross(hba.dir, hbb.dir), Vec2.dot(hba.dir, hbb.dir));
    }
  }, {
    key: "loopIsConvex",
    value: function loopIsConvex(loop) {
      var _this16 = this;
      return loop.every(function (item, k, loopArr) {
        var angle = _this16.halfBondAngle(item, loopArr[(k + 1) % loopArr.length]);
        return angle <= 0;
      });
    }
  }, {
    key: "loopIsInner",
    value: function loopIsInner(loop) {
      var _this17 = this;
      var totalAngle = 2 * Math.PI;
      loop.forEach(function (hbida, k, loopArr) {
        var hbidb = loopArr[(k + 1) % loopArr.length];
        var hbb = _this17.halfBonds.get(hbidb);
        var angle = _this17.halfBondAngle(hbida, hbidb);
        totalAngle += hbb.contra === hbida ? Math.PI : angle;
      });
      return Math.abs(totalAngle) < Math.PI;
    }
  }, {
    key: "findLoops",
    value: function findLoops() {
      var _this18 = this;
      var newLoops = [];
      var bondsToMark = new Pile();
      var hbIdNext, c, loop;
      this.halfBonds.forEach(function (hb, hbId) {
        if (hb.loop !== -1) return;
        for (hbIdNext = hbId, c = 0, loop = []; c <= _this18.halfBonds.size; hbIdNext = _this18.halfBonds.get(hbIdNext).next, ++c) {
          if (!(c > 0 && hbIdNext === hbId)) {
            loop.push(hbIdNext);
            continue;
          }
          var subloops = _this18.partitionLoop(loop);
          subloops.forEach(function (loop) {
            var loopId;
            if (_this18.loopIsInner(loop) && !_this18.loopHasSelfIntersections(loop)) {
              loopId = Math.min.apply(Math, _toConsumableArray__default["default"](loop));
              _this18.loops.set(loopId, new Loop(loop, _this18, _this18.loopIsConvex(loop)));
            } else {
              loopId = -2;
            }
            loop.forEach(function (hbid) {
              _this18.halfBonds.get(hbid).loop = loopId;
              bondsToMark.add(_this18.halfBonds.get(hbid).bid);
            });
            if (loopId >= 0) newLoops.push(loopId);
          });
          break;
        }
      });
      return {
        newLoops: newLoops,
        bondsToMark: Array.from(bondsToMark)
      };
    }
  }, {
    key: "calcImplicitHydrogen",
    value: function calcImplicitHydrogen(aid) {
      var atom = this.atoms.get(aid);
      var charge = atom.charge || 0;
      var _this$calcConn = this.calcConn(atom),
        _this$calcConn2 = _slicedToArray__default["default"](_this$calcConn, 2),
        conn = _this$calcConn2[0],
        isAromatic = _this$calcConn2[1];
      var correctConn = conn;
      atom.badConn = false;
      if (isAromatic) {
        if (atom.label === 'C' && charge === 0) {
          if (conn === 3) {
            atom.implicitH = -radicalElectrons(atom.radical);
            return;
          }
          if (conn === 2) {
            atom.implicitH = 1 - radicalElectrons(atom.radical);
            return;
          }
        } else if (atom.label === 'O' && charge === 0 || atom.label === 'N' && charge === 0 && conn === 3 || atom.label === 'N' && charge === 1 && conn === 3 || atom.label === 'S' && charge === 0 && conn === 3 || !atom.implicitH) {
          atom.implicitH = 0;
          return;
        } else if (!atom.hasImplicitH) {
          correctConn++;
        }
      }
      if (correctConn < 0 || atom.isQuery() || atom.attachmentPoints) {
        atom.implicitH = 0;
        return;
      }
      if (atom.explicitValence >= 0) {
        var elem = Elements.get(atom.label);
        atom.implicitH = elem ? atom.explicitValence - atom.calcValenceMinusHyd(correctConn) : 0;
        if (atom.implicitH < 0) {
          atom.implicitH = 0;
          atom.badConn = true;
        }
      } else {
        atom.calcValence(correctConn);
      }
    }
  }, {
    key: "setImplicitHydrogen",
    value: function setImplicitHydrogen(list) {
      var _this19 = this;
      this.sgroups.forEach(function (item) {
        if (item.data.fieldName === 'MRV_IMPLICIT_H') {
          _this19.atoms.get(item.atoms[0]).hasImplicitH = true;
        }
      });
      if (!list) {
        this.atoms.forEach(function (_atom, aid) {
          _this19.calcImplicitHydrogen(aid);
        });
      } else {
        list.forEach(function (aid) {
          if (_this19.atoms.get(aid)) {
            _this19.calcImplicitHydrogen(aid);
          }
        });
      }
    }
  }, {
    key: "atomGetNeighbors",
    value: function atomGetNeighbors(aid) {
      var _this$atoms$get,
        _this20 = this;
      return (_this$atoms$get = this.atoms.get(aid)) === null || _this$atoms$get === void 0 ? void 0 : _this$atoms$get.neighbors.map(function (nei) {
        var hb = _this20.halfBonds.get(nei);
        return {
          aid: hb.end,
          bid: hb.bid
        };
      });
    }
  }, {
    key: "getComponents",
    value: function getComponents() {
      var _this21 = this;
      var connectedComponents = this.findConnectedComponents(true);
      var barriers = [];
      var arrowPos = null;
      this.rxnArrows.forEach(function (item) {
        arrowPos = item.center().x;
      });
      this.rxnPluses.forEach(function (item) {
        barriers.push(item.pp.x);
      });
      if (arrowPos !== null) barriers.push(arrowPos);
      barriers.sort(function (a, b) {
        return a - b;
      });
      var components = [];
      connectedComponents.forEach(function (component) {
        var bb = _this21.getCoordBoundingBox(component);
        var c = Vec2.lc2(bb.min, 0.5, bb.max, 0.5);
        var j = 0;
        while (c.x > barriers[j]) ++j;
        components[j] = components[j] || new Pile();
        components[j] = components[j].union(component);
      });
      var reactants = [];
      var products = [];
      components.forEach(function (component) {
        if (!component) {
          return;
        }
        var rxnFragmentType = _this21.defineRxnFragmentTypeForAtomset(component, arrowPos || 0);
        if (rxnFragmentType === 1) reactants.push(component);else products.push(component);
      });
      return {
        reactants: reactants,
        products: products
      };
    }
  }, {
    key: "defineRxnFragmentTypeForAtomset",
    value: function defineRxnFragmentTypeForAtomset(atomset, arrowpos) {
      var bb = this.getCoordBoundingBox(atomset);
      var c = Vec2.lc2(bb.min, 0.5, bb.max, 0.5);
      return c.x < arrowpos ? 1 : 2;
    }
  }, {
    key: "getBondFragment",
    value: function getBondFragment(bid) {
      var _this$bonds$get, _this$atoms$get2;
      var aid = (_this$bonds$get = this.bonds.get(bid)) === null || _this$bonds$get === void 0 ? void 0 : _this$bonds$get.begin;
      return aid && ((_this$atoms$get2 = this.atoms.get(aid)) === null || _this$atoms$get2 === void 0 ? void 0 : _this$atoms$get2.fragment);
    }
  }, {
    key: "bindSGroupsToFunctionalGroups",
    value: function bindSGroupsToFunctionalGroups() {
      var _this22 = this;
      this.sgroups.forEach(function (sgroup) {
        if (FunctionalGroup.isFunctionalGroup(sgroup) || SGroup.isSuperAtom(sgroup)) {
          _this22.functionalGroups.add(new FunctionalGroup(sgroup));
        }
      });
    }
  }, {
    key: "getGroupIdFromAtomId",
    value: function getGroupIdFromAtomId(atomId) {
      for (var _i = 0, _Array$from = Array.from(this.sgroups); _i < _Array$from.length; _i++) {
        var _Array$from$_i = _slicedToArray__default["default"](_Array$from[_i], 2),
          groupId = _Array$from$_i[0],
          sgroup = _Array$from$_i[1];
        if (sgroup.atoms.includes(atomId)) return groupId;
      }
      return null;
    }
  }, {
    key: "getGroupFromAtomId",
    value: function getGroupFromAtomId(atomId) {
      var _this$sgroups;
      var sgroupId = this.getGroupIdFromAtomId(atomId);
      return (_this$sgroups = this.sgroups) === null || _this$sgroups === void 0 ? void 0 : _this$sgroups.get(sgroupId);
    }
  }, {
    key: "getGroupIdFromBondId",
    value: function getGroupIdFromBondId(bondId) {
      var bond = this.bonds.get(bondId);
      if (!bond) return null;
      for (var _i2 = 0, _Array$from2 = Array.from(this.sgroups); _i2 < _Array$from2.length; _i2++) {
        var _Array$from2$_i = _slicedToArray__default["default"](_Array$from2[_i2], 2),
          groupId = _Array$from2$_i[0],
          sgroup = _Array$from2$_i[1];
        if (sgroup.atoms.includes(bond.begin) || sgroup.atoms.includes(bond.end)) {
          return groupId;
        }
      }
      return null;
    }
  }, {
    key: "getGroupsIdsFromBondId",
    value: function getGroupsIdsFromBondId(bondId) {
      var bond = this.bonds.get(bondId);
      if (!bond) return [];
      var groupsIds = [];
      for (var _i3 = 0, _Array$from3 = Array.from(this.sgroups); _i3 < _Array$from3.length; _i3++) {
        var _Array$from3$_i = _slicedToArray__default["default"](_Array$from3[_i3], 2),
          groupId = _Array$from3$_i[0],
          sgroup = _Array$from3$_i[1];
        if (sgroup.atoms.includes(bond.begin) || sgroup.atoms.includes(bond.end)) {
          groupsIds.push(groupId);
        }
      }
      return groupsIds;
    }
  }, {
    key: "getBondIdByHalfBond",
    value: function getBondIdByHalfBond(halfBondId) {
      var halfBond = this.halfBonds.get(halfBondId);
      if (halfBond) {
        return halfBond.bid;
      }
      return undefined;
    }
  }, {
    key: "getSelectedVisibleAtoms",
    value: function getSelectedVisibleAtoms(selection) {
      var _selection$atoms,
        _this23 = this;
      return (selection === null || selection === void 0 || (_selection$atoms = selection.atoms) === null || _selection$atoms === void 0 ? void 0 : _selection$atoms.filter(function (atomId) {
        var atom = _this23.atoms.get(atomId);
        if (!atom) {
          return false;
        }
        var isAtomNotInContractedGroup = !FunctionalGroup.isAtomInContractedFunctionalGroup(atom, _this23.sgroups, _this23.functionalGroups, false);
        if (isAtomNotInContractedGroup) {
          return true;
        }
        var groupId = _this23.getGroupIdFromAtomId(atomId);
        var sgroup = _this23.sgroups.get(groupId);
        return (sgroup === null || sgroup === void 0 ? void 0 : sgroup.getAttachmentAtomId()) === atomId;
      })) || [];
    }
  }, {
    key: "getRGroupAttachmentPointsByAtomId",
    value: function getRGroupAttachmentPointsByAtomId(atomId) {
      var rgroupAttachmentPoints = this.rgroupAttachmentPoints.filter(function (_id, attachmentPoint) {
        return attachmentPoint.atomId === atomId;
      });
      return _toConsumableArray__default["default"](rgroupAttachmentPoints.keys());
    }
  }, {
    key: "isAtomFromMacromolecule",
    value: function isAtomFromMacromolecule(atomId) {
      var sgroup = this.getGroupFromAtomId(atomId);
      return sgroup instanceof MonomerMicromolecule;
    }
  }, {
    key: "isBondFromMacromolecule",
    value: function isBondFromMacromolecule(bondId) {
      var bond = this.bonds.get(bondId);
      assert__default["default"](bond);
      return this.isAtomFromMacromolecule(bond.begin) || this.isAtomFromMacromolecule(bond.end);
    }
  }, {
    key: "isFunctionalGroupFromMacromolecule",
    value: function isFunctionalGroupFromMacromolecule(functionalGroupId) {
      var functionalGroup = this.functionalGroups.get(functionalGroupId);
      return (functionalGroup === null || functionalGroup === void 0 ? void 0 : functionalGroup.relatedSGroup) instanceof MonomerMicromolecule;
    }
  }, {
    key: "isTargetFromMacromolecule",
    value: function isTargetFromMacromolecule(target) {
      return target && (target.map === 'functionalGroups' && this.isFunctionalGroupFromMacromolecule(target.id) || target.map === 'atoms' && this.isAtomFromMacromolecule(target.id) || target.map === 'bonds' && this.isBondFromMacromolecule(target.id));
    }
  }, {
    key: "disableInitiallySelected",
    value: function disableInitiallySelected() {
      this.atoms.changeInitiallySelectedPropertiesForPool(true);
      this.bonds.changeInitiallySelectedPropertiesForPool(true);
      this.rxnPluses.changeInitiallySelectedPropertiesForPool(true);
      this.rxnArrows.changeInitiallySelectedPropertiesForPool(true);
      this.texts.changeInitiallySelectedPropertiesForPool(true);
    }
  }, {
    key: "enableInitiallySelected",
    value: function enableInitiallySelected() {
      this.atoms.changeInitiallySelectedPropertiesForPool();
      this.bonds.changeInitiallySelectedPropertiesForPool();
      this.rxnPluses.changeInitiallySelectedPropertiesForPool();
      this.rxnArrows.changeInitiallySelectedPropertiesForPool();
      this.texts.changeInitiallySelectedPropertiesForPool();
    }
  }]);
  return Struct;
}();

function _callSuper$1j(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1j() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1j() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1j = function _isNativeReflectConstruct() { return !!t; })(); }
exports.TextCommand = void 0;
(function (TextCommand) {
  TextCommand["Bold"] = "BOLD";
  TextCommand["Italic"] = "ITALIC";
  TextCommand["Subscript"] = "SUBSCRIPT";
  TextCommand["Superscript"] = "SUPERSCRIPT";
  TextCommand["FontSize"] = "CUSTOM_FONT_SIZE";
})(exports.TextCommand || (exports.TextCommand = {}));
function preparePositions(positions) {
  if (!positions || !positions.length) {
    return [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
  }
  return positions.map(function (position) {
    return new Vec2(position);
  });
}
var Text = function (_BaseMicromoleculeEnt) {
  _inherits__default["default"](Text, _BaseMicromoleculeEnt);
  function Text(attributes) {
    var _this;
    _classCallCheck__default["default"](this, Text);
    _this = _callSuper$1j(this, Text, [attributes === null || attributes === void 0 ? void 0 : attributes.initiallySelected]);
    _this.pos = preparePositions(attributes === null || attributes === void 0 ? void 0 : attributes.pos);
    _this.content = (attributes === null || attributes === void 0 ? void 0 : attributes.content) || '';
    _this.position = attributes !== null && attributes !== void 0 && attributes.position ? new Vec2(attributes.position) : new Vec2();
    return _this;
  }
  _createClass__default["default"](Text, [{
    key: "setPos",
    value: function setPos(coords) {
      this.pos = coords || [];
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Text(this);
    }
  }]);
  return Text;
}(BaseMicromoleculeEntity);

var Highlight = _createClass__default["default"](function Highlight(attributes) {
  _classCallCheck__default["default"](this, Highlight);
  var atoms = attributes.atoms,
    bonds = attributes.bonds,
    color = attributes.color;
  this.color = color;
  this.atoms = atoms;
  this.bonds = bonds;
});

var SGroupAttachmentPoint = function () {
  function SGroupAttachmentPoint(atomId, leaveAtomId, attachmentId) {
    _classCallCheck__default["default"](this, SGroupAttachmentPoint);
    this.atomId = atomId;
    this.leaveAtomId = leaveAtomId;
    this.attachmentId = attachmentId;
  }
  _createClass__default["default"](SGroupAttachmentPoint, [{
    key: "clone",
    value: function clone(atomIdMap) {
      var newAtomId = atomIdMap.get(this.atomId);
      assert__default["default"](newAtomId != null);
      var newLeaveAtomId = atomIdMap.get(this.leaveAtomId);
      return new SGroupAttachmentPoint(newAtomId, newLeaveAtomId, this.attachmentId);
    }
  }, {
    key: "convertToRGroupAttachmentPointForDisplayPurpose",
    value: function convertToRGroupAttachmentPointForDisplayPurpose(attachedAtomId) {
      return new RGroupAttachmentPoint(attachedAtomId, 'primary');
    }
  }]);
  return SGroupAttachmentPoint;
}();

var editorSettings = {
  microModeScale: 40,
  macroModeScale: 40
};
function provideEditorSettings() {
  return editorSettings;
}

var canvasSelector = '#polymer-editor-canvas';
var drawnStructuresSelector = '.drawn-structures';

var notifyRenderComplete = ___default["default"].debounce(function () {
  var event = new Event('renderComplete');
  window.dispatchEvent(event);
}, 750);
var notifyItemsToMergeInitializationComplete = function notifyItemsToMergeInitializationComplete() {
  var event = new Event('itemsToMergeInitializationComplete');
  window.dispatchEvent(event);
};

var AUTO_SCROLL_OFFSET_X = 10;
var AUTO_SCROLL_OFFSET_Y = 10;
var ZoomTool = function () {
  function ZoomTool(drawingEntitiesManager) {
    var _this = this;
    _classCallCheck__default["default"](this, ZoomTool);
    _defineProperty__default["default"](this, "resizeObserver", null);
    _defineProperty__default["default"](this, "zoomEventHandlers", []);
    _defineProperty__default["default"](this, "COLOR", '#a5afb9');
    _defineProperty__default["default"](this, "MIN_LENGTH", 40);
    _defineProperty__default["default"](this, "RADIUS", 2);
    _defineProperty__default["default"](this, "MARGIN", 5);
    _defineProperty__default["default"](this, "HORIZONTAL_DIST_TO_EDGE", 16);
    _defineProperty__default["default"](this, "VERTICAL_DIST_TO_EDGE", 4);
    _defineProperty__default["default"](this, "WIDTH", 4);
    _defineProperty__default["default"](this, "MINZOOMSCALE", 0.2);
    _defineProperty__default["default"](this, "MAXZOOMSCALE", 4);
    _defineProperty__default["default"](this, "dragged", function (name) {
      return function (event) {
        if (name === 'horizontal') {
          var _this$zoom;
          (_this$zoom = _this.zoom) === null || _this$zoom === void 0 || _this$zoom.translateBy(_this.canvasWrapper, -event.dx, 0);
        } else {
          var _this$zoom2;
          (_this$zoom2 = _this.zoom) === null || _this$zoom2 === void 0 || _this$zoom2.translateBy(_this.canvasWrapper, 0, -event.dy);
        }
      };
    });
    _defineProperty__default["default"](this, "observeCanvasResize", function () {
      _this.resizeObserver = new ResizeObserver(function () {
        _this.drawScrollBars();
      });
      _this.resizeObserver.observe(_this.canvasWrapper.node());
    });
    this.canvasWrapper = d3.select(canvasSelector);
    this.canvas = d3.select(drawnStructuresSelector);
    this.zoomLevel = 1;
    this.zoomTransform = new d3.ZoomTransform(1, 0, 0);
    this.drawingEntitiesManager = drawingEntitiesManager;
    this.initActions();
  }
  _createClass__default["default"](ZoomTool, [{
    key: "initActions",
    value: function initActions() {
      var _this2 = this;
      this.zoom = d3.zoom().scaleExtent([this.MINZOOMSCALE, this.MAXZOOMSCALE]).wheelDelta(this.defaultWheelDelta).filter(function (e) {
        e.preventDefault();
        if (e.ctrlKey && e.type === 'wheel') {
          return true;
        }
        return false;
      }).on('zoom', this.zoomAction.bind(this)).on('end', function () {
        notifyRenderComplete();
      });
      this.canvasWrapper.call(this.zoom);
      this.canvasWrapper.on('wheel', function (event) {
        if (event.ctrlKey) {
          event.preventDefault();
        } else {
          _this2.mouseWheeled(event);
        }
      });
      this.initMenuZoom();
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoomLevel) {
      this.zoomLevel = zoomLevel;
    }
  }, {
    key: "getZoomLevel",
    value: function getZoomLevel() {
      return this.zoomLevel;
    }
  }, {
    key: "setZoomTransform",
    value: function setZoomTransform(transform) {
      this.zoomTransform = transform;
    }
  }, {
    key: "zoomAction",
    value: function zoomAction(_ref) {
      var _this3 = this;
      var transform = _ref.transform;
      this.canvas.attr('transform', transform);
      this.zoomLevel = transform.k;
      this.zoomTransform = transform;
      this.drawScrollBars();
      requestAnimationFrame(function () {
        _this3.dispatchZoomEventHandlers(transform);
      });
    }
  }, {
    key: "subscribeOnZoomEvent",
    value: function subscribeOnZoomEvent(zoomEventHandler) {
      this.zoomEventHandlers.push(zoomEventHandler);
    }
  }, {
    key: "dispatchZoomEventHandlers",
    value: function dispatchZoomEventHandlers(transform) {
      this.zoomEventHandlers.forEach(function (zoomEventHandler) {
        zoomEventHandler(transform);
      });
    }
  }, {
    key: "drawScrollBars",
    value: function drawScrollBars() {
      if (this.canvas.node() && this.canvasWrapper.node()) {
        this.initScrollBars();
        this.renderScrollBar(this.scrollBars.horizontal);
        this.renderScrollBar(this.scrollBars.vertical);
      }
    }
  }, {
    key: "renderScrollBar",
    value: function renderScrollBar(scrollBar) {
      var hasOffset = scrollBar.offsetStart < 0 || scrollBar.offsetEnd < 0;
      if (hasOffset) {
        if (scrollBar.bar) {
          this.updateScrollBarAttrs(scrollBar);
        } else {
          this.drawScrollBar(scrollBar);
        }
      } else {
        var _scrollBar$bar;
        (_scrollBar$bar = scrollBar.bar) === null || _scrollBar$bar === void 0 || _scrollBar$bar.remove();
        scrollBar.bar = undefined;
      }
    }
  }, {
    key: "drawScrollBar",
    value: function drawScrollBar(scrollBar) {
      var _scrollBar$bar2;
      scrollBar.bar = this.canvasWrapper.append('rect');
      var dragged = d3.drag().on('drag', this.dragged(scrollBar.name).bind(this));
      (_scrollBar$bar2 = scrollBar.bar) === null || _scrollBar$bar2 === void 0 || _scrollBar$bar2.call(dragged);
      this.updateScrollBarAttrs(scrollBar);
    }
  }, {
    key: "updateScrollBarAttrs",
    value: function updateScrollBarAttrs(scrollBar) {
      var _scrollBar$bar5;
      var _this$calculateDynami = this.calculateDynamicAttr(scrollBar),
        start = _this$calculateDynami.start,
        length = _this$calculateDynami.length;
      if (scrollBar.name === 'horizontal') {
        var _scrollBar$bar3;
        (_scrollBar$bar3 = scrollBar.bar) === null || _scrollBar$bar3 === void 0 || _scrollBar$bar3.attr('x', start).attr('y', scrollBar.maxHeight - this.HORIZONTAL_DIST_TO_EDGE).attr('width', length).attr('height', this.WIDTH);
      } else {
        var _scrollBar$bar4;
        (_scrollBar$bar4 = scrollBar.bar) === null || _scrollBar$bar4 === void 0 || _scrollBar$bar4.attr('x', scrollBar.maxHeight - this.VERTICAL_DIST_TO_EDGE).attr('y', start).attr('width', this.WIDTH).attr('height', length);
      }
      (_scrollBar$bar5 = scrollBar.bar) === null || _scrollBar$bar5 === void 0 || _scrollBar$bar5.attr('rx', this.RADIUS).attr('draggable', true).attr('cursor', 'pointer').attr('stroke', this.COLOR).attr('fill', this.COLOR).attr('data-testid', scrollBar.name + '-bar');
    }
  }, {
    key: "calculateDynamicAttr",
    value: function calculateDynamicAttr(scrollBar) {
      var start = _.clamp(-scrollBar.offsetStart, this.MARGIN, scrollBar.maxWidth - this.MIN_LENGTH - this.MARGIN);
      var end = scrollBar.maxWidth - _.clamp(-scrollBar.offsetEnd, this.MARGIN, scrollBar.maxWidth);
      var length = Math.max(end - start, this.MIN_LENGTH);
      return {
        start: start,
        length: length
      };
    }
  }, {
    key: "scrollTo",
    value: function scrollTo(position) {
      var _this$canvasWrapper$n, _this$canvasWrapper$n2, _this$zoom3;
      var canvasWrapperHeight = ((_this$canvasWrapper$n = this.canvasWrapper.node()) === null || _this$canvasWrapper$n === void 0 ? void 0 : _this$canvasWrapper$n.height.baseVal.value) || 0;
      var canvasWrapperWidth = ((_this$canvasWrapper$n2 = this.canvasWrapper.node()) === null || _this$canvasWrapper$n2 === void 0 ? void 0 : _this$canvasWrapper$n2.width.baseVal.value) || 0;
      (_this$zoom3 = this.zoom) === null || _this$zoom3 === void 0 || _this$zoom3.translateTo(this.canvasWrapper, position.x + canvasWrapperWidth / 2 - canvasWrapperWidth * AUTO_SCROLL_OFFSET_X / 100, position.y + canvasWrapperHeight / 2 - canvasWrapperHeight * AUTO_SCROLL_OFFSET_Y / 100);
    }
  }, {
    key: "mouseWheeled",
    value: function mouseWheeled(event) {
      var isShiftKeydown = event.shiftKey;
      var boxNode = this.canvasWrapper.node();
      if (boxNode && (event.deltaX || event.deltaY)) {
        var x = -event.deltaX / this.zoomLevel;
        var y = -event.deltaY / this.zoomLevel;
        if (isShiftKeydown) {
          var _this$zoom4;
          (_this$zoom4 = this.zoom) === null || _this$zoom4 === void 0 || _this$zoom4.translateBy(this.canvasWrapper, x - y, 0);
        } else {
          var _this$zoom5;
          (_this$zoom5 = this.zoom) === null || _this$zoom5 === void 0 || _this$zoom5.translateBy(this.canvasWrapper, x, y);
        }
      }
    }
  }, {
    key: "initScrollBars",
    value: function initScrollBars() {
      var _this$canvas$node, _this$canvasWrapper$n3, _this$canvasWrapper$n4, _this$canvasWrapper$n5, _this$scrollBars, _this$scrollBars2;
      var boundingBox = (_this$canvas$node = this.canvas.node()) === null || _this$canvas$node === void 0 ? void 0 : _this$canvas$node.getBoundingClientRect();
      var wrapperBoundingBox = (_this$canvasWrapper$n3 = this.canvasWrapper.node()) === null || _this$canvasWrapper$n3 === void 0 ? void 0 : _this$canvasWrapper$n3.getBoundingClientRect();
      var canvasWrapperHeight = ((_this$canvasWrapper$n4 = this.canvasWrapper.node()) === null || _this$canvasWrapper$n4 === void 0 ? void 0 : _this$canvasWrapper$n4.height.baseVal.value) || 0;
      var canvasWrapperWidth = ((_this$canvasWrapper$n5 = this.canvasWrapper.node()) === null || _this$canvasWrapper$n5 === void 0 ? void 0 : _this$canvasWrapper$n5.width.baseVal.value) || 0;
      this.scrollBars = {
        horizontal: {
          name: 'horizontal',
          offsetStart: boundingBox.left - wrapperBoundingBox.left,
          offsetEnd: wrapperBoundingBox.width - boundingBox.right,
          maxWidth: canvasWrapperWidth,
          maxHeight: canvasWrapperHeight,
          bar: (_this$scrollBars = this.scrollBars) === null || _this$scrollBars === void 0 || (_this$scrollBars = _this$scrollBars.horizontal) === null || _this$scrollBars === void 0 ? void 0 : _this$scrollBars.bar
        },
        vertical: {
          name: 'vertical',
          offsetStart: boundingBox.top - wrapperBoundingBox.top,
          offsetEnd: wrapperBoundingBox.height - boundingBox.bottom,
          maxWidth: canvasWrapperHeight,
          maxHeight: canvasWrapperWidth,
          bar: (_this$scrollBars2 = this.scrollBars) === null || _this$scrollBars2 === void 0 || (_this$scrollBars2 = _this$scrollBars2.vertical) === null || _this$scrollBars2 === void 0 ? void 0 : _this$scrollBars2.bar
        }
      };
    }
  }, {
    key: "zoomStep",
    get: function get() {
      return 0.1;
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      var _this$zoom6;
      var zoomStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.zoomStep;
      (_this$zoom6 = this.zoom) === null || _this$zoom6 === void 0 || _this$zoom6.scaleTo(this.canvasWrapper, this.zoomLevel + zoomStep);
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      var _this$zoom7;
      var zoomStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.zoomStep;
      (_this$zoom7 = this.zoom) === null || _this$zoom7 === void 0 || _this$zoom7.scaleTo(this.canvasWrapper, this.zoomLevel - zoomStep);
    }
  }, {
    key: "resetZoom",
    value: function resetZoom() {
      var _this$zoom8;
      (_this$zoom8 = this.zoom) === null || _this$zoom8 === void 0 || _this$zoom8.transform(this.canvasWrapper, new d3.ZoomTransform(1, 0, 0));
    }
  }, {
    key: "initMenuZoom",
    value: function initMenuZoom() {
      var _this4 = this;
      d3.select('.zoom-in').on('click', function () {
        _this4.zoomIn();
      });
      d3.select('.zoom-out').on('click', function () {
        _this4.zoomOut();
      });
      d3.select('.zoom-reset').on('click', function () {
        _this4.resetZoom();
      });
    }
  }, {
    key: "defaultWheelDelta",
    value: function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002);
    }
  }, {
    key: "scaleCoordinates",
    value: function scaleCoordinates(position) {
      var newX = this.zoomTransform.applyX(position.x);
      var newY = this.zoomTransform.applyY(position.y);
      return new Vec2(newX, newY);
    }
  }, {
    key: "invertZoom",
    value: function invertZoom(position) {
      var newX = this.zoomTransform.invertX(position.x);
      var newY = this.zoomTransform.invertY(position.y);
      return new Vec2(newX, newY);
    }
  }, {
    key: "unzoomValue",
    value: function unzoomValue(value) {
      return value / this.zoomLevel;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$scrollBars$hori, _this$scrollBars$vert, _this$resizeObserver;
      (_this$scrollBars$hori = this.scrollBars.horizontal) === null || _this$scrollBars$hori === void 0 || (_this$scrollBars$hori = _this$scrollBars$hori.bar) === null || _this$scrollBars$hori === void 0 || _this$scrollBars$hori.remove();
      (_this$scrollBars$vert = this.scrollBars.vertical) === null || _this$scrollBars$vert === void 0 || (_this$scrollBars$vert = _this$scrollBars$vert.bar) === null || _this$scrollBars$vert === void 0 || _this$scrollBars$vert.remove();
      (_this$resizeObserver = this.resizeObserver) === null || _this$resizeObserver === void 0 || _this$resizeObserver.unobserve(this.canvasWrapper.node());
      this.zoom = null;
      this.zoomEventHandlers = [];
    }
  }], [{
    key: "instance",
    get:
    function get() {
      return ZoomTool._instance;
    }
  }, {
    key: "initInstance",
    value: function initInstance(drawingEntitiesManager) {
      ZoomTool._instance = new ZoomTool(drawingEntitiesManager);
      return ZoomTool._instance;
    }
  }]);
  return ZoomTool;
}();

var Coordinates = function () {
  function Coordinates() {
    _classCallCheck__default["default"](this, Coordinates);
  }
  _createClass__default["default"](Coordinates, null, [{
    key: "canvasToModel",
    value: function canvasToModel(position) {
      var settings = provideEditorSettings();
      return position.scaled(1 / settings.macroModeScale);
    }
  }, {
    key: "viewToModel",
    value: function viewToModel(position) {
      var settings = provideEditorSettings();
      var pos = ZoomTool.instance.invertZoom(position);
      return pos.scaled(1 / settings.macroModeScale);
    }
  }, {
    key: "modelToView",
    value: function modelToView(position) {
      var settings = provideEditorSettings();
      return ZoomTool.instance.scaleCoordinates(position.scaled(settings.macroModeScale));
    }
  }, {
    key: "modelToCanvas",
    value: function modelToCanvas(position) {
      var settings = provideEditorSettings();
      return position.scaled(settings.macroModeScale);
    }
  }, {
    key: "canvasToView",
    value: function canvasToView(position) {
      return ZoomTool.instance.scaleCoordinates(position);
    }
  }, {
    key: "viewToCanvas",
    value: function viewToCanvas(position) {
      return ZoomTool.instance.invertZoom(position);
    }
  }]);
  return Coordinates;
}();

var BaseRenderer = function () {
  function BaseRenderer(drawingEntity) {
    var _ZoomTool$instance, _ZoomTool$instance2;
    _classCallCheck__default["default"](this, BaseRenderer);
    this.drawingEntity = drawingEntity;
    this.canvasWrapper = ((_ZoomTool$instance = ZoomTool.instance) === null || _ZoomTool$instance === void 0 ? void 0 : _ZoomTool$instance.canvasWrapper) || d3.select(canvasSelector);
    this.canvas = ((_ZoomTool$instance2 = ZoomTool.instance) === null || _ZoomTool$instance2 === void 0 ? void 0 : _ZoomTool$instance2.canvas) || d3.select(drawnStructuresSelector);
  }
  _createClass__default["default"](BaseRenderer, [{
    key: "editorSettings",
    get: function get() {
      return provideEditorSettings();
    }
  }, {
    key: "rootBBox",
    get: function get() {
      var _this$rootElement;
      var rootNode = (_this$rootElement = this.rootElement) === null || _this$rootElement === void 0 ? void 0 : _this$rootElement.node();
      if (!rootNode) return;
      return rootNode.getBBox();
    }
  }, {
    key: "width",
    get: function get() {
      var _this$rootBBox;
      return ((_this$rootBBox = this.rootBBox) === null || _this$rootBBox === void 0 ? void 0 : _this$rootBBox.width) || 0;
    }
  }, {
    key: "height",
    get: function get() {
      var _this$rootBBox2;
      return ((_this$rootBBox2 = this.rootBBox) === null || _this$rootBBox2 === void 0 ? void 0 : _this$rootBBox2.height) || 0;
    }
  }, {
    key: "x",
    get: function get() {
      var _this$rootBBox3;
      return ((_this$rootBBox3 = this.rootBBox) === null || _this$rootBBox3 === void 0 ? void 0 : _this$rootBBox3.x) || 0;
    }
  }, {
    key: "y",
    get: function get() {
      var _this$rootBBox4;
      return ((_this$rootBBox4 = this.rootBBox) === null || _this$rootBBox4 === void 0 ? void 0 : _this$rootBBox4.y) || 0;
    }
  }, {
    key: "remove",
    value: function remove() {
      var _this$rootElement2;
      (_this$rootElement2 = this.rootElement) === null || _this$rootElement2 === void 0 || _this$rootElement2.remove();
      this.rootElement = undefined;
    }
  }, {
    key: "redrawHover",
    value: function redrawHover() {
      if (this.drawingEntity.hovered) {
        var hoverElement = this.appendHover(this.hoverAreaElement);
        if (hoverElement) {
          this.hoverElement = hoverElement;
        }
      } else {
        this.removeHover();
        this.hoverElement = undefined;
      }
    }
  }, {
    key: "move",
    value: function move() {}
  }]);
  return BaseRenderer;
}();

function _callSuper$1i(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1i() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1i() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1i = function _isNativeReflectConstruct() { return !!t; })(); }
var BaseSequenceRenderer = function (_BaseRenderer) {
  _inherits__default["default"](BaseSequenceRenderer, _BaseRenderer);
  function BaseSequenceRenderer() {
    _classCallCheck__default["default"](this, BaseSequenceRenderer);
    return _callSuper$1i(this, BaseSequenceRenderer, arguments);
  }
  _createClass__default["default"](BaseSequenceRenderer, [{
    key: "appendHover",
    value: function appendHover(_hoverArea) {
      return undefined;
    }
  }, {
    key: "appendHoverAreaElement",
    value: function appendHoverAreaElement() {}
  }, {
    key: "drawSelection",
    value: function drawSelection() {}
  }, {
    key: "moveSelection",
    value: function moveSelection() {}
  }, {
    key: "removeHover",
    value: function removeHover() {}
  }, {
    key: "show",
    value: function show(_theme) {}
  }, {
    key: "center",
    get: function get() {
      return new Vec2(0, 0, 0);
    }
  }]);
  return BaseSequenceRenderer;
}(BaseRenderer);

var id = 0;
var DrawingEntity = function () {
  function DrawingEntity() {
    var _position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vec2(0, 0);
    _classCallCheck__default["default"](this, DrawingEntity);
    _defineProperty__default["default"](this, "selected", false);
    _defineProperty__default["default"](this, "hovered", false);
    _defineProperty__default["default"](this, "id", 0);
    this._position = _position;
    this._position = _position || new Vec2(0, 0);
    this.id = id;
    id++;
  }
  _createClass__default["default"](DrawingEntity, [{
    key: "moveRelative",
    value: function moveRelative(position) {
      this._position.x += position.x;
      this._position.y += position.y;
    }
  }, {
    key: "moveAbsolute",
    value: function moveAbsolute(position) {
      this._position = position;
    }
  }, {
    key: "position",
    get: function get() {
      return this._position;
    }
  }, {
    key: "turnOnHover",
    value: function turnOnHover() {
      this.hovered = true;
    }
  }, {
    key: "turnOffHover",
    value: function turnOffHover() {
      this.hovered = false;
    }
  }, {
    key: "turnOnSelection",
    value: function turnOnSelection() {
      this.selected = true;
    }
  }, {
    key: "turnOffSelection",
    value: function turnOffSelection() {
      this.selected = false;
    }
  }, {
    key: "selectIfLocatedInRectangle",
    value: function selectIfLocatedInRectangle(rectangleTopLeftPoint, rectangleBottomRightPoint) {
      var isPreviousSelected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var shiftKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      assert__default["default"](this.baseRenderer);
      var prevSelectedValue = this.selected;
      var center = Coordinates.modelToCanvas(this.center);
      if (this.baseRenderer instanceof BaseSequenceRenderer) {
        center = this.baseRenderer.center;
      }
      var locatedInRectangle = rectangleBottomRightPoint.x > center.x && rectangleBottomRightPoint.y > center.y && rectangleTopLeftPoint.x < center.x && rectangleTopLeftPoint.y < center.y;
      if (shiftKey && !isPreviousSelected || !shiftKey) {
        if (locatedInRectangle) {
          this.turnOnSelection();
        } else {
          this.turnOffSelection();
        }
      }
      return prevSelectedValue !== this.selected;
    }
  }, {
    key: "setBaseRenderer",
    value: function setBaseRenderer(renderer) {
      this.baseRenderer = renderer;
    }
  }, {
    key: "isPartOfRna",
    get: function get() {
      return false;
    }
  }]);
  return DrawingEntity;
}();

exports.AttachmentPointName = void 0;
(function (AttachmentPointName) {
  AttachmentPointName["R1"] = "R1";
  AttachmentPointName["R2"] = "R2";
  AttachmentPointName["R3"] = "R3";
  AttachmentPointName["R4"] = "R4";
  AttachmentPointName["R5"] = "R5";
  AttachmentPointName["R6"] = "R6";
  AttachmentPointName["R7"] = "R7";
  AttachmentPointName["R8"] = "R8";
})(exports.AttachmentPointName || (exports.AttachmentPointName = {}));
var attachmentPointNames = ['R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8'];

function canvasToMonomerCoordinates(coordinatesOnCanvas, centerOFMonomer, monomerWidth, monomerHeight) {
  var zeroPointCoord = {
    x: centerOFMonomer.x - monomerWidth / 2,
    y: centerOFMonomer.y - monomerHeight / 2
  };
  var monomerCoord = {
    x: coordinatesOnCanvas.x - zeroPointCoord.x,
    y: coordinatesOnCanvas.y - zeroPointCoord.y
  };
  return monomerCoord;
}
function findLabelPoint(pointOnBorder, angle, lineLength, lineOffset, labelSize, isUsed) {
  var angleRadians = Vec2.degrees_to_radians(angle);
  var pointOfAttachment = Vec2.findSecondPoint(pointOnBorder, lineLength, angleRadians);
  var attachmentVector = {
    x: pointOfAttachment.x - pointOnBorder.x,
    y: pointOfAttachment.y - pointOnBorder.y
  };
  var rotatedVector = {
    x: -attachmentVector.y,
    y: attachmentVector.x
  };
  var normalizedVector = {
    x: rotatedVector.x / lineLength,
    y: rotatedVector.y / lineLength
  };
  var normalizedAttachmentVector = {
    x: attachmentVector.x / lineLength,
    y: attachmentVector.y / lineLength
  };
  var addedOrtogonalOffset = 0;
  var addedParallelOffset = lineOffset + Math.max(labelSize.x, labelSize.y) + 1;
  if (isUsed) {
    if (angle >= -270 && angle <= 0) {
      addedOrtogonalOffset = 5;
    } else if (angle >= -360 && angle < -270) {
      addedOrtogonalOffset = -5;
    }
  }
  var ortogonalOffset = {
    x: normalizedVector.x * addedOrtogonalOffset,
    y: normalizedVector.y * addedOrtogonalOffset
  };
  var parallelOffset = {
    x: normalizedAttachmentVector.x * addedParallelOffset,
    y: normalizedAttachmentVector.y * addedParallelOffset
  };
  var labelCoordinates = {
    x: pointOfAttachment.x + ortogonalOffset.x + parallelOffset.x - labelSize.x,
    y: pointOfAttachment.y + ortogonalOffset.y + parallelOffset.y + labelSize.y
  };
  return [labelCoordinates, pointOfAttachment];
}
function getSearchFunction(initialAngle, canvasOffset, monomer) {
  return function findPointOnMonomerBorder(coordStart, length) {
    var angle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : initialAngle;
    var angleRadians = Vec2.degrees_to_radians(angle);
    var secondPoint = Vec2.findSecondPoint(coordStart, length, angleRadians);
    var diff = Vec2.diff(new Vec2(coordStart.x, coordStart.y), new Vec2(secondPoint.x, secondPoint.y));
    if (diff.length() < 1.01) {
      return secondPoint;
    }
    var newLength = Math.round(diff.length() / 1.4);
    var newCoordStart = {
      x: secondPoint.x,
      y: secondPoint.y
    };
    var zoomedCoordinateOfSecondPoint = Coordinates.canvasToView(new Vec2(secondPoint));
    var newPointCoord = {
      x: Math.round(zoomedCoordinateOfSecondPoint.x) + canvasOffset.x,
      y: Math.round(zoomedCoordinateOfSecondPoint.y) + canvasOffset.y
    };
    var newAngle = initialAngle;
    var elementsAtPoint = document.elementsFromPoint(newPointCoord.x, newPointCoord.y);
    var isCurrentMonomerAtNewPoint = elementsAtPoint.some(function (element) {
      var _monomer$renderer;
      return element === ((_monomer$renderer = monomer.renderer) === null || _monomer$renderer === void 0 || (_monomer$renderer = _monomer$renderer.bodyElement) === null || _monomer$renderer === void 0 ? void 0 : _monomer$renderer.node());
    });
    if (isCurrentMonomerAtNewPoint) {
      newAngle = initialAngle;
    } else {
      newAngle = initialAngle - 180;
    }
    return findPointOnMonomerBorder(newCoordStart, newLength, newAngle);
  };
}
var anglesToSector = {
  '45': {
    min: 23,
    max: 68,
    center: 45
  },
  '90': {
    min: 68,
    max: 113,
    center: 90
  },
  '135': {
    min: 113,
    max: 148,
    center: 135
  },
  '180': {
    min: 148,
    max: 203,
    center: 180
  },
  '225': {
    min: 203,
    max: 248,
    center: 225
  },
  '270': {
    min: 248,
    max: 293,
    center: 270
  },
  '315': {
    min: 293,
    max: 228,
    center: 315
  },
  '360': {
    min: 338,
    max: 360,
    center: 360
  },
  '0': {
    min: 0,
    max: 23,
    center: 0
  }
};
var attachmentPointNumberToAngle;
(function (attachmentPointNumberToAngle) {
  attachmentPointNumberToAngle[attachmentPointNumberToAngle["R1"] = 0] = "R1";
  attachmentPointNumberToAngle[attachmentPointNumberToAngle["R2"] = 180] = "R2";
  attachmentPointNumberToAngle[attachmentPointNumberToAngle["R3"] = 90] = "R3";
  attachmentPointNumberToAngle[attachmentPointNumberToAngle["R4"] = 270] = "R4";
  attachmentPointNumberToAngle[attachmentPointNumberToAngle["R5"] = 45] = "R5";
  attachmentPointNumberToAngle[attachmentPointNumberToAngle["R6"] = 135] = "R6";
  attachmentPointNumberToAngle[attachmentPointNumberToAngle["R7"] = 315] = "R7";
  attachmentPointNumberToAngle[attachmentPointNumberToAngle["R8"] = 225] = "R8";
})(attachmentPointNumberToAngle || (attachmentPointNumberToAngle = {}));
var sectorsList = [45, 90, 135, 180, 225, 270, 315, 0, 360];
function checkFor0and360(sectorsList) {
  if (!sectorsList.includes(0) && sectorsList.includes(360)) {
    return sectorsList.filter(function (item) {
      return item !== 360;
    });
  }
  if (!sectorsList.includes(360) && sectorsList.includes(0)) {
    return sectorsList.filter(function (item) {
      return item !== 0;
    });
  }
  return sectorsList;
}
function convertAttachmentPointNumberToLabel(attachmentPointNumber) {
  var attachmentPointLabel = '';
  for (var rgi = 0; rgi < 32; rgi++) {
    if (attachmentPointNumber & 1 << rgi) {
      attachmentPointLabel = 'R' + (rgi + 1).toString();
    }
  }
  return attachmentPointLabel;
}

function ownKeys$r(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$r(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$r(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$r(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$1h(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1h() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1h() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1h = function _isNativeReflectConstruct() { return !!t; })(); }
var BaseMonomer = function (_DrawingEntity) {
  _inherits__default["default"](BaseMonomer, _DrawingEntity);
  function BaseMonomer(monomerItem, _position) {
    var _this;
    _classCallCheck__default["default"](this, BaseMonomer);
    _this = _callSuper$1h(this, BaseMonomer, [_position]);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "renderer", undefined);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "attachmentPointsToBonds", {});
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "potentialAttachmentPointsToBonds", {});
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "attachmentPointsVisible", false);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "isMonomerInRnaChainRow", false);
    _this.monomerItem = _objectSpread$r({}, monomerItem);
    if (!_this.monomerItem.props.isMicromoleculeFragment) {
      _this.attachmentPointsToBonds = _this.getAttachmentPointDict();
      _this.potentialAttachmentPointsToBonds = _this.getAttachmentPointDict();
      _this.monomerItem.attachmentPoints = _this.monomerItem.attachmentPoints || _this.getMonomerDefinitionAttachmentPoints();
    }
    _this.chosenFirstAttachmentPointForBond = null;
    _this.potentialSecondAttachmentPointForBond = null;
    _this.chosenSecondAttachmentPointForBond = null;
    return _this;
  }
  _createClass__default["default"](BaseMonomer, [{
    key: "label",
    get: function get() {
      return this.monomerItem.label;
    }
  }, {
    key: "center",
    get: function get() {
      return this.position;
    }
  }, {
    key: "listOfAttachmentPoints",
    get: function get() {
      var maxAttachmentPointNumber = this.getMaxAttachmentPointNumber();
      var attachmentPointList = [];
      for (var i = 1; i <= maxAttachmentPointNumber; i++) {
        if (this.attachmentPointsToBonds["R".concat(i)] !== undefined) {
          attachmentPointList.push("R".concat(i));
        }
      }
      return attachmentPointList;
    }
  }, {
    key: "turnOnAttachmentPointsVisibility",
    value: function turnOnAttachmentPointsVisibility() {
      this.attachmentPointsVisible = true;
    }
  }, {
    key: "turnOffAttachmentPointsVisibility",
    value: function turnOffAttachmentPointsVisibility() {
      this.attachmentPointsVisible = false;
    }
  }, {
    key: "setChosenFirstAttachmentPoint",
    value: function setChosenFirstAttachmentPoint(attachmentPoint) {
      this.chosenFirstAttachmentPointForBond = attachmentPoint;
    }
  }, {
    key: "setChosenSecondAttachmentPoint",
    value: function setChosenSecondAttachmentPoint(attachmentPoint) {
      this.chosenSecondAttachmentPointForBond = attachmentPoint;
    }
  }, {
    key: "setPotentialSecondAttachmentPoint",
    value: function setPotentialSecondAttachmentPoint(attachmentPoint) {
      this.potentialSecondAttachmentPointForBond = attachmentPoint;
    }
  }, {
    key: "setPotentialBond",
    value: function setPotentialBond(attachmentPoint, potentialBond) {
      if (attachmentPoint !== undefined) {
        this.potentialAttachmentPointsToBonds[attachmentPoint] = potentialBond;
      }
    }
  }, {
    key: "getAttachmentPointByBond",
    value: function getAttachmentPointByBond(bond) {
      for (var attachmentPointName in this.attachmentPointsToBonds) {
        if (this.attachmentPointsToBonds[attachmentPointName] === bond) {
          return attachmentPointName;
        }
      }
      return undefined;
    }
  }, {
    key: "getPotentialAttachmentPointByBond",
    value: function getPotentialAttachmentPointByBond(bond) {
      for (var attachmentPointName in this.potentialAttachmentPointsToBonds) {
        if (this.potentialAttachmentPointsToBonds[attachmentPointName] === bond) {
          return attachmentPointName;
        }
      }
      return undefined;
    }
  }, {
    key: "firstFreeAttachmentPoint",
    get: function get() {
      var maxAttachmentPointNumber = this.getMaxAttachmentPointNumber();
      for (var i = 1; i <= maxAttachmentPointNumber; i++) {
        var attachmentPoint = "R".concat(i);
        if (this.hasAttachmentPoint(attachmentPoint) && this.attachmentPointsToBonds[attachmentPoint] === null) {
          return attachmentPoint;
        }
      }
      return undefined;
    }
  }, {
    key: "getMaxAttachmentPointNumber",
    value: function getMaxAttachmentPointNumber() {
      var maxAttachmentPointNumber = 1;
      for (var attachmentPoint in this.attachmentPointsToBonds) {
        var match = attachmentPoint.match(/R(\d+)/);
        if (match) {
          var pointNumber = parseInt(match[1]);
          if (!isNaN(pointNumber) && pointNumber > maxAttachmentPointNumber) {
            maxAttachmentPointNumber = pointNumber;
          }
        }
      }
      return maxAttachmentPointNumber;
    }
  }, {
    key: "R1AttachmentPoint",
    get: function get() {
      if (this.attachmentPointsToBonds.R1 === null) {
        return exports.AttachmentPointName.R1;
      }
      return undefined;
    }
  }, {
    key: "R2AttachmentPoint",
    get: function get() {
      if (this.attachmentPointsToBonds.R2 === null) {
        return exports.AttachmentPointName.R2;
      }
      return undefined;
    }
  }, {
    key: "hasFreeAttachmentPoint",
    get: function get() {
      return Boolean(this.firstFreeAttachmentPoint);
    }
  }, {
    key: "isAttachmentPointExistAndFree",
    value: function isAttachmentPointExistAndFree(attachmentPoint) {
      return this.hasAttachmentPoint(attachmentPoint) && !this.isAttachmentPointUsed(attachmentPoint);
    }
  }, {
    key: "setRenderer",
    value: function setRenderer(renderer) {
      _get__default["default"](_getPrototypeOf__default["default"](BaseMonomer.prototype), "setBaseRenderer", this).call(this, renderer);
      this.renderer = renderer;
    }
  }, {
    key: "forEachBond",
    value: function forEachBond(callback) {
      for (var attachmentPointName in this.attachmentPointsToBonds) {
        if (this.attachmentPointsToBonds[attachmentPointName]) {
          callback(this.attachmentPointsToBonds[attachmentPointName], attachmentPointName);
        }
      }
    }
  }, {
    key: "setBond",
    value: function setBond(attachmentPointName, bond) {
      this.attachmentPointsToBonds[attachmentPointName] = bond;
    }
  }, {
    key: "unsetBond",
    value: function unsetBond(attachmentPointName) {
      this.attachmentPointsToBonds[attachmentPointName] = null;
    }
  }, {
    key: "hasBonds",
    get: function get() {
      var hasBonds = false;
      for (var bondName in this.attachmentPointsToBonds) {
        if (this.attachmentPointsToBonds[bondName]) {
          hasBonds = true;
        }
      }
      return hasBonds;
    }
  }, {
    key: "hasPotentialBonds",
    value: function hasPotentialBonds() {
      return Object.values(this.potentialAttachmentPointsToBonds).some(function (bond) {
        return !!bond;
      });
    }
  }, {
    key: "getPotentialBond",
    value: function getPotentialBond(attachmentPointName) {
      return this.potentialAttachmentPointsToBonds[attachmentPointName];
    }
  }, {
    key: "removeBond",
    value: function removeBond(polymerBond) {
      var attachmentPointName = this.getAttachmentPointByBond(polymerBond);
      if (!attachmentPointName) return;
      this.unsetBond(attachmentPointName);
    }
  }, {
    key: "removePotentialBonds",
    value: function removePotentialBonds() {
      var clearSelectedPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (clearSelectedPoints) {
        this.chosenFirstAttachmentPointForBond = null;
        this.chosenSecondAttachmentPointForBond = null;
        this.potentialSecondAttachmentPointForBond = null;
      }
      for (var attachmentPointName in this.potentialAttachmentPointsToBonds) {
        this.potentialAttachmentPointsToBonds[attachmentPointName] = null;
      }
    }
  }, {
    key: "availableAttachmentPointForBondEnd",
    get: function get() {
      if (this.chosenSecondAttachmentPointForBond) {
        return this.chosenSecondAttachmentPointForBond;
      }
      return this.firstFreeAttachmentPoint;
    }
  }, {
    key: "hasAttachmentPoint",
    value: function hasAttachmentPoint(attachmentPointName) {
      return this.attachmentPointsToBonds[attachmentPointName] !== undefined;
    }
  }, {
    key: "usedAttachmentPointsNamesList",
    get: function get() {
      var list = [];
      for (var attachmentPointName in this.attachmentPointsToBonds) {
        if (this.isAttachmentPointUsed(attachmentPointName)) {
          list.push(attachmentPointName);
        }
      }
      return list;
    }
  }, {
    key: "unUsedAttachmentPointsNamesList",
    get: function get() {
      var list = [];
      for (var attachmentPointName in this.attachmentPointsToBonds) {
        if (!this.isAttachmentPointUsed(attachmentPointName)) {
          list.push(attachmentPointName);
        }
      }
      return list;
    }
  }, {
    key: "getBondByAttachmentPoint",
    value: function getBondByAttachmentPoint(attachmentPointName) {
      return this.attachmentPointsToBonds[attachmentPointName];
    }
  }, {
    key: "getPotentialBondByAttachmentPoint",
    value: function getPotentialBondByAttachmentPoint(attachmentPointName) {
      return this.potentialAttachmentPointsToBonds[attachmentPointName];
    }
  }, {
    key: "isAttachmentPointUsed",
    value: function isAttachmentPointUsed(attachmentPointName) {
      return Boolean(this.getBondByAttachmentPoint(attachmentPointName));
    }
  }, {
    key: "isAttachmentPointPotentiallyUsed",
    value: function isAttachmentPointPotentiallyUsed(attachmentPointName) {
      return Boolean(this.getPotentialBondByAttachmentPoint(attachmentPointName));
    }
  }, {
    key: "getAttachmentPointDict",
    value: function getAttachmentPointDict() {
      if (this.monomerItem.attachmentPoints) {
        var _BaseMonomer$getAttac = BaseMonomer.getAttachmentPointDictFromMonomerDefinition(this.monomerItem.attachmentPoints),
          attachmentPointDictionary = _BaseMonomer$getAttac.attachmentPointDictionary;
        return attachmentPointDictionary;
      } else {
        return this.getAttachmentPointDictFromAtoms();
      }
    }
  }, {
    key: "attachmentPointNumberToType",
    get: function get() {
      return {
        1: 'left',
        2: 'right',
        moreThanTwo: 'side'
      };
    }
  }, {
    key: "getMonomerDefinitionAttachmentPoints",
    value: function getMonomerDefinitionAttachmentPoints() {
      var _this2 = this;
      var monomerDefinitionAttachmentPoints = [];
      this.leavingGroupsAtoms.forEach(function (leavingGroupsAtom) {
        var bondId = _this2.monomerItem.struct.bonds.find(function (_, bond) {
          return bond.begin === leavingGroupsAtom.id || bond.end === leavingGroupsAtom.id;
        });
        var attachmentAtomId;
        var leavingGroupsAtomId;
        if (_.isNumber(bondId)) {
          var bond = _this2.monomerItem.struct.bonds.get(bondId);
          attachmentAtomId = bond.begin === leavingGroupsAtom.id ? bond.end : bond.begin;
          leavingGroupsAtomId = leavingGroupsAtom.id;
        } else {
          attachmentAtomId = leavingGroupsAtom.id;
        }
        monomerDefinitionAttachmentPoints.push({
          attachmentAtom: attachmentAtomId,
          leavingGroup: {
            atoms: leavingGroupsAtomId ? [leavingGroupsAtomId] : []
          },
          type: _this2.attachmentPointNumberToType[leavingGroupsAtom.rglabel] || _this2.attachmentPointNumberToType.moreThanTwo
        });
      });
      return monomerDefinitionAttachmentPoints;
    }
  }, {
    key: "leavingGroupsAtoms",
    get: function get() {
      var leavingGroupsAtoms = this.monomerItem.struct.atoms.filter(function (_, value) {
        return Boolean(value.rglabel);
      });
      var leavingGroupsAtomsArray = [];
      leavingGroupsAtoms.forEach(function (attachmentAtom, attachmentAtomId) {
        leavingGroupsAtomsArray.push({
          id: attachmentAtomId,
          rglabel: Number(attachmentAtom.rglabel)
        });
      });
      leavingGroupsAtomsArray.sort(function (atom1, atom2) {
        return Number(atom1.rglabel) > Number(atom2.rglabel) ? 1 : -1;
      });
      return leavingGroupsAtomsArray;
    }
  }, {
    key: "getAttachmentPointDictFromAtoms",
    value: function getAttachmentPointDictFromAtoms() {
      var attachmentPointNameToBond = {};
      this.leavingGroupsAtoms.forEach(function (_ref, _) {
        var rglabel = _ref.rglabel;
        var label = convertAttachmentPointNumberToLabel(Number(rglabel));
        attachmentPointNameToBond[label] = null;
      });
      return attachmentPointNameToBond;
    }
  }, {
    key: "startBondAttachmentPoint",
    get: function get() {
      if (this.chosenFirstAttachmentPointForBond) {
        return this.chosenFirstAttachmentPointForBond;
      }
      if (this.attachmentPointsToBonds.R2 === null) {
        return 'R2';
      }
      if (this.attachmentPointsToBonds.R1 === null) {
        return 'R1';
      }
      return this.firstFreeAttachmentPoint;
    }
  }, {
    key: "isMonomerTypeDifferentForChaining",
    value: function isMonomerTypeDifferentForChaining(monomerToChain) {
      return this.SubChainConstructor !== monomerToChain.SubChainConstructor;
    }
  }, {
    key: "isPartOfRna",
    get: function get() {
      return false;
    }
  }], [{
    key: "getAttachmentPointDictFromMonomerDefinition",
    value: function getAttachmentPointDictFromMonomerDefinition(attachmentPoints) {
      var attachmentPointDictionary = {};
      var attachmentPointsList = [];
      var attachmentPointTypeToNumber = {
        left: function left() {
          return 1;
        },
        right: function right() {
          return 2;
        },
        side: function side(attachmentPointNumber) {
          assert__default["default"](attachmentPointNumber);
          return attachmentPointNumber + Number(!('R1' in attachmentPointDictionary)) + Number(!('R2' in attachmentPointDictionary));
        }
      };
      attachmentPoints.forEach(function (attachmentPoint, attachmentPointIndex) {
        var attachmentPointNumber = attachmentPointIndex + 1;
        var calculatedAttachmentPointNumber;
        if (attachmentPoint.type) {
          var getLabelByTypeAction = attachmentPointTypeToNumber[attachmentPoint.type];
          calculatedAttachmentPointNumber = typeof getLabelByTypeAction === 'function' ? attachmentPointTypeToNumber[attachmentPoint.type](attachmentPointNumber) : attachmentPointNumber;
        } else {
          calculatedAttachmentPointNumber = attachmentPointNumber;
        }
        var calculatedLabel = attachmentPoint.label || "R".concat(calculatedAttachmentPointNumber);
        attachmentPointDictionary[calculatedLabel] = null;
        attachmentPointsList.push(calculatedLabel);
      });
      return {
        attachmentPointDictionary: attachmentPointDictionary,
        attachmentPointsList: attachmentPointsList
      };
    }
  }]);
  return BaseMonomer;
}(DrawingEntity);

var BaseSubChain = function () {
  function BaseSubChain() {
    _classCallCheck__default["default"](this, BaseSubChain);
    _defineProperty__default["default"](this, "nodes", []);
    _defineProperty__default["default"](this, "bonds", []);
  }
  _createClass__default["default"](BaseSubChain, [{
    key: "lastNode",
    get: function get() {
      return this.nodes[this.nodes.length - 1];
    }
  }, {
    key: "firstNode",
    get: function get() {
      return this.nodes[0];
    }
  }, {
    key: "add",
    value: function add(node) {
      this.nodes.push(node);
    }
  }, {
    key: "length",
    get: function get() {
      return this.nodes.length;
    }
  }]);
  return BaseSubChain;
}();

function _callSuper$1g(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1g() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1g() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1g = function _isNativeReflectConstruct() { return !!t; })(); }
var PeptideSubChain = function (_BaseSubChain) {
  _inherits__default["default"](PeptideSubChain, _BaseSubChain);
  function PeptideSubChain() {
    _classCallCheck__default["default"](this, PeptideSubChain);
    return _callSuper$1g(this, PeptideSubChain, arguments);
  }
  return _createClass__default["default"](PeptideSubChain);
}(BaseSubChain);

function _callSuper$1f(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1f() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1f() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1f = function _isNativeReflectConstruct() { return !!t; })(); }
var ChemSubChain = function (_BaseSubChain) {
  _inherits__default["default"](ChemSubChain, _BaseSubChain);
  function ChemSubChain() {
    _classCallCheck__default["default"](this, ChemSubChain);
    return _callSuper$1f(this, ChemSubChain, arguments);
  }
  return _createClass__default["default"](ChemSubChain);
}(BaseSubChain);

function _callSuper$1e(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1e() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1e() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1e = function _isNativeReflectConstruct() { return !!t; })(); }
var Peptide = function (_BaseMonomer) {
  _inherits__default["default"](Peptide, _BaseMonomer);
  function Peptide() {
    _classCallCheck__default["default"](this, Peptide);
    return _callSuper$1e(this, Peptide, arguments);
  }
  _createClass__default["default"](Peptide, [{
    key: "getValidSourcePoint",
    value: function getValidSourcePoint(secondMonomer) {
      if (this.chosenFirstAttachmentPointForBond) {
        return this.chosenFirstAttachmentPointForBond;
      }
      if (this.unUsedAttachmentPointsNamesList.length === 1) {
        return this.unUsedAttachmentPointsNamesList[0];
      }
      if (secondMonomer !== null && secondMonomer !== void 0 && secondMonomer.potentialSecondAttachmentPointForBond) {
        if ((secondMonomer === null || secondMonomer === void 0 ? void 0 : secondMonomer.potentialSecondAttachmentPointForBond) === exports.AttachmentPointName.R1 && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
          return exports.AttachmentPointName.R2;
        }
        if ((secondMonomer === null || secondMonomer === void 0 ? void 0 : secondMonomer.potentialSecondAttachmentPointForBond) === exports.AttachmentPointName.R2 && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1)) {
          return exports.AttachmentPointName.R1;
        }
        return;
      }
      if ((!secondMonomer || secondMonomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1)) && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
        return exports.AttachmentPointName.R2;
      }
      if (this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1) && secondMonomer !== null && secondMonomer !== void 0 && secondMonomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
        return exports.AttachmentPointName.R1;
      }
      return undefined;
    }
  }, {
    key: "getValidTargetPoint",
    value: function getValidTargetPoint(firstMonomer) {
      if (this.potentialSecondAttachmentPointForBond) {
        return this.potentialSecondAttachmentPointForBond;
      }
      if (this.unUsedAttachmentPointsNamesList.length === 1) {
        return this.unUsedAttachmentPointsNamesList[0];
      }
      if (firstMonomer !== null && firstMonomer !== void 0 && firstMonomer.chosenFirstAttachmentPointForBond) {
        if ((firstMonomer === null || firstMonomer === void 0 ? void 0 : firstMonomer.chosenFirstAttachmentPointForBond) === exports.AttachmentPointName.R1 && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
          return exports.AttachmentPointName.R2;
        }
        if ((firstMonomer === null || firstMonomer === void 0 ? void 0 : firstMonomer.chosenFirstAttachmentPointForBond) === exports.AttachmentPointName.R2 && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1)) {
          return exports.AttachmentPointName.R1;
        }
        return;
      }
      if (this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1) && firstMonomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
        return exports.AttachmentPointName.R1;
      }
      if (firstMonomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1) && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
        return exports.AttachmentPointName.R2;
      }
      return undefined;
    }
  }, {
    key: "SubChainConstructor",
    get: function get() {
      return PeptideSubChain;
    }
  }, {
    key: "isMonomerTypeDifferentForChaining",
    value: function isMonomerTypeDifferentForChaining(monomerToChain) {
      return ![PeptideSubChain, ChemSubChain].includes(monomerToChain.SubChainConstructor);
    }
  }]);
  return Peptide;
}(BaseMonomer);

function _callSuper$1d(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1d() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1d() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1d = function _isNativeReflectConstruct() { return !!t; })(); }
var Chem = function (_BaseMonomer) {
  _inherits__default["default"](Chem, _BaseMonomer);
  function Chem() {
    _classCallCheck__default["default"](this, Chem);
    return _callSuper$1d(this, Chem, arguments);
  }
  _createClass__default["default"](Chem, [{
    key: "getValidSourcePoint",
    value: function getValidSourcePoint(monomer) {
      return Peptide.prototype.getValidSourcePoint.call(this, monomer);
    }
  }, {
    key: "getValidTargetPoint",
    value: function getValidTargetPoint(monomer) {
      return Peptide.prototype.getValidTargetPoint.call(this, monomer);
    }
  }, {
    key: "SubChainConstructor",
    get: function get() {
      return ChemSubChain;
    }
  }, {
    key: "isMonomerTypeDifferentForChaining",
    value: function isMonomerTypeDifferentForChaining(monomerToChain) {
      return ![PeptideSubChain, ChemSubChain].includes(monomerToChain.SubChainConstructor);
    }
  }]);
  return Chem;
}(BaseMonomer);

function _callSuper$1c(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1c() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1c() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1c = function _isNativeReflectConstruct() { return !!t; })(); }
var RNABase = function (_BaseMonomer) {
  _inherits__default["default"](RNABase, _BaseMonomer);
  function RNABase() {
    _classCallCheck__default["default"](this, RNABase);
    return _callSuper$1c(this, RNABase, arguments);
  }
  _createClass__default["default"](RNABase, [{
    key: "getValidSourcePoint",
    value: function getValidSourcePoint() {
      if (this.chosenFirstAttachmentPointForBond) {
        return this.chosenFirstAttachmentPointForBond;
      }
      return this.firstFreeAttachmentPoint;
    }
  }, {
    key: "getValidTargetPoint",
    value: function getValidTargetPoint() {
      if (this.potentialSecondAttachmentPointForBond) {
        return this.potentialSecondAttachmentPointForBond;
      }
      return this.firstFreeAttachmentPoint;
    }
  }, {
    key: "SubChainConstructor",
    get: function get() {
      return ChemSubChain;
    }
  }, {
    key: "isPartOfRna",
    get: function get() {
      var _this$attachmentPoint;
      return ((_this$attachmentPoint = this.attachmentPointsToBonds.R1) === null || _this$attachmentPoint === void 0 ? void 0 : _this$attachmentPoint.getAnotherMonomer(this)) instanceof Sugar;
    }
  }]);
  return RNABase;
}(BaseMonomer);

function _callSuper$1b(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1b() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1b() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1b = function _isNativeReflectConstruct() { return !!t; })(); }
var PhosphateSubChain = function (_BaseSubChain) {
  _inherits__default["default"](PhosphateSubChain, _BaseSubChain);
  function PhosphateSubChain() {
    _classCallCheck__default["default"](this, PhosphateSubChain);
    return _callSuper$1b(this, PhosphateSubChain, arguments);
  }
  return _createClass__default["default"](PhosphateSubChain);
}(BaseSubChain);

function _callSuper$1a(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1a() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1a() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1a = function _isNativeReflectConstruct() { return !!t; })(); }
var RnaSubChain = function (_BaseSubChain) {
  _inherits__default["default"](RnaSubChain, _BaseSubChain);
  function RnaSubChain() {
    _classCallCheck__default["default"](this, RnaSubChain);
    return _callSuper$1a(this, RnaSubChain, arguments);
  }
  return _createClass__default["default"](RnaSubChain);
}(BaseSubChain);

function _callSuper$19(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$19() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$19() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$19 = function _isNativeReflectConstruct() { return !!t; })(); }
var Phosphate = function (_BaseMonomer) {
  _inherits__default["default"](Phosphate, _BaseMonomer);
  function Phosphate(monomerItem, _position) {
    _classCallCheck__default["default"](this, Phosphate);
    return _callSuper$19(this, Phosphate, [monomerItem, _position]);
  }
  _createClass__default["default"](Phosphate, [{
    key: "getValidSourcePoint",
    value: function getValidSourcePoint(secondMonomer) {
      return this.getValidPoint(secondMonomer, secondMonomer.potentialSecondAttachmentPointForBond);
    }
  }, {
    key: "getValidTargetPoint",
    value: function getValidTargetPoint(firstMonomer) {
      return this.getValidPoint(firstMonomer, firstMonomer.chosenFirstAttachmentPointForBond);
    }
  }, {
    key: "getValidPoint",
    value: function getValidPoint(otherMonomer, potentialPointOnOther) {
      if (this.chosenFirstAttachmentPointForBond) {
        return this.chosenFirstAttachmentPointForBond;
      }
      if (this.potentialSecondAttachmentPointForBond) {
        return this.potentialSecondAttachmentPointForBond;
      }
      if (this.unUsedAttachmentPointsNamesList.length === 1) {
        return this.unUsedAttachmentPointsNamesList[0];
      }
      if (!(otherMonomer instanceof Sugar)) {
        return;
      }
      if (potentialPointOnOther) {
        if (potentialPointOnOther === exports.AttachmentPointName.R2 && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1)) {
          return exports.AttachmentPointName.R1;
        } else if (potentialPointOnOther !== exports.AttachmentPointName.R2 && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
          return exports.AttachmentPointName.R2;
        } else {
          return;
        }
      }
      if (otherMonomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2) && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1)) {
        return exports.AttachmentPointName.R1;
      }
      if (!otherMonomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2) && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
        return exports.AttachmentPointName.R2;
      }
      return undefined;
    }
  }, {
    key: "isMonomerTypeDifferentForChaining",
    value: function isMonomerTypeDifferentForChaining(monomerToChain) {
      return ![PhosphateSubChain, RnaSubChain].includes(monomerToChain.SubChainConstructor);
    }
  }, {
    key: "SubChainConstructor",
    get: function get() {
      return PhosphateSubChain;
    }
  }, {
    key: "isPartOfRna",
    get: function get() {
      var _this$attachmentPoint, _previousMonomer$atta, _this$attachmentPoint2;
      var previousMonomer = (_this$attachmentPoint = this.attachmentPointsToBonds.R1) === null || _this$attachmentPoint === void 0 ? void 0 : _this$attachmentPoint.getAnotherMonomer(this);
      var isPreviousMonomerSugar = previousMonomer instanceof Sugar;
      var isSugarConnectedToBase = (previousMonomer === null || previousMonomer === void 0 || (_previousMonomer$atta = previousMonomer.attachmentPointsToBonds.R3) === null || _previousMonomer$atta === void 0 ? void 0 : _previousMonomer$atta.getAnotherMonomer(previousMonomer)) instanceof RNABase;
      var nextMonomer = (_this$attachmentPoint2 = this.attachmentPointsToBonds.R2) === null || _this$attachmentPoint2 === void 0 ? void 0 : _this$attachmentPoint2.getAnotherMonomer(this);
      var isNextMonomerRna = nextMonomer === null || nextMonomer === void 0 ? void 0 : nextMonomer.isPartOfRna;
      return isPreviousMonomerSugar && isSugarConnectedToBase && isNextMonomerRna;
    }
  }]);
  return Phosphate;
}(BaseMonomer);

function _callSuper$18(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$18() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$18() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$18 = function _isNativeReflectConstruct() { return !!t; })(); }
var Sugar = function (_BaseMonomer) {
  _inherits__default["default"](Sugar, _BaseMonomer);
  function Sugar() {
    _classCallCheck__default["default"](this, Sugar);
    return _callSuper$18(this, Sugar, arguments);
  }
  _createClass__default["default"](Sugar, [{
    key: "getValidSourcePoint",
    value: function getValidSourcePoint(secondMonomer) {
      return this.getValidPoint(secondMonomer, secondMonomer.potentialSecondAttachmentPointForBond);
    }
  }, {
    key: "getValidTargetPoint",
    value: function getValidTargetPoint(firstMonomer) {
      return this.getValidPoint(firstMonomer, firstMonomer.chosenFirstAttachmentPointForBond);
    }
  }, {
    key: "getValidPoint",
    value: function getValidPoint(otherMonomer, potentialPointOnOther) {
      if (this.chosenFirstAttachmentPointForBond) {
        return this.chosenFirstAttachmentPointForBond;
      }
      if (this.potentialSecondAttachmentPointForBond) {
        return this.potentialSecondAttachmentPointForBond;
      }
      if (this.unUsedAttachmentPointsNamesList.length === 1) {
        return this.unUsedAttachmentPointsNamesList[0];
      }
      if (!(otherMonomer instanceof Phosphate) && !(otherMonomer instanceof RNABase)) {
        return;
      }
      if (otherMonomer instanceof RNABase) {
        if (this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R3)) {
          return exports.AttachmentPointName.R3;
        } else return;
      }
      if (potentialPointOnOther) {
        if (potentialPointOnOther === exports.AttachmentPointName.R1 && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
          return exports.AttachmentPointName.R2;
        } else if (potentialPointOnOther !== exports.AttachmentPointName.R1 && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1)) {
          return exports.AttachmentPointName.R1;
        } else {
          return;
        }
      }
      if (otherMonomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1) && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2)) {
        return exports.AttachmentPointName.R2;
      }
      if (otherMonomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R2) && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1)) {
        return exports.AttachmentPointName.R1;
      }
      if (!otherMonomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1) && this.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1)) {
        return exports.AttachmentPointName.R1;
      }
      return undefined;
    }
  }, {
    key: "SubChainConstructor",
    get: function get() {
      return RnaSubChain;
    }
  }, {
    key: "isMonomerTypeDifferentForChaining",
    value: function isMonomerTypeDifferentForChaining(monomerToChain) {
      return ![PhosphateSubChain, RnaSubChain].includes(monomerToChain.SubChainConstructor);
    }
  }, {
    key: "isPartOfRna",
    get: function get() {
      var _this$attachmentPoint;
      return ((_this$attachmentPoint = this.attachmentPointsToBonds.R3) === null || _this$attachmentPoint === void 0 ? void 0 : _this$attachmentPoint.getAnotherMonomer(this)) instanceof RNABase;
    }
  }]);
  return Sugar;
}(BaseMonomer);

exports.Axis = void 0;
(function (Axis) {
  Axis["x"] = "x";
  Axis["y"] = "y";
  Axis["z"] = "z";
})(exports.Axis || (exports.Axis = {}));

function getMonomerUniqueKey(monomer) {
  return "".concat(monomer.props.MonomerName, "___").concat(monomer.props.Name);
}
function checkIsR2R1Connection(monomer, nextMonomer) {
  var _nextMonomer$attachme;
  return ((_nextMonomer$attachme = nextMonomer.attachmentPointsToBonds.R1) === null || _nextMonomer$attachme === void 0 ? void 0 : _nextMonomer$attachme.getAnotherMonomer(nextMonomer)) === monomer;
}
function getNextMonomerInChain(monomer, firstMonomer) {
  if (!monomer) return undefined;
  var r2PolymerBond = monomer.attachmentPointsToBonds.R2;
  var nextMonomer = r2PolymerBond === null || r2PolymerBond === void 0 ? void 0 : r2PolymerBond.getAnotherMonomer(monomer);
  if (nextMonomer === firstMonomer && r2PolymerBond) return undefined;
  return r2PolymerBond && (nextMonomer === null || nextMonomer === void 0 ? void 0 : nextMonomer.getAttachmentPointByBond(r2PolymerBond)) === exports.AttachmentPointName.R1 ? nextMonomer : undefined;
}
function getRnaBaseFromSugar(monomer) {
  if (!monomer) return undefined;
  var r3PolymerBond = monomer.attachmentPointsToBonds.R3;
  var r3ConnectedMonomer = r3PolymerBond === null || r3PolymerBond === void 0 ? void 0 : r3PolymerBond.getAnotherMonomer(monomer);
  return r3ConnectedMonomer instanceof RNABase ? r3ConnectedMonomer : undefined;
}
function getSugarFromRnaBase(monomer) {
  if (!monomer) return undefined;
  var r1PolymerBond = monomer.attachmentPointsToBonds.R1;
  var r1ConnectedMonomer = r1PolymerBond === null || r1PolymerBond === void 0 ? void 0 : r1PolymerBond.getAnotherMonomer(monomer);
  return r1ConnectedMonomer instanceof Sugar ? r1ConnectedMonomer : undefined;
}
function getPhosphateFromSugar(monomer) {
  if (!monomer) return undefined;
  var nextMonomerInChain = getNextMonomerInChain(monomer);
  return nextMonomerInChain instanceof Phosphate ? nextMonomerInChain : undefined;
}
function isMonomerBeginningOfChain(monomer, MonomerTypes) {
  var r1PolymerBond = monomer.attachmentPointsToBonds.R1;
  var previousMonomer = r1PolymerBond === null || r1PolymerBond === void 0 ? void 0 : r1PolymerBond.getAnotherMonomer(monomer);
  var isPreviousMonomerPartOfChain = previousMonomer && !MonomerTypes.some(function (MonomerType) {
    return previousMonomer instanceof MonomerType;
  });
  var previousConnectionNotR2 = r1PolymerBond && (previousMonomer === null || previousMonomer === void 0 ? void 0 : previousMonomer.getAttachmentPointByBond(r1PolymerBond)) !== 'R2';
  return (monomer.isAttachmentPointExistAndFree(exports.AttachmentPointName.R1) || !monomer.hasAttachmentPoint(exports.AttachmentPointName.R1)) && monomer.hasBonds || previousConnectionNotR2 || isPreviousMonomerPartOfChain;
}
function isValidNucleotide(sugar) {
  var phosphate = getPhosphateFromSugar(sugar);
  var nextMonomerAfterPhosphate = getNextMonomerInChain(phosphate);
  return Boolean(getRnaBaseFromSugar(sugar) && getPhosphateFromSugar(sugar) && nextMonomerAfterPhosphate instanceof Sugar && getRnaBaseFromSugar(nextMonomerAfterPhosphate));
}
function isValidNucleoside(sugar) {
  var phosphate = getPhosphateFromSugar(sugar);
  var nextMonomerAfterPhosphate = getNextMonomerInChain(phosphate);
  return getRnaBaseFromSugar(sugar) && (!phosphate || !(nextMonomerAfterPhosphate instanceof Sugar && getRnaBaseFromSugar(nextMonomerAfterPhosphate)));
}

function Handler(f, once, priority) {
  this.f = f;
  this.once = once;
  this.priority = priority;
}

function Subscription() {
  this.handlers = [];
}
var Subscription_1 = Subscription;

function insert(s, handler) {
  var pos = 0;
  for (; pos < s.handlers.length; pos++)
    if (s.handlers[pos].priority < handler.priority) break
  s.handlers = s.handlers.slice(0, pos).concat(handler).concat(s.handlers.slice(pos));
}

Subscription.prototype.handlersForDispatch = function() {
  var handlers = this.handlers, updated = null;
  for (var i = handlers.length - 1; i >= 0; i--) if (handlers[i].once) {
    if (!updated) updated = handlers.slice();
    updated.splice(i, 1);
  }
  if (updated) this.handlers = updated;
  return handlers
};

Subscription.prototype.add = function(f, priority) {
  insert(this, new Handler(f, false, priority || 0));
};

Subscription.prototype.addOnce = function(f, priority) {
  insert(this, new Handler(f, true, priority || 0));
};

Subscription.prototype.remove = function(f) {
  for (var i = 0; i < this.handlers.length; i++) if (this.handlers[i].f == f) {
    this.handlers = this.handlers.slice(0, i).concat(this.handlers.slice(i + 1));
    return
  }
};

Subscription.prototype.hasHandler = function() {
  return this.handlers.length > 0
};

Subscription.prototype.dispatch = function() {
  var handlers = this.handlersForDispatch();
  for (var i = 0; i < handlers.length; i++)
    handlers[i].f.apply(null, arguments);
};

function PipelineSubscription() {
  Subscription.call(this);
}

PipelineSubscription.prototype = new Subscription;

PipelineSubscription.prototype.dispatch = function(value) {
  var handlers = this.handlersForDispatch();
  for (var i = 0; i < handlers.length; i++)
    value = handlers[i].f(value);
  return value
};

function StoppableSubscription() {
  Subscription.call(this);
}

StoppableSubscription.prototype = new Subscription;

StoppableSubscription.prototype.dispatch = function() {
  var handlers = this.handlersForDispatch();
  for (var i = 0; i < handlers.length; i++) {
    var result = handlers[i].f.apply(null, arguments);
    if (result) return result
  }
};

function DOMSubscription() {
  Subscription.call(this);
}
var DOMSubscription_1 = DOMSubscription;

DOMSubscription.prototype = new Subscription;

DOMSubscription.prototype.dispatch = function(event) {
  var handlers = this.handlersForDispatch();
  for (var i = 0; i < handlers.length; i++)
    if (handlers[i].f(event) || event.defaultPrevented) return true
  return false
};

function isBaseTool(tool) {
  return (tool === null || tool === void 0 ? void 0 : tool.destroy) !== undefined;
}

exports.editorEvents = void 0;
function resetEditorEvents() {
  exports.editorEvents = {
    selectMonomer: new Subscription_1(),
    selectPreset: new Subscription_1(),
    selectTool: new Subscription_1(),
    createBondViaModal: new Subscription_1(),
    cancelBondCreationViaModal: new Subscription_1(),
    selectMode: new Subscription_1(),
    layoutModeChange: new Subscription_1(),
    selectHistory: new Subscription_1(),
    error: new Subscription_1(),
    openMonomerConnectionModal: new Subscription_1(),
    mouseOverPolymerBond: new Subscription_1(),
    mouseLeavePolymerBond: new Subscription_1(),
    mouseOverMonomer: new Subscription_1(),
    mouseOnMoveMonomer: new Subscription_1(),
    mouseLeaveMonomer: new Subscription_1(),
    mouseOverAttachmentPoint: new Subscription_1(),
    mouseLeaveAttachmentPoint: new Subscription_1(),
    mouseUpAttachmentPoint: new Subscription_1(),
    mouseDownAttachmentPoint: new Subscription_1(),
    mouseOverDrawingEntity: new Subscription_1(),
    mouseLeaveDrawingEntity: new Subscription_1(),
    mouseUpMonomer: new Subscription_1(),
    rightClickSequence: new Subscription_1(),
    rightClickCanvas: new Subscription_1(),
    editSequence: new Subscription_1(),
    startNewSequence: new Subscription_1(),
    mouseOverSequenceItem: new Subscription_1(),
    mouseOnMoveSequenceItem: new Subscription_1(),
    mouseLeaveSequenceItem: new Subscription_1(),
    changeSequenceTypeEnterMode: new Subscription_1(),
    toggleSequenceEditMode: new Subscription_1()
  };
}
resetEditorEvents();
var renderersEvents = ['mouseOverPolymerBond', 'mouseLeavePolymerBond', 'mouseOverMonomer', 'mouseOnMoveMonomer', 'mouseOverAttachmentPoint', 'mouseLeaveAttachmentPoint', 'mouseUpAttachmentPoint', 'mouseDownAttachmentPoint', 'mouseLeaveMonomer', 'mouseOverDrawingEntity', 'mouseLeaveDrawingEntity', 'mouseUpMonomer', 'rightClickSequence', 'rightClickCanvas', 'editSequence', 'startNewSequence', 'mouseOverSequenceItem', 'mouseOnMoveSequenceItem', 'mouseLeaveSequenceItem', 'changeSequenceTypeEnterMode', 'toggleSequenceEditMode'];
var hotkeysConfiguration = {
  exit: {
    shortcut: ['Shift+Tab', 'Escape'],
    handler: function handler(editor) {
      editor.events.selectTool.dispatch('select-rectangle');
    }
  },
  undo: {
    shortcut: 'Mod+z',
    handler: function handler(editor) {
      editor.onSelectHistory('undo');
    }
  },
  redo: {
    shortcut: ['Mod+Shift+z', 'Mod+y'],
    handler: function handler(editor) {
      editor.onSelectHistory('redo');
    }
  },
  erase: {
    shortcut: ['Delete', 'Backspace'],
    handler: function handler(editor) {
      if (editor.isSequenceEditMode) return;
      editor.events.selectTool.dispatch('erase');
      editor.events.selectTool.dispatch('select-rectangle');
    }
  },
  clear: {
    shortcut: ['Mod+Delete', 'Mod+Backspace'],
    handler: function handler(editor) {
      editor.events.selectTool.dispatch('clear');
      editor.events.selectTool.dispatch('select-rectangle');
    }
  },
  'zoom-plus': {
    shortcut: 'Mod+=',
    handler: function handler() {
      ZoomTool.instance.zoomIn();
    }
  },
  'zoom-minus': {
    shortcut: 'Mod+-',
    handler: function handler() {
      ZoomTool.instance.zoomOut();
    }
  },
  'zoom-reset': {
    shortcut: 'Mod+0',
    handler: function handler() {
      ZoomTool.instance.resetZoom();
    }
  },
  'select-all': {
    shortcut: 'Mod+a',
    handler: function handler(editor) {
      var modelChanges = editor.drawingEntitiesManager.selectAllDrawingEntities();
      editor.renderersContainer.update(modelChanges);
    }
  }
};

var _AttachmentPoint;
var AttachmentPoint = function () {
  function AttachmentPoint(constructorParams) {
    var _constructorParams$ca, _constructorParams$mo;
    _classCallCheck__default["default"](this, AttachmentPoint);
    _defineProperty__default["default"](this, "initialAngle", 0);
    this.rootElement = constructorParams.rootElement;
    this.monomer = constructorParams.monomer;
    this.bodyWidth = constructorParams.bodyWidth;
    this.bodyHeight = constructorParams.bodyHeight;
    this.canvasOffset = ((_constructorParams$ca = constructorParams.canvas.node()) === null || _constructorParams$ca === void 0 ? void 0 : _constructorParams$ca.getBoundingClientRect()) || new DOMRect(0, 0, 0, 0);
    this.attachmentPointName = constructorParams.attachmentPointName;
    this.centerOfMonomer = ((_constructorParams$mo = constructorParams.monomer.renderer) === null || _constructorParams$mo === void 0 ? void 0 : _constructorParams$mo.center) || new Vec2(0, 0, 0);
    this.isSnake = constructorParams.isSnake;
    this.isUsed = constructorParams.isUsed;
    this.initialAngle = constructorParams.angle;
    this.editorEvents = exports.editorEvents;
    this.attachmentPoint = null;
    if (constructorParams.isPotentiallyUsed) {
      this.fill = AttachmentPoint.colors.fillPotentially;
      this.stroke = AttachmentPoint.colors.strokePotentially;
    } else if (constructorParams.isUsed) {
      this.fill = AttachmentPoint.colors.fillUsed;
      this.stroke = AttachmentPoint.colors.strokeUsed;
    } else {
      this.fill = AttachmentPoint.colors.fill;
      this.stroke = AttachmentPoint.colors.stroke;
    }
    this.appendAttachmentPoint();
  }
  _createClass__default["default"](AttachmentPoint, [{
    key: "removeAttachmentPoint",
    value: function removeAttachmentPoint() {
      var _this = this;
      var remove = function remove() {
        var _this$element;
        (_this$element = _this.element) === null || _this$element === void 0 || _this$element.remove();
      };
      setTimeout(remove, 1);
    }
  }, {
    key: "renderAttachmentPointByCoordinates",
    value: function renderAttachmentPointByCoordinates(attachmentOnBorder, attachmentPointCoordinates, labelCoordinatesOnMonomer) {
      var fill = this.fill;
      var stroke = this.stroke;
      this.attachmentPoint = this.rootElement.insert('g', ':first-child');
      var attachmentPointElement = this.attachmentPoint.append('g');
      attachmentPointElement.append('line').attr('x1', attachmentOnBorder.x).attr('y1', attachmentOnBorder.y).attr('x2', attachmentPointCoordinates.x).attr('y2', attachmentPointCoordinates.y).attr('stroke', stroke).attr('stroke-linecap', 'round').attr('stroke-width', '1px');
      attachmentPointElement.append('circle').attr('r', AttachmentPoint.radius).attr('cx', attachmentPointCoordinates.x).attr('cy', attachmentPointCoordinates.y).attr('stroke', fill === 'white' ? '#0097A8' : 'white').attr('stroke-width', '1px').attr('fill', fill);
      var labelGroup = this.attachmentPoint.append('text');
      labelGroup.text(this.attachmentPointName).attr('x', labelCoordinatesOnMonomer.x).attr('y', labelCoordinatesOnMonomer.y).style('font-size', '6px').style('fill', '#585858').style('user-select', 'none');
      return this.attachmentPoint;
    }
  }, {
    key: "renderHoverableArea",
    value: function renderHoverableArea(monomerCenter, attachmentPointCenter, angleDegrees) {
      var _this2 = this;
      if (!this.element) {
        return;
      }
      var rotation = angleDegrees + 90;
      var halfWidth = 20;
      var areaHeight = Math.sqrt(Math.pow(monomerCenter.x - attachmentPointCenter.x, 2) + Math.pow(monomerCenter.y - attachmentPointCenter.y, 2));
      var points = [{
        x: -AttachmentPoint.radius,
        y: AttachmentPoint.radius
      }, {
        x: AttachmentPoint.radius,
        y: AttachmentPoint.radius
      }, {
        x: halfWidth,
        y: -areaHeight + 10
      }, {
        x: -halfWidth,
        y: -areaHeight + 10
      }, {
        x: -AttachmentPoint.radius,
        y: AttachmentPoint.radius
      }];
      var lineFunction = d3.line().x(function (_ref) {
        var x = _ref.x;
        return x;
      }).y(function (_ref2) {
        var y = _ref2.y;
        return y;
      });
      var hoverableAreaElement = this.element.append('g');
      hoverableAreaElement.append('path').attr('d', lineFunction(points) + 'z').attr('stroke', 'black').attr('stroke-width', '1px').attr('fill', '#0097A8').style('opacity', '0').attr('transform', "translate(".concat(attachmentPointCenter.x, ",").concat(attachmentPointCenter.y, ")rotate(").concat(rotation, ")"));
      hoverableAreaElement.on('mouseover', function (event) {
        event.attachmentPointName = _this2.attachmentPointName;
        _this2.editorEvents.mouseOverAttachmentPoint.dispatch(event);
      }).on('mouseleave', function (event) {
        _this2.editorEvents.mouseLeaveAttachmentPoint.dispatch(event);
      }).on('mousedown', function (event) {
        event.attachmentPointName = _this2.attachmentPointName;
        _this2.editorEvents.mouseDownAttachmentPoint.dispatch(event);
      }).on('mouseup', function (event) {
        event.attachmentPointName = _this2.attachmentPointName;
        _this2.editorEvents.mouseUpAttachmentPoint.dispatch(event);
      });
      return hoverableAreaElement;
    }
  }, {
    key: "appendAttachmentPoint",
    value: function appendAttachmentPoint() {
      var _this$monomer$attachm, _this$monomer$attachm2;
      var angleDegrees;
      var angleRadians;
      var flip = this.monomer.id === ((_this$monomer$attachm = this.monomer.attachmentPointsToBonds[this.attachmentPointName]) === null || _this$monomer$attachm === void 0 || (_this$monomer$attachm = _this$monomer$attachm.firstMonomer) === null || _this$monomer$attachm === void 0 ? void 0 : _this$monomer$attachm.id);
      var isAttachmentpointR1 = this.attachmentPointName === 'R1';
      if (!this.isUsed) {
        angleDegrees = this.initialAngle;
      } else if (this.isSnake && !((_this$monomer$attachm2 = this.monomer.attachmentPointsToBonds[this.attachmentPointName]) !== null && _this$monomer$attachm2 !== void 0 && _this$monomer$attachm2.renderer.isMonomersOnSameHorizontalLine())) {
        angleRadians = isAttachmentpointR1 ? 0 : Math.PI;
        angleDegrees = Vec2.radiansToDegrees(angleRadians);
      } else {
        angleRadians = this.rotateToAngle(this.monomer.attachmentPointsToBonds[this.attachmentPointName], flip);
        angleDegrees = Vec2.radiansToDegrees(angleRadians);
      }
      var _this$getCoordinates = this.getCoordinates(angleDegrees),
        _this$getCoordinates2 = _slicedToArray__default["default"](_this$getCoordinates, 3),
        attachmentToBorderCoordinates = _this$getCoordinates2[0],
        attachmentPointCoordinates = _this$getCoordinates2[1],
        labelCoordinates = _this$getCoordinates2[2];
      var attachmentToCenterCoordinates = canvasToMonomerCoordinates(this.centerOfMonomer, this.centerOfMonomer, this.bodyWidth, this.bodyHeight);
      var attachmentPoint = this.renderAttachmentPointByCoordinates(attachmentToBorderCoordinates, attachmentPointCoordinates, labelCoordinates);
      this.element = attachmentPoint;
      var hoverableArea = this.renderHoverableArea(attachmentToCenterCoordinates, attachmentPointCoordinates, angleDegrees);
      this.hoverableArea = hoverableArea;
      return attachmentPoint;
    }
  }, {
    key: "updateAttachmentPointStyleForHover",
    value: function updateAttachmentPointStyleForHover() {
      var isAttachmentPointUsed = this.monomer.isAttachmentPointUsed(this.attachmentPointName);
      if (isAttachmentPointUsed) {
        var _this$attachmentPoint, _this$attachmentPoint2;
        (_this$attachmentPoint = this.attachmentPoint) === null || _this$attachmentPoint === void 0 || _this$attachmentPoint.select('line').style('stroke', AttachmentPoint.colors.fillUsed);
        (_this$attachmentPoint2 = this.attachmentPoint) === null || _this$attachmentPoint2 === void 0 || _this$attachmentPoint2.select('circle').style('fill', AttachmentPoint.colors.fillUsed).attr('stroke', 'white');
      }
    }
  }, {
    key: "rotateToAngle",
    value: function rotateToAngle(polymerBond) {
      var flip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var angleRadians = 0;
      if (flip) {
        angleRadians = Vec2.oxAngleForVector(polymerBond.endPosition, polymerBond.position);
      } else {
        angleRadians = Vec2.oxAngleForVector(polymerBond.position, polymerBond.endPosition);
      }
      return angleRadians;
    }
  }, {
    key: "getCoordinates",
    value: function getCoordinates(angleDegrees) {
      var _this$catchThePoint = this.catchThePoint(angleDegrees),
        _this$catchThePoint2 = _slicedToArray__default["default"](_this$catchThePoint, 3),
        pointOnBorder = _this$catchThePoint2[0],
        pointOfAttachment = _this$catchThePoint2[1],
        labelPoint = _this$catchThePoint2[2];
      var attachmentToBorderCoordinates = canvasToMonomerCoordinates(pointOnBorder, this.centerOfMonomer, this.bodyWidth, this.bodyHeight);
      var attachmentPointCoordinates = canvasToMonomerCoordinates(pointOfAttachment, this.centerOfMonomer, this.bodyWidth, this.bodyHeight);
      var labelCoordinates = canvasToMonomerCoordinates(labelPoint, this.centerOfMonomer, this.bodyWidth, this.bodyHeight);
      return [attachmentToBorderCoordinates, attachmentPointCoordinates, labelCoordinates];
    }
  }, {
    key: "updateCoords",
    value: function updateCoords() {
      var _this$monomer$attachm3, _this$attachmentPoint3, _this$attachmentPoint4, _this$attachmentPoint5;
      var flip = this.monomer.id === ((_this$monomer$attachm3 = this.monomer.attachmentPointsToBonds[this.attachmentPointName]) === null || _this$monomer$attachm3 === void 0 || (_this$monomer$attachm3 = _this$monomer$attachm3.firstMonomer) === null || _this$monomer$attachm3 === void 0 ? void 0 : _this$monomer$attachm3.id);
      var angleRadians = this.rotateToAngle(this.monomer.attachmentPointsToBonds[this.attachmentPointName], flip);
      var angleDegrees = Vec2.radiansToDegrees(angleRadians);
      var _this$getCoordinates3 = this.getCoordinates(angleDegrees),
        _this$getCoordinates4 = _slicedToArray__default["default"](_this$getCoordinates3, 3),
        attachmentToBorderCoordinates = _this$getCoordinates4[0],
        attachmentPointCoordinates = _this$getCoordinates4[1],
        labelCoordinates = _this$getCoordinates4[2];
      (_this$attachmentPoint3 = this.attachmentPoint) === null || _this$attachmentPoint3 === void 0 || _this$attachmentPoint3.select('line').attr('x1', attachmentToBorderCoordinates.x).attr('y1', attachmentToBorderCoordinates.y).attr('x2', attachmentPointCoordinates.x).attr('y2', attachmentPointCoordinates.y);
      (_this$attachmentPoint4 = this.attachmentPoint) === null || _this$attachmentPoint4 === void 0 || _this$attachmentPoint4.select('circle').attr('cx', attachmentPointCoordinates.x).attr('cy', attachmentPointCoordinates.y).attr('stroke', 'white').attr('fill', AttachmentPoint.colors.fillPotentially);
      (_this$attachmentPoint5 = this.attachmentPoint) === null || _this$attachmentPoint5 === void 0 || _this$attachmentPoint5.select('text').attr('x', labelCoordinates.x).attr('y', labelCoordinates.y);
    }
  }, {
    key: "catchThePoint",
    value: function catchThePoint(rotationAngle) {
      assert__default["default"](this.monomer.renderer);
      var currentMonomerCenter = {
        x: this.monomer.renderer.center.x,
        y: this.monomer.renderer.center.y
      };
      this.initialAngle = rotationAngle;
      var findPointOnMonomerBorder = getSearchFunction(this.initialAngle - 180, this.canvasOffset, this.monomer);
      var pointOnBorder = findPointOnMonomerBorder(currentMonomerCenter, (this.bodyWidth + this.bodyHeight) / 2);
      var _findLabelPoint = findLabelPoint(pointOnBorder, this.initialAngle - 180, AttachmentPoint.attachmentPointLength, AttachmentPoint.labelOffset, AttachmentPoint.labelSize, this.isUsed),
        _findLabelPoint2 = _slicedToArray__default["default"](_findLabelPoint, 2),
        labelPoint = _findLabelPoint2[0],
        pointOfAttachment = _findLabelPoint2[1];
      return [pointOnBorder, pointOfAttachment, labelPoint];
    }
  }, {
    key: "getElement",
    value: function getElement() {
      return this.element;
    }
  }, {
    key: "getAttachmentPointName",
    value: function getAttachmentPointName() {
      return this.attachmentPointName;
    }
  }, {
    key: "getHoverableArea",
    value: function getHoverableArea() {
      return this.hoverableArea;
    }
  }, {
    key: "getAngle",
    value: function getAngle() {
      if (this.initialAngle < 0 && this.isUsed) {
        return this.initialAngle + 360;
      }
      return this.initialAngle;
    }
  }]);
  return AttachmentPoint;
}();
_AttachmentPoint = AttachmentPoint;
_defineProperty__default["default"](AttachmentPoint, "attachmentPointVector", 6);
_defineProperty__default["default"](AttachmentPoint, "attachmentPointLength", Math.hypot(_AttachmentPoint.attachmentPointVector, _AttachmentPoint.attachmentPointVector));
_defineProperty__default["default"](AttachmentPoint, "labelOffset", 3.5);
_defineProperty__default["default"](AttachmentPoint, "radius", 3);
_defineProperty__default["default"](AttachmentPoint, "labelSize", {
  x: 3.5,
  y: 2.5
});
_defineProperty__default["default"](AttachmentPoint, "colors", {
  fillUsed: '#0097A8',
  fill: 'white',
  fillPotentially: '#167782',
  strokeUsed: '#0097A8',
  stroke: '#167782',
  strokePotentially: '#167782'
});

function _callSuper$17(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$17() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$17() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$17 = function _isNativeReflectConstruct() { return !!t; })(); }
var labelPositions = {};
var BaseMonomerRenderer = function (_BaseRenderer) {
  _inherits__default["default"](BaseMonomerRenderer, _BaseRenderer);
  function BaseMonomerRenderer(monomer, monomerSelectedElementId, monomerHoveredElementId, monomerSymbolElementId, scale) {
    var _this$monomerSymbolEl, _this$monomerSymbolEl2;
    var _this;
    _classCallCheck__default["default"](this, BaseMonomerRenderer);
    _this = _callSuper$17(this, BaseMonomerRenderer, [monomer]);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "freeSectorsList", sectorsList);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "attachmentPoints", []);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "hoveredAttachmenPoint", null);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "enumeration", null);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "beginning", null);
    _this.monomer = monomer;
    _this.monomerSelectedElementId = monomerSelectedElementId;
    _this.monomerHoveredElementId = monomerHoveredElementId;
    _this.scale = scale;
    _this.monomer.setRenderer(_assertThisInitialized__default["default"](_this));
    _this.editorEvents = exports.editorEvents;
    _this.monomerSymbolElement = document.querySelector("".concat(monomerSymbolElementId, " .monomer-body"));
    _this.monomerSize = {
      width: +(((_this$monomerSymbolEl = _this.monomerSymbolElement) === null || _this$monomerSymbolEl === void 0 ? void 0 : _this$monomerSymbolEl.getAttribute('data-actual-width')) || 0),
      height: +(((_this$monomerSymbolEl2 = _this.monomerSymbolElement) === null || _this$monomerSymbolEl2 === void 0 ? void 0 : _this$monomerSymbolEl2.getAttribute('data-actual-height')) || 0)
    };
    return _this;
  }
  _createClass__default["default"](BaseMonomerRenderer, [{
    key: "isSnakeBondForAttachmentPoint",
    value: function isSnakeBondForAttachmentPoint(attachmentPointName) {
      var _this$monomer$attachm, _this$monomer$attachm2;
      return ((_this$monomer$attachm = this.monomer.attachmentPointsToBonds[attachmentPointName]) === null || _this$monomer$attachm === void 0 || (_this$monomer$attachm = _this$monomer$attachm.renderer) === null || _this$monomer$attachm === void 0 ? void 0 : _this$monomer$attachm.isSnake) && !((_this$monomer$attachm2 = this.monomer.attachmentPointsToBonds[attachmentPointName]) !== null && _this$monomer$attachm2 !== void 0 && (_this$monomer$attachm2 = _this$monomer$attachm2.renderer) !== null && _this$monomer$attachm2 !== void 0 && _this$monomer$attachm2.isMonomersOnSameHorizontalLine());
    }
  }, {
    key: "center",
    get: function get() {
      return new Vec2(this.scaledMonomerPosition.x + this.monomerSize.width / 2, this.scaledMonomerPosition.y + this.monomerSize.height / 2);
    }
  }, {
    key: "textColor",
    get: function get() {
      var WHITE = 'white';
      var colorsMap = {
        D: WHITE,
        F: WHITE,
        K: WHITE,
        Q: WHITE,
        R: WHITE,
        W: WHITE,
        Y: WHITE
      };
      return colorsMap[this.monomer.monomerItem.props.MonomerNaturalAnalogCode] || 'black';
    }
  }, {
    key: "getMonomerColor",
    value: function getMonomerColor(theme) {
      var _theme$monomer$color$;
      return ((_theme$monomer$color$ = theme.monomer.color[this.monomer.monomerItem.props.MonomerNaturalAnalogCode]) === null || _theme$monomer$color$ === void 0 ? void 0 : _theme$monomer$color$.regular) || theme.monomer.color["default"].regular;
    }
  }, {
    key: "redrawAttachmentPoints",
    value: function redrawAttachmentPoints() {
      this.hoveredAttachmenPoint = null;
      if (!this.rootElement) return;
      if (this.monomer.attachmentPointsVisible) {
        this.removeAttachmentPoints();
        this.drawAttachmentPoints();
      } else {
        this.removeAttachmentPoints();
      }
    }
  }, {
    key: "updateAttachmentPoints",
    value: function updateAttachmentPoints() {
      this.hoveredAttachmenPoint = null;
      if (!this.rootElement) return;
      if (this.attachmentPoints.length > 0) {
        this.attachmentPoints.forEach(function (point) {
          point.updateAttachmentPointStyleForHover();
        });
      } else {
        this.drawAttachmentPoints();
      }
    }
  }, {
    key: "redrawAttachmentPointsCoordinates",
    value: function redrawAttachmentPointsCoordinates() {
      var chosenAttachmentPointName = this.monomer.chosenFirstAttachmentPointForBond;
      var chosenAttachmentPoint = this.attachmentPoints.find(function (item) {
        return item.getAttachmentPointName() === chosenAttachmentPointName;
      });
      var angle = chosenAttachmentPoint === null || chosenAttachmentPoint === void 0 ? void 0 : chosenAttachmentPoint.getAngle();
      var allAngles = this.attachmentPoints.map(function (item) {
        return item.getAngle();
      });
      var isSectorOccupied = allAngles.some(function (item) {
        if (angle !== item && typeof angle === 'number') {
          return Math.abs(angle - item) < 20 || Math.abs(angle - item) > 340;
        }
        return false;
      });
      if (isSectorOccupied) {
        this.redrawAttachmentPoints();
        return;
      }
      var attachmentPoint = this.attachmentPoints.find(function (item) {
        return item.getAttachmentPointName() === chosenAttachmentPointName;
      });
      assert__default["default"](attachmentPoint);
      attachmentPoint.updateCoords();
    }
  }, {
    key: "drawAttachmentPoints",
    value: function drawAttachmentPoints() {
      var _this2 = this;
      if (this.attachmentPoints.length) {
        return;
      }
      this.monomer.usedAttachmentPointsNamesList.forEach(function (item) {
        var attachmentPoint = _this2.appendAttachmentPoint(item);
        var angle = attachmentPoint.getAngle();
        _this2.attachmentPoints.push(attachmentPoint);
        if (typeof angle === 'number') {
          var newList = _this2.freeSectorsList.filter(function (item) {
            return anglesToSector[item].min > angle || anglesToSector[item].max <= angle;
          });
          _this2.freeSectorsList = checkFor0and360(newList);
        }
      });
      var unrenderedAtPoints = [];
      this.monomer.unUsedAttachmentPointsNamesList.forEach(function (item) {
        var properAngleForFreeAttachmentPoint = attachmentPointNumberToAngle[item];
        if (_this2.freeSectorsList.includes(properAngleForFreeAttachmentPoint)) {
          var attachmentPoint = _this2.appendAttachmentPoint(item, properAngleForFreeAttachmentPoint);
          _this2.attachmentPoints.push(attachmentPoint);
          var newList = _this2.freeSectorsList.filter(function (item) {
            return item !== properAngleForFreeAttachmentPoint;
          });
          _this2.freeSectorsList = checkFor0and360(newList);
        } else {
          unrenderedAtPoints.push(item);
        }
      });
      unrenderedAtPoints.forEach(function (item) {
        var customAngle = _this2.freeSectorsList.shift();
        var attachmentPoint = _this2.appendAttachmentPoint(item, customAngle);
        _this2.attachmentPoints.push(attachmentPoint);
      });
    }
  }, {
    key: "appendAttachmentPoint",
    value: function appendAttachmentPoint(attachmentPointName, customAngle) {
      var rotation;
      if (!this.monomer.isAttachmentPointUsed(attachmentPointName)) {
        rotation = attachmentPointNumberToAngle[attachmentPointName];
      }
      var attachmentPointParams = {
        rootElement: this.rootElement,
        monomer: this.monomer,
        bodyWidth: this.monomerSize.width,
        bodyHeight: this.monomerSize.height,
        canvas: this.canvasWrapper,
        attachmentPointName: attachmentPointName,
        isUsed: this.monomer.isAttachmentPointUsed(attachmentPointName),
        isPotentiallyUsed: this.monomer.isAttachmentPointPotentiallyUsed(attachmentPointName) || this.hoveredAttachmenPoint === attachmentPointName,
        angle: customAngle || rotation,
        isSnake: !!this.isSnakeBondForAttachmentPoint(attachmentPointName)
      };
      var attPointInstance = new AttachmentPoint(attachmentPointParams);
      return attPointInstance;
    }
  }, {
    key: "removeAttachmentPoints",
    value: function removeAttachmentPoints() {
      this.attachmentPoints.forEach(function (item) {
        item.removeAttachmentPoint();
      });
      this.attachmentPoints = [];
      this.freeSectorsList = sectorsList;
    }
  }, {
    key: "hoverAttachmenPoint",
    value: function hoverAttachmenPoint(attachmentPointName) {
      this.hoveredAttachmenPoint = attachmentPointName;
    }
  }, {
    key: "appendRootElement",
    value: function appendRootElement(canvas) {
      return canvas.append('g').data([this]).attr('transition', 'transform 0.2s').attr('transform', "translate(".concat(this.scaledMonomerPosition.x, ", ").concat(this.scaledMonomerPosition.y, ") scale(").concat(this.scale || 1, ")"));
    }
  }, {
    key: "appendLabel",
    value: function appendLabel(rootElement) {
      var _labelPositions$monom, _labelPositions$monom2;
      var fontSize = 6;
      var textElement = rootElement.append('text').text(this.monomer.label).attr('fill', this.textColor).attr('font-size', "".concat(fontSize, "px")).attr('line-height', "".concat(fontSize, "px")).attr('font-weight', '700').style('cursor', 'pointer').style('user-select', 'none').attr('pointer-events', 'none');
      var monomerUniqueKey = this.monomer.label + this.monomer.monomerItem.props.MonomerType;
      if (!labelPositions[monomerUniqueKey]) {
        var textBBox = textElement.node().getBBox();
        labelPositions[monomerUniqueKey] = {
          x: this.width / 2 - textBBox.width / 2,
          y: this.height / 2
        };
      }
      textElement.attr('x', ((_labelPositions$monom = labelPositions[monomerUniqueKey]) === null || _labelPositions$monom === void 0 ? void 0 : _labelPositions$monom.x) || 0).attr('y', ((_labelPositions$monom2 = labelPositions[monomerUniqueKey]) === null || _labelPositions$monom2 === void 0 ? void 0 : _labelPositions$monom2.y) || 0);
      if (this.scale && this.scale !== 1) {
        labelPositions[monomerUniqueKey] = undefined;
      }
    }
  }, {
    key: "appendHover",
    value: function appendHover(hoverAreaElement) {
      if (this.hoverElement) this.hoverElement.remove();
      return hoverAreaElement.append('use').attr('href', this.monomerHoveredElementId).attr('pointer-events', 'none');
    }
  }, {
    key: "removeHover",
    value: function removeHover() {
      if (!this.hoverElement) return;
      this.hoverElement.remove();
    }
  }, {
    key: "scaledMonomerPosition",
    get: function get() {
      return BaseMonomerRenderer.getScaledMonomerPosition(this.monomer.position, this.monomerSize);
    }
  }, {
    key: "appendSelection",
    value: function appendSelection() {
      if (this.selectionCircle) {
        this.selectionCircle.attr('cx', this.center.x).attr('cy', this.center.y);
      } else {
        var _this$rootElement, _this$canvas;
        this.selectionBorder = (_this$rootElement = this.rootElement) === null || _this$rootElement === void 0 ? void 0 : _this$rootElement.append('use').attr('href', this.monomerSelectedElementId).attr('stroke', '#57FF8F').attr('pointer-events', 'none');
        this.selectionCircle = (_this$canvas = this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.insert('circle', ':first-child').attr('r', '21px').attr('opacity', '0.7').attr('cx', this.center.x).attr('cy', this.center.y).attr('fill', '#57FF8F');
      }
    }
  }, {
    key: "removeSelection",
    value: function removeSelection() {
      var _this$selectionCircle, _this$selectionBorder;
      (_this$selectionCircle = this.selectionCircle) === null || _this$selectionCircle === void 0 || _this$selectionCircle.remove();
      (_this$selectionBorder = this.selectionBorder) === null || _this$selectionBorder === void 0 || _this$selectionBorder.remove();
      this.selectionCircle = undefined;
      this.selectionBorder = undefined;
    }
  }, {
    key: "appendHoverAreaElement",
    value: function appendHoverAreaElement() {
      this.hoverAreaElement = this.rootElement;
    }
  }, {
    key: "appendEvents",
    value: function appendEvents() {
      var _this3 = this;
      assert__default["default"](this.bodyElement);
      this.bodyElement.on('mouseover', function (event) {
        _this3.editorEvents.mouseOverDrawingEntity.dispatch(event);
        _this3.editorEvents.mouseOverMonomer.dispatch(event);
      }).on('mousemove', function (event) {
        _this3.editorEvents.mouseOnMoveMonomer.dispatch(event);
      }).on('mouseleave', function (event) {
        _this3.editorEvents.mouseLeaveDrawingEntity.dispatch(event);
        _this3.editorEvents.mouseLeaveMonomer.dispatch(event);
      }).on('mouseup', function (event) {
        _this3.editorEvents.mouseUpMonomer.dispatch(event);
      });
    }
  }, {
    key: "setEnumeration",
    value: function setEnumeration(enumeration) {
      this.enumeration = enumeration;
    }
  }, {
    key: "appendEnumeration",
    value: function appendEnumeration() {
      assert__default["default"](this.rootElement);
      assert__default["default"](this.enumerationElementPosition);
      this.enumerationElement = this.rootElement.append('text').attr('direction', 'rtl').attr('fill', '#7C7C7F').attr('font-size', '6px').attr('line-height', '7px').attr('font-weight', '500').attr('text-align', 'right').attr('x', this.enumerationElementPosition.x).attr('y', this.enumerationElementPosition.y).text(this.enumeration);
    }
  }, {
    key: "redrawEnumeration",
    value: function redrawEnumeration() {
      assert__default["default"](this.enumerationElement);
      this.enumerationElement.text(this.enumeration);
    }
  }, {
    key: "setBeginning",
    value: function setBeginning(beginning) {
      this.beginning = beginning;
    }
  }, {
    key: "appendChainBeginning",
    value: function appendChainBeginning() {
      assert__default["default"](this.rootElement);
      assert__default["default"](this.beginningElementPosition);
      this.beginningElement = this.rootElement.append('text').attr('direction', 'rtl').attr('fill', '#0097A8').attr('font-size', '6px').attr('line-height', '7px').attr('font-weight', '700').attr('text-align', 'right').attr('x', this.beginningElementPosition.x).attr('y', this.beginningElementPosition.y).text(this.beginning);
    }
  }, {
    key: "reDrawChainBeginning",
    value: function reDrawChainBeginning() {
      assert__default["default"](this.beginningElement);
      assert__default["default"](this.beginningElementPosition);
      this.beginningElement.attr('x', this.beginningElementPosition.x).attr('y', this.beginningElementPosition.y).text(this.beginning);
    }
  }, {
    key: "show",
    value: function show(theme) {
      this.rootElement = this.rootElement || this.appendRootElement(this.scale ? this.canvasWrapper : this.canvas);
      this.bodyElement = this.appendBody(this.rootElement, theme);
      this.appendEvents();
      this.appendLabel(this.rootElement);
      this.appendHoverAreaElement();
      if (this.monomer.selected) {
        this.drawSelection();
      }
      this.redrawAttachmentPoints();
    }
  }, {
    key: "drawSelection",
    value: function drawSelection() {
      if (!this.rootElement) {
        return;
      }
      if (this.monomer.selected) {
        this.appendSelection();
        this.raiseElement();
      } else {
        this.removeSelection();
      }
    }
  }, {
    key: "raiseElement",
    value: function raiseElement() {
      var _this$selectionCircle2, _this$rootElement2;
      (_this$selectionCircle2 = this.selectionCircle) === null || _this$selectionCircle2 === void 0 || _this$selectionCircle2.raise();
      (_this$rootElement2 = this.rootElement) === null || _this$rootElement2 === void 0 || _this$rootElement2.raise();
    }
  }, {
    key: "moveSelection",
    value: function moveSelection() {
      assert__default["default"](this.rootElement);
      this.appendSelection();
      this.move();
    }
  }, {
    key: "move",
    value: function move() {
      var _this$rootElement3;
      (_this$rootElement3 = this.rootElement) === null || _this$rootElement3 === void 0 || _this$rootElement3.attr('transform', "translate(".concat(this.scaledMonomerPosition.x, ", ").concat(this.scaledMonomerPosition.y, ") scale(").concat(this.scale || 1, ")"));
    }
  }, {
    key: "remove",
    value: function remove() {
      var _this$rootElement4;
      (_this$rootElement4 = this.rootElement) === null || _this$rootElement4 === void 0 || _this$rootElement4.remove();
      this.rootElement = undefined;
      this.removeSelection();
      if (this.monomer.hovered) {
        this.editorEvents.mouseLeaveMonomer.dispatch();
      }
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }, {
    key: "getScaledMonomerPosition",
    value: function getScaledMonomerPosition(positionInAngstoms) {
      var monomerSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        width: 0,
        height: 0
      };
      var monomerPositionInPixels = Coordinates.modelToCanvas(positionInAngstoms);
      return new Vec2(monomerPositionInPixels.x - monomerSize.width / 2, monomerPositionInPixels.y - monomerSize.height / 2);
    }
  }]);
  return BaseMonomerRenderer;
}(BaseRenderer);

function _callSuper$16(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$16() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$16() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$16 = function _isNativeReflectConstruct() { return !!t; })(); }
var CHEM_SELECTED_ELEMENT_ID = '#chem-selection';
var CHEM_SYMBOL_ELEMENT_ID = '#chem';
var ChemRenderer = function (_BaseMonomerRenderer) {
  _inherits__default["default"](ChemRenderer, _BaseMonomerRenderer);
  function ChemRenderer(monomer, scale) {
    var _this;
    _classCallCheck__default["default"](this, ChemRenderer);
    _this = _callSuper$16(this, ChemRenderer, [monomer, CHEM_SELECTED_ELEMENT_ID, CHEM_SELECTED_ELEMENT_ID, CHEM_SYMBOL_ELEMENT_ID, scale]);
    _this.monomer = monomer;
    return _this;
  }
  _createClass__default["default"](ChemRenderer, [{
    key: "appendBody",
    value: function appendBody(rootElement, theme) {
      return rootElement.append('use').data([this]).attr('href', CHEM_SYMBOL_ELEMENT_ID).style('cursor', 'pointer').attr('stroke', theme.monomer.color.CHEM.regular);
    }
  }, {
    key: "enumerationElementPosition",
    get: function get() {
      return undefined;
    }
  }, {
    key: "beginningElementPosition",
    get: function get() {
      return undefined;
    }
  }]);
  return ChemRenderer;
}(BaseMonomerRenderer);

function _callSuper$15(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$15() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$15() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$15 = function _isNativeReflectConstruct() { return !!t; })(); }
var PEPTIDE_SELECTED_ELEMENT_ID = '#peptide-selection';
var PEPTIDE_HOVERED_ELEMENT_ID = '#peptide-hover';
var PEPTIDE_SYMBOL_ELEMENT_ID = '#peptide';
var PeptideRenderer = function (_BaseMonomerRenderer) {
  _inherits__default["default"](PeptideRenderer, _BaseMonomerRenderer);
  function PeptideRenderer(monomer, scale) {
    var _this;
    _classCallCheck__default["default"](this, PeptideRenderer);
    _this = _callSuper$15(this, PeptideRenderer, [monomer, PEPTIDE_SELECTED_ELEMENT_ID, PEPTIDE_HOVERED_ELEMENT_ID, PEPTIDE_SYMBOL_ELEMENT_ID, scale]);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "CHAIN_BEGINNING", 'N');
    _this.monomer = monomer;
    return _this;
  }
  _createClass__default["default"](PeptideRenderer, [{
    key: "appendBody",
    value: function appendBody(rootElement, theme) {
      return rootElement.append('use').data([this]).attr('href', PEPTIDE_SYMBOL_ELEMENT_ID).style('cursor', 'pointer').attr('fill', this.getMonomerColor(theme));
    }
  }, {
    key: "show",
    value: function show(theme) {
      _get__default["default"](_getPrototypeOf__default["default"](PeptideRenderer.prototype), "show", this).call(this, theme);
      this.appendEnumeration();
      this.appendChainBeginning();
    }
  }, {
    key: "enumerationElementPosition",
    get: function get() {
      return {
        x: 10,
        y: -1
      };
    }
  }, {
    key: "beginningElementPosition",
    get: function get() {
      return {
        x: -6,
        y: 10
      };
    }
  }]);
  return PeptideRenderer;
}(BaseMonomerRenderer);

function _callSuper$14(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$14() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$14() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$14 = function _isNativeReflectConstruct() { return !!t; })(); }
var PHOSPHATE_SELECTED_ELEMENT_ID = '#phosphate-selection';
var PHOSPHATE_SYMBOL_ELEMENT_ID = '#phosphate';
var PhosphateRenderer = function (_BaseMonomerRenderer) {
  _inherits__default["default"](PhosphateRenderer, _BaseMonomerRenderer);
  function PhosphateRenderer(monomer, scale) {
    var _this;
    _classCallCheck__default["default"](this, PhosphateRenderer);
    _this = _callSuper$14(this, PhosphateRenderer, [monomer, PHOSPHATE_SELECTED_ELEMENT_ID, PHOSPHATE_SELECTED_ELEMENT_ID, PHOSPHATE_SYMBOL_ELEMENT_ID, scale]);
    _this.monomer = monomer;
    return _this;
  }
  _createClass__default["default"](PhosphateRenderer, [{
    key: "appendBody",
    value: function appendBody(rootElement, theme) {
      return rootElement.append('use').data([this]).attr('href', PHOSPHATE_SYMBOL_ELEMENT_ID).style('cursor', 'pointer').attr('fill', this.getMonomerColor(theme));
    }
  }, {
    key: "enumerationElementPosition",
    get: function get() {
      return undefined;
    }
  }, {
    key: "beginningElementPosition",
    get: function get() {
      return undefined;
    }
  }]);
  return PhosphateRenderer;
}(BaseMonomerRenderer);

function _callSuper$13(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$13() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$13() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$13 = function _isNativeReflectConstruct() { return !!t; })(); }
var SUGAR_SELECTED_ELEMENT_ID = '#sugar-selection';
var SUGAR_SYMBOL_ELEMENT_ID = '#sugar';
var SugarRenderer = function (_BaseMonomerRenderer) {
  _inherits__default["default"](SugarRenderer, _BaseMonomerRenderer);
  function SugarRenderer(monomer, scale) {
    var _this;
    _classCallCheck__default["default"](this, SugarRenderer);
    _this = _callSuper$13(this, SugarRenderer, [monomer, SUGAR_SELECTED_ELEMENT_ID, SUGAR_SELECTED_ELEMENT_ID, SUGAR_SYMBOL_ELEMENT_ID, scale]);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "CHAIN_BEGINNING", '’5');
    _this.monomer = monomer;
    return _this;
  }
  _createClass__default["default"](SugarRenderer, [{
    key: "appendBody",
    value: function appendBody(rootElement, theme) {
      return rootElement.append('use').data([this]).attr('href', SUGAR_SYMBOL_ELEMENT_ID).style('cursor', 'pointer').attr('fill', this.getMonomerColor(theme));
    }
  }, {
    key: "show",
    value: function show(theme) {
      _get__default["default"](_getPrototypeOf__default["default"](SugarRenderer.prototype), "show", this).call(this, theme);
      this.appendChainBeginning();
    }
  }, {
    key: "enumerationElementPosition",
    get: function get() {
      return undefined;
    }
  }, {
    key: "beginningElementPosition",
    get: function get() {
      return {
        x: -5,
        y: 7
      };
    }
  }]);
  return SugarRenderer;
}(BaseMonomerRenderer);

function _callSuper$12(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$12() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$12() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$12 = function _isNativeReflectConstruct() { return !!t; })(); }
var RNABASE_SELECTED_ELEMENT_ID = '#rna-base-selection';
var RNABASE_SYMBOL_ELEMENT_ID = '#rna-base';
var RNABaseRenderer = function (_BaseMonomerRenderer) {
  _inherits__default["default"](RNABaseRenderer, _BaseMonomerRenderer);
  function RNABaseRenderer(monomer, scale) {
    var _this;
    _classCallCheck__default["default"](this, RNABaseRenderer);
    _this = _callSuper$12(this, RNABaseRenderer, [monomer, RNABASE_SELECTED_ELEMENT_ID, RNABASE_SELECTED_ELEMENT_ID, RNABASE_SYMBOL_ELEMENT_ID, scale]);
    _this.monomer = monomer;
    return _this;
  }
  _createClass__default["default"](RNABaseRenderer, [{
    key: "appendBody",
    value: function appendBody(rootElement, theme) {
      return rootElement.append('use').data([this]).attr('href', RNABASE_SYMBOL_ELEMENT_ID).style('cursor', 'pointer').attr('fill', this.getMonomerColor(theme));
    }
  }, {
    key: "show",
    value: function show(theme) {
      _get__default["default"](_getPrototypeOf__default["default"](RNABaseRenderer.prototype), "show", this).call(this, theme);
      this.appendEnumeration();
    }
  }, {
    key: "enumerationElementPosition",
    get: function get() {
      return {
        x: 11,
        y: 5
      };
    }
  }, {
    key: "beginningElementPosition",
    get: function get() {
      return undefined;
    }
  }]);
  return RNABaseRenderer;
}(BaseMonomerRenderer);

var Command = function () {
  function Command() {
    _classCallCheck__default["default"](this, Command);
    _defineProperty__default["default"](this, "operations", []);
    _defineProperty__default["default"](this, "undoOperationReverse", false);
  }
  _createClass__default["default"](Command, [{
    key: "addOperation",
    value: function addOperation(operation) {
      this.operations.push(operation);
    }
  }, {
    key: "merge",
    value: function merge(command) {
      this.operations = [].concat(_toConsumableArray__default["default"](this.operations), _toConsumableArray__default["default"](command.operations));
    }
  }, {
    key: "setUndoOperationReverse",
    value: function setUndoOperationReverse() {
      this.undoOperationReverse = true;
    }
  }, {
    key: "invert",
    value: function invert(renderersManagers) {
      var operations = this.undoOperationReverse ? this.operations.slice().reverse() : this.operations;
      operations.forEach(function (operation) {
        return operation.invert(renderersManagers);
      });
      renderersManagers.runPostRenderMethods();
    }
  }, {
    key: "execute",
    value: function execute(renderersManagers) {
      this.operations.forEach(function (operation) {
        return operation.execute(renderersManagers);
      });
      renderersManagers.runPostRenderMethods();
    }
  }]);
  return Command;
}();

var PolymerBondAddOperation = function () {
  function PolymerBondAddOperation(addPolymerBondChangeModel, deletePolymerBondChangeModel) {
    _classCallCheck__default["default"](this, PolymerBondAddOperation);
    this.addPolymerBondChangeModel = addPolymerBondChangeModel;
    this.deletePolymerBondChangeModel = deletePolymerBondChangeModel;
    this.polymerBond = this.addPolymerBondChangeModel();
  }
  _createClass__default["default"](PolymerBondAddOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      this.polymerBond = this.addPolymerBondChangeModel(this.polymerBond);
      renderersManager.addPolymerBond(this.polymerBond);
    }
  }, {
    key: "invert",
    value: function invert(renderersManager) {
      this.deletePolymerBondChangeModel(this.polymerBond);
      renderersManager.deletePolymerBond(this.polymerBond);
    }
  }]);
  return PolymerBondAddOperation;
}();
var PolymerBondDeleteOperation = function () {
  function PolymerBondDeleteOperation(polymerBond, deletePolymerBondChangeModel, finishPolymerBondCreationModelChange) {
    _classCallCheck__default["default"](this, PolymerBondDeleteOperation);
    this.polymerBond = polymerBond;
    this.deletePolymerBondChangeModel = deletePolymerBondChangeModel;
    this.finishPolymerBondCreationModelChange = finishPolymerBondCreationModelChange;
  }
  _createClass__default["default"](PolymerBondDeleteOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      this.deletePolymerBondChangeModel();
      renderersManager.deletePolymerBond(this.polymerBond);
    }
  }, {
    key: "invert",
    value: function invert(renderersManager) {
      this.polymerBond = this.finishPolymerBondCreationModelChange(this.polymerBond);
      renderersManager.addPolymerBond(this.polymerBond);
    }
  }]);
  return PolymerBondDeleteOperation;
}();
var PolymerBondMoveOperation = function () {
  function PolymerBondMoveOperation(polymerBond) {
    _classCallCheck__default["default"](this, PolymerBondMoveOperation);
    this.polymerBond = polymerBond;
  }
  _createClass__default["default"](PolymerBondMoveOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      renderersManager.movePolymerBond(this.polymerBond);
    }
  }, {
    key: "invert",
    value: function invert() {}
  }]);
  return PolymerBondMoveOperation;
}();
var PolymerBondShowInfoOperation = function () {
  function PolymerBondShowInfoOperation(polymerBond) {
    _classCallCheck__default["default"](this, PolymerBondShowInfoOperation);
    this.polymerBond = polymerBond;
  }
  _createClass__default["default"](PolymerBondShowInfoOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      renderersManager.showPolymerBondInformation(this.polymerBond);
    }
  }, {
    key: "invert",
    value: function invert() {}
  }]);
  return PolymerBondShowInfoOperation;
}();
var PolymerBondCancelCreationOperation = function () {
  function PolymerBondCancelCreationOperation(polymerBond, secondMonomer) {
    _classCallCheck__default["default"](this, PolymerBondCancelCreationOperation);
    this.polymerBond = polymerBond;
    this.secondMonomer = secondMonomer;
  }
  _createClass__default["default"](PolymerBondCancelCreationOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      renderersManager.cancelPolymerBondCreation(this.polymerBond, this.secondMonomer);
    }
  }, {
    key: "invert",
    value: function invert() {}
  }]);
  return PolymerBondCancelCreationOperation;
}();
var PolymerBondFinishCreationOperation = function () {
  function PolymerBondFinishCreationOperation(finishPolymerBondCreationModelChange, deletePolymerBondCreationModelChange) {
    _classCallCheck__default["default"](this, PolymerBondFinishCreationOperation);
    this.finishPolymerBondCreationModelChange = finishPolymerBondCreationModelChange;
    this.deletePolymerBondCreationModelChange = deletePolymerBondCreationModelChange;
    this.polymerBond = this.finishPolymerBondCreationModelChange();
  }
  _createClass__default["default"](PolymerBondFinishCreationOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      this.polymerBond = this.finishPolymerBondCreationModelChange(this.polymerBond);
      renderersManager.finishPolymerBondCreation(this.polymerBond);
    }
  }, {
    key: "invert",
    value: function invert(renderersManager) {
      this.deletePolymerBondCreationModelChange(this.polymerBond);
      renderersManager.deletePolymerBond(this.polymerBond);
    }
  }]);
  return PolymerBondFinishCreationOperation;
}();
var SelectLayoutModeOperation = function () {
  function SelectLayoutModeOperation(_onExecute, _onInvert, mode, prevMode) {
    _classCallCheck__default["default"](this, SelectLayoutModeOperation);
    this._onExecute = _onExecute;
    this._onInvert = _onInvert;
    this.mode = mode;
    this.prevMode = prevMode;
    this.onExecute = _onExecute;
    this.onInvert = _onInvert;
  }
  _createClass__default["default"](SelectLayoutModeOperation, [{
    key: "execute",
    value: function execute() {
      this.onExecute();
    }
  }, {
    key: "invert",
    value: function invert() {
      this.onInvert();
    }
  }]);
  return SelectLayoutModeOperation;
}();

var BaseMode = function () {
  function BaseMode(modeName) {
    var previousMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'flex-layout-mode';
    _classCallCheck__default["default"](this, BaseMode);
    this.modeName = modeName;
    this.previousMode = previousMode;
  }
  _createClass__default["default"](BaseMode, [{
    key: "changeMode",
    value: function changeMode(editor, modeName) {
      editor.events.layoutModeChange.dispatch(modeName);
      var ModeConstructor = modesMap[modeName];
      editor.setMode(new ModeConstructor());
      editor.mode.initialize();
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var command = new Command();
      var editor = CoreEditor.provideEditorInstance();
      command.addOperation(new SelectLayoutModeOperation(this.changeMode.bind(this, editor, this.modeName), this.changeMode.bind(this, editor, this.previousMode), this.modeName, this.previousMode));
      editor.events.selectTool.dispatch('select-rectangle');
      return command;
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);
  return BaseMode;
}();

function _callSuper$11(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$11() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$11() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$11 = function _isNativeReflectConstruct() { return !!t; })(); }
var FlexMode = function (_BaseMode) {
  _inherits__default["default"](FlexMode, _BaseMode);
  function FlexMode(previousMode) {
    _classCallCheck__default["default"](this, FlexMode);
    return _callSuper$11(this, FlexMode, ['flex-layout-mode', previousMode]);
  }
  _createClass__default["default"](FlexMode, [{
    key: "initialize",
    value: function initialize() {
      var command = _get__default["default"](_getPrototypeOf__default["default"](FlexMode.prototype), "initialize", this).call(this);
      var editor = CoreEditor.provideEditorInstance();
      var modelChanges = editor.drawingEntitiesManager.applyFlexLayoutMode(true);
      editor.renderersContainer.update(modelChanges);
      return command;
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(_event) {}
  }]);
  return FlexMode;
}(BaseMode);

function _callSuper$10(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$10() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$10() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$10 = function _isNativeReflectConstruct() { return !!t; })(); }
var EmptySubChain = function (_BaseSubChain) {
  _inherits__default["default"](EmptySubChain, _BaseSubChain);
  function EmptySubChain() {
    _classCallCheck__default["default"](this, EmptySubChain);
    return _callSuper$10(this, EmptySubChain, arguments);
  }
  return _createClass__default["default"](EmptySubChain);
}(BaseSubChain);

function _callSuper$$(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$$() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$$() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$$ = function _isNativeReflectConstruct() { return !!t; })(); }
function getEmptyMonomerItem() {
  return {
    label: '',
    struct: new Struct(),
    props: {
      MonomerNaturalAnalogCode: '',
      MonomerName: '',
      Name: ''
    }
  };
}
var EmptyMonomer = function (_BaseMonomer) {
  _inherits__default["default"](EmptyMonomer, _BaseMonomer);
  function EmptyMonomer() {
    _classCallCheck__default["default"](this, EmptyMonomer);
    return _callSuper$$(this, EmptyMonomer, [getEmptyMonomerItem()]);
  }
  _createClass__default["default"](EmptyMonomer, [{
    key: "getValidSourcePoint",
    value: function getValidSourcePoint() {
      return undefined;
    }
  }, {
    key: "getValidTargetPoint",
    value: function getValidTargetPoint() {
      return undefined;
    }
  }, {
    key: "SubChainConstructor",
    get: function get() {
      return EmptySubChain;
    }
  }, {
    key: "isMonomerTypeDifferentForChaining",
    value: function isMonomerTypeDifferentForChaining() {
      return true;
    }
  }]);
  return EmptyMonomer;
}(BaseMonomer);

var EmptySequenceNode = function () {
  function EmptySequenceNode() {
    _classCallCheck__default["default"](this, EmptySequenceNode);
    _defineProperty__default["default"](this, "renderer", undefined);
    _defineProperty__default["default"](this, "monomer", new EmptyMonomer());
  }
  _createClass__default["default"](EmptySequenceNode, [{
    key: "SubChainConstructor",
    get: function get() {
      return EmptySubChain;
    }
  }, {
    key: "firstMonomerInNode",
    get: function get() {
      return this.monomer;
    }
  }, {
    key: "lastMonomerInNode",
    get: function get() {
      return this.monomer;
    }
  }, {
    key: "hovered",
    get: function get() {
      return false;
    }
  }, {
    key: "selected",
    get: function get() {
      return false;
    }
  }, {
    key: "monomerItem",
    get: function get() {
      return {
        props: {
          MonomerNaturalAnalogCode: null
        }
      };
    }
  }, {
    key: "monomers",
    get: function get() {
      return [];
    }
  }, {
    key: "setRenderer",
    value: function setRenderer(renderer) {
      this.renderer = renderer;
      this.monomer.setRenderer(renderer);
    }
  }, {
    key: "modified",
    get: function get() {
      return false;
    }
  }]);
  return EmptySequenceNode;
}();

function _callSuper$_(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$_() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$_() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$_ = function _isNativeReflectConstruct() { return !!t; })(); }
var CHAIN_START_ARROW_SYMBOL_ID = 'sequence-start-arrow';
var BaseSequenceItemRenderer = function (_BaseSequenceRenderer) {
  _inherits__default["default"](BaseSequenceItemRenderer, _BaseSequenceRenderer);
  function BaseSequenceItemRenderer(node, firstNodeInChainPosition, monomerIndexInChain, isLastMonomerInChain, subChain, _isEditingSymbol, monomerSize, scaledMonomerPosition) {
    var _this;
    _classCallCheck__default["default"](this, BaseSequenceItemRenderer);
    _this = _callSuper$_(this, BaseSequenceItemRenderer, [node.monomer]);
    _this.node = node;
    _this.firstNodeInChainPosition = firstNodeInChainPosition;
    _this.monomerIndexInChain = monomerIndexInChain;
    _this.isLastMonomerInChain = isLastMonomerInChain;
    _this.subChain = subChain;
    _this._isEditingSymbol = _isEditingSymbol;
    _this.monomerSize = monomerSize;
    _this.scaledMonomerPosition = scaledMonomerPosition;
    _this.editorEvents = exports.editorEvents;
    return _this;
  }
  _createClass__default["default"](BaseSequenceItemRenderer, [{
    key: "isEditingSymbol",
    get: function get() {
      return this._isEditingSymbol;
    },
    set: function set(isEditingSymbol) {
      this._isEditingSymbol = isEditingSymbol;
    }
  }, {
    key: "appendHover",
    value: function appendHover() {
      return undefined;
    }
  }, {
    key: "appendHoverAreaElement",
    value: function appendHoverAreaElement() {}
  }, {
    key: "moveSelection",
    value: function moveSelection() {}
  }, {
    key: "currentSubChain",
    get: function get() {
      return this.subChain;
    }
  }, {
    key: "scaledMonomerPositionForSequence",
    get: function get() {
      var indexInRow = this.monomerIndexInChain % this.symbolsInRow;
      var rowIndex = Math.floor(this.monomerIndexInChain / this.symbolsInRow);
      return new Vec2(this.firstNodeInChainPosition.x + indexInRow * 20 + Math.floor(indexInRow / this.nthSeparationInRow) * 10, this.firstNodeInChainPosition.y + 47 * rowIndex);
    }
  }, {
    key: "center",
    get: function get() {
      return this.scaledMonomerPositionForSequence.add(new Vec2(4.5, 0, 0));
    }
  }, {
    key: "isSequenceEditModeTurnedOn",
    get: function get() {
      var editor = CoreEditor.provideEditorInstance();
      return editor.mode instanceof SequenceMode && editor.mode.isEditMode;
    }
  }, {
    key: "appendRootElement",
    value: function appendRootElement() {
      return this.canvas.append('g').data([this]).attr('transition', 'transform 0.2s').attr('transform', "translate(".concat(this.scaledMonomerPositionForSequence.x, ", ").concat(this.scaledMonomerPositionForSequence.y, ")"));
    }
  }, {
    key: "appendBackgroundElement",
    value: function appendBackgroundElement() {
      var _this$rootElement;
      var backgroundElement = (_this$rootElement = this.rootElement) === null || _this$rootElement === void 0 ? void 0 : _this$rootElement.append('rect').attr('width', 16).attr('height', 20).attr('y', -16).attr('x', -2).attr('rx', 2).attr('cursor', 'text');
      if (this.node.modified) {
        backgroundElement === null || backgroundElement === void 0 || backgroundElement.attr('stroke', '#585858').attr('stroke-width', '1px');
      }
      backgroundElement === null || backgroundElement === void 0 || backgroundElement.attr('fill', this.isSequenceEditModeTurnedOn ? '#FF7A001A' : 'transparent');
      return backgroundElement;
    }
  }, {
    key: "appendSpacerElement",
    value: function appendSpacerElement() {
      var _this$rootElement2;
      var spacerGroupElement = (_this$rootElement2 = this.rootElement) === null || _this$rootElement2 === void 0 ? void 0 : _this$rootElement2.append('g').attr('transform', 'translate(14, -16)');
      spacerGroupElement === null || spacerGroupElement === void 0 || spacerGroupElement.append('rect').attr('width', 4).attr('height', 20).attr('cursor', 'text').attr('fill', 'transparent');
      return spacerGroupElement;
    }
  }, {
    key: "nthSeparationInRow",
    get: function get() {
      return 10;
    }
  }, {
    key: "symbolsInRow",
    get: function get() {
      return 30;
    }
  }, {
    key: "appendCounterElement",
    value: function appendCounterElement(rootElement) {
      return rootElement.append('text').attr('x', '-2').attr('y', '-24').text(this.monomerIndexInChain + 1).attr('font-family', 'Courier New').attr('font-size', '12px').attr('font-weight', '700').attr('fill', '#7C7C7F');
    }
  }, {
    key: "needDisplayCounter",
    get: function get() {
      return ((this.monomerIndexInChain + 1) % this.nthSeparationInRow === 0 || this.isLastMonomerInChain) && !(this.node instanceof EmptySequenceNode);
    }
  }, {
    key: "isBeginningOfChain",
    get: function get() {
      return this.monomerIndexInChain === 0;
    }
  }, {
    key: "appendCaretElement",
    value: function appendCaretElement() {
      var _this$spacerElement;
      (_this$spacerElement = this.spacerElement) === null || _this$spacerElement === void 0 || _this$spacerElement.append('line').attr('x1', -16).attr('y1', -1).attr('x2', -16).attr('y2', 21).attr('stroke', '#333').attr('class', 'blinking');
    }
  }, {
    key: "drawHover",
    value: function drawHover() {
      var _this$backgroundEleme;
      (_this$backgroundEleme = this.backgroundElement) === null || _this$backgroundEleme === void 0 || _this$backgroundEleme.attr('fill', this.isSequenceEditModeTurnedOn ? '#FF7A0033' : '#EFF2F5');
    }
  }, {
    key: "removeHover",
    value: function removeHover() {
      var _this$backgroundEleme2;
      (_this$backgroundEleme2 = this.backgroundElement) === null || _this$backgroundEleme2 === void 0 || _this$backgroundEleme2.attr('fill', this.isSequenceEditModeTurnedOn ? '#FF7A001A' : 'transparent');
    }
  }, {
    key: "appendChainStartArrow",
    value: function appendChainStartArrow() {
      var _this$rootElement3;
      (_this$rootElement3 = this.rootElement) === null || _this$rootElement3 === void 0 || _this$rootElement3.append('use').attr('x', -17).attr('y', -27).attr('href', "#".concat(CHAIN_START_ARROW_SYMBOL_ID));
    }
  }, {
    key: "show",
    value: function show() {
      var _this2 = this;
      this.rootElement = this.appendRootElement();
      if (this.isBeginningOfChain && this.isSequenceEditModeTurnedOn) {
        this.appendChainStartArrow();
      }
      this.spacerElement = this.appendSpacerElement();
      this.backgroundElement = this.appendBackgroundElement();
      if (this.isSequenceEditModeTurnedOn) {
        if (this.isEditingSymbol) {
          this.appendCaretElement();
        }
        this.drawSelection();
      }
      this.textElement = this.rootElement.append('text').text(this.symbolToDisplay).attr('font-family', 'Courier New').attr('font-size', '20px').attr('font-weight', '700').attr('fill', '#333333');
      this.appendEvents();
      if (this.needDisplayCounter) {
        this.counterElement = this.appendCounterElement(this.rootElement);
      }
      this.rootElement.on('mouseover', function () {
        if (!_this2.node.monomer.selected) {
          _this2.drawHover();
        }
      });
      this.rootElement.on('mouseleave', function () {
        _this2.removeHover();
      });
    }
  }, {
    key: "drawSelection",
    value: function drawSelection() {
      if (!this.rootElement) {
        return;
      }
      if (this.node.monomer.selected) {
        this.appendSelection();
        this.removeHover();
        this.raiseElement();
      } else {
        this.removeSelection();
      }
    }
  }, {
    key: "appendSelection",
    value: function appendSelection() {
      if (this.selectionRectangle) {
        this.selectionRectangle.attr('x', this.scaledMonomerPositionForSequence.x - 4).attr('y', this.scaledMonomerPositionForSequence.y - 16).attr('width', 20).attr('height', 20);
      } else {
        var _this$rootElement4, _this$canvas;
        this.selectionBorder = (_this$rootElement4 = this.rootElement) === null || _this$rootElement4 === void 0 ? void 0 : _this$rootElement4.append('use').attr('href', this.monomerIndexInChain).attr('stroke', '#57FF8F').attr('pointer-events', 'none');
        this.selectionRectangle = (_this$canvas = this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.insert('rect', ':first-child').attr('opacity', '0.7').attr('fill', '#57FF8F').attr('x', this.scaledMonomerPositionForSequence.x - 4).attr('y', this.scaledMonomerPositionForSequence.y - 16).attr('width', 20).attr('height', 20);
      }
    }
  }, {
    key: "removeSelection",
    value: function removeSelection() {
      var _this$selectionRectan, _this$selectionBorder;
      (_this$selectionRectan = this.selectionRectangle) === null || _this$selectionRectan === void 0 || _this$selectionRectan.remove();
      (_this$selectionBorder = this.selectionBorder) === null || _this$selectionBorder === void 0 || _this$selectionBorder.remove();
      this.selectionRectangle = undefined;
      this.selectionBorder = undefined;
    }
  }, {
    key: "raiseElement",
    value: function raiseElement() {
      var _this$selectionRectan2, _this$rootElement5;
      (_this$selectionRectan2 = this.selectionRectangle) === null || _this$selectionRectan2 === void 0 || _this$selectionRectan2.raise();
      (_this$rootElement5 = this.rootElement) === null || _this$rootElement5 === void 0 || _this$rootElement5.raise();
    }
  }, {
    key: "remove",
    value: function remove() {
      var _this$rootElement6;
      (_this$rootElement6 = this.rootElement) === null || _this$rootElement6 === void 0 || _this$rootElement6.remove();
      this.rootElement = undefined;
      this.removeSelection();
    }
  }, {
    key: "setEnumeration",
    value: function setEnumeration() {}
  }, {
    key: "redrawEnumeration",
    value: function redrawEnumeration() {}
  }, {
    key: "redrawAttachmentPoints",
    value: function redrawAttachmentPoints() {}
  }, {
    key: "redrawAttachmentPointsCoordinates",
    value: function redrawAttachmentPointsCoordinates() {}
  }, {
    key: "enumeration",
    get: function get() {
      return null;
    }
  }, {
    key: "hoverAttachmenPoint",
    value: function hoverAttachmenPoint() {}
  }, {
    key: "updateAttachmentPoints",
    value: function updateAttachmentPoints() {}
  }, {
    key: "appendEvents",
    value: function appendEvents() {
      var _this3 = this;
      assert__default["default"](this.textElement);
      this.textElement.on('mouseover', function (event) {
        _this3.editorEvents.mouseOverSequenceItem.dispatch(event);
      });
      this.textElement.on('mousemove', function (event) {
        _this3.editorEvents.mouseOnMoveSequenceItem.dispatch(event);
      });
      this.textElement.on('mouseleave', function (event) {
        _this3.editorEvents.mouseLeaveSequenceItem.dispatch(event);
      });
    }
  }]);
  return BaseSequenceItemRenderer;
}(BaseSequenceRenderer);

function _callSuper$Z(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$Z() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$Z() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$Z = function _isNativeReflectConstruct() { return !!t; })(); }
var PeptideSequenceItemRenderer = function (_BaseSequenceItemRend) {
  _inherits__default["default"](PeptideSequenceItemRenderer, _BaseSequenceItemRend);
  function PeptideSequenceItemRenderer() {
    _classCallCheck__default["default"](this, PeptideSequenceItemRenderer);
    return _callSuper$Z(this, PeptideSequenceItemRenderer, arguments);
  }
  _createClass__default["default"](PeptideSequenceItemRenderer, [{
    key: "symbolToDisplay",
    get: function get() {
      return this.node.monomer.monomerItem.props.MonomerNaturalAnalogCode || '@';
    }
  }]);
  return PeptideSequenceItemRenderer;
}(BaseSequenceItemRenderer);

function _callSuper$Y(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$Y() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$Y() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$Y = function _isNativeReflectConstruct() { return !!t; })(); }
var ChemSequenceItemRenderer = function (_BaseSequenceItemRend) {
  _inherits__default["default"](ChemSequenceItemRenderer, _BaseSequenceItemRend);
  function ChemSequenceItemRenderer() {
    _classCallCheck__default["default"](this, ChemSequenceItemRenderer);
    return _callSuper$Y(this, ChemSequenceItemRenderer, arguments);
  }
  _createClass__default["default"](ChemSequenceItemRenderer, [{
    key: "symbolToDisplay",
    get: function get() {
      return '@';
    }
  }]);
  return ChemSequenceItemRenderer;
}(BaseSequenceItemRenderer);

function _callSuper$X(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$X() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$X() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$X = function _isNativeReflectConstruct() { return !!t; })(); }
var PhosphateSequenceItemRenderer = function (_BaseSequenceItemRend) {
  _inherits__default["default"](PhosphateSequenceItemRenderer, _BaseSequenceItemRend);
  function PhosphateSequenceItemRenderer() {
    _classCallCheck__default["default"](this, PhosphateSequenceItemRenderer);
    return _callSuper$X(this, PhosphateSequenceItemRenderer, arguments);
  }
  _createClass__default["default"](PhosphateSequenceItemRenderer, [{
    key: "symbolToDisplay",
    get: function get() {
      return 'p';
    }
  }]);
  return PhosphateSequenceItemRenderer;
}(BaseSequenceItemRenderer);

function _callSuper$W(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$W() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$W() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$W = function _isNativeReflectConstruct() { return !!t; })(); }
var NucleotideSequenceItemRenderer = function (_BaseSequenceItemRend) {
  _inherits__default["default"](NucleotideSequenceItemRenderer, _BaseSequenceItemRend);
  function NucleotideSequenceItemRenderer() {
    _classCallCheck__default["default"](this, NucleotideSequenceItemRenderer);
    return _callSuper$W(this, NucleotideSequenceItemRenderer, arguments);
  }
  _createClass__default["default"](NucleotideSequenceItemRenderer, [{
    key: "symbolToDisplay",
    get: function get() {
      var _this$node$monomer$at;
      return ((_this$node$monomer$at = this.node.monomer.attachmentPointsToBonds.R3) === null || _this$node$monomer$at === void 0 || (_this$node$monomer$at = _this$node$monomer$at.getAnotherMonomer(this.node.monomer)) === null || _this$node$monomer$at === void 0 || (_this$node$monomer$at = _this$node$monomer$at.monomerItem) === null || _this$node$monomer$at === void 0 ? void 0 : _this$node$monomer$at.props.MonomerNaturalAnalogCode) || '@';
    }
  }]);
  return NucleotideSequenceItemRenderer;
}(BaseSequenceItemRenderer);

var RNA_DNA_NON_MODIFIED_PART;
(function (RNA_DNA_NON_MODIFIED_PART) {
  RNA_DNA_NON_MODIFIED_PART["SUGAR_RNA"] = "R";
  RNA_DNA_NON_MODIFIED_PART["SUGAR_DNA"] = "dR";
  RNA_DNA_NON_MODIFIED_PART["PHOSPHATE"] = "P";
})(RNA_DNA_NON_MODIFIED_PART || (RNA_DNA_NON_MODIFIED_PART = {}));
var rnaDnaNaturalAnalogues = ['A', 'T', 'G', 'C', 'U'];
var peptideNaturalAnalogues = ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y'];

function getRnaPartLibraryItem(editor, rnaBaseName) {
  return editor.monomersLibrary.RNA.find(function (libraryItem) {
    return libraryItem.props.MonomerName === rnaBaseName;
  });
}
function getPeptideLibraryItem(editor, peptideName) {
  return editor.monomersLibrary.PEPTIDE.find(function (libraryItem) {
    return libraryItem.props.MonomerName === peptideName;
  });
}
function getSugarBySequenceType(sequenceType) {
  switch (sequenceType) {
    case exports.SequenceType.DNA:
      return RNA_DNA_NON_MODIFIED_PART.SUGAR_DNA;
    case exports.SequenceType.RNA:
      return RNA_DNA_NON_MODIFIED_PART.SUGAR_RNA;
    default:
      return undefined;
  }
}

var Nucleotide = function () {
  function Nucleotide(sugar, rnaBase, phosphate) {
    _classCallCheck__default["default"](this, Nucleotide);
    this.sugar = sugar;
    this.rnaBase = rnaBase;
    this.phosphate = phosphate;
  }
  _createClass__default["default"](Nucleotide, [{
    key: "isMonomerTypeDifferentForChaining",
    value: function isMonomerTypeDifferentForChaining(monomerToChain) {
      return this.sugar.isMonomerTypeDifferentForChaining(monomerToChain);
    }
  }, {
    key: "SubChainConstructor",
    get: function get() {
      return this.sugar.SubChainConstructor;
    }
  }, {
    key: "monomer",
    get: function get() {
      return this.sugar;
    }
  }, {
    key: "monomers",
    get: function get() {
      return [this.sugar, this.rnaBase, this.phosphate];
    }
  }, {
    key: "firstMonomerInNode",
    get: function get() {
      return this.sugar;
    }
  }, {
    key: "lastMonomerInNode",
    get: function get() {
      return this.phosphate;
    }
  }, {
    key: "renderer",
    get: function get() {
      return this.monomer.renderer;
    }
  }, {
    key: "modified",
    get: function get() {
      return this.sugar.label !== RNA_DNA_NON_MODIFIED_PART.SUGAR_RNA;
    }
  }], [{
    key: "fromSugar",
    value: function fromSugar(sugar) {
      var needValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (needValidation) {
        assert__default["default"](isValidNucleotide(sugar), 'Nucleotide is not valid. Please check nucleotide parts connections.');
        var isNucleoside = isValidNucleoside(sugar);
        assert__default["default"](!isNucleoside, 'Nucleotide is nucleoside because it is a last sugar+base of rna chain');
      }
      return new Nucleotide(sugar, getRnaBaseFromSugar(sugar), getPhosphateFromSugar(sugar));
    }
  }, {
    key: "createOnCanvas",
    value: function createOnCanvas(rnaBaseName, position) {
      var editor = CoreEditor.provideEditorInstance();
      var rnaBaseLibraryItem = getRnaPartLibraryItem(editor, rnaBaseName);
      var phosphateLibraryItem = getRnaPartLibraryItem(editor, RNA_DNA_NON_MODIFIED_PART.PHOSPHATE);
      var sugarName = getSugarBySequenceType(editor.sequenceTypeEnterMode);
      assert__default["default"](sugarName);
      var sugarLibraryItem = getRnaPartLibraryItem(editor, sugarName);
      assert__default["default"](sugarLibraryItem);
      assert__default["default"](rnaBaseLibraryItem);
      assert__default["default"](phosphateLibraryItem);
      var _editor$drawingEntiti = editor.drawingEntitiesManager.addRnaPreset({
          sugar: sugarLibraryItem,
          sugarPosition: position,
          rnaBase: rnaBaseLibraryItem,
          rnaBasePosition: position,
          phosphate: phosphateLibraryItem,
          phosphatePosition: position
        }),
        modelChanges = _editor$drawingEntiti.command,
        monomers = _editor$drawingEntiti.monomers;
      var sugar = monomers.find(function (monomer) {
        return monomer instanceof Sugar;
      });
      return {
        modelChanges: modelChanges,
        node: Nucleotide.fromSugar(sugar, false)
      };
    }
  }]);
  return Nucleotide;
}();

function _callSuper$V(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$V() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$V() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$V = function _isNativeReflectConstruct() { return !!t; })(); }
var EmptySequenceItemRenderer = function (_BaseSequenceItemRend) {
  _inherits__default["default"](EmptySequenceItemRenderer, _BaseSequenceItemRend);
  function EmptySequenceItemRenderer() {
    _classCallCheck__default["default"](this, EmptySequenceItemRenderer);
    return _callSuper$V(this, EmptySequenceItemRenderer, arguments);
  }
  _createClass__default["default"](EmptySequenceItemRenderer, [{
    key: "symbolToDisplay",
    get: function get() {
      return '';
    }
  }]);
  return EmptySequenceItemRenderer;
}(BaseSequenceItemRenderer);

var SequenceNodeRendererFactory = function () {
  function SequenceNodeRendererFactory() {
    _classCallCheck__default["default"](this, SequenceNodeRendererFactory);
  }
  _createClass__default["default"](SequenceNodeRendererFactory, null, [{
    key: "fromNode",
    value: function fromNode(node, firstMonomerInChainPosition, monomerIndexInChain, isLastMonomerInChain, subChain, isEditingSymbol, renderer) {
      var RendererClass;
      switch (node.constructor) {
        case Nucleotide:
          RendererClass = NucleotideSequenceItemRenderer;
          break;
        case Nucleoside:
          RendererClass = NucleotideSequenceItemRenderer;
          break;
        case EmptySequenceNode:
          RendererClass = EmptySequenceItemRenderer;
          break;
        default:
          switch (node.monomer.constructor) {
            case Phosphate:
              RendererClass = PhosphateSequenceItemRenderer;
              break;
            case Peptide:
              RendererClass = PeptideSequenceItemRenderer;
              break;
            case Chem:
              RendererClass = ChemSequenceItemRenderer;
              break;
            default:
              RendererClass = ChemSequenceItemRenderer;
              break;
          }
      }
      return new RendererClass(node, firstMonomerInChainPosition, monomerIndexInChain, isLastMonomerInChain, subChain, isEditingSymbol, renderer === null || renderer === void 0 ? void 0 : renderer.monomerSize, renderer === null || renderer === void 0 ? void 0 : renderer.scaledMonomerPosition);
    }
  }]);
  return SequenceNodeRendererFactory;
}();

function _callSuper$U(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$U() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$U() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$U = function _isNativeReflectConstruct() { return !!t; })(); }
var PolymerBondSequenceRenderer = function (_BaseSequenceRenderer) {
  _inherits__default["default"](PolymerBondSequenceRenderer, _BaseSequenceRenderer);
  function PolymerBondSequenceRenderer(polymerBond, firstNode, secondNode) {
    var _this;
    _classCallCheck__default["default"](this, PolymerBondSequenceRenderer);
    _this = _callSuper$U(this, PolymerBondSequenceRenderer, [polymerBond]);
    _this.polymerBond = polymerBond;
    _this.firstNode = firstNode;
    _this.secondNode = secondNode;
    return _this;
  }
  _createClass__default["default"](PolymerBondSequenceRenderer, [{
    key: "firstMonomer",
    get: function get() {
      var _this$firstNode;
      return ((_this$firstNode = this.firstNode) === null || _this$firstNode === void 0 ? void 0 : _this$firstNode.monomer) || this.polymerBond.firstMonomer;
    }
  }, {
    key: "secondMonomer",
    get: function get() {
      var _this$secondNode;
      return ((_this$secondNode = this.secondNode) === null || _this$secondNode === void 0 ? void 0 : _this$secondNode.monomer) || this.polymerBond.secondMonomer;
    }
  }, {
    key: "areMonomersOnSameRow",
    get: function get() {
      var _this$secondMonomer, _this$firstMonomer$re, _this$secondMonomer2;
      assert__default["default"](this.firstMonomer.renderer instanceof BaseSequenceItemRenderer);
      assert__default["default"](((_this$secondMonomer = this.secondMonomer) === null || _this$secondMonomer === void 0 ? void 0 : _this$secondMonomer.renderer) instanceof BaseSequenceItemRenderer);
      return ((_this$firstMonomer$re = this.firstMonomer.renderer) === null || _this$firstMonomer$re === void 0 ? void 0 : _this$firstMonomer$re.scaledMonomerPositionForSequence.y) === ((_this$secondMonomer2 = this.secondMonomer) === null || _this$secondMonomer2 === void 0 || (_this$secondMonomer2 = _this$secondMonomer2.renderer) === null || _this$secondMonomer2 === void 0 ? void 0 : _this$secondMonomer2.scaledMonomerPositionForSequence.y);
    }
  }, {
    key: "scaledPosition",
    get: function get() {
      var _this$secondMonomer3;
      assert__default["default"](this.firstMonomer.renderer instanceof BaseSequenceItemRenderer);
      assert__default["default"](((_this$secondMonomer3 = this.secondMonomer) === null || _this$secondMonomer3 === void 0 ? void 0 : _this$secondMonomer3.renderer) instanceof BaseSequenceItemRenderer);
      var firstMonomerY = this.firstMonomer.renderer.scaledMonomerPositionForSequence.y;
      var firstMonomerX = this.firstMonomer.renderer.scaledMonomerPositionForSequence.x;
      var secondMonomerY = this.secondMonomer.renderer.scaledMonomerPositionForSequence.y;
      var secondMonomerX = this.secondMonomer.renderer.scaledMonomerPositionForSequence.x;
      return {
        startPosition: new Vec2(firstMonomerX, firstMonomerY),
        endPosition: new Vec2(secondMonomerX, secondMonomerY)
      };
    }
  }, {
    key: "center",
    get: function get() {
      return Vec2.centre(new Vec2(this.scaledPosition.startPosition.x + 6, this.mainLineY.mainLineY1), new Vec2(this.scaledPosition.startPosition.x + 6, this.mainLineY.mainLineY2));
    }
  }, {
    key: "mainLineY",
    get: function get() {
      var mainLineY1 = this.scaledPosition.startPosition.y - (this.scaledPosition.startPosition.y > this.scaledPosition.endPosition.y ? 15 : -3) + (this.areMonomersOnSameRow ? -25 : 0);
      var mainLineY2 = this.scaledPosition.endPosition.y - (this.scaledPosition.endPosition.y > this.scaledPosition.startPosition.y ? 15 : -3) + (this.areMonomersOnSameRow ? -25 : 0);
      return {
        mainLineY1: mainLineY1,
        mainLineY2: mainLineY2
      };
    }
  }, {
    key: "show",
    value: function show() {
      var _this$rootElement;
      this.rootElement = this.canvas.insert('g', ":first-child").data([this]);
      (_this$rootElement = this.rootElement) === null || _this$rootElement === void 0 || _this$rootElement.append('path').attr('stroke', 'black').attr('fill', 'none').attr('d', this.getBondPath());
    }
  }, {
    key: "drawSelection",
    value: function drawSelection() {
      assert__default["default"](this.rootElement);
      if (this.polymerBond.selected) {
        var _this$selectionElemen, _this$rootElement2;
        (_this$selectionElemen = this.selectionElement) === null || _this$selectionElemen === void 0 || _this$selectionElemen.remove();
        this.selectionElement = (_this$rootElement2 = this.rootElement) === null || _this$rootElement2 === void 0 ? void 0 : _this$rootElement2.insert('path', ':first-child').attr('stroke', '#57FF8F').attr('stroke-width', '6').attr('fill', 'none');
        this.selectionElement.attr('d', this.getBondPath());
      } else {
        var _this$selectionElemen2;
        (_this$selectionElemen2 = this.selectionElement) === null || _this$selectionElemen2 === void 0 || _this$selectionElemen2.remove();
      }
    }
  }, {
    key: "getBondPath",
    value: function getBondPath() {
      var path = '';
      if (this.areMonomersOnSameRow) {
        path = "M ".concat(this.scaledPosition.startPosition.x + 6, ",\n      ").concat(this.mainLineY.mainLineY1 + 5, " \n      L ").concat(this.scaledPosition.startPosition.x + 6, ", ").concat(this.mainLineY.mainLineY1, " \n      L ").concat(this.scaledPosition.endPosition.x + 6, ", ").concat(this.mainLineY.mainLineY2, "\n      L ").concat(this.scaledPosition.endPosition.x + 6, ", ").concat(this.mainLineY.mainLineY2 + 5);
      } else {
        path = "M ".concat(this.scaledPosition.startPosition.x + 6, ", ").concat(this.mainLineY.mainLineY1, " L ").concat(this.scaledPosition.endPosition.x + 6, ", ").concat(this.mainLineY.mainLineY2);
      }
      return path;
    }
  }, {
    key: "moveStart",
    value: function moveStart() {}
  }, {
    key: "moveEnd",
    value: function moveEnd() {}
  }, {
    key: "isSnake",
    get: function get() {
      return false;
    }
  }, {
    key: "isMonomersOnSameHorizontalLine",
    value: function isMonomersOnSameHorizontalLine() {
      return false;
    }
  }]);
  return PolymerBondSequenceRenderer;
}(BaseSequenceRenderer);

function _callSuper$T(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$T() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$T() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$T = function _isNativeReflectConstruct() { return !!t; })(); }
var BackBoneBondSequenceRenderer = function (_BaseSequenceRenderer) {
  _inherits__default["default"](BackBoneBondSequenceRenderer, _BaseSequenceRenderer);
  function BackBoneBondSequenceRenderer(polymerBond) {
    _classCallCheck__default["default"](this, BackBoneBondSequenceRenderer);
    return _callSuper$T(this, BackBoneBondSequenceRenderer, [polymerBond]);
  }
  _createClass__default["default"](BackBoneBondSequenceRenderer, [{
    key: "isSnake",
    get: function get() {
      return false;
    }
  }, {
    key: "isMonomersOnSameHorizontalLine",
    value: function isMonomersOnSameHorizontalLine() {
      return false;
    }
  }, {
    key: "moveStart",
    value: function moveStart() {}
  }, {
    key: "moveEnd",
    value: function moveEnd() {}
  }]);
  return BackBoneBondSequenceRenderer;
}(BaseSequenceRenderer);

function _callSuper$S(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$S() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$S() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$S = function _isNativeReflectConstruct() { return !!t; })(); }
var PolymerBond$1 = function (_DrawingEntity) {
  _inherits__default["default"](PolymerBond, _DrawingEntity);
  function PolymerBond(firstMonomer, secondMonomer) {
    var _this;
    _classCallCheck__default["default"](this, PolymerBond);
    _this = _callSuper$S(this, PolymerBond);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "renderer", undefined);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "endPosition", new Vec2());
    _this.firstMonomer = firstMonomer;
    _this.firstMonomer = firstMonomer;
    _this.secondMonomer = secondMonomer;
    return _this;
  }
  _createClass__default["default"](PolymerBond, [{
    key: "setFirstMonomer",
    value: function setFirstMonomer(monomer) {
      this.firstMonomer = monomer;
    }
  }, {
    key: "setSecondMonomer",
    value: function setSecondMonomer(monomer) {
      this.secondMonomer = monomer;
    }
  }, {
    key: "setRenderer",
    value: function setRenderer(renderer) {
      _get__default["default"](_getPrototypeOf__default["default"](PolymerBond.prototype), "setBaseRenderer", this).call(this, renderer);
      this.renderer = renderer;
    }
  }, {
    key: "finished",
    get: function get() {
      return Boolean(this.firstMonomer && this.secondMonomer);
    }
  }, {
    key: "center",
    get: function get() {
      return Vec2.centre(this.startPosition, this.endPosition);
    }
  }, {
    key: "moveToLinkedMonomers",
    value: function moveToLinkedMonomers() {
      var _this$secondMonomer;
      var firstMonomerCenter = this.firstMonomer.position;
      var secondMonomerCenter = (_this$secondMonomer = this.secondMonomer) === null || _this$secondMonomer === void 0 ? void 0 : _this$secondMonomer.position;
      this.moveBondStartAbsolute(firstMonomerCenter.x, firstMonomerCenter.y);
      if (secondMonomerCenter) {
        this.moveBondEndAbsolute(secondMonomerCenter.x, secondMonomerCenter.y);
      }
    }
  }, {
    key: "moveBondStartAbsolute",
    value: function moveBondStartAbsolute(x, y) {
      this.moveAbsolute(new Vec2(x, y));
    }
  }, {
    key: "moveBondEndAbsolute",
    value: function moveBondEndAbsolute(x, y) {
      this.endPosition = new Vec2(x, y);
    }
  }, {
    key: "startPosition",
    get: function get() {
      return this.position;
    }
  }, {
    key: "getAnotherMonomer",
    value: function getAnotherMonomer(monomer) {
      return this.firstMonomer === monomer ? this.secondMonomer : this.firstMonomer;
    }
  }, {
    key: "isBackBoneChainConnection",
    get: function get() {
      return !this.isSideChainConnection;
    }
  }, {
    key: "isSideChainConnection",
    get: function get() {
      var _this$secondMonomer2;
      var firstMonomerAttachmentPoint = this.firstMonomer.getAttachmentPointByBond(this);
      var secondMonomerAttachmentPoint = (_this$secondMonomer2 = this.secondMonomer) === null || _this$secondMonomer2 === void 0 ? void 0 : _this$secondMonomer2.getAttachmentPointByBond(this);
      if (!firstMonomerAttachmentPoint || !secondMonomerAttachmentPoint) {
        return false;
      }
      return !(PolymerBond.backBoneChainAttachmentPoints.includes(firstMonomerAttachmentPoint) && PolymerBond.backBoneChainAttachmentPoints.includes(secondMonomerAttachmentPoint)) || firstMonomerAttachmentPoint === secondMonomerAttachmentPoint;
    }
  }], [{
    key: "backBoneChainAttachmentPoints",
    get: function get() {
      return [exports.AttachmentPointName.R1, exports.AttachmentPointName.R2];
    }
  }]);
  return PolymerBond;
}(DrawingEntity);

var MonomerSequenceNode = function () {
  function MonomerSequenceNode(monomer) {
    _classCallCheck__default["default"](this, MonomerSequenceNode);
    this.monomer = monomer;
  }
  _createClass__default["default"](MonomerSequenceNode, [{
    key: "SubChainConstructor",
    get: function get() {
      return this.monomer.SubChainConstructor;
    }
  }, {
    key: "firstMonomerInNode",
    get: function get() {
      return this.monomer;
    }
  }, {
    key: "lastMonomerInNode",
    get: function get() {
      return this.monomer;
    }
  }, {
    key: "monomers",
    get: function get() {
      return [this.monomer];
    }
  }, {
    key: "renderer",
    get: function get() {
      return this.monomer.renderer;
    }
  }, {
    key: "modified",
    get: function get() {
      return false;
    }
  }]);
  return MonomerSequenceNode;
}();

var Chain = function () {
  function Chain(firstMonomer, isCyclic) {
    _classCallCheck__default["default"](this, Chain);
    _defineProperty__default["default"](this, "subChains", []);
    _defineProperty__default["default"](this, "isCyclic", false);
    this.firstMonomer = null;
    if (firstMonomer) {
      this.firstMonomer = firstMonomer;
      this.fillSubChains(firstMonomer);
    }
    if (isCyclic) {
      this.isCyclic = isCyclic;
    }
  }
  _createClass__default["default"](Chain, [{
    key: "add",
    value: function add(monomer) {
      var _this$lastNode;
      var needCreateNewSubchain = !((_this$lastNode = this.lastNode) !== null && _this$lastNode !== void 0 && _this$lastNode.monomer) || monomer.isMonomerTypeDifferentForChaining(this.lastNode.monomer);
      if (needCreateNewSubchain) {
        this.subChains.push(new monomer.SubChainConstructor());
      }
      if (!(monomer instanceof Sugar)) {
        this.lastSubChain.add(new MonomerSequenceNode(monomer));
      } else if (isValidNucleoside(monomer)) {
        this.lastSubChain.add(Nucleoside.fromSugar(monomer));
      } else if (isValidNucleotide(monomer)) {
        this.lastSubChain.add(Nucleotide.fromSugar(monomer));
      } else {
        this.lastSubChain.add(new MonomerSequenceNode(monomer));
      }
    }
  }, {
    key: "fillSubChains",
    value: function fillSubChains(monomer) {
      if (!monomer) return;
      this.add(monomer);
      if (this.lastNode instanceof Nucleotide) {
        this.fillSubChains(getNextMonomerInChain(getPhosphateFromSugar(monomer), this.firstMonomer));
      } else {
        this.fillSubChains(getNextMonomerInChain(monomer, this.firstMonomer));
      }
    }
  }, {
    key: "lastSubChain",
    get: function get() {
      return this.subChains[this.subChains.length - 1];
    }
  }, {
    key: "lastNode",
    get: function get() {
      var _this$lastSubChain;
      return (_this$lastSubChain = this.lastSubChain) === null || _this$lastSubChain === void 0 ? void 0 : _this$lastSubChain.lastNode;
    }
  }, {
    key: "firstSubChain",
    get: function get() {
      return this.subChains[0];
    }
  }, {
    key: "firstNode",
    get: function get() {
      var _this$firstSubChain;
      return (_this$firstSubChain = this.firstSubChain) === null || _this$firstSubChain === void 0 ? void 0 : _this$firstSubChain.firstNode;
    }
  }, {
    key: "length",
    get: function get() {
      var length = 0;
      this.subChains.forEach(function (subChain) {
        length += subChain.length;
      });
      return length;
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return this.subChains.length === 1 && this.subChains[0].nodes.length === 1 && this.subChains[0].nodes[0] instanceof EmptySequenceNode;
    }
  }, {
    key: "forEachNode",
    value: function forEachNode(callback) {
      this.subChains.forEach(function (subChain) {
        subChain.nodes.forEach(function (node) {
          callback({
            node: node,
            subChain: subChain
          });
        });
      });
    }
  }]);
  return Chain;
}();

var ReinitializeSequenceModeCommand = function () {
  function ReinitializeSequenceModeCommand() {
    _classCallCheck__default["default"](this, ReinitializeSequenceModeCommand);
  }
  _createClass__default["default"](ReinitializeSequenceModeCommand, [{
    key: "execute",
    value: function execute(_renderersManager) {
      var editor = CoreEditor.provideEditorInstance();
      assert__default["default"](editor.mode instanceof SequenceMode);
      editor.mode.initialize(false);
    }
  }, {
    key: "invert",
    value: function invert(_renderersManager) {
      var editor = CoreEditor.provideEditorInstance();
      assert__default["default"](editor.mode instanceof SequenceMode);
      editor.mode.initialize(false);
    }
  }]);
  return ReinitializeSequenceModeCommand;
}();
var RestoreSequenceCaretPositionCommand = function () {
  function RestoreSequenceCaretPositionCommand(previousPosition, nextPosition) {
    _classCallCheck__default["default"](this, RestoreSequenceCaretPositionCommand);
    this.previousPosition = previousPosition;
    this.nextPosition = nextPosition;
    this.execute();
  }
  _createClass__default["default"](RestoreSequenceCaretPositionCommand, [{
    key: "execute",
    value: function execute() {
      SequenceRenderer.setCaretPosition(this.nextPosition);
    }
  }, {
    key: "invert",
    value: function invert(_renderersManager) {
      SequenceRenderer.setCaretPosition(this.previousPosition);
    }
  }]);
  return RestoreSequenceCaretPositionCommand;
}();

Raphael__default["default"].el.translateAbs = function (x, y) {
  this.delta = this.delta || new Vec2();
  this.delta.x += x - 0;
  this.delta.y += y - 0;
  this.transform('t' + this.delta.x.toString() + ',' + this.delta.y.toString());
};
Raphael__default["default"].st.translateAbs = function (x, y) {
  this.forEach(function (el) {
    el.translateAbs(x, y);
  });
};

var Visel = function () {
  function Visel(type) {
    _classCallCheck__default["default"](this, Visel);
    this.type = type;
    this.paths = [];
    this.boxes = [];
    this.boundingBox = null;
    this.oldBoundingBox = null;
    this.exts = [];
  }
  _createClass__default["default"](Visel, [{
    key: "add",
    value: function add(path, bb, ext) {
      this.paths.push(path);
      if (bb) {
        this.boxes.push(bb);
        this.boundingBox = this.boundingBox == null ? bb : Box2Abs.union(this.boundingBox, bb);
      }
      if (ext) this.exts.push(ext);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.paths = [];
      this.boxes = [];
      this.exts = [];
      if (this.boundingBox !== null) {
        this.oldBoundingBox = this.boundingBox.clone();
      }
      this.boundingBox = null;
    }
  }, {
    key: "translate",
    value: function translate() {
      if (arguments.length > 2) {
        throw new Error('One vector or two scalar arguments expected');
      }
      if (arguments.length === 1) {
        var vector = arguments.length <= 0 ? undefined : arguments[0];
        this.translate(vector.x, vector.y);
      } else {
        var x = arguments.length <= 0 ? undefined : arguments[0];
        var y = arguments.length <= 1 ? undefined : arguments[1];
        var delta = new Vec2(x, y);
        for (var i = 0; i < this.paths.length; ++i) {
          this.paths[i].translateAbs(x, y);
        }
        for (var j = 0; j < this.boxes.length; ++j) {
          this.boxes[j] = this.boxes[j].translate(delta);
        }
        if (this.boundingBox !== null) {
          this.boundingBox = this.boundingBox.translate(delta);
        }
      }
    }
  }, {
    key: "rotate",
    value: function rotate(degree, center) {
      for (var i = 0; i < this.paths.length; ++i) {
        this.paths[i].rotate(degree, center.x, center.y);
      }
      for (var j = 0; j < this.boxes.length; ++j) {
        this.boxes[j] = this.boxes[j].transform(function (point) {
          return point.rotateAroundOrigin(degree, center);
        });
      }
      if (this.boundingBox !== null) {
        this.boundingBox = this.boundingBox.transform(function (point) {
          return point.rotateAroundOrigin(degree, center);
        });
      }
    }
  }]);
  return Visel;
}();

var ReObject = function () {
  function ReObject(viselType) {
    _classCallCheck__default["default"](this, ReObject);
    _defineProperty__default["default"](this, "hover", false);
    _defineProperty__default["default"](this, "hovering", null);
    _defineProperty__default["default"](this, "selected", false);
    _defineProperty__default["default"](this, "selectionPlate", null);
    this.visel = new Visel(viselType);
  }
  _createClass__default["default"](ReObject, [{
    key: "changeSelectionStyle",
    value: function changeSelectionStyle(options) {
      var hoverStyle = options.hoverStyle;
      if (this.visel.type === 'simpleObject') {
        var _this$hovering;
        (_this$hovering = this.hovering) === null || _this$hovering === void 0 || _this$hovering.attr({
          'fill-opacity': this.selected ? 1 : 0
        });
      } else {
        var _this$hovering2;
        (_this$hovering2 = this.hovering) === null || _this$hovering2 === void 0 || _this$hovering2.attr({
          fill: hoverStyle.fill,
          'fill-opacity': this.selected ? 1 : 0
        });
      }
    }
  }, {
    key: "getVBoxObj",
    value: function getVBoxObj(render) {
      var vbox = this.visel.boundingBox;
      if (vbox === null) return null;
      if (render.options.offset) {
        vbox = vbox.translate(render.options.offset.negated());
      }
      return vbox.transform(Scale.canvasToModel, render.options);
    }
  }, {
    key: "setHover",
    value: function setHover(hover, render) {
      var options = render.options;
      if (hover) {
        var noredraw = 'hovering' in this && this.hovering !== null;
        if (noredraw) {
          if (this.hovering.type === 'set') {
            if (!this.hovering[0]) return;
            noredraw = !this.hovering[0].removed;
          } else {
            noredraw = !this.hovering.removed;
          }
        }
        if (noredraw) {
          this.changeSelectionStyle(options);
          this.hovering.show();
        } else {
          render.paper.setStart();
          this.drawHover(render);
          this.hovering = render.paper.setFinish();
        }
      } else if (this.hovering) {
        this.changeSelectionStyle(options);
        this.hovering.hide();
      }
      this.hover = hover;
    }
  }, {
    key: "drawHover",
    value: function drawHover(_render) {
      throw new Error('ReObject.drawHover is not overridden.');
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(_restruct, _paper, _styles) {
      throw new Error('ReObject.makeSelectionPlate is not overridden');
    }
  }]);
  return ReObject;
}();

exports.LayerMap = void 0;
(function (LayerMap) {
  LayerMap["background"] = "background";
  LayerMap["selectionPlate"] = "selectionPlate";
  LayerMap["hovering"] = "hovering";
  LayerMap["atom"] = "atom";
  LayerMap["bondSkeleton"] = "bondSkeleton";
  LayerMap["warnings"] = "warnings";
  LayerMap["data"] = "data";
  LayerMap["additionalInfo"] = "additionalInfo";
  LayerMap["indices"] = "indices";
})(exports.LayerMap || (exports.LayerMap = {}));
exports.StereoColoringType = void 0;
(function (StereoColoringType) {
  StereoColoringType["LabelsOnly"] = "LabelsOnly";
  StereoColoringType["BondsOnly"] = "BondsOnly";
  StereoColoringType["LabelsAndBonds"] = "LabelsAndBonds";
  StereoColoringType["Off"] = "Off";
})(exports.StereoColoringType || (exports.StereoColoringType = {}));
exports.StereLabelStyleType = void 0;
(function (StereLabelStyleType) {
  StereLabelStyleType["IUPAC"] = "Iupac";
  StereLabelStyleType["Classic"] = "Classic";
  StereLabelStyleType["On"] = "On";
  StereLabelStyleType["Off"] = "Off";
})(exports.StereLabelStyleType || (exports.StereLabelStyleType = {}));

function relBox(box) {
  return {
    x: box.x,
    y: box.y,
    width: box.width,
    height: box.height
  };
}
function shiftRayBox(p, d, bb) {
  assert__default["default"](!!p);
  assert__default["default"](!!d);
  assert__default["default"](!!bb);
  var b = [bb.p0, new Vec2(bb.p1.x, bb.p0.y), bb.p1, new Vec2(bb.p0.x, bb.p1.y)];
  var r = b.map(function (v) {
    return v.sub(p);
  });
  d = d.normalized();
  var rc = r.map(function (v) {
    return Vec2.cross(v, d);
  });
  var rd = r.map(function (v) {
    return Vec2.dot(v, d);
  });
  var pid = -1;
  var nid = -1;
  for (var i = 0; i < 4; ++i) {
    if (rc[i] > 0) {
      if (pid < 0 || rd[pid] < rd[i]) pid = i;
    } else if (nid < 0 || rd[nid] < rd[i]) {
      nid = i;
    }
  }
  if (nid < 0 || pid < 0) {
    return 0;
  }
  var id0 = rd[pid] > rd[nid] ? nid : pid;
  var id1 = rd[pid] > rd[nid] ? pid : nid;
  return rd[id0] + Math.abs(rc[id0]) * (rd[id1] - rd[id0]) / (Math.abs(rc[id0]) + Math.abs(rc[id1]));
}
function calcCoordinates(aPoint, bPoint, lengthHyp) {
  var obj = {
    pos1: null,
    pos2: null
  };
  var oPos2 = {
    x: bPoint.x - aPoint.x,
    y: bPoint.y - aPoint.y
  };
  var c = (Math.pow(lengthHyp, 2) - oPos2.x * oPos2.x - oPos2.y * oPos2.y - Math.pow(lengthHyp, 2)) / -2;
  var a = oPos2.x * oPos2.x + oPos2.y * oPos2.y;
  if (oPos2.x !== 0) {
    var b = -2 * oPos2.y * c;
    var e = c * c - lengthHyp * lengthHyp * oPos2.x * oPos2.x;
    var D = b * b - 4 * a * e;
    if (D > 0) {
      obj.pos1 = {
        x: 0,
        y: 0
      };
      obj.pos2 = {
        x: 0,
        y: 0
      };
      obj.pos1.y = (-b + Math.sqrt(D)) / (2 * a);
      obj.pos2.y = (-b - Math.sqrt(D)) / (2 * a);
      obj.pos1.x = (c - obj.pos1.y * oPos2.y) / oPos2.x;
      obj.pos2.x = (c - obj.pos2.y * oPos2.y) / oPos2.x;
    }
  } else {
    obj.pos1 = {
      x: 0,
      y: 0
    };
    obj.pos2 = {
      x: 0,
      y: 0
    };
    obj.pos1.y = c / oPos2.y;
    obj.pos2.y = c / oPos2.y;
    obj.pos1.x = -Math.sqrt(Math.pow(lengthHyp, 2) - Math.pow(c, 2) / Math.pow(oPos2.y, 2));
    obj.pos2.x = Math.sqrt(Math.pow(lengthHyp, 2) - Math.pow(c, 2) / Math.pow(oPos2.y, 2));
  }
  if (obj.pos1 !== null) {
    obj.pos1.x += aPoint.x;
    obj.pos1.y += aPoint.y;
  }
  if (obj.pos2 !== null) {
    obj.pos2.x += aPoint.x;
    obj.pos2.y += aPoint.y;
  }
  return obj;
}
function getCIPValuePath(_ref) {
  var paper = _ref.paper,
    cipLabelPosition = _ref.cipLabelPosition,
    atomOrBond = _ref.atomOrBond,
    options = _ref.options;
  var text = paper.text(cipLabelPosition.x, cipLabelPosition.y, "(".concat(atomOrBond.cip, ")")).attr({
    font: options.font,
    'font-size': options.fontsz
  });
  var box = text.getBBox();
  var path = paper.set();
  var rect = paper
  .rect(box.x - 1, box.y - 1, box.width + 2, box.height + 2, 3, 3).attr({
    fill: '#fff',
    stroke: '#fff'
  });
  path.push(rect.toFront(), text.toFront());
  return {
    path: path,
    text: text,
    rectangle: rect
  };
}
function drawCIPLabel(_ref2) {
  var atomOrBond = _ref2.atomOrBond,
    position = _ref2.position,
    restruct = _ref2.restruct,
    visel = _ref2.visel;
  var _restruct$render = restruct.render,
    options = _restruct$render.options,
    paper = _restruct$render.paper;
  var path = paper.set();
  var cipLabelPosition = position.scaled(options.microModeScale);
  var cipValuePath = getCIPValuePath({
    paper: paper,
    cipLabelPosition: cipLabelPosition,
    atomOrBond: atomOrBond,
    options: options
  });
  var box = relBox(cipValuePath.path.getBBox());
  cipValuePath.path.translateAbs(0.5 * box.width, -0.5 * box.height);
  path.push(cipValuePath.path.toFront());
  restruct.addReObjectPath(exports.LayerMap.additionalInfo, visel, path, null, true);
  return cipValuePath;
}
function updateHalfBondCoordinates(hb1, hb2, xShift) {
  if (hb1.p.y !== hb2.p.y) return [hb1, hb2];
  if (hb1.p.x < hb2.p.x && hb1.p.y === hb2.p.y) {
    hb1.p.x = hb1.p.x + xShift;
  } else if (hb1.p.x > hb2.p.x) {
    hb1.p.x = hb1.p.x - xShift;
  }
  return [hb1, hb2];
}
var util = {
  relBox: relBox,
  shiftRayBox: shiftRayBox,
  calcCoordinates: calcCoordinates,
  drawCIPLabel: drawCIPLabel,
  updateHalfBondCoordinates: updateHalfBondCoordinates
};

function ownKeys$q(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$q(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$q(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$q(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function rectangle(paper, points) {
  return paper.rect(
  tfx(Math.min(points[0].x, points[1].x)), tfx(Math.min(points[0].y, points[1].y)), tfx(Math.abs(points[1].x - points[0].x)), tfx(Math.abs(points[1].y - points[0].y)));
}
function rectangleArrowHighlightAndSelection(_paper, _ref, length, angle) {
  var _ref$pos = _slicedToArray__default["default"](_ref.pos, 1),
    start = _ref$pos[0],
    height = _ref.height;
  var endX = start.x + length;
  var wOffset = 5,
    hOffset = height || 8;
  var path = "M".concat(tfx(start.x - wOffset), ",").concat(tfx(start.y)) + "L".concat(tfx(start.x - wOffset), ",").concat(tfx(start.y - hOffset)) + "L".concat(tfx(endX + wOffset), ",").concat(tfx(start.y - hOffset)) + "L".concat(tfx(endX + wOffset), ",").concat(tfx(start.y + (!height ? hOffset : 0))) + "L".concat(tfx(start.x - wOffset), ",").concat(tfx(start.y + (!height ? hOffset : 0)), "Z");
  return svgPath__default["default"](path).rotate(angle, start.x, start.y).toString();
}
function ellipse(paper, points) {
  var rad = Vec2.diff(points[1], points[0]);
  var rx = rad.x / 2;
  var ry = rad.y / 2;
  return paper.ellipse(points[0].x + rx, points[0].y + ry, Math.abs(rx), Math.abs(ry));
}
function polyline(paper, points) {
  var path = ['M', points[0].x, points[0].y];
  for (var i = 1; i < points.length; i++) path.push('L', points[i].x, points[i].y);
  return paper.path(path);
}
function line(paper, points) {
  var path = ['M', points[0].x, points[0].y];
  path.push('L', points[1].x, points[1].y);
  return paper.path(path);
}
function arrow(paper, item, length, angle, options, isResizing) {
  var shouldApplySnappingStyle = isResizing && ['0', '-0', '90', '-90', '180', '-180'].includes(angle.toFixed());
  switch (item.mode) {
    case exports.RxnArrowMode.OpenAngle:
      {
        return arrowOpenAngle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.FilledTriangle:
      {
        return arrowFilledTriangle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.FilledBow:
      {
        return arrowFilledBow(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.DashedOpenAngle:
      {
        return arrowDashedOpenAngle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.Failed:
      {
        return arrowFailed(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.BothEndsFilledTriangle:
      {
        return arrowBothEndsFilledTriangle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.EquilibriumFilledHalfBow:
      {
        return arrowEquilibriumFilledHalfBow(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.EquilibriumFilledTriangle:
      {
        return arrowEquilibriumFilledTriangle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.EquilibriumOpenAngle:
      {
        return arrowEquilibriumOpenAngle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.UnbalancedEquilibriumFilledHalfBow:
      {
        return arrowUnbalancedEquilibriumFilledHalfBow(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.UnbalancedEquilibriumOpenHalfAngle:
      {
        return arrowUnbalancedEquilibriumOpenHalfAngle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.UnbalancedEquilibriumLargeFilledHalfBow:
      {
        return arrowUnbalancedEquilibriumLargeFilledHalfBow(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.UnbalancedEquilibriumFilledHalfTriangle:
      {
        return arrowUnbalancedEquilibriumFilledHalfTriangle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.EllipticalArcFilledBow:
      {
        return arrowEllipticalArcFilledBow(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.EllipticalArcFilledTriangle:
      {
        return arrowEllipticalArcFilledTriangle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.EllipticalArcOpenAngle:
      {
        return arrowEllipticalArcOpenAngle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
    case exports.RxnArrowMode.EllipticalArcOpenHalfAngle:
      {
        return arrowEllipticalArcOpenHalfAngle(paper, item, length, angle, options, shouldApplySnappingStyle);
      }
  }
}
function arrowEllipticalArcFilledBow(paper, _ref2, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref2$pos = _slicedToArray__default["default"](_ref2.pos, 1),
    start = _ref2$pos[0],
    height = _ref2.height;
  var direction = height >= 0 ? 1 : -1;
  var arrowHeadLength = direction * 10;
  var arrowHeadWidth = direction * 5;
  var arrowHeadAttr = direction * 4;
  var endX = start.x + arrowLength;
  var path = "M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "A".concat(arrowLength / 2, ",").concat(height, ",", 0, ",", 0, ",").concat(direction > 0 ? 1 : 0, ",").concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - arrowHeadWidth), ",").concat(tfx(start.y - arrowHeadLength)) + "l".concat(tfx(arrowHeadWidth), ",").concat(tfx(arrowHeadAttr)) + "l".concat(tfx(arrowHeadWidth), ",").concat(tfx(-arrowHeadAttr)) + "l".concat(tfx(-arrowHeadWidth), ",").concat(arrowHeadLength);
  var transformedPath = svgPath__default["default"](path).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), shouldApplySnappingStyle && {
    stroke: options.arrowSnappingStyle.stroke
  }));
}
function arrowEllipticalArcFilledTriangle(paper, _ref3, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref3$pos = _slicedToArray__default["default"](_ref3.pos, 1),
    start = _ref3$pos[0],
    height = _ref3.height;
  var direction = height >= 0 ? 1 : -1;
  var triangleLength = direction * 10;
  var triangleWidth = direction * 5;
  var endX = start.x + arrowLength;
  var path = "M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "A".concat(arrowLength / 2, ",").concat(height, ",", 0, ",", 0, ",").concat(direction > 0 ? 1 : 0, ",").concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - triangleWidth), ",").concat(tfx(start.y - triangleLength)) + "l".concat(tfx(triangleLength), ",").concat(tfx(0)) + "l".concat(tfx(-triangleWidth), ",").concat(tfx(triangleLength));
  var transformedPath = svgPath__default["default"](path).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), shouldApplySnappingStyle && {
    stroke: options.arrowSnappingStyle.stroke
  }));
}
function arrowEllipticalArcOpenAngle(paper, _ref4, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref4$pos = _slicedToArray__default["default"](_ref4.pos, 1),
    start = _ref4$pos[0],
    height = _ref4.height;
  var direction = height >= 0 ? 1 : -1;
  var width = direction * 5;
  var length = direction * 7;
  var endX = start.x + arrowLength;
  var path = "M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "A".concat(arrowLength / 2, ",").concat(height, ",", 0, ",", 0, ",").concat(direction > 0 ? 1 : 0, ",").concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - width), ",").concat(tfx(start.y - length)) + "M".concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX + width), ", ").concat(tfx(start.y - length));
  var transformedPath = svgPath__default["default"](path).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), shouldApplySnappingStyle && {
    stroke: options.arrowSnappingStyle.stroke
  }));
}
function arrowEllipticalArcOpenHalfAngle(paper, _ref5, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref5$pos = _slicedToArray__default["default"](_ref5.pos, 1),
    start = _ref5$pos[0],
    height = _ref5.height;
  var direction = height >= 0 ? 1 : -1;
  var width = direction * 5;
  var length = direction * 7;
  var endX = start.x + arrowLength;
  var path = "M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "A".concat(arrowLength / 2, ",").concat(height, ",", 0, ",", 0, ",").concat(direction > 0 ? 1 : 0, ", ").concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX + width), ", ").concat(tfx(start.y - length));
  var transformedPath = svgPath__default["default"](path).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), shouldApplySnappingStyle && {
    stroke: options.arrowSnappingStyle.stroke
  }));
}
function arrowOpenAngle(paper, _ref6, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref6$pos = _slicedToArray__default["default"](_ref6.pos, 1),
    start = _ref6$pos[0];
  var width = 5;
  var length = 7;
  var endX = start.x + arrowLength;
  var path = "M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "L".concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - length), ",").concat(tfx(start.y - width)) + "M".concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - length), ", ").concat(tfx(start.y + width));
  var transformedPath = svgPath__default["default"](path).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), shouldApplySnappingStyle && {
    stroke: options.arrowSnappingStyle.stroke
  }));
}
function arrowFilledTriangle(paper, _ref7, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref7$pos = _slicedToArray__default["default"](_ref7.pos, 1),
    start = _ref7$pos[0];
  var triangleLength = 10;
  var triangleWidth = 5;
  var endX = start.x + arrowLength;
  var path = "M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "L".concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - triangleLength), ",").concat(tfx(start.y + triangleWidth)) + "L".concat(tfx(endX - triangleLength), ",").concat(tfx(start.y - triangleWidth)) + "L".concat(tfx(endX), ",").concat(tfx(start.y), "Z");
  var transformedPath = svgPath__default["default"](path).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function arrowFilledBow(paper, _ref8, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref8$pos = _slicedToArray__default["default"](_ref8.pos, 1),
    start = _ref8$pos[0];
  var arrowHeadLength = 10;
  var arrowHeadWidth = 5;
  var arrowHeadAttr = 4;
  var endX = start.x + arrowLength;
  var path = "M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "L".concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - arrowHeadLength), ",").concat(tfx(start.y + arrowHeadWidth)) + "L".concat(tfx(endX - arrowHeadLength + arrowHeadAttr), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - arrowHeadLength), ",").concat(tfx(start.y - arrowHeadWidth)) + "L".concat(tfx(endX), ",").concat(tfx(start.y), "Z");
  var transformedPath = svgPath__default["default"](path).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function arrowDashedOpenAngle(paper, _ref9, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref9$pos = _slicedToArray__default["default"](_ref9.pos, 1),
    start = _ref9$pos[0];
  var triangleLength = 10;
  var triangleWidth = 5;
  var dashInterval = 3.5;
  var path = [];
  var endX = start.x + arrowLength;
  for (var i = 0; i < arrowLength / dashInterval; i++) {
    if (i % 2) {
      path.push("L".concat(tfx(start.x + i * dashInterval), ",").concat(tfx(start.y)));
    } else {
      path.push("M".concat(tfx(start.x + i * dashInterval), ",").concat(tfx(start.y)));
    }
  }
  path.push("M".concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - triangleLength), ",").concat(tfx(start.y + triangleWidth)) + "M".concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - triangleLength), ",").concat(tfx(start.y - triangleWidth)));
  var transformedPath = svgPath__default["default"](path.join('')).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function arrowFailed(paper, _ref10, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref10$pos = _slicedToArray__default["default"](_ref10.pos, 1),
    start = _ref10$pos[0];
  var arrowHeadLength = 10;
  var arrowHeadWidth = 5;
  var arrowHeadAttr = 4;
  var failSignWidth = 8;
  var endX = start.x + arrowLength;
  var arrowCenter = endX - (endX - start.x) / 2;
  var path = [];
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "L".concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - arrowHeadLength), ",").concat(tfx(start.y + arrowHeadWidth)) + "L".concat(tfx(endX - arrowHeadLength + arrowHeadAttr), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - arrowHeadLength), ",").concat(tfx(start.y - arrowHeadWidth)) + "L".concat(tfx(endX), ",").concat(tfx(start.y), "Z"));
  path.push("M".concat(tfx(arrowCenter + failSignWidth), ",").concat(tfx(start.y + failSignWidth)) + "L".concat(tfx(arrowCenter - failSignWidth), ",").concat(tfx(start.y - failSignWidth)));
  path.push("M".concat(tfx(arrowCenter + failSignWidth), ",").concat(tfx(start.y - failSignWidth)) + "L".concat(tfx(arrowCenter - failSignWidth), ",").concat(tfx(start.y + failSignWidth)));
  var transformedPath = svgPath__default["default"](path.join('')).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function arrowBothEndsFilledTriangle(paper, _ref11, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref11$pos = _slicedToArray__default["default"](_ref11.pos, 1),
    start = _ref11$pos[0];
  var triangleLength = 10;
  var triangleWidth = 5;
  var endX = start.x + arrowLength;
  var path = "M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "L".concat(tfx(endX), ",").concat(tfx(start.y)) + "L".concat(tfx(endX - triangleLength), ",").concat(tfx(start.y + triangleWidth)) + "L".concat(tfx(endX - triangleLength), ",").concat(tfx(start.y - triangleWidth)) + "L".concat(tfx(endX), ",").concat(tfx(start.y)) + "M".concat(tfx(start.x), ",").concat(tfx(start.y)) + "L".concat(tfx(start.x + triangleLength), ",").concat(tfx(start.y - triangleWidth)) + "L".concat(tfx(start.x + triangleLength), ",").concat(tfx(start.y + triangleWidth)) + "L".concat(tfx(start.x), ",").concat(tfx(start.y));
  var transformedPath = svgPath__default["default"](path).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function arrowEquilibriumFilledHalfBow(paper, _ref12, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref12$pos = _slicedToArray__default["default"](_ref12.pos, 1),
    start = _ref12$pos[0];
  var arrowLen = 9;
  var lineOffset = 3.5;
  var arrowOffset = 7;
  var arrowHeadAttr = 2;
  var endX = start.x + arrowLength;
  var path = [];
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX - arrowLen), ",").concat(tfx(start.y - arrowOffset)) + "L".concat(tfx(endX - arrowLen + arrowHeadAttr), ",").concat(tfx(start.y - lineOffset), "Z"));
  path.push("M".concat(tfx(endX), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(start.x), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(start.x + arrowLen), ",").concat(tfx(start.y + arrowOffset)) + "L".concat(tfx(start.x + arrowLen - arrowHeadAttr), ",").concat(start.y + lineOffset, "Z"));
  var transformedPath = svgPath__default["default"](path.join('')).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function arrowEquilibriumFilledTriangle(paper, _ref13, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref13$pos = _slicedToArray__default["default"](_ref13.pos, 1),
    start = _ref13$pos[0];
  var arrowLen = 9;
  var lineOffset = 3.5;
  var arrowOffset = 7;
  var endX = start.x + arrowLength;
  var path = [];
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX - arrowLen), ",").concat(tfx(start.y - arrowOffset)) + "L".concat(tfx(endX - arrowLen), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX - arrowLen), ",").concat(tfx(start.y)) + "L".concat(tfx(endX), ",").concat(tfx(start.y - lineOffset), "Z"));
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(endX), ",").concat(tfx(start.y + lineOffset)) + "M".concat(tfx(start.x), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(start.x + arrowLen), ",").concat(tfx(start.y + arrowOffset)) + "L".concat(tfx(start.x + arrowLen), ",").concat(start.y + lineOffset, "Z") + "L".concat(tfx(start.x + arrowLen), ",").concat(tfx(start.y)) + "L".concat(tfx(start.x + arrowLen), ",").concat(start.y + lineOffset, "Z"));
  var transformedPath = svgPath__default["default"](path.join('')).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function arrowEquilibriumOpenAngle(paper, _ref14, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref14$pos = _slicedToArray__default["default"](_ref14.pos, 1),
    start = _ref14$pos[0];
  var width = 5;
  var length = 7;
  var arrowLen = 9;
  var lineOffset = 3.5;
  var endX = start.x + arrowLength;
  var path = [];
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX - length), ",").concat(tfx(start.y - width - lineOffset)));
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(endX), ",").concat(tfx(start.y + lineOffset)) + "M".concat(tfx(start.x), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(start.x + arrowLen), ",").concat(tfx(start.y + lineOffset + width)));
  var transformedPath = svgPath__default["default"](path.join('')).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), shouldApplySnappingStyle && {
    stroke: options.arrowSnappingStyle.stroke
  }));
}
function arrowUnbalancedEquilibriumFilledHalfBow(paper, _ref15, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref15$pos = _slicedToArray__default["default"](_ref15.pos, 1),
    start = _ref15$pos[0];
  var arrowLen = 9;
  var lineOffset = 3.5;
  var arrowOffset = 7;
  var arrowHeadAttr = 2;
  var unbalanceVal = 15;
  var endX = start.x + arrowLength;
  var path = [];
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX - arrowLen), ",").concat(tfx(start.y - arrowOffset)) + "L".concat(tfx(endX - arrowLen + arrowHeadAttr), ",").concat(tfx(start.y - lineOffset), "Z"));
  path.push("M".concat(tfx(start.x + unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(endX - unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "M".concat(tfx(start.x + unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(start.x + arrowLen + unbalanceVal), ",").concat(tfx(start.y + arrowOffset)) + "L".concat(tfx(start.x + arrowLen - arrowHeadAttr + unbalanceVal), ",").concat(start.y + lineOffset, "Z"));
  var transformedPath = svgPath__default["default"](path.join('')).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function arrowUnbalancedEquilibriumOpenHalfAngle(paper, _ref16, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref16$pos = _slicedToArray__default["default"](_ref16.pos, 1),
    start = _ref16$pos[0];
  var width = 5;
  var length = 7;
  var arrowLen = 9;
  var lineOffset = 3.5;
  var unbalanceVal = 15;
  var endX = start.x + arrowLength;
  var path = [];
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX - length), ",").concat(tfx(start.y - width - lineOffset)));
  path.push("M".concat(tfx(start.x + unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(endX - unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "M".concat(tfx(start.x + unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(start.x + arrowLen + unbalanceVal), ",").concat(tfx(start.y + lineOffset + width)));
  var transformedPath = svgPath__default["default"](path.join('')).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), shouldApplySnappingStyle && {
    stroke: options.arrowSnappingStyle.stroke
  }));
}
function arrowUnbalancedEquilibriumLargeFilledHalfBow(paper, _ref17, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref17$pos = _slicedToArray__default["default"](_ref17.pos, 1),
    start = _ref17$pos[0];
  var arrowLen = 9;
  var lineOffset = 3.5;
  var arrowOffset = 10;
  var arrowHeadAttr = 2;
  var unbalanceVal = 15;
  var endX = start.x + arrowLength;
  var path = [];
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX - arrowLen), ",").concat(tfx(start.y - arrowOffset)) + "L".concat(tfx(endX - arrowLen + arrowHeadAttr), ",").concat(tfx(start.y - lineOffset), "Z"));
  path.push("M".concat(tfx(start.x + unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(endX - unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "M".concat(tfx(start.x + unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(start.x + arrowLen + unbalanceVal), ",").concat(tfx(start.y + arrowOffset)) + "L".concat(tfx(start.x + arrowLen - arrowHeadAttr + unbalanceVal), ",").concat(start.y + lineOffset, "Z"));
  var transformedPath = svgPath__default["default"](path.join('')).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function arrowUnbalancedEquilibriumFilledHalfTriangle(paper, _ref18, arrowLength, arrowAngle, options, shouldApplySnappingStyle) {
  var _ref18$pos = _slicedToArray__default["default"](_ref18.pos, 1),
    start = _ref18$pos[0];
  var arrowLen = 9;
  var lineOffset = 3.5;
  var arrowOffset = 7;
  var unbalanceVal = 15;
  var endX = start.x + arrowLength;
  var path = [];
  path.push("M".concat(tfx(start.x), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX), ",").concat(tfx(start.y - lineOffset)) + "L".concat(tfx(endX - arrowLen), ",").concat(tfx(start.y - arrowOffset)) + "L".concat(tfx(endX - arrowLen), ",").concat(tfx(start.y - lineOffset), "Z"));
  path.push("M".concat(tfx(start.x + unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(endX - unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "M".concat(tfx(start.x + unbalanceVal), ",").concat(tfx(start.y + lineOffset)) + "L".concat(tfx(start.x + arrowLen + unbalanceVal), ",").concat(tfx(start.y + arrowOffset)) + "L".concat(tfx(start.x + arrowLen + unbalanceVal), ",").concat(start.y + lineOffset, "Z"));
  var transformedPath = svgPath__default["default"](path.join('')).rotate(arrowAngle, start.x, start.y).toString();
  return paper.path(transformedPath).attr(_objectSpread$q(_objectSpread$q({}, options.lineattr), {}, {
    fill: '#000'
  }, shouldApplySnappingStyle && options.arrowSnappingStyle));
}
function plus(paper, point, options) {
  var s = options.microModeScale / 5;
  return paper.path('M{0},{4}L{0},{5}M{2},{1}L{3},{1}',
  tfx(point.x), tfx(point.y), tfx(point.x - s), tfx(point.x + s), tfx(point.y - s), tfx(point.y + s)).attr(options.lineattr);
}
function bondSingle(paper, halfBond1, halfBond2, options, isSnapping) {
  var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '#000';
  var a = halfBond1.p;
  var b = halfBond2.p;
  return paper.path(makeStroke(a, b)).attr(options.lineattr).attr({
    fill: color,
    stroke: color
  }).attr(isSnapping ? options.bondSnappingStyle : {});
}
function bondSingleUp(paper, a, b2, b3, options, isSnapping) {
  var color = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '#000';
  return paper.path('M{0},{1}L{2},{3}L{4},{5}Z',
  tfx(a.x), tfx(a.y), tfx(b2.x), tfx(b2.y), tfx(b3.x), tfx(b3.y)).attr(options.lineattr).attr({
    fill: color,
    stroke: color
  }).attr(isSnapping ? options.bondSnappingStyle : {});
}
function bondSingleStereoBold(paper, a1, a2, a3, a4, options, isSnapping) {
  var color = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : '#000';
  var bond = paper.path('M{0},{1}L{2},{3}L{4},{5}L{6},{7}Z',
  tfx(a1.x), tfx(a1.y), tfx(a2.x), tfx(a2.y), tfx(a3.x), tfx(a3.y), tfx(a4.x), tfx(a4.y)).attr(options.lineattr).attr({
    stroke: color,
    fill: color
  }).attr(isSnapping ? options.bondSnappingStyle : {});
  return bond;
}
function bondDoubleStereoBold(paper, sgBondPath, b1, b2, options, isSnapping) {
  var color = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '#000';
  return paper.set([sgBondPath, paper
  .path('M{0},{1}L{2},{3}', tfx(b1.x), tfx(b1.y), tfx(b2.x), tfx(b2.y)).attr(options.lineattr).attr({
    stroke: color,
    fill: color
  }).attr(isSnapping ? options.bondSnappingStyle : {})]);
}
function bondSingleDown(paper, halfBond1, d, nlines, step, options, isSnapping) {
  var color = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : '#000';
  var a = halfBond1.p;
  var n = halfBond1.norm;
  var bsp = 0.7 * options.stereoBond;
  var path = '';
  var p;
  var q;
  var r;
  for (var i = 0; i < nlines; ++i) {
    r = a.addScaled(d, step * i);
    p = r.addScaled(n, bsp * (i + 0.5) / (nlines - 0.5));
    q = r.addScaled(n, -bsp * (i + 0.5) / (nlines - 0.5));
    path += makeStroke(p, q);
  }
  return paper.path(path).attr(options.lineattr).attr({
    fill: color,
    stroke: color
  }).attr(isSnapping ? options.bondSnappingStyle : {});
}
function bondSingleEither(paper, halfBond1, d, nlines, step, options, isSnapping) {
  var color = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : '#000';
  var a = halfBond1.p;
  var n = halfBond1.norm;
  var bsp = 0.7 * options.stereoBond;
  var path = 'M' + tfx(a.x) + ',' + tfx(a.y);
  var r = a;
  for (var i = 0; i < nlines; ++i) {
    r = a.addScaled(d, step * (i + 0.5)).addScaled(n, (i & 1 ? -1 : +1) * bsp * (i + 0.5) / (nlines - 0.5));
    path += 'L' + tfx(r.x) + ',' + tfx(r.y);
  }
  return paper.path(path).attr(options.lineattr).attr({
    fill: color,
    stroke: color
  }).attr(isSnapping ? options.bondSnappingStyle : {});
}
function bondDouble(paper, a1, a2, b1, b2, cisTrans, options, isSnapping) {
  return paper.path(cisTrans ? 'M{0},{1}L{6},{7}M{4},{5}L{2},{3}' : 'M{0},{1}L{2},{3}M{4},{5}L{6},{7}',
  tfx(a1.x), tfx(a1.y), tfx(b1.x), tfx(b1.y), tfx(a2.x), tfx(a2.y), tfx(b2.x), tfx(b2.y)).attr(options.lineattr).attr(isSnapping ? options.bondSnappingStyle : {});
}
function bondSingleOrDouble(paper, halfBond1, halfBond2, nSect, options, isSnapping) {
  var a = halfBond1.p;
  var b = halfBond2.p;
  var n = halfBond1.norm;
  var bsp = options.bondSpace / 2;
  var path = '';
  var pi;
  var pp = a;
  for (var i = 1; i <= nSect; ++i) {
    pi = Vec2.lc2(a, (nSect - i) / nSect, b, i / nSect);
    if (i & 1) {
      path += makeStroke(pp, pi);
    } else {
      path += makeStroke(pp.addScaled(n, bsp), pi.addScaled(n, bsp));
      path += makeStroke(pp.addScaled(n, -bsp), pi.addScaled(n, -bsp));
    }
    pp = pi;
  }
  return paper.path(path).attr(options.lineattr).attr(isSnapping ? options.bondSnappingStyle : {});
}
function bondTriple(paper, halfBond1, halfBond2, options, isSnapping) {
  var color = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : '#000';
  var a = halfBond1.p;
  var b = halfBond2.p;
  var n = halfBond1.norm;
  var a2 = a.addScaled(n, options.bondSpace);
  var b2 = b.addScaled(n, options.bondSpace);
  var a3 = a.addScaled(n, -options.bondSpace);
  var b3 = b.addScaled(n, -options.bondSpace);
  return paper.path(makeStroke(a, b) + makeStroke(a2, b2) + makeStroke(a3, b3)).attr(options.lineattr).attr({
    fill: color,
    stroke: color
  }).attr(isSnapping ? options.bondSnappingStyle : {});
}
function bondAromatic(paper, paths, bondShift, options, isSnapping) {
  var l1 = paper.path(paths[0]).attr(options.lineattr).attr(isSnapping ? options.bondSnappingStyle : {});
  var l2 = paper.path(paths[1]).attr(options.lineattr).attr(isSnapping ? options.bondSnappingStyle : {});
  if (bondShift !== undefined && bondShift !== null) {
    (bondShift > 0 ? l1 : l2).attr({
      'stroke-dasharray': '- '
    });
  }
  return paper.set([l1, l2]);
}
function bondAny(paper, halfBond1, halfBond2, options, isSnapping) {
  var a = halfBond1.p;
  var b = halfBond2.p;
  return paper.path(makeStroke(a, b)).attr(options.lineattr).attr({
    'stroke-dasharray': '- '
  }).attr(isSnapping ? options.bondSnappingStyle : {});
}
function bondHydrogen(paper, halfBond1, halfBond2, options, isSnapping) {
  var a = halfBond1.p;
  var b = halfBond2.p;
  return paper.path(makeStroke(a, b)).attr(options.lineattr).attr({
    'stroke-dasharray': '.',
    'stroke-linecap': 'square'
  }).attr(isSnapping ? options.bondSnappingStyle : {});
}
function bondDative(paper, halfBond1, halfBond2, options, isSnapping) {
  var a = halfBond1.p;
  var b = halfBond2.p;
  return paper.path(makeStroke(a, b)).attr(options.lineattr).attr({
    'arrow-end': 'block-midium-long'
  }).attr(isSnapping ? options.bondSnappingStyle : {});
}
function reactingCenter(paper, points, options) {
  var pathDesc = '';
  for (var i = 0; i < points.length / 2; ++i) {
    pathDesc += makeStroke(points[2 * i], points[2 * i + 1]);
  }
  return paper.path(pathDesc).attr(options.lineattr);
}
function bondMark(paper, point, mark, options) {
  var path = paper.text(point.x, point.y, mark).attr({
    font: options.font,
    'font-size': options.fontszsub,
    fill: '#000'
  });
  var rbb = util.relBox(path.getBBox());
  recenterText(path, rbb);
  return path;
}
function radicalCap(paper, point1, options) {
  var s = options.lineWidth * 0.9;
  var dw = s;
  var dh = 2 * s;
  return paper.path('M{0},{1}L{2},{3}L{4},{5}',
  tfx(point1.x - dw), tfx(point1.y + dh), tfx(point1.x), tfx(point1.y), tfx(point1.x + dw), tfx(point1.y + dh)).attr({
    stroke: '#000',
    'stroke-width': options.lineWidth * 0.7,
    'stroke-linecap': 'square',
    'stroke-linejoin': 'miter'
  });
}
function radicalBullet(paper, point1, options) {
  return paper.circle(tfx(point1.x), tfx(point1.y), options.lineWidth).attr({
    stroke: null,
    fill: '#000'
  });
}
function bracket(paper, bracketAngleDirection, bracketDirection, bondCenter, bracketWidth, bracketHeight, options) {
  var isBracketContainAttachment = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  bracketWidth = bracketWidth || 0.25;
  bracketHeight = bracketHeight || 1.0;
  var halfBracketHeight = 0.5;
  var bracketPoint0, bracketPoint1;
  if (isBracketContainAttachment) {
    var longHalfBracketHeight = -0.8;
    var shortHalfBracketHeight = 0.2;
    bracketPoint0 = bondCenter.addScaled(bracketDirection, shortHalfBracketHeight * bracketHeight);
    bracketPoint1 = bondCenter.addScaled(bracketDirection, longHalfBracketHeight * bracketHeight);
  } else {
    bracketPoint0 = bondCenter.addScaled(bracketDirection, -halfBracketHeight * bracketHeight);
    bracketPoint1 = bondCenter.addScaled(bracketDirection, halfBracketHeight * bracketHeight);
  }
  var bracketArc0 = bracketPoint0.addScaled(bracketAngleDirection, -bracketWidth);
  var bracketArc1 = bracketPoint1.addScaled(bracketAngleDirection, -bracketWidth);
  return paper.path('M{0},{1}L{2},{3}L{4},{5}L{6},{7}',
  tfx(bracketArc0.x), tfx(bracketArc0.y), tfx(bracketPoint0.x), tfx(bracketPoint0.y), tfx(bracketPoint1.x), tfx(bracketPoint1.y), tfx(bracketArc1.x), tfx(bracketArc1.y)).attr(options.sgroupBracketStyle);
}
function selectionRectangle(paper, point1, point2, options) {
  return paper.rect(
  tfx(Math.min(point1.x, point2.x)), tfx(Math.min(point1.y, point2.y)), tfx(Math.abs(point2.x - point1.x)), tfx(Math.abs(point2.y - point1.y))).attr(options.lassoStyle);
}
function selectionPolygon(paper, r, options) {
  var v = r[r.length - 1];
  var pstr = 'M' + tfx(v.x) + ',' + tfx(v.y);
  for (var i = 0; i < r.length; ++i) {
    pstr += 'L' + tfx(r[i].x) + ',' + tfx(r[i].y);
  }
  return paper.path(pstr).attr(options.lassoStyle);
}
function selectionLine(paper, point1, point2, options) {
  return paper.path(makeStroke(point1, point2)).attr(options.lassoStyle);
}
function makeStroke(point1, point2) {
  return 'M' + tfx(point1.x) + ',' + tfx(point1.y) + 'L' + tfx(point2.x) + ',' + tfx(point2.y) + '	';
}
function dashedPath(point1, point2, dash) {
  var t0 = 0;
  var t1 = Vec2.dist(point1, point2);
  var d = Vec2.diff(point2, point1).normalized();
  var black = true;
  var path = '';
  var i = 0;
  while (t0 < t1) {
    var len = dash[i % dash.length];
    var t2 = t0 + Math.min(len, t1 - t0);
    if (black) {
      path += 'M ' + point1.addScaled(d, t0).coordStr() + ' L ' + point1.addScaled(d, t2).coordStr();
    }
    t0 += len;
    black = !black;
    i++;
  }
  return path;
}
function aromaticBondPaths(a2, a3, b2, b3, mask, dash) {
  var l1 = dash && mask & 1 ? dashedPath(a2, b2, dash) : makeStroke(a2, b2);
  var l2 = dash && mask & 2 ? dashedPath(a3, b3, dash) : makeStroke(a3, b3);
  return [l1, l2];
}
function recenterText(path, relativeBox) {
  if (Raphael__default["default"].vml) {
    var gap = relativeBox.height * 0.16;
    path.translateAbs(0, gap);
    relativeBox.y += gap;
  }
}
function rgroupAttachmentPoint(paper, shiftedAtomPositionVector, attachmentPointEnd, directionVector, options) {
  var linePath = paper.path('M{0},{1}L{2},{3}',
  tfx(shiftedAtomPositionVector.x), tfx(shiftedAtomPositionVector.y), tfx(attachmentPointEnd.x), tfx(attachmentPointEnd.y));
  var curvePath = paper.path(getSvgCurveShapeAttachmentPoint(attachmentPointEnd, directionVector, options.microModeScale));
  var resultShape = paper.set([curvePath, linePath]).attr(options.lineattr).attr({
    'stroke-width': options.lineWidth
  });
  return resultShape;
}
function getSvgCurveShapeAttachmentPoint(centerPosition, directionVector, basicSize) {
  var attachmentPointSvgPathString = "M13 1.5l-1.5 3.7c-0.3 0.8-1.5 0.8-1.9 0l-1.7-4.4c-0.3-0.8-1.5-0.8-1.9 0l-1.7 4.4c-0.3 0.8-1.5 0.8-1.8 0l-1.8-4.4c-0.3-0.8-1.5-0.8-1.8 0l-1.7 4.4c-0.3 0.8-1.5 0.8-1.9 0l-1.7-4.4c-0.3-0.8-1.5-0.8-1.9 0l-1.6 4.2c-0.3 0.9-1.6 0.8-1.9 0l-1.2-3.5";
  var attachmentPointSvgPathSize = 39.8;
  var shapeScale = basicSize / attachmentPointSvgPathSize;
  var angleDegrees = Math.atan2(directionVector.y, directionVector.x) * 180 / Math.PI - 90;
  return svgPath__default["default"](attachmentPointSvgPathString).rotate(angleDegrees).scale(shapeScale).translate(centerPosition.x, centerPosition.y).toString();
}
function rgroupAttachmentPointLabel(paper, labelPosition, labelText, options, fill) {
  var labelPath = paper.text(labelPosition.x, labelPosition.y, labelText).attr({
    font: options.font,
    'font-size': options.fontsz * 0.9,
    fill: fill
  });
  return labelPath;
}
var draw = {
  recenterText: recenterText,
  arrow: arrow,
  plus: plus,
  aromaticBondPaths: aromaticBondPaths,
  bondSingle: bondSingle,
  bondSingleUp: bondSingleUp,
  bondSingleStereoBold: bondSingleStereoBold,
  bondDoubleStereoBold: bondDoubleStereoBold,
  bondSingleDown: bondSingleDown,
  bondSingleEither: bondSingleEither,
  bondDouble: bondDouble,
  bondSingleOrDouble: bondSingleOrDouble,
  bondTriple: bondTriple,
  bondAromatic: bondAromatic,
  bondAny: bondAny,
  bondHydrogen: bondHydrogen,
  bondDative: bondDative,
  reactingCenter: reactingCenter,
  bondMark: bondMark,
  radicalCap: radicalCap,
  radicalBullet: radicalBullet,
  bracket: bracket,
  selectionRectangle: selectionRectangle,
  selectionPolygon: selectionPolygon,
  selectionLine: selectionLine,
  ellipse: ellipse,
  rectangle: rectangle,
  rectangleArrowHighlightAndSelection: rectangleArrowHighlightAndSelection,
  polyline: polyline,
  line: line,
  rgroupAttachmentPoint: rgroupAttachmentPoint,
  rgroupAttachmentPointLabel: rgroupAttachmentPointLabel
};

function ownKeys$p(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$p(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$p(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$p(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$R(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$R() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$R() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$R = function _isNativeReflectConstruct() { return !!t; })(); }
var StereoLabelMinOpacity = 0.3;
var MAX_LABEL_LENGTH = 8;
exports.ShowHydrogenLabels = void 0;
(function (ShowHydrogenLabels) {
  ShowHydrogenLabels["Off"] = "off";
  ShowHydrogenLabels["Hetero"] = "Hetero";
  ShowHydrogenLabels["Terminal"] = "Terminal";
  ShowHydrogenLabels["TerminalAndHetero"] = "Terminal and Hetero";
  ShowHydrogenLabels["On"] = "all";
})(exports.ShowHydrogenLabels || (exports.ShowHydrogenLabels = {}));
exports.ShowHydrogenLabelNames = void 0;
(function (ShowHydrogenLabelNames) {
  ShowHydrogenLabelNames["Off"] = "Off";
  ShowHydrogenLabelNames["Hetero"] = "Hetero";
  ShowHydrogenLabelNames["Terminal"] = "Terminal";
  ShowHydrogenLabelNames["TerminalAndHetero"] = "Terminal and Hetero";
  ShowHydrogenLabelNames["On"] = "On";
})(exports.ShowHydrogenLabelNames || (exports.ShowHydrogenLabelNames = {}));
var ReAtom = function (_ReObject) {
  _inherits__default["default"](ReAtom, _ReObject);
  function ReAtom(atom) {
    var _this;
    _classCallCheck__default["default"](this, ReAtom);
    _this = _callSuper$R(this, ReAtom, ['atom']);
    _this.a = atom;
    _this.showLabel = false;
    _this.hydrogenOnTheLeft = false;
    _this.color = '#000000';
    _this.component = -1;
    return _this;
  }
  _createClass__default["default"](ReAtom, [{
    key: "getVBoxObj",
    value: function getVBoxObj(render) {
      if (this.visel.boundingBox) {
        return ReObject.prototype.getVBoxObj.call(this, render);
      }
      return new Box2Abs(this.a.pp, this.a.pp);
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      var ret = this.makeHoverPlate(render);
      render.ctab.addReObjectPath(exports.LayerMap.atom, this.visel, ret);
      return ret;
    }
  }, {
    key: "getLabeledSelectionContour",
    value: function getLabeledSelectionContour(render) {
      var paper = render.paper,
        restruct = render.ctab,
        options = render.options;
      var fontsz = options.fontsz,
        radiusScaleFactor = options.radiusScaleFactor;
      var padding = fontsz * radiusScaleFactor;
      var radius = fontsz * radiusScaleFactor * 2;
      var box = this.getVBoxObj(restruct.render);
      var ps1 = Scale.modelToCanvas(box.p0, restruct.render.options);
      var ps2 = Scale.modelToCanvas(box.p1, restruct.render.options);
      var width = ps2.x - ps1.x;
      var height = fontsz * 1.23;
      return paper.rect(ps1.x - padding, ps1.y - padding, width + padding * 2, height + padding * 2, radius);
    }
  }, {
    key: "getUnlabeledSelectionContour",
    value: function getUnlabeledSelectionContour(render) {
      var paper = render.paper,
        options = render.options;
      var atomSelectionPlateRadius = options.atomSelectionPlateRadius;
      var ps = Scale.modelToCanvas(this.a.pp, options);
      return paper.circle(ps.x, ps.y, atomSelectionPlateRadius);
    }
  }, {
    key: "getSelectionContour",
    value: function getSelectionContour(render) {
      var hasLabel = this.a.pseudo && this.a.pseudo.length > 1 && !getQueryAttrsText(this) || this.showLabel && this.a.implicitH !== 0;
      return hasLabel ? this.getLabeledSelectionContour(render) : this.getUnlabeledSelectionContour(render);
    }
  }, {
    key: "makeHoverPlate",
    value: function makeHoverPlate(render) {
      var atom = this.a;
      var options = render.options;
      var sgroups = render.ctab.sgroups;
      var functionalGroups = render.ctab.molecule.functionalGroups;
      if (FunctionalGroup.isAtomInContractedFunctionalGroup(atom, sgroups, functionalGroups, true)) {
        return null;
      }
      return this.getSelectionContour(render).attr(options.hoverStyle);
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(restruct) {
      var atom = this.a;
      var render = restruct.render;
      var options = render.options;
      var sgroups = render.ctab.sgroups;
      var functionalGroups = render.ctab.molecule.functionalGroups;
      if (FunctionalGroup.isAtomInContractedFunctionalGroup(atom, sgroups, functionalGroups, true)) {
        return null;
      }
      return this.getSelectionContour(render).attr(options.selectionStyle);
    }
  }, {
    key: "getShiftedSegmentPosition",
    value: function getShiftedSegmentPosition(renderOptions, direction, _atomPosition) {
      var atomPosition = Scale.modelToCanvas(_atomPosition || this.a.pp, renderOptions);
      var atomSymbolShift = 0;
      var exts = this.visel.exts;
      for (var k = 0; k < exts.length; ++k) {
        var box = exts[k].translate(atomPosition);
        atomSymbolShift = Math.max(atomSymbolShift, util.shiftRayBox(atomPosition, direction, box));
      }
      if (atomSymbolShift > 0) {
        return atomPosition.addScaled(direction, atomSymbolShift + 3 * renderOptions.lineWidth);
      } else {
        return atomPosition;
      }
    }
  }, {
    key: "hasAttachmentPoint",
    value: function hasAttachmentPoint() {
      return Boolean(this.a.attachmentPoints);
    }
  }, {
    key: "show",
    value: function show(restruct, aid, options) {
      var _restruct$atoms$get;
      var atom = restruct.molecule.atoms.get(aid);
      var sgroups = restruct.molecule.sgroups;
      var functionalGroups = restruct.molecule.functionalGroups;
      var render = restruct.render;
      var ps = Scale.modelToCanvas(this.a.pp, render.options);
      if (FunctionalGroup.isAtomInContractedFunctionalGroup(atom, sgroups, functionalGroups, false)) {
        var sgroup = restruct.molecule.getGroupFromAtomId(aid);
        var isPositionAtom = (sgroup === null || sgroup === void 0 ? void 0 : sgroup.getContractedPosition(restruct.molecule).atomId) === aid;
        if (isPositionAtom) {
          var position = Scale.modelToCanvas(sgroup instanceof MonomerMicromolecule ? sgroup.pp : this.a.pp, render.options);
          var path = render.paper.text(position.x, position.y, sgroup.data.name).attr({
            'font-weight': '700',
            'font-size': 14
          });
          restruct.addReObjectPath(exports.LayerMap.data, this.visel, path, position, true);
        }
        return;
      }
      this.hydrogenOnTheLeft = shouldHydrogenBeOnLeft(restruct.molecule, this);
      this.showLabel = isLabelVisible(restruct, render.options, this);
      this.color = 'black';
      var delta;
      var rightMargin;
      var leftMargin;
      var implh;
      var isHydrogen;
      var label;
      var index = null;
      if (this.showLabel) {
        var data = buildLabel(this, render.paper, ps, options);
        delta = 0.5 * options.lineWidth;
        label = data.label;
        rightMargin = data.rightMargin;
        leftMargin = data.leftMargin;
        implh = Math.floor(this.a.implicitH);
        isHydrogen = label.text === 'H';
        if (label.background) {
          restruct.addReObjectPath(exports.LayerMap.data, this.visel, label.background, ps, true);
        }
        restruct.addReObjectPath(exports.LayerMap.data, this.visel, label.path, ps, true);
      }
      if (options.showAtomIds) {
        index = {};
        index.text = aid.toString();
        var idPos = this.hydrogenOnTheLeft ? Vec2.lc(ps, 1, new Vec2({
          x: -2,
          y: 0,
          z: 0
        }), 6) : Vec2.lc(ps, 1, new Vec2({
          x: 2,
          y: 0,
          z: 0
        }), 6);
        if (this.showLabel) {
          idPos = Vec2.lc(idPos, 1, new Vec2({
            x: 1,
            y: -3,
            z: 0
          }), 6);
        }
        index.path = render.paper.text(idPos.x, idPos.y, index.text).attr({
          font: options.font,
          'font-size': options.fontszsub,
          fill: '#070'
        });
        index.rbb = util.relBox(index.path.getBBox());
        draw.recenterText(index.path, index.rbb);
        restruct.addReObjectPath(exports.LayerMap.indices, this.visel, index.path, ps);
      }
      if (this.showLabel) {
        var hydroIndex = null;
        if (isHydrogen && implh > 0) {
          hydroIndex = showHydroIndex(this, render, implh, rightMargin);
          rightMargin += hydroIndex.rbb.width + delta;
          restruct.addReObjectPath(exports.LayerMap.data, this.visel, hydroIndex.path, ps, true);
        }
        if (this.a.radical !== 0) {
          var radical = showRadical(this, render);
          restruct.addReObjectPath(exports.LayerMap.data, this.visel, radical.path, ps, true);
        }
        if (this.a.isotope !== null) {
          var isotope = showIsotope(this, render, leftMargin);
          leftMargin -= isotope.rbb.width + delta;
          restruct.addReObjectPath(exports.LayerMap.data, this.visel, isotope.path, ps, true);
        }
        if (!isHydrogen && !this.a.alias && implh > 0 && displayHydrogen(this, options.showHydrogenLabels)) {
          var _data = showHydrogen(this, render, implh, {
            hydrogen: {},
            hydroIndex: hydroIndex,
            rightMargin: rightMargin,
            leftMargin: leftMargin
          });
          var hydrogen = _data.hydrogen;
          hydroIndex = _data.hydroIndex;
          rightMargin = _data.rightMargin;
          leftMargin = _data.leftMargin;
          restruct.addReObjectPath(exports.LayerMap.data, this.visel, hydrogen.path, ps, true);
          if (hydroIndex != null) {
            restruct.addReObjectPath(exports.LayerMap.data, this.visel, hydroIndex.path, ps, true);
          }
        }
        if (this.a.charge !== null && options.showCharge) {
          var charge = showCharge(this, render, rightMargin);
          rightMargin += charge.rbb.width + delta;
          restruct.addReObjectPath(exports.LayerMap.data, this.visel, charge.path, ps, true);
        }
        if (this.a.explicitValence >= 0 && options.showValence) {
          var valence = showExplicitValence(this, render, rightMargin);
          rightMargin += valence.rbb.width + delta;
          restruct.addReObjectPath(exports.LayerMap.data, this.visel, valence.path, ps, true);
        }
        if (this.a.badConn && options.showValenceWarnings) {
          var warning = showWarning(this, render, leftMargin, rightMargin);
          restruct.addReObjectPath(exports.LayerMap.warnings, this.visel, warning.path, ps, true);
        }
        if (index) {
          pathAndRBoxTranslate(index.path, index.rbb, -0.5 * label.rbb.width - 0.5 * index.rbb.width - delta, 0.3 * label.rbb.height);
        }
      }
      this.setHover(this.hover, render);
      var stereoLabel = this.a.stereoLabel;
      var aamText = getAamText(this);
      var customQueryText = checkIsSmartPropertiesExist(this.a) ? getOnlyQueryAttributesCustomQuery(this.a) : getQueryAttrsText(this);
      var shortenCustomQueryText = customQueryText;
      var customQueryTooltipText;
      if (shortenCustomQueryText.length > MAX_LABEL_LENGTH) {
        customQueryTooltipText = shortenCustomQueryText;
        shortenCustomQueryText = "".concat(shortenCustomQueryText.substring(0, MAX_LABEL_LENGTH), "...");
      }
      var fragmentId = Number((_restruct$atoms$get = restruct.atoms.get(aid)) === null || _restruct$atoms$get === void 0 ? void 0 : _restruct$atoms$get.a.fragment);
      var fragment = restruct.molecule.frags.get(fragmentId);
      var displayStereoLabel = shouldDisplayStereoLabel(stereoLabel, options.stereoLabelStyle, options.ignoreChiralFlag, fragment === null || fragment === void 0 ? void 0 : fragment.enhancedStereoFlag);
      var text = '';
      if (displayStereoLabel) {
        text = "".concat(stereoLabel, "\n");
      }
      if (shortenCustomQueryText.length > 0) {
        text += "".concat(shortenCustomQueryText, "\n");
      }
      if (aamText.length > 0) {
        text += ".".concat(aamText, ".");
      }
      if (text.length > 0) {
        var elem = Elements.get(this.a.label);
        var aamPath = render.paper.text(ps.x, ps.y, text).attr({
          font: options.font,
          'font-size': options.fontszsub,
          fill: options.atomColoring && elem ? ElementColor[this.a.label] : '#000'
        });
        if (stereoLabel) {
          var color = getStereoAtomColor(render.options, stereoLabel);
          aamPath.node.childNodes[0].setAttribute('fill', color);
          var opacity = getStereoAtomOpacity(render.options, stereoLabel);
          aamPath.node.childNodes[0].setAttribute('fill-opacity', opacity);
        }
        var aamBox = util.relBox(aamPath.getBBox());
        draw.recenterText(aamPath, aamBox);
        var visel = this.visel;
        var t = 3;
        var dir = this.bisectLargestSector(restruct.molecule);
        for (var i = 0; i < visel.exts.length; ++i) {
          t = Math.max(t, util.shiftRayBox(ps, dir, visel.exts[i].translate(ps)));
        }
        t += util.shiftRayBox(ps, dir.negated(), Box2Abs.fromRelBox(aamBox));
        dir = dir.scaled(8 + t);
        pathAndRBoxTranslate(aamPath, aamBox, dir.x, dir.y);
        restruct.addReObjectPath(exports.LayerMap.data, this.visel, aamPath, ps, true);
        if (customQueryTooltipText) {
          addTooltip(aamPath.node, customQueryTooltipText);
        }
      }
      var highlights = restruct.molecule.highlights;
      var isHighlighted = false;
      var highlightColor = '';
      highlights.forEach(function (highlight) {
        var _highlight$atoms;
        var hasCurrentHighlight = (_highlight$atoms = highlight.atoms) === null || _highlight$atoms === void 0 ? void 0 : _highlight$atoms.includes(aid);
        isHighlighted = isHighlighted || hasCurrentHighlight;
        if (hasCurrentHighlight) {
          highlightColor = highlight.color;
        }
      });
      if (isHighlighted) {
        var style = {
          fill: highlightColor,
          stroke: 'none'
        };
        var _ps = Scale.modelToCanvas(this.a.pp, restruct.render.options);
        var _path = render.paper.circle(_ps.x, _ps.y, options.atomSelectionPlateRadius * 0.8).attr(style);
        restruct.addReObjectPath(exports.LayerMap.hovering, this.visel, _path);
      }
      if (atom.cip) {
        this.cip = util.drawCIPLabel({
          atomOrBond: atom,
          position: atom.pp,
          restruct: render.ctab,
          visel: this.visel
        });
      }
    }
  }, {
    key: "getLargestSectorFromNeighbors",
    value: function getLargestSectorFromNeighbors(struct) {
      var angles = [];
      this.a.neighbors.forEach(function (halfBondId) {
        var halfBond = struct.halfBonds.get(halfBondId);
        halfBond && angles.push(halfBond.ang);
      });
      angles = angles.sort(function (a, b) {
        return a - b;
      });
      var largeAngles = [];
      for (var i = 0; i < angles.length - 1; ++i) {
        largeAngles.push(angles[(i + 1) % angles.length] - angles[i]);
      }
      largeAngles.push(angles[0] - angles[angles.length - 1] + 2 * Math.PI);
      var largestAngle = 0;
      var neighborAngle = -Math.PI / 2;
      for (var _i = 0; _i < angles.length; ++_i) {
        if (largeAngles[_i] > largestAngle) {
          largestAngle = largeAngles[_i];
          neighborAngle = angles[_i];
        }
      }
      return {
        neighborAngle: neighborAngle,
        largestAngle: largestAngle
      };
    }
  }, {
    key: "bisectLargestSector",
    value: function bisectLargestSector(struct) {
      var _this$getLargestSecto = this.getLargestSectorFromNeighbors(struct),
        largestAngle = _this$getLargestSecto.largestAngle,
        neighborAngle = _this$getLargestSecto.neighborAngle;
      var bisectAngle = neighborAngle + largestAngle / 2;
      return newVectorFromAngle$1(bisectAngle);
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }]);
  return ReAtom;
}(ReObject);
function getStereoAtomColor(options, stereoLabel) {
  if (!stereoLabel || options.colorStereogenicCenters === exports.StereoColoringType.Off || options.colorStereogenicCenters === exports.StereoColoringType.BondsOnly) {
    return '#000';
  }
  return getColorFromStereoLabel(options, stereoLabel);
}
function getColorFromStereoLabel(options, stereoLabel) {
  var stereoLabelType = stereoLabel.match(/\D+/g)[0];
  switch (stereoLabelType) {
    case exports.StereoLabel.And:
      return options.colorOfAndCenters;
    case exports.StereoLabel.Or:
      return options.colorOfOrCenters;
    case exports.StereoLabel.Abs:
      return options.colorOfAbsoluteCenters;
    default:
      return '#000';
  }
}
function getStereoAtomOpacity(options, stereoLabel) {
  var stereoLabelType = stereoLabel.match(/\D+/g)[0];
  var stereoLabelNumber = +stereoLabel.replace(stereoLabelType, '');
  if (!options.autoFadeOfStereoLabels || stereoLabelType === exports.StereoLabel.Abs || options.colorStereogenicCenters === exports.StereoColoringType.Off || options.colorStereogenicCenters === exports.StereoColoringType.BondsOnly) {
    return 1;
  }
  return Math.max(1 - (stereoLabelNumber - 1) / 10, StereoLabelMinOpacity);
}
function shouldDisplayStereoLabel(stereoLabel, labelStyle, ignoreChiralFlag, flag) {
  if (!stereoLabel) {
    return false;
  }
  var stereoLabelType = stereoLabel.match(/\D+/g)[0];
  if (ignoreChiralFlag && stereoLabelType === exports.StereoLabel.Abs) {
    return false;
  }
  if (ignoreChiralFlag && stereoLabelType !== exports.StereoLabel.Abs) {
    return true;
  }
  switch (labelStyle) {
    case exports.StereLabelStyleType.Off:
      return false;
    case exports.StereLabelStyleType.On:
      return true;
    case exports.StereLabelStyleType.Classic:
      return !!(flag === exports.StereoFlag.Mixed || stereoLabelType === exports.StereoLabel.Or);
    case exports.StereLabelStyleType.IUPAC:
      return !!(flag === exports.StereoFlag.Mixed && stereoLabelType !== exports.StereoLabel.Abs);
    default:
      return true;
  }
}
function isLabelVisible(restruct, options, atom) {
  var isAttachmentPointAtom = Boolean(atom.a.attachmentPoints);
  var isCarbon = atom.a.label.toLowerCase() === 'c';
  var visibleTerminal = options.showHydrogenLabels !== exports.ShowHydrogenLabels.Off && options.showHydrogenLabels !== exports.ShowHydrogenLabels.Hetero;
  var neighborsLength = atom.a.neighbors.length === 0 || atom.a.neighbors.length < 2 && visibleTerminal;
  if (isAttachmentPointAtom && isCarbon) {
    return false;
  }
  var shouldBeVisible = neighborsLength || options.carbonExplicitly || options.showHydrogenLabels === exports.ShowHydrogenLabels.On || atom.a.alias || atom.a.isotope !== null || atom.a.radical !== 0 || atom.a.charge !== null || atom.a.explicitValence >= 0 || atom.a.atomList !== null || atom.a.rglabel !== null || atom.a.badConn && options.showValenceWarnings || atom.a.label.toLowerCase() !== 'c';
  if (shouldBeVisible) return true;
  if (atom.a.neighbors.length === 2) {
    var nei1 = atom.a.neighbors[0];
    var nei2 = atom.a.neighbors[1];
    var hb1 = restruct.molecule.halfBonds.get(nei1);
    var hb2 = restruct.molecule.halfBonds.get(nei2);
    var bond1 = restruct.bonds.get(hb1.bid);
    var bond2 = restruct.bonds.get(hb2.bid);
    var sameNotStereo = bond1.b.type === bond2.b.type && bond1.b.stereo === Bond.PATTERN.STEREO.NONE && bond2.b.stereo === Bond.PATTERN.STEREO.NONE;
    if (sameNotStereo && Math.abs(Vec2.cross(hb1.dir, hb2.dir)) < 0.2) {
      return true;
    }
  }
  return false;
}
function displayHydrogen(atom, hydrogenLabels) {
  var _atom$label, _atom$label2;
  return hydrogenLabels === exports.ShowHydrogenLabels.On || hydrogenLabels === exports.ShowHydrogenLabels.Terminal && atom.a.neighbors.length < 2 || hydrogenLabels === exports.ShowHydrogenLabels.Hetero && ((_atom$label = atom.label) === null || _atom$label === void 0 ? void 0 : _atom$label.text.toLowerCase()) !== 'c' || hydrogenLabels === exports.ShowHydrogenLabels.TerminalAndHetero && (atom.a.neighbors.length < 2 || ((_atom$label2 = atom.label) === null || _atom$label2 === void 0 ? void 0 : _atom$label2.text.toLowerCase()) !== 'c');
}
function shouldHydrogenBeOnLeft(struct, atom) {
  if (atom.a.neighbors.length === 0) {
    if (atom.a.label === 'D' || atom.a.label === 'T') {
      return false;
    } else {
      var element = Elements.get(atom.a.label);
      return !element || Boolean(element.leftH);
    }
  }
  if (atom.a.neighbors.length === 1) {
    var neighbor = atom.a.neighbors[0];
    var neighborDirection = struct.halfBonds.get(neighbor).dir;
    return neighborDirection.x > 0;
  }
  return false;
}
function getOnlyQueryAttributesCustomQuery(atom) {
  var queryText = atom.queryProperties.customQuery || getAtomCustomQuery(_objectSpread$p(_objectSpread$p({}, atom), atom.queryProperties), true);
  return queryText;
}
function addTooltip(node, text) {
  var tooltip = "<p>".concat(text.split(/(?<=[;,])/).join(' '), "</p>");
  node.childNodes[0].setAttribute('data-tooltip', tooltip);
}
function buildLabel(atom, paper, ps, options) {
  var _options$connectedMon, _label$text;
  var label = {
    text: getLabelText(atom.a)
  };
  var tooltip = null;
  if (!label.text) {
    label.text = 'R#';
  }
  if (label.text === atom.a.label) {
    var element = Elements.get(label.text);
    if (options.atomColoring && element) {
      atom.color = ElementColor[label.text] || '#000';
    }
  }
  var isMonomerAttachmentPoint = attachmentPointNames.includes(label.text);
  var isMonomerAttachmentPointSelected = options.currentlySelectedMonomerAttachmentPoint === label.text;
  var isMonomerAttachmentPointUsed = (_options$connectedMon = options.connectedMonomerAttachmentPoints) === null || _options$connectedMon === void 0 ? void 0 : _options$connectedMon.includes(label.text);
  if (isMonomerAttachmentPoint && options.labelInMonomerConnectionsModal) {
    atom.color = isMonomerAttachmentPointSelected ? '#FFF' : isMonomerAttachmentPointUsed ? '#B4B9D6' : '#585858';
  }
  if (((_label$text = label.text) === null || _label$text === void 0 ? void 0 : _label$text.length) > MAX_LABEL_LENGTH) {
    var _label$text2;
    tooltip = label.text;
    label.text = "".concat((_label$text2 = label.text) === null || _label$text2 === void 0 ? void 0 : _label$text2.substring(0, 8), "...");
  }
  var previewOpacity = options.previewOpacity;
  label.path = paper.text(ps.x, ps.y, label.text).attr({
    font: options.font,
    'font-size': options.fontsz,
    fill: atom.color,
    'font-style': atom.a.pseudo ? 'italic' : '',
    'fill-opacity': atom.a.isPreview ? previewOpacity : 1
  });
  if (isMonomerAttachmentPoint && options.labelInMonomerConnectionsModal) {
    var fill = isMonomerAttachmentPointSelected ? '#167782' : isMonomerAttachmentPointUsed ? '#E1E5EA' : '#FFF';
    var backgroundSize = options.fontsz * 2;
    label.background = paper.rect(ps.x - backgroundSize / 2, ps.y - backgroundSize / 2, backgroundSize, backgroundSize, 10).attr({
      fill: fill
    }).attr({
      stroke: isMonomerAttachmentPointUsed ? '#B4B9D6' : '#7C7C7F'
    });
  }
  if (tooltip) {
    addTooltip(label.path.node, tooltip);
  }
  label.rbb = util.relBox(label.path.getBBox());
  draw.recenterText(label.path, label.rbb);
  var rightMargin = label.rbb.width / 2 * (options.zoom > 1 ? 1 : options.zoom);
  var leftMargin = -label.rbb.width / 2 * (options.zoom > 1 ? 1 : options.zoom);
  if (atom.a.atomList !== null) {
    var xShift = (atom.hydrogenOnTheLeft ? -1 : 1) * (label.rbb.width - label.rbb.height) / 2;
    pathAndRBoxTranslate(label.path, label.rbb, xShift, 0);
    rightMargin += xShift;
    leftMargin += xShift;
  }
  atom.label = label;
  return {
    label: label,
    rightMargin: rightMargin,
    leftMargin: leftMargin
  };
}
function getLabelText(atom) {
  if (atom.atomList !== null) return atom.atomList.label();
  if (atom.pseudo) return atom.pseudo;
  if (atom.alias) return atom.alias;
  if (atom.label === 'R#' && atom.rglabel !== null) {
    var text = '';
    for (var rgi = 0; rgi < 32; rgi++) {
      if (atom.rglabel & 1 << rgi) {
        text += 'R' + (rgi + 1).toString();
      }
    }
    return text;
  }
  return atom.label;
}
function showHydroIndex(atom, render, implh, rightMargin) {
  var ps = Scale.modelToCanvas(atom.a.pp, render.options);
  var options = render.options;
  var delta = 0.5 * options.lineWidth;
  var hydroIndex = {};
  hydroIndex.text = (implh + 1).toString();
  hydroIndex.path = render.paper.text(ps.x, ps.y, hydroIndex.text).attr({
    font: options.font,
    'font-size': options.fontszsub,
    fill: atom.color
  });
  hydroIndex.rbb = util.relBox(hydroIndex.path.getBBox());
  draw.recenterText(hydroIndex.path, hydroIndex.rbb);
  pathAndRBoxTranslate(hydroIndex.path, hydroIndex.rbb, rightMargin + 0.5 * hydroIndex.rbb.width + delta, 0.2 * atom.label.rbb.height);
  return hydroIndex;
}
function showRadical(atom, render) {
  var ps = Scale.modelToCanvas(atom.a.pp, render.options);
  var options = render.options;
  var paper = render.paper;
  var radical = {};
  var hshift;
  switch (atom.a.radical) {
    case 1:
      radical.path = paper.set();
      hshift = 1.6 * options.lineWidth;
      radical.path.push(draw.radicalBullet(paper, ps.add(new Vec2(-hshift, 0)), options), draw.radicalBullet(paper, ps.add(new Vec2(hshift, 0)), options));
      radical.path.attr('fill', atom.color);
      break;
    case 2:
      radical.path = paper.set();
      radical.path.push(draw.radicalBullet(paper, ps, options));
      radical.path.attr('fill', atom.color);
      break;
    case 3:
      radical.path = paper.set();
      hshift = 1.6 * options.lineWidth;
      radical.path.push(draw.radicalCap(paper, ps.add(new Vec2(-hshift, 0)), options), draw.radicalCap(paper, ps.add(new Vec2(hshift, 0)), options));
      radical.path.attr('stroke', atom.color);
      break;
  }
  radical.rbb = util.relBox(radical.path.getBBox());
  var vshift = -0.5 * (atom.label.rbb.height + radical.rbb.height);
  if (atom.a.radical === 3) vshift -= options.lineWidth / 2;
  pathAndRBoxTranslate(radical.path, radical.rbb, 0, vshift);
  return radical;
}
function showIsotope(atom, render, leftMargin) {
  var ps = Scale.modelToCanvas(atom.a.pp, render.options);
  var options = render.options;
  var delta = 0.5 * options.lineWidth;
  var isotope = {};
  isotope.text = atom.a.isotope === null ? '' : atom.a.isotope.toString();
  isotope.path = render.paper.text(ps.x, ps.y, isotope.text).attr({
    font: options.font,
    'font-size': options.fontszsub,
    fill: atom.color
  });
  isotope.rbb = util.relBox(isotope.path.getBBox());
  draw.recenterText(isotope.path, isotope.rbb);
  pathAndRBoxTranslate(isotope.path, isotope.rbb, leftMargin - 0.5 * isotope.rbb.width - delta, -0.3 * atom.label.rbb.height);
  return isotope;
}
function showCharge(atom, render, rightMargin) {
  var ps = Scale.modelToCanvas(atom.a.pp, render.options);
  var options = render.options;
  var delta = 0.5 * options.lineWidth;
  var charge = {};
  charge.text = '';
  if (atom.a.charge !== null) {
    var absCharge = Math.abs(atom.a.charge);
    if (absCharge !== 1) charge.text = absCharge.toString();
    if (atom.a.charge < 0) charge.text += "\u2013";else charge.text += '+';
  } else {
    charge.text = '';
  }
  charge.path = render.paper.text(ps.x, ps.y, charge.text).attr({
    font: options.font,
    'font-size': options.fontszsub,
    fill: atom.color
  });
  charge.rbb = util.relBox(charge.path.getBBox());
  draw.recenterText(charge.path, charge.rbb);
  pathAndRBoxTranslate(charge.path, charge.rbb, rightMargin + 0.5 * charge.rbb.width + delta, -0.3 * atom.label.rbb.height);
  return charge;
}
function showExplicitValence(atom, render, rightMargin) {
  var mapValence = {
    0: '0',
    1: 'I',
    2: 'II',
    3: 'III',
    4: 'IV',
    5: 'V',
    6: 'VI',
    7: 'VII',
    8: 'VIII',
    9: 'IX',
    10: 'X',
    11: 'XI',
    12: 'XII',
    13: 'XIII',
    14: 'XIV'
  };
  var ps = Scale.modelToCanvas(atom.a.pp, render.options);
  var options = render.options;
  var delta = 0.5 * options.lineWidth;
  var valence = {};
  valence.text = mapValence[atom.a.explicitValence];
  if (!valence.text) {
    throw new Error('invalid valence ' + atom.a.explicitValence.toString());
  }
  valence.text = '(' + valence.text + ')';
  valence.path = render.paper.text(ps.x, ps.y, valence.text).attr({
    font: options.font,
    'font-size': options.fontszsub,
    fill: atom.color
  });
  valence.rbb = util.relBox(valence.path.getBBox());
  draw.recenterText(valence.path, valence.rbb);
  pathAndRBoxTranslate(valence.path, valence.rbb, rightMargin + 0.5 * valence.rbb.width + delta, -0.3 * atom.label.rbb.height);
  return valence;
}
function showHydrogen(atom, render, implh, data) {
  var hydroIndex = data.hydroIndex;
  var hydrogenLeft = atom.hydrogenOnTheLeft;
  var ps = Scale.modelToCanvas(atom.a.pp, render.options);
  var options = render.options;
  var delta = 0.5 * options.lineWidth;
  var hydrogen = data.hydrogen;
  hydrogen.text = 'H';
  hydrogen.path = render.paper.text(ps.x, ps.y, hydrogen.text).attr({
    font: options.font,
    'font-size': options.fontsz,
    fill: atom.color
  });
  hydrogen.rbb = util.relBox(hydrogen.path.getBBox());
  draw.recenterText(hydrogen.path, hydrogen.rbb);
  if (!hydrogenLeft) {
    pathAndRBoxTranslate(hydrogen.path, hydrogen.rbb, data.rightMargin + 0.5 * hydrogen.rbb.width + delta, 0);
    data.rightMargin += hydrogen.rbb.width + delta;
  }
  if (implh > 1) {
    hydroIndex = {};
    hydroIndex.text = implh.toString();
    hydroIndex.path = render.paper.text(ps.x, ps.y, hydroIndex.text).attr({
      font: options.font,
      'font-size': options.fontszsub,
      fill: atom.color
    });
    hydroIndex.rbb = util.relBox(hydroIndex.path.getBBox());
    draw.recenterText(hydroIndex.path, hydroIndex.rbb);
    if (!hydrogenLeft) {
      pathAndRBoxTranslate(hydroIndex.path, hydroIndex.rbb, data.rightMargin + 0.5 * hydroIndex.rbb.width * (options.zoom > 1 ? 1 : options.zoom) + delta, 0.2 * atom.label.rbb.height);
      data.rightMargin += hydroIndex.rbb.width + delta;
    }
  }
  if (hydrogenLeft) {
    if (hydroIndex != null) {
      pathAndRBoxTranslate(hydroIndex.path, hydroIndex.rbb, data.leftMargin - 0.5 * hydroIndex.rbb.width - delta, 0.2 * atom.label.rbb.height);
      data.leftMargin -= hydroIndex.rbb.width + delta;
    }
    pathAndRBoxTranslate(hydrogen.path, hydrogen.rbb, data.leftMargin - 0.5 * hydrogen.rbb.width * (implh > 1 && options.zoom < 1 ? options.zoom : 1) - delta, 0);
    data.leftMargin -= hydrogen.rbb.width + delta;
  }
  return Object.assign(data, {
    hydrogen: hydrogen,
    hydroIndex: hydroIndex
  });
}
function showWarning(atom, render, leftMargin, rightMargin) {
  var ps = Scale.modelToCanvas(atom.a.pp, render.options);
  var delta = 0.5 * render.options.lineWidth;
  var warning = {};
  var y = ps.y + atom.label.rbb.height / 2 + delta;
  warning.path = render.paper.path('M{0},{1}L{2},{3}', tfx(ps.x + leftMargin), tfx(y), tfx(ps.x + rightMargin), tfx(y)).attr(render.options.lineattr).attr({
    stroke: '#F00'
  });
  warning.rbb = util.relBox(warning.path.getBBox());
  return warning;
}
function getAamText(atom) {
  var aamText = '';
  if (atom.a.aam > 0) aamText += atom.a.aam;
  if (atom.a.invRet > 0) {
    if (aamText.length > 0) aamText += ',';
    if (atom.a.invRet === 1) aamText += 'Inv';else if (atom.a.invRet === 2) aamText += 'Ret';else throw new Error('Invalid value for the invert/retain flag');
  }
  if (atom.a.exactChangeFlag > 0) {
    if (aamText.length > 0) aamText += ',';
    if (atom.a.exactChangeFlag === 1) aamText += 'ext';else throw new Error('Invalid value for the exact change flag');
  }
  return aamText;
}
function getRingBondCountAttrText(value) {
  var attrText;
  if (value > 0) {
    attrText = 'rb' + value.toString();
  } else if (value === -1) {
    attrText = 'rb0';
  } else if (value === -2) {
    attrText = 'rb*';
  } else {
    throw new Error('Ring bond count invalid');
  }
  return attrText;
}
function getRingConnectivity(value) {
  if (value > 0) {
    return 'x' + value.toString();
  } else if (value === -1 || value === -2) {
    return 'x0';
  } else {
    return '';
  }
}
function getDegree(value) {
  if (value > 0) {
    return 'D' + value.toString();
  } else if (value === -1 || value === -2) {
    return 'D0';
  } else {
    return '';
  }
}
function getSubstitutionCountAttrText(value) {
  var attrText;
  if (value > 0) {
    attrText = 's' + value.toString();
  } else if (value === -1) {
    attrText = 's0';
  } else if (value === -2) {
    attrText = 's*';
  } else {
    throw new Error('Substitution count invalid');
  }
  return attrText;
}
function getAtomType(atom) {
  return atom.atomList ? 'list' : atom.pseudo === atom.label ? 'pseudo' : 'single';
}
function checkIsSmartPropertiesExist(atom) {
  var smartsSpecificProperties = ['ringMembership', 'ringSize', 'connectivity', 'chirality', 'aromaticity', 'customQuery'];
  return smartsSpecificProperties.some(function (name) {
    var _atom$queryProperties;
    return (_atom$queryProperties = atom.queryProperties) === null || _atom$queryProperties === void 0 ? void 0 : _atom$queryProperties[name];
  });
}
function getAtomCustomQuery(atom, includeOnlyQueryAttributes) {
  var queryAttrsText = '';
  var nonQueryAttributes = ['charge', 'explicitValence', 'isotope'];
  var addSemicolon = function addSemicolon() {
    if (queryAttrsText.length > 0) queryAttrsText += ';';
  };
  var patterns = {
    isotope: function isotope(value) {
      return value;
    },
    aromaticity: function aromaticity(value) {
      return value === 'aromatic' ? 'a' : 'A';
    },
    charge: function charge(value) {
      if (value === '') return value;
      var regExpResult = /^([+-]?)([0-9]{1,3}|1000)([+-]?)$/.exec(value);
      var charge = regExpResult ? parseInt(regExpResult[1] + regExpResult[3] + regExpResult[2]).toString() : value;
      return charge[0] !== '-' ? "+".concat(charge) : charge;
    },
    unsaturatedAtom: function unsaturatedAtom(value) {
      return Number(value) === 1 ? 'u' : '';
    },
    explicitValence: function explicitValence(value) {
      return Number(value) !== -1 ? "v".concat(value) : '';
    },
    ringBondCount: function ringBondCount(value) {
      return getRingConnectivity(Number(value));
    },
    substitutionCount: function substitutionCount(value) {
      return getDegree(Number(value));
    },
    hCount: function hCount(value) {
      return Number(value) > 0 ? 'H' + (Number(value) - 1).toString() : '';
    },
    implicitHCount: function implicitHCount(value) {
      return "h".concat(value);
    },
    ringMembership: function ringMembership(value) {
      return "R".concat(value);
    },
    ringSize: function ringSize(value) {
      return "r".concat(value);
    },
    connectivity: function connectivity(value) {
      return "X".concat(value);
    },
    chirality: function chirality(value) {
      return value === 'clockwise' ? '@@' : '@';
    }
  };
  for (var propertyName in patterns) {
    if (includeOnlyQueryAttributes && nonQueryAttributes.includes(propertyName)) {
      continue;
    }
    var value = atom[propertyName];
    if (propertyName in atom && value !== null) {
      var attrText = patterns[propertyName](value, atom);
      if (attrText) {
        addSemicolon();
      }
      queryAttrsText += attrText;
    }
  }
  return queryAttrsText;
}
function getQueryAttrsText(atom) {
  var queryAttrsText = '';
  var addSemicolon = function addSemicolon() {
    if (queryAttrsText.length > 0) queryAttrsText += ';';
  };
  var _atom$a = atom.a,
    ringBondCount = _atom$a.ringBondCount,
    substitutionCount = _atom$a.substitutionCount,
    unsaturatedAtom = _atom$a.unsaturatedAtom,
    hCount = _atom$a.hCount;
  if (ringBondCount !== 0) {
    queryAttrsText += getRingBondCountAttrText(ringBondCount);
  }
  if (substitutionCount !== 0) {
    addSemicolon();
    queryAttrsText += getSubstitutionCountAttrText(substitutionCount);
  }
  if (unsaturatedAtom > 0) {
    addSemicolon();
    if (unsaturatedAtom === 1) queryAttrsText += 'u';else throw new Error('Unsaturated atom invalid value');
  }
  if (hCount > 0) {
    addSemicolon();
    queryAttrsText += 'H' + (hCount - 1).toString();
  }
  return queryAttrsText;
}
function pathAndRBoxTranslate(path, rbb, x, y) {
  path.translateAbs(x, y);
  rbb.x += x;
  rbb.y += y;
}
function newVectorFromAngle$1(angle) {
  return new Vec2(Math.cos(angle), Math.sin(angle));
}

function ownKeys$o(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$o(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$o(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$o(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$Q(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$Q() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$Q() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$Q = function _isNativeReflectConstruct() { return !!t; })(); }
var ReBond = function (_ReObject) {
  _inherits__default["default"](ReBond, _ReObject);
  function ReBond(bond) {
    var _this;
    _classCallCheck__default["default"](this, ReBond);
    _this = _callSuper$Q(this, ReBond, ['bond']);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "neihbid1", -1);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "neihbid2", -1);
    _this.b = bond;
    _this.doubleBondShift = 0;
    return _this;
  }
  _createClass__default["default"](ReBond, [{
    key: "drawHover",
    value: function drawHover(render) {
      var ret = this.makeHoverPlate(render);
      render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, ret);
      return ret;
    }
  }, {
    key: "getSelectionPoints",
    value: function getSelectionPoints(render) {
      var bond = this.b;
      var restruct = render.ctab,
        options = render.options;
      var bondThickness = options.bondThickness,
        doubleBondWidth = options.doubleBondWidth,
        stereoBondWidth = options.stereoBondWidth;
      var regularSelectionThikness = doubleBondWidth + bondThickness;
      var halfBondStart = restruct.molecule.halfBonds.get(bond.hb1).p;
      var halfBondEnd = restruct.molecule.halfBonds.get(bond.hb2).p;
      var isStereoBond = bond.stereo !== Bond.PATTERN.STEREO.NONE && bond.stereo !== Bond.PATTERN.STEREO.CIS_TRANS;
      var addPadding = isStereoBond ? 0 : -2;
      var contourStart = Vec2.getLinePoint(halfBondEnd, halfBondStart, addPadding);
      var contourEnd = Vec2.getLinePoint(halfBondStart, halfBondEnd, addPadding);
      var stereoBondStartHeightCoef = 0.5;
      var bondPadding = 0.5;
      var addStart = isStereoBond ? stereoBondWidth * stereoBondStartHeightCoef : regularSelectionThikness + bondPadding;
      var stereoBondEndHeightCoef = 1;
      var addEnd = isStereoBond ? stereoBondWidth + regularSelectionThikness * stereoBondEndHeightCoef / stereoBondWidth : regularSelectionThikness + bondPadding;
      var contourPaddedStart = Vec2.getLinePoint(contourStart, contourEnd, addEnd);
      var contourPaddedEnd = Vec2.getLinePoint(contourEnd, contourStart, addStart);
      var startPoint = contourStart.add(new Vec2(addEnd, 0));
      var endPoint = contourEnd.add(new Vec2(addStart, 0));
      var padStartPoint = contourPaddedStart.add(new Vec2(addEnd, 0));
      var padEndPoint = contourPaddedEnd.add(new Vec2(addStart, 0));
      var angle = bond.angle;
      var startTop = startPoint.rotateAroundOrigin(angle + 90, new Vec2(contourStart.x, contourStart.y));
      var startBottom = startPoint.rotateAroundOrigin(angle - 90, new Vec2(contourStart.x, contourStart.y));
      var startPadTop = padStartPoint.rotateAroundOrigin(angle + 90, contourPaddedStart);
      var startPadBottom = padStartPoint.rotateAroundOrigin(angle - 90, contourPaddedStart);
      var endTop = endPoint.rotateAroundOrigin(angle + 90, contourEnd);
      var endBottom = endPoint.rotateAroundOrigin(angle - 90, contourEnd);
      var endPadTop = padEndPoint.rotateAroundOrigin(angle + 90, contourPaddedEnd);
      var endPadBottom = padEndPoint.rotateAroundOrigin(angle - 90, contourPaddedEnd);
      return [startPadTop, startTop, endTop, endPadTop, endPadBottom, endBottom, startPadBottom, startBottom];
    }
  }, {
    key: "getSelectionContour",
    value: function getSelectionContour(render) {
      var paper = render.paper;
      var _this$getSelectionPoi = this.getSelectionPoints(render),
        _this$getSelectionPoi2 = _slicedToArray__default["default"](_this$getSelectionPoi, 8),
        startPadTop = _this$getSelectionPoi2[0],
        startTop = _this$getSelectionPoi2[1],
        endTop = _this$getSelectionPoi2[2],
        endPadTop = _this$getSelectionPoi2[3],
        endPadBottom = _this$getSelectionPoi2[4],
        endBottom = _this$getSelectionPoi2[5],
        startPadBottom = _this$getSelectionPoi2[6],
        startBottom = _this$getSelectionPoi2[7];
      var pathString = "\n      M ".concat(startTop.x, " ").concat(startTop.y, "\n      L ").concat(endTop.x, " ").concat(endTop.y, "\n      C ").concat(endPadTop.x, " ").concat(endPadTop.y, ", ").concat(endPadBottom.x, " ").concat(endPadBottom.y, ", ").concat(endBottom.x, " ").concat(endBottom.y, "\n      L ").concat(startBottom.x, " ").concat(startBottom.y, "\n      C ").concat(startPadBottom.x, " ").concat(startPadBottom.y, ", ").concat(startPadTop.x, " ").concat(startPadTop.y, ", ").concat(startTop.x, " ").concat(startTop.y, "\n    ");
      return paper.path(pathString);
    }
  }, {
    key: "makeHoverPlate",
    value: function makeHoverPlate(render) {
      var restruct = render.ctab;
      var options = render.options;
      ReBond.bondRecalc(this, restruct, options);
      var bond = this.b;
      var sgroups = restruct.sgroups;
      var functionalGroups = restruct.molecule.functionalGroups;
      if (FunctionalGroup.isBondInContractedFunctionalGroup(bond, sgroups, functionalGroups)) {
        return null;
      }
      var rect = this.getSelectionContour(render);
      return rect.attr(_objectSpread$o({}, options.hoverStyle));
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(restruct, _, options) {
      ReBond.bondRecalc(this, restruct, options);
      var bond = this.b;
      var sgroups = restruct.render.ctab.sgroups;
      var functionalGroups = restruct.render.ctab.molecule.functionalGroups;
      if (FunctionalGroup.isBondInContractedFunctionalGroup(bond, sgroups, functionalGroups)) {
        return null;
      }
      var rect = this.getSelectionContour(restruct.render);
      return rect.attr(options.selectionStyle);
    }
  }, {
    key: "show",
    value: function show(restruct, bid, options) {
      var render = restruct.render;
      var struct = restruct.molecule;
      var bond = restruct.molecule.bonds.get(bid);
      var sgroups = restruct.molecule.sgroups;
      var functionalGroups = restruct.molecule.functionalGroups;
      if (bond && FunctionalGroup.isBondInContractedFunctionalGroup(bond, sgroups, functionalGroups)) {
        return;
      }
      var paper = render.paper;
      var hb1 = this.b.hb1 !== undefined ? struct.halfBonds.get(this.b.hb1) : null;
      var hb2 = this.b.hb2 !== undefined ? struct.halfBonds.get(this.b.hb2) : null;
      checkStereoBold(bid, this, restruct);
      ReBond.bondRecalc(this, restruct, options);
      setDoubleBondShift(this, struct);
      if (!hb1 || !hb2) return;
      var isSnapping = restruct.isSnappingBond(bid);
      this.path = getBondPath(restruct, this, hb1, hb2, isSnapping);
      this.rbb = util.relBox(this.path.getBBox());
      restruct.addReObjectPath(exports.LayerMap.bondSkeleton, this.visel, this.path, null, true);
      var reactingCenter = {};
      reactingCenter.path = getReactingCenterPath(render, this, hb1, hb2);
      if (reactingCenter.path) {
        reactingCenter.rbb = util.relBox(reactingCenter.path.getBBox());
        restruct.addReObjectPath(exports.LayerMap.data, this.visel, reactingCenter.path, null, true);
      }
      var topology = {};
      topology.path = getBondMark(render, this, hb1, hb2);
      if (topology.path) {
        topology.rbb = util.relBox(topology.path.getBBox());
        restruct.addReObjectPath(exports.LayerMap.data, this.visel, topology.path, null, true);
      }
      this.setHover(this.hover, render);
      var ipath = null;
      var bondIdxOff = options.subFontSize * 0.6;
      if (options.showBondIds) {
        ipath = getIdsPath(bid, paper, hb1, hb2, bondIdxOff, 0.5, 0.5, hb1.norm);
        restruct.addReObjectPath(exports.LayerMap.indices, this.visel, ipath);
      }
      if (options.showHalfBondIds) {
        ipath = getIdsPath(this.b.hb1, paper, hb1, hb2, bondIdxOff, 0.8, 0.2, hb1.norm);
        restruct.addReObjectPath(exports.LayerMap.indices, this.visel, ipath);
        ipath = getIdsPath(this.b.hb2, paper, hb1, hb2, bondIdxOff, 0.2, 0.8, hb2.norm);
        restruct.addReObjectPath(exports.LayerMap.indices, this.visel, ipath);
      }
      if (options.showLoopIds && !options.showBondIds) {
        ipath = getIdsPath(hb1.loop, paper, hb1, hb2, bondIdxOff, 0.5, 0.5, hb2.norm);
        restruct.addReObjectPath(exports.LayerMap.indices, this.visel, ipath);
        ipath = getIdsPath(hb2.loop, paper, hb1, hb2, bondIdxOff, 0.5, 0.5, hb1.norm);
        restruct.addReObjectPath(exports.LayerMap.indices, this.visel, ipath);
      }
      var highlights = restruct.molecule.highlights;
      var isHighlighted = false;
      var highlightColor = '';
      highlights.forEach(function (highlight) {
        var _highlight$bonds;
        var hasCurrentHighlight = (_highlight$bonds = highlight.bonds) === null || _highlight$bonds === void 0 ? void 0 : _highlight$bonds.includes(bid);
        isHighlighted = isHighlighted || hasCurrentHighlight;
        if (hasCurrentHighlight) {
          highlightColor = highlight.color;
        }
      });
      if (isHighlighted) {
        var style = {
          fill: highlightColor,
          stroke: highlightColor,
          'stroke-width': options.lineattr['stroke-width'] * 7,
          'stroke-linecap': 'round'
        };
        var c = Scale.modelToCanvas(this.b.center, restruct.render.options);
        var highlightPath = getHighlightPath(restruct, hb1, hb2);
        highlightPath.attr(style);
        restruct.addReObjectPath(exports.LayerMap.hovering, this.visel, highlightPath, c, true);
      }
      if (bond.cip) {
        this.cip = util.drawCIPLabel({
          atomOrBond: bond,
          position: bond.center,
          restruct: render.ctab,
          visel: this.visel
        });
      }
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }, {
    key: "bondRecalc",
    value: function bondRecalc(bond, restruct, options) {
      var render = restruct.render;
      var sgroup1 = restruct.molecule.getGroupFromAtomId(bond.b.begin);
      var sgroup2 = restruct.molecule.getGroupFromAtomId(bond.b.end);
      var beginAtom = restruct.atoms.get(sgroup1 instanceof MonomerMicromolecule ? sgroup1.getAttachmentAtomId() : bond.b.begin);
      var endAtom = restruct.atoms.get(sgroup2 instanceof MonomerMicromolecule ? sgroup2.getAttachmentAtomId() : bond.b.end);
      if (!beginAtom || !endAtom || bond.b.hb1 === undefined || bond.b.hb2 === undefined) {
        return;
      }
      var p1 = sgroup1 instanceof MonomerMicromolecule ? sgroup1.pp : beginAtom.a.pp;
      var p2 = sgroup2 instanceof MonomerMicromolecule ? sgroup2.pp : endAtom.a.pp;
      var hb1 = restruct.molecule.halfBonds.get(bond.b.hb1);
      var hb2 = restruct.molecule.halfBonds.get(bond.b.hb2);
      if (!(hb1 !== null && hb1 !== void 0 && hb1.dir) || !(hb2 !== null && hb2 !== void 0 && hb2.dir)) return;
      hb1.p = beginAtom.getShiftedSegmentPosition(options, hb1.dir, p1);
      hb2.p = endAtom.getShiftedSegmentPosition(options, hb2.dir, p2);
      bond.b.center = Vec2.lc2(p1, 0.5, p2, 0.5);
      bond.b.len = Vec2.dist(Scale.modelToCanvas(p1, render.options), Scale.modelToCanvas(p2, render.options));
      bond.b.sb = options.lineWidth * 5;
      bond.b.sa = Math.max(bond.b.sb, bond.b.len / 2 - options.lineWidth * 2);
      bond.b.angle = Math.atan2(hb1.dir.y, hb1.dir.x) * 180 / Math.PI;
    }
  }]);
  return ReBond;
}(ReObject);
function getHighlightPath(restruct, hb1, hb2) {
  var beginning = {
    x: hb1.p.x,
    y: hb1.p.y
  };
  var end = {
    x: hb2.p.x,
    y: hb2.p.y
  };
  var paper = restruct.render.paper;
  var pathString = "M".concat(beginning.x, ",").concat(beginning.y, " L").concat(end.x, ",").concat(end.y);
  var path = paper.path(pathString);
  return path;
}
function findIncomingStereoUpBond(atom, bid0, includeBoldStereoBond, restruct) {
  return atom.neighbors.findIndex(function (hbid) {
    var hb = restruct.molecule.halfBonds.get(hbid);
    if (!hb || hb.bid === bid0) return false;
    var neibond = restruct.bonds.get(hb.bid);
    if (!neibond) return false;
    var singleUp = neibond.b.type === Bond.PATTERN.TYPE.SINGLE && neibond.b.stereo === Bond.PATTERN.STEREO.UP;
    if (singleUp) {
      return neibond.b.end === hb.begin || neibond.boldStereo && includeBoldStereoBond;
    }
    return !!(neibond.b.type === Bond.PATTERN.TYPE.DOUBLE && neibond.b.stereo === Bond.PATTERN.STEREO.NONE && includeBoldStereoBond && neibond.boldStereo);
  });
}
function findIncomingUpBonds(bid0, bond, restruct) {
  var _restruct$atoms$get, _restruct$atoms$get2;
  var halfbonds = [bond.b.begin, bond.b.end].map(function (aid) {
    var atom = restruct.molecule.atoms.get(aid);
    if (!atom) return -1;
    var pos = findIncomingStereoUpBond(atom, bid0, true, restruct);
    return pos < 0 ? -1 : atom.neighbors[pos];
  });
  bond.neihbid1 = (_restruct$atoms$get = restruct.atoms.get(bond.b.begin)) !== null && _restruct$atoms$get !== void 0 && _restruct$atoms$get.showLabel ? -1 : halfbonds[0];
  bond.neihbid2 = (_restruct$atoms$get2 = restruct.atoms.get(bond.b.end)) !== null && _restruct$atoms$get2 !== void 0 && _restruct$atoms$get2.showLabel ? -1 : halfbonds[1];
}
function checkStereoBold(bid0, bond, restruct) {
  var halfbonds = [bond.b.begin, bond.b.end].map(function (aid) {
    var atom = restruct.molecule.atoms.get(aid);
    var pos = findIncomingStereoUpBond(atom, bid0, false, restruct);
    return pos < 0 ? -1 : atom.neighbors[pos];
  });
  bond.boldStereo = halfbonds[0] >= 0 && halfbonds[1] >= 0;
}
function getBondPath(restruct, bond, hb1, hb2, isSnapping) {
  var _restruct$atoms$get3, _restruct$atoms$get4;
  var path = null;
  var render = restruct.render;
  var struct = restruct.molecule;
  var shiftA = !((_restruct$atoms$get3 = restruct.atoms.get(hb1.begin)) !== null && _restruct$atoms$get3 !== void 0 && _restruct$atoms$get3.showLabel);
  var shiftB = !((_restruct$atoms$get4 = restruct.atoms.get(hb2.begin)) !== null && _restruct$atoms$get4 !== void 0 && _restruct$atoms$get4.showLabel);
  var newHalfBonds;
  var xShiftMinus1 = -1;
  var xShiftPlus1 = 1;
  switch (bond.b.type) {
    case Bond.PATTERN.TYPE.SINGLE:
      switch (bond.b.stereo) {
        case Bond.PATTERN.STEREO.UP:
          findIncomingUpBonds(hb1.bid, bond, restruct);
          if (bond.boldStereo && bond.neihbid1 >= 0 && bond.neihbid2 >= 0) {
            path = getBondSingleStereoBoldPath(render, hb1, hb2, bond, struct, isSnapping);
          } else path = getBondSingleUpPath(render, hb1, hb2, bond, struct, isSnapping);
          break;
        case Bond.PATTERN.STEREO.DOWN:
          path = getBondSingleDownPath(render, hb1, hb2, bond, struct, isSnapping);
          break;
        case Bond.PATTERN.STEREO.EITHER:
          path = getBondSingleEitherPath(render, hb1, hb2, bond, struct, isSnapping);
          break;
        default:
          path = draw.bondSingle(render.paper, hb1, hb2, render.options, isSnapping, getStereoBondColor(render.options, bond, struct));
          break;
      }
      break;
    case Bond.PATTERN.TYPE.DOUBLE:
      findIncomingUpBonds(hb1.bid, bond, restruct);
      if (bond.b.stereo === Bond.PATTERN.STEREO.NONE && bond.boldStereo && bond.neihbid1 >= 0 && bond.neihbid2 >= 0) {
        path = getBondDoubleStereoBoldPath(render, hb1, hb2, bond, struct, shiftA, shiftB, isSnapping);
      } else path = getBondDoublePath(render, hb1, hb2, bond, shiftA, shiftB, isSnapping);
      break;
    case Bond.PATTERN.TYPE.TRIPLE:
      path = draw.bondTriple(render.paper, hb1, hb2, render.options, isSnapping);
      break;
    case Bond.PATTERN.TYPE.AROMATIC:
      {
        var _struct$loops$get, _struct$loops$get2;
        var inAromaticLoop = hb1.loop >= 0 && ((_struct$loops$get = struct.loops.get(hb1.loop)) === null || _struct$loops$get === void 0 ? void 0 : _struct$loops$get.aromatic) || hb2.loop >= 0 && ((_struct$loops$get2 = struct.loops.get(hb2.loop)) === null || _struct$loops$get2 === void 0 ? void 0 : _struct$loops$get2.aromatic);
        path = inAromaticLoop ? draw.bondSingle(render.paper, hb1, hb2, render.options, isSnapping) : getBondAromaticPath(render, hb1, hb2, bond, shiftA, shiftB, isSnapping);
        break;
      }
    case Bond.PATTERN.TYPE.SINGLE_OR_DOUBLE:
      newHalfBonds = util.updateHalfBondCoordinates(hb1, hb2, xShiftPlus1);
      path = getSingleOrDoublePath(render, newHalfBonds[0], newHalfBonds[1], isSnapping);
      break;
    case Bond.PATTERN.TYPE.SINGLE_OR_AROMATIC:
      path = getBondAromaticPath(render, hb1, hb2, bond, shiftA, shiftB, isSnapping);
      break;
    case Bond.PATTERN.TYPE.DOUBLE_OR_AROMATIC:
      newHalfBonds = util.updateHalfBondCoordinates(hb1, hb2, xShiftMinus1);
      path = getBondAromaticPath(render, newHalfBonds[0], newHalfBonds[1], bond, shiftA, shiftB, isSnapping);
      break;
    case Bond.PATTERN.TYPE.ANY:
      newHalfBonds = util.updateHalfBondCoordinates(hb1, hb2, xShiftMinus1);
      path = draw.bondAny(render.paper, newHalfBonds[0], newHalfBonds[1], render.options, isSnapping);
      break;
    case Bond.PATTERN.TYPE.HYDROGEN:
      newHalfBonds = util.updateHalfBondCoordinates(hb1, hb2, xShiftPlus1);
      path = draw.bondHydrogen(render.paper, newHalfBonds[0], newHalfBonds[1], render.options, isSnapping);
      break;
    case Bond.PATTERN.TYPE.DATIVE:
      path = draw.bondDative(render.paper, hb1, hb2, render.options, isSnapping);
      break;
    default:
      throw new Error('Bond type ' + bond.b.type + ' not supported');
  }
  if (path) {
    var previewOpacity = render.options.previewOpacity;
    path.attr({
      opacity: bond.b.isPreview ? previewOpacity : 1
    });
  }
  return path;
}
function getBondSingleUpPath(render, hb1, hb2, bond, struct, isSnapping) {
  var a = hb1.p;
  var b = hb2.p;
  var n = hb1.norm;
  var options = render.options;
  var bsp = 0.7 * options.stereoBond;
  var b2 = b.addScaled(n, bsp);
  var b3 = b.addScaled(n, -bsp);
  if (bond.neihbid2 >= 0) {
    var coords = stereoUpBondGetCoordinates(hb2, bond.neihbid2, options.stereoBond, struct);
    b2 = coords[0];
    b3 = coords[1];
  }
  return draw.bondSingleUp(render.paper, a, b2, b3, options, isSnapping, getStereoBondColor(options, bond, struct));
}
function getStereoBondColor(options, bond, struct) {
  var _struct$atoms$get, _struct$atoms$get2;
  var defaultColor = '#000';
  if (bond.b.stereo === 0) return defaultColor;
  var beginAtomStereoLabel = (_struct$atoms$get = struct.atoms.get(bond.b.begin)) === null || _struct$atoms$get === void 0 ? void 0 : _struct$atoms$get.stereoLabel;
  var endAtomStereoLabel = (_struct$atoms$get2 = struct.atoms.get(bond.b.end)) === null || _struct$atoms$get2 === void 0 ? void 0 : _struct$atoms$get2.stereoLabel;
  var stereoLabel = '';
  if (beginAtomStereoLabel && !endAtomStereoLabel) {
    stereoLabel = beginAtomStereoLabel;
  } else if (!beginAtomStereoLabel && endAtomStereoLabel) {
    stereoLabel = endAtomStereoLabel;
  }
  if (
  !stereoLabel || options.colorStereogenicCenters === exports.StereoColoringType.Off || options.colorStereogenicCenters === exports.StereoColoringType.LabelsOnly) {
    return defaultColor;
  }
  return getColorFromStereoLabel(options, stereoLabel);
}
function getBondSingleStereoBoldPath(render, hb1, hb2, bond, struct, isSnapping) {
  var options = render.options;
  var coords1 = stereoUpBondGetCoordinates(hb1, bond.neihbid1, options.stereoBond, struct);
  var coords2 = stereoUpBondGetCoordinates(hb2, bond.neihbid2, options.stereoBond, struct);
  var a1 = coords1[0];
  var a2 = coords1[1];
  var a3 = coords2[0];
  var a4 = coords2[1];
  return draw.bondSingleStereoBold(render.paper, a1, a2, a3, a4, options, isSnapping, getStereoBondColor(options, bond, struct));
}
function getBondDoubleStereoBoldPath(render, hb1, hb2, bond, struct, shiftA, shiftB, isSnapping) {
  var a = hb1.p;
  var b = hb2.p;
  var n = hb1.norm;
  var shift = bond.doubleBondShift;
  var bsp = 1.5 * render.options.stereoBond;
  var b1 = a.addScaled(n, bsp * shift);
  var b2 = b.addScaled(n, bsp * shift);
  if (shift > 0) {
    if (shiftA) {
      b1 = b1.addScaled(hb1.dir, bsp * getBondLineShift(hb1.rightCos, hb1.rightSin));
    }
    if (shiftB) {
      b2 = b2.addScaled(hb1.dir, -bsp * getBondLineShift(hb2.leftCos, hb2.leftSin));
    }
  } else if (shift < 0) {
    if (shiftA) {
      b1 = b1.addScaled(hb1.dir, bsp * getBondLineShift(hb1.leftCos, hb1.leftSin));
    }
    if (shiftB) {
      b2 = b2.addScaled(hb1.dir, -bsp * getBondLineShift(hb2.rightCos, hb2.rightSin));
    }
  }
  var sgBondPath = getBondSingleStereoBoldPath(render, hb1, hb2, bond, struct, isSnapping);
  return draw.bondDoubleStereoBold(render.paper,
  sgBondPath, b1, b2, render.options, isSnapping, getStereoBondColor(render.options, bond, struct));
}
function getBondLineShift(cos, sin) {
  if (sin < 0 || Math.abs(cos) > 0.9) return 0;
  return sin / (1 - cos);
}
function stereoUpBondGetCoordinates(hb, neihbid, bondSpace, struct) {
  var neihb = struct.halfBonds.get(neihbid);
  var cos = Vec2.dot(hb.dir, neihb.dir);
  var sin = Vec2.cross(hb.dir, neihb.dir);
  var cosHalf = Math.sqrt(0.5 * (1 - cos));
  var biss = neihb.dir.rotateSC((sin >= 0 ? -1 : 1) * cosHalf, Math.sqrt(0.5 * (1 + cos)));
  var denomAdd = 0.3;
  var scale = 0.7;
  var a1 = hb.p.addScaled(biss, scale * bondSpace / (cosHalf + denomAdd));
  var a2 = hb.p.addScaled(biss.negated(), scale * bondSpace / (cosHalf + denomAdd));
  return sin > 0 ? [a1, a2] : [a2, a1];
}
function getBondSingleDownPath(render, hb1, hb2, bond, struct, isSnapping) {
  var a = hb1.p;
  var b = hb2.p;
  var options = render.options;
  var d = b.sub(a);
  var len = d.length() + 0.2;
  d = d.normalized();
  var interval = 1.2 * options.lineWidth;
  var nlines = Math.max(Math.floor((len - options.lineWidth) / (options.lineWidth + interval)), 0) + 2;
  var step = len / (nlines - 1);
  return draw.bondSingleDown(render.paper, hb1, d, nlines, step, options, isSnapping, getStereoBondColor(options, bond, struct));
}
function getBondSingleEitherPath(render, hb1, hb2, bond, struct, isSnapping) {
  var a = hb1.p;
  var b = hb2.p;
  var options = render.options;
  var d = b.sub(a);
  var len = d.length();
  d = d.normalized();
  var interval = 0.6 * options.lineWidth;
  var nlines = Math.max(Math.floor((len - options.lineWidth) / (options.lineWidth + interval)), 0) + 2;
  var step = len / (nlines - 0.5);
  return draw.bondSingleEither(render.paper, hb1, d, nlines, step, options, isSnapping, getStereoBondColor(options, bond, struct));
}
function getBondDoublePath(render, hb1, hb2, bond, shiftA, shiftB, isSnapping) {
  var cisTrans = bond.b.stereo === Bond.PATTERN.STEREO.CIS_TRANS;
  var a = hb1.p;
  var b = hb2.p;
  var n = hb1.norm;
  var shift = cisTrans ? 0 : bond.doubleBondShift;
  var options = render.options;
  var bsp = options.bondSpace / 2;
  var s1 = bsp + shift * bsp;
  var s2 = -bsp + shift * bsp;
  var a1 = a.addScaled(n, s1);
  var b1 = b.addScaled(n, s1);
  var a2 = a.addScaled(n, s2);
  var b2 = b.addScaled(n, s2);
  if (shift > 0) {
    if (shiftA) {
      a1 = a1.addScaled(hb1.dir, options.bondSpace * getBondLineShift(hb1.rightCos, hb1.rightSin));
    }
    if (shiftB) {
      b1 = b1.addScaled(hb1.dir, -options.bondSpace * getBondLineShift(hb2.leftCos, hb2.leftSin));
    }
  } else if (shift < 0) {
    if (shiftA) {
      a2 = a2.addScaled(hb1.dir, options.bondSpace * getBondLineShift(hb1.leftCos, hb1.leftSin));
    }
    if (shiftB) {
      b2 = b2.addScaled(hb1.dir, -options.bondSpace * getBondLineShift(hb2.rightCos, hb2.rightSin));
    }
  }
  return draw.bondDouble(render.paper, a1, a2, b1, b2, cisTrans, options, isSnapping);
}
function getSingleOrDoublePath(render, hb1, hb2, isSnapping) {
  var a = hb1.p;
  var b = hb2.p;
  var options = render.options;
  var nSect = Vec2.dist(a, b) / Number((options.bondSpace + options.lineWidth).toFixed());
  if (!(nSect & 1)) nSect += 1;
  return draw.bondSingleOrDouble(render.paper, hb1, hb2, nSect, options, isSnapping);
}
function getBondAromaticPath(render, hb1, hb2, bond, shiftA, shiftB, isSnapping) {
  var dashdotPattern = [0.125, 0.125, 0.005, 0.125];
  var mask = 0;
  var dash = null;
  var options = render.options;
  var bondShift = bond.doubleBondShift;
  if (bond.b.type === Bond.PATTERN.TYPE.SINGLE_OR_AROMATIC) {
    mask = bondShift > 0 ? 1 : 2;
    dash = dashdotPattern.map(function (v) {
      return v * options.microModeScale;
    });
  }
  if (bond.b.type === Bond.PATTERN.TYPE.DOUBLE_OR_AROMATIC) {
    mask = 3;
    dash = dashdotPattern.map(function (v) {
      return v * options.microModeScale;
    });
  }
  var paths = getAromaticBondPaths(hb1, hb2, bondShift, shiftA, shiftB, options.bondSpace, mask, dash);
  return draw.bondAromatic(render.paper, paths, bondShift, options, isSnapping);
}
function getAromaticBondPaths(hb1, hb2, shift, shiftA, shiftB, bondSpace, mask, dash) {
  var a = hb1.p;
  var b = hb2.p;
  var n = hb1.norm;
  var bsp = bondSpace / 2;
  var s1 = bsp + shift * bsp;
  var s2 = -bsp + shift * bsp;
  var a2 = a.addScaled(n, s1);
  var b2 = b.addScaled(n, s1);
  var a3 = a.addScaled(n, s2);
  var b3 = b.addScaled(n, s2);
  if (shift > 0) {
    if (shiftA) {
      a2 = a2.addScaled(hb1.dir, bondSpace * getBondLineShift(hb1.rightCos, hb1.rightSin));
    }
    if (shiftB) {
      b2 = b2.addScaled(hb1.dir, -bondSpace * getBondLineShift(hb2.leftCos, hb2.leftSin));
    }
  } else if (shift < 0) {
    if (shiftA) {
      a3 = a3.addScaled(hb1.dir, bondSpace * getBondLineShift(hb1.leftCos, hb1.leftSin));
    }
    if (shiftB) {
      b3 = b3.addScaled(hb1.dir, -bondSpace * getBondLineShift(hb2.rightCos, hb2.rightSin));
    }
  }
  return draw.aromaticBondPaths(a2, a3, b2, b3, mask, dash);
}
function getReactingCenterPath(render, bond, hb1, hb2) {
  var a = hb1.p;
  var b = hb2.p;
  var c = b.add(a).scaled(0.5);
  var d = b.sub(a).normalized();
  var n = d.rotateSC(1, 0);
  var p = [];
  var lw = render.options.lineWidth;
  var bs = render.options.bondSpace / 2;
  var alongIntRc = lw;
  var alongIntMadeBroken = 2 * lw;
  var alongSz = 1.5 * bs;
  var acrossInt = 1.5 * bs;
  var acrossSz = 3.0 * bs;
  var tiltTan = 0.2;
  switch (bond.b.reactingCenterStatus) {
    case Bond.PATTERN.REACTING_CENTER.NOT_CENTER:
      p.push(c.addScaled(n, acrossSz).addScaled(d, tiltTan * acrossSz));
      p.push(c.addScaled(n, -acrossSz).addScaled(d, -tiltTan * acrossSz));
      p.push(c.addScaled(n, acrossSz).addScaled(d, -tiltTan * acrossSz));
      p.push(c.addScaled(n, -acrossSz).addScaled(d, tiltTan * acrossSz));
      break;
    case Bond.PATTERN.REACTING_CENTER.CENTER:
      p.push(c.addScaled(n, acrossSz).addScaled(d, tiltTan * acrossSz).addScaled(d, alongIntRc));
      p.push(c.addScaled(n, -acrossSz).addScaled(d, -tiltTan * acrossSz).addScaled(d, alongIntRc));
      p.push(c.addScaled(n, acrossSz).addScaled(d, tiltTan * acrossSz).addScaled(d, -alongIntRc));
      p.push(c.addScaled(n, -acrossSz).addScaled(d, -tiltTan * acrossSz).addScaled(d, -alongIntRc));
      p.push(c.addScaled(d, alongSz).addScaled(n, acrossInt));
      p.push(c.addScaled(d, -alongSz).addScaled(n, acrossInt));
      p.push(c.addScaled(d, alongSz).addScaled(n, -acrossInt));
      p.push(c.addScaled(d, -alongSz).addScaled(n, -acrossInt));
      break;
    case Bond.PATTERN.REACTING_CENTER.MADE_OR_BROKEN:
      p.push(c.addScaled(n, acrossSz).addScaled(d, alongIntMadeBroken));
      p.push(c.addScaled(n, -acrossSz).addScaled(d, alongIntMadeBroken));
      p.push(c.addScaled(n, acrossSz).addScaled(d, -alongIntMadeBroken));
      p.push(c.addScaled(n, -acrossSz).addScaled(d, -alongIntMadeBroken));
      break;
    case Bond.PATTERN.REACTING_CENTER.ORDER_CHANGED:
      p.push(c.addScaled(n, acrossSz));
      p.push(c.addScaled(n, -acrossSz));
      break;
    case Bond.PATTERN.REACTING_CENTER.MADE_OR_BROKEN_AND_CHANGED:
      p.push(c.addScaled(n, acrossSz).addScaled(d, alongIntMadeBroken));
      p.push(c.addScaled(n, -acrossSz).addScaled(d, alongIntMadeBroken));
      p.push(c.addScaled(n, acrossSz).addScaled(d, -alongIntMadeBroken));
      p.push(c.addScaled(n, -acrossSz).addScaled(d, -alongIntMadeBroken));
      p.push(c.addScaled(n, acrossSz));
      p.push(c.addScaled(n, -acrossSz));
      break;
    default:
      return null;
  }
  return draw.reactingCenter(render.paper, p, render.options);
}
function getBondMark(render, bond, hb1, hb2) {
  var options = render.options;
  var mark = null;
  var tooltip = null;
  if (bond.b.customQuery) {
    mark = bond.b.customQuery;
    if (bond.b.customQuery.length > 8) {
      tooltip = bond.b.customQuery;
      mark = "".concat(bond.b.customQuery.substring(0, 8), "...");
    }
  } else if (bond.b.topology === Bond.PATTERN.TOPOLOGY.RING) {
    mark = 'rng';
  } else if (bond.b.topology === Bond.PATTERN.TOPOLOGY.CHAIN) {
    mark = 'chn';
  } else {
    return null;
  }
  var a = hb1.p;
  var b = hb2.p;
  var c = b.add(a).scaled(0.5);
  var d = b.sub(a).normalized();
  var n = d.rotateSC(1, 0);
  var fixed = options.lineWidth;
  if (bond.doubleBondShift > 0) n = n.scaled(-bond.doubleBondShift);else if (bond.doubleBondShift === 0) fixed += options.bondSpace / 2;
  var s = new Vec2(2, 1).scaled(options.bondSpace);
  if (bond.b.type === Bond.PATTERN.TYPE.TRIPLE) fixed += options.bondSpace;
  var p = c.add(new Vec2(n.x * (s.x + fixed), n.y * (s.y + fixed)));
  var path = draw.bondMark(render.paper, p, mark, options);
  tooltip && path.node.childNodes[0].setAttribute('data-tooltip', tooltip);
  return path;
}
function getIdsPath(bid, paper, hb1, hb2, bondIdxOff, param1, param2, norm) {
  var pb = Vec2.lc(hb1.p, param1, hb2.p, param2, norm, bondIdxOff);
  var ipath = paper.text(pb.x, pb.y, bid.toString());
  var irbb = util.relBox(ipath.getBBox());
  draw.recenterText(ipath, irbb);
  return ipath;
}
function setDoubleBondShift(bond, struct) {
  var hb1 = bond.b.hb1;
  var hb2 = bond.b.hb2;
  if (!hb1 && hb1 !== 0 || !hb2 && hb2 !== 0) {
    bond.doubleBondShift = selectDoubleBondShiftChain(struct, bond);
    return;
  }
  var loop1 = struct.halfBonds.get(hb1).loop;
  var loop2 = struct.halfBonds.get(hb2).loop;
  if (loop1 >= 0 && loop2 >= 0) {
    var d1 = struct.loops.get(loop1).dblBonds;
    var d2 = struct.loops.get(loop2).dblBonds;
    var n1 = struct.loops.get(loop1).hbs.length;
    var n2 = struct.loops.get(loop2).hbs.length;
    bond.doubleBondShift = selectDoubleBondShift(n1, n2, d1, d2);
  } else if (loop1 >= 0) {
    bond.doubleBondShift = -1;
  } else if (loop2 >= 0) {
    bond.doubleBondShift = 1;
  } else {
    bond.doubleBondShift = selectDoubleBondShiftChain(struct, bond);
  }
}
function selectDoubleBondShift(n1, n2, d1, d2) {
  if (n1 === 6 && n2 !== 6 && (d1 > 1 || d2 === 1)) return -1;
  if (n2 === 6 && n1 !== 6 && (d2 > 1 || d1 === 1)) return 1;
  if (n2 * d1 > n1 * d2) return -1;
  if (n2 * d1 < n1 * d2) return 1;
  if (n2 > n1) return -1;
  return 1;
}
function selectDoubleBondShiftChain(struct, bond) {
  if (!bond.b.hb1 && bond.b.hb1 !== 0 || !bond.b.hb2 && bond.b.hb2 !== 0) {
    return 0;
  }
  var hb1 = struct.halfBonds.get(bond.b.hb1);
  var hb2 = struct.halfBonds.get(bond.b.hb2);
  if (!hb1 || !hb2) return 0;
  var nLeft = (hb1.leftSin > 0.3 ? 1 : 0) + (hb2.rightSin > 0.3 ? 1 : 0);
  var nRight = (hb2.leftSin > 0.3 ? 1 : 0) + (hb1.rightSin > 0.3 ? 1 : 0);
  if (nLeft > nRight) return -1;
  if (nLeft < nRight) return 1;
  if ((hb1.leftSin > 0.3 ? 1 : 0) + (hb1.rightSin > 0.3 ? 1 : 0) === 1) return 1;
  return 0;
}

function _callSuper$P(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$P() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$P() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$P = function _isNativeReflectConstruct() { return !!t; })(); }
function _classPrivateFieldInitSpec$c(obj, privateMap, value) { _checkPrivateRedeclaration$c(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$c(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _path = new WeakMap();
var ReEnhancedFlag = function (_ReObject) {
  _inherits__default["default"](ReEnhancedFlag, _ReObject);
  function ReEnhancedFlag() {
    var _this;
    _classCallCheck__default["default"](this, ReEnhancedFlag);
    _this = _callSuper$P(this, ReEnhancedFlag, ['enhancedFlag']);
    _classPrivateFieldInitSpec$c(_assertThisInitialized__default["default"](_this), _path, {
      writable: true,
      value: void 0
    });
    return _this;
  }
  _createClass__default["default"](ReEnhancedFlag, [{
    key: "hoverPath",
    value: function hoverPath(render) {
      var box = Box2Abs.fromRelBox(_classPrivateFieldGet__default["default"](this, _path).getBBox());
      var sz = box.p1.sub(box.p0);
      var p0 = box.p0.sub(render.options.offset);
      return render.paper.rect(p0.x, p0.y, sz.x, sz.y);
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      var _classPrivateFieldGet2;
      if (!((_classPrivateFieldGet2 = _classPrivateFieldGet__default["default"](this, _path)) !== null && _classPrivateFieldGet2 !== void 0 && _classPrivateFieldGet2.attrs)) return null;
      var ret = this.hoverPath(render).attr(render.options.hoverStyle);
      render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, ret);
      return ret;
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(restruct, _paper, options) {
      var _classPrivateFieldGet3;
      if (!((_classPrivateFieldGet3 = _classPrivateFieldGet__default["default"](this, _path)) !== null && _classPrivateFieldGet3 !== void 0 && _classPrivateFieldGet3.attrs)) return null;
      return this.hoverPath(restruct.render).attr(options.selectionStyle);
    }
  }, {
    key: "show",
    value: function show(restruct, fragmentId, options) {
      var render = restruct.render;
      var fragment = restruct.molecule.frags.get(fragmentId);
      if (!(fragment !== null && fragment !== void 0 && fragment.enhancedStereoFlag)) {
        return;
      }
      var position = fragment.stereoFlagPosition ? fragment.stereoFlagPosition : Fragment.getDefaultStereoFlagPosition(restruct.molecule, fragmentId);
      var paper = render.paper;
      var ps = Scale.modelToCanvas(position, options);
      var stereoFlagMap = _defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"]({}, exports.StereoFlag.Abs, options.absFlagLabel), exports.StereoFlag.And, options.andFlagLabel), exports.StereoFlag.Mixed, options.mixedFlagLabel), exports.StereoFlag.Or, options.orFlagLabel);
      if (options.showStereoFlags && !options.ignoreChiralFlag) {
        _classPrivateFieldSet__default["default"](this, _path, paper.text(ps.x, ps.y, fragment.enhancedStereoFlag ? stereoFlagMap[fragment.enhancedStereoFlag] : '').attr({
          font: options.font,
          'font-size': options.fontsz,
          fill: '#000'
        }));
      }
      render.ctab.addReObjectPath(exports.LayerMap.data, this.visel, _classPrivateFieldGet__default["default"](this, _path), null, true);
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }]);
  return ReEnhancedFlag;
}(ReObject);

function _callSuper$O(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$O() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$O() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$O = function _isNativeReflectConstruct() { return !!t; })(); }
var ReFrag = function (_ReObject) {
  _inherits__default["default"](ReFrag, _ReObject);
  function ReFrag( frag) {
    var _this;
    _classCallCheck__default["default"](this, ReFrag);
    _this = _callSuper$O(this, ReFrag, ['frag']);
    _this.item = frag;
    return _this;
  }
  _createClass__default["default"](ReFrag, [{
    key: "fragGetAtoms",
    value: function fragGetAtoms(restruct, fid) {
      return Array.from(restruct.atoms.keys()).filter(function (aid) {
        return restruct.atoms.get(aid).a.fragment === fid;
      });
    }
  }, {
    key: "fragGetBonds",
    value: function fragGetBonds(restruct, fid) {
      return Array.from(restruct.bonds.keys()).filter(function (bid) {
        var bond = restruct.bonds.get(bid).b;
        var firstFrag = restruct.atoms.get(bond.begin).a.fragment;
        var secondFrag = restruct.atoms.get(bond.end).a.fragment;
        return firstFrag === fid && secondFrag === fid;
      });
    }
  }, {
    key: "calcBBox",
    value: function calcBBox(restruct, fid, render) {
      var ret;
      restruct.atoms.forEach(function (atom) {
        if (atom.a.fragment !== fid) return;
        var bba = atom.visel.boundingBox;
        if (!bba) {
          bba = new Box2Abs(atom.a.pp, atom.a.pp);
          var ext = new Vec2(0.05 * 3, 0.05 * 3);
          bba = bba.extend(ext, ext);
        } else {
          if (!render) render = global._ui_editor.render;
          bba = bba.translate((render.options.offset || new Vec2()).negated()).transform(Scale.canvasToModel, render.options);
        }
        ret = ret ? Box2Abs.union(ret, bba) : bba;
      });
      return ret;
    }
  }, {
    key: "_draw",
    value: function _draw(render, fid, attrs) {
      var bb = this.calcBBox(render.ctab, fid, render);
      if (bb) {
        var p0 = Scale.modelToCanvas(new Vec2(bb.p0.x, bb.p0.y), render.options);
        var p1 = Scale.modelToCanvas(new Vec2(bb.p1.x, bb.p1.y), render.options);
        return render.paper.rect(p0.x, p0.y, p1.x - p0.x, p1.y - p0.y, 0).attr(attrs);
      }
    }
  }, {
    key: "draw",
    value: function draw(_render) {
      return null;
    }
  }, {
    key: "drawHover",
    value: function drawHover(_render) {
    }
  }, {
    key: "setHover",
    value: function setHover(hover, render) {
      var fid = render.ctab.frags.keyOf(this);
      if (!fid && fid !== 0) {
        return;
      }
      fid = parseInt(fid, 10);
      render.ctab.atoms.forEach(function (atom) {
        if (atom.a.fragment === fid) atom.setHover(hover, render);
      });
      render.ctab.bonds.forEach(function (bond) {
        if (render.ctab.atoms.get(bond.b.begin).a.fragment === fid) {
          bond.setHover(hover, render);
        }
      });
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return false;
    }
  }]);
  return ReFrag;
}(ReObject);

function _callSuper$N(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$N() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$N() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$N = function _isNativeReflectConstruct() { return !!t; })(); }
var BORDER_EXT = new Vec2(0.05 * 3, 0.05 * 3);
var PADDING_VECTOR = new Vec2(0.2, 0.4);
var ReRGroup = function (_ReObject) {
  _inherits__default["default"](ReRGroup, _ReObject);
  function ReRGroup( rgroup) {
    var _this;
    _classCallCheck__default["default"](this, ReRGroup);
    _this = _callSuper$N(this, ReRGroup, ['rgroup']);
    _this.labelBox = null;
    _this.item = rgroup;
    return _this;
  }
  _createClass__default["default"](ReRGroup, [{
    key: "getAtoms",
    value: function getAtoms(render) {
      var ret = [];
      this.item.frags.forEach(function (fid) {
        ret = ret.concat(render.ctab.frags.get(fid).fragGetAtoms(render.ctab, fid));
      });
      return ret;
    }
  }, {
    key: "getBonds",
    value: function getBonds(render) {
      var ret = [];
      this.item.frags.forEach(function (fid) {
        ret = ret.concat(render.ctab.frags.get(fid).fragGetBonds(render.ctab, fid));
      });
      return ret;
    }
  }, {
    key: "calcBBox",
    value: function calcBBox(render) {
      var rGroupBoundingBox = null;
      this.item.frags.forEach(function (fid) {
        var fragBox = render.ctab.frags.get(fid).calcBBox(render.ctab, fid, render);
        if (fragBox) {
          rGroupBoundingBox = rGroupBoundingBox ? Box2Abs.union(rGroupBoundingBox, fragBox) : fragBox;
        }
      });
      var rGroupAttachmentPointsVBox = render.ctab.getRGroupAttachmentPointsVBoxByAtomIds(this.getAtoms(render));
      if (rGroupBoundingBox && rGroupAttachmentPointsVBox) {
        rGroupBoundingBox = Box2Abs.union(rGroupBoundingBox, rGroupAttachmentPointsVBox);
      }
      rGroupBoundingBox = rGroupBoundingBox ? rGroupBoundingBox.extend(BORDER_EXT, BORDER_EXT) : rGroupBoundingBox;
      return rGroupBoundingBox;
    }
  }, {
    key: "draw",
    value: function draw(render, options) {
      var bb = this.calcBBox(render);
      if (!bb) {
        return {};
      } else {
        bb = bb.extend(PADDING_VECTOR, PADDING_VECTOR);
      }
      var ret = {
        data: []
      };
      var p0 = Scale.modelToCanvas(bb.p0, options);
      var p1 = Scale.modelToCanvas(bb.p1, options);
      var brackets = render.paper.set();
      rGroupdrawBrackets(brackets, render, bb);
      ret.data.push(brackets);
      var key = render.ctab.rgroups.keyOf(this);
      var labelSet = render.paper.set();
      var label = render.paper.text(p0.x, (p0.y + p1.y) / 2, 'R' + key + '=').attr({
        font: options.font,
        'font-size': options.fontRLabel,
        fill: 'black'
      });
      var labelBox = util.relBox(label.getBBox());
      label.translateAbs(-labelBox.width / 2 - options.lineWidth, 0);
      labelSet.push(label);
      var logicStyle = {
        font: options.font,
        'font-size': options.fontRLogic,
        fill: 'black'
      };
      var logic = [rLogicToString(key, this.item)];
      var shift = labelBox.height / 2 + options.lineWidth / 2;
      for (var i = 0; i < logic.length; ++i) {
        var logicPath = render.paper.text(p0.x, (p0.y + p1.y) / 2, logic[i]).attr(logicStyle);
        var logicBox = util.relBox(logicPath.getBBox());
        shift += logicBox.height / 2;
        logicPath.translateAbs(-logicBox.width / 2 - 6 * options.lineWidth, shift);
        shift += logicBox.height / 2 + options.lineWidth / 2;
        ret.data.push(logicPath);
        labelSet.push(logicPath);
      }
      ret.data.push(label);
      this.labelBox = Box2Abs.fromRelBox(labelSet.getBBox()).transform(Scale.canvasToModel, render.options);
      return ret;
    }
  }, {
    key: "_draw",
    value: function _draw(render, rgid, attrs) {
      if (!this.getVBoxObj(render)) return null;
      var bb = this.getVBoxObj(render).extend(BORDER_EXT, BORDER_EXT);
      if (!bb) return null;
      var p0 = Scale.modelToCanvas(bb.p0, render.options);
      var p1 = Scale.modelToCanvas(bb.p1, render.options);
      return render.paper.rect(p0.x, p0.y, p1.x - p0.x, p1.y - p0.y, 0).attr(attrs);
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      var rgid = render.ctab.rgroups.keyOf(this);
      if (!rgid) {
        return null;
      }
      var ret = this._draw(render, rgid, render.options.hoverStyle );
      render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, ret);
      this.item.frags.forEach(function (fnum, fid) {
        render.ctab.frags.get(fid).drawHover(render);
      });
      return ret;
    }
  }, {
    key: "show",
    value: function show(restruct, id, options) {
      var _this2 = this;
      var drawing = this.draw(restruct.render, options);
      Object.keys(drawing).forEach(function (group) {
        while (drawing[group].length > 0) {
          restruct.addReObjectPath(exports.LayerMap.data, _this2.visel, drawing[group].shift(), null, true);
        }
      });
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return false;
    }
  }]);
  return ReRGroup;
}(ReObject);
function rGroupdrawBrackets(set, render, bb, d) {
  d = Scale.modelToCanvas(d || new Vec2(1, 0), render.options);
  var bracketWidth = Math.min(0.25, bb.sz().x * 0.3);
  var bracketHeight = bb.p1.y - bb.p0.y;
  var cy = 0.5 * (bb.p1.y + bb.p0.y);
  var leftBracket = draw.bracket(render.paper, d.negated(), d.negated().rotateSC(1, 0), Scale.modelToCanvas(new Vec2(bb.p0.x, cy), render.options), bracketWidth, bracketHeight, render.options);
  var rightBracket = draw.bracket(render.paper, d, d.rotateSC(1, 0), Scale.modelToCanvas(new Vec2(bb.p1.x, cy), render.options), bracketWidth, bracketHeight, render.options);
  return set.push(leftBracket, rightBracket);
}
function rLogicToString(id, rLogic) {
  var ifThen = rLogic.ifthen > 0 ? 'IF ' : '';
  var rangeExists = rLogic.range.startsWith('>') || rLogic.range.startsWith('<') || rLogic.range.startsWith('=');
  var range = null;
  if (rLogic.range.length > 0) {
    range = rangeExists ? rLogic.range : '=' + rLogic.range;
  } else range = '>0';
  var restH = rLogic.resth ? ' (RestH)' : '';
  var nextRg = rLogic.ifthen > 0 ? '\nTHEN R' + rLogic.ifthen.toString() : '';
  return "".concat(ifThen, "R").concat(id.toString()).concat(range).concat(restH).concat(nextRg);
}

function ownKeys$n(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$n(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$n(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$n(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$M(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$M() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$M() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$M = function _isNativeReflectConstruct() { return !!t; })(); }
var ReRxnArrow = function (_ReObject) {
  _inherits__default["default"](ReRxnArrow, _ReObject);
  function ReRxnArrow( arrow) {
    var _this;
    _classCallCheck__default["default"](this, ReRxnArrow);
    _this = _callSuper$M(this, ReRxnArrow, ['rxnArrow']);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "isResizing", false);
    _this.item = arrow;
    return _this;
  }
  _createClass__default["default"](ReRxnArrow, [{
    key: "calcDistance",
    value: function calcDistance(p, s) {
      var point = new Vec2(p.x, p.y);
      var distRef = this.getReferencePointDistance(p);
      var item = this.item;
      var pos = item.pos;
      var dist = calculateDistanceToLine$1(pos, point);
      if (RxnArrow.isElliptical(item)) {
        var _this$getReferencePoi = this.getReferencePoints(),
          _this$getReferencePoi2 = _slicedToArray__default["default"](_this$getReferencePoi, 3),
          startPoint = _this$getReferencePoi2[0],
          endPoint = _this$getReferencePoi2[1],
          middlePoint = _this$getReferencePoi2[2];
        dist = Math.min(dist, calculateDistanceToLine$1([startPoint, middlePoint], point), calculateDistanceToLine$1([middlePoint, endPoint], point));
      }
      var refPoint = distRef.minDist <= 8 / s ? distRef.refPoint : null;
      dist = Math.min(distRef.minDist, dist);
      return {
        minDist: dist,
        refPoint: refPoint
      };
    }
  }, {
    key: "getReferencePointDistance",
    value: function getReferencePointDistance(p) {
      var dist = [];
      var refPoints = this.getReferencePoints();
      refPoints.forEach(function (rp) {
        dist.push({
          minDist: Math.abs(Vec2.dist(p, rp)),
          refPoint: rp
        });
      });
      var minDist = dist.reduce(function (acc, current) {
        return !acc ? current : acc.minDist < current.minDist ? acc : current;
      }, null);
      return minDist;
    }
  }, {
    key: "hoverPath",
    value: function hoverPath(render) {
      var path = this.generatePath(render, render.options, 'selection');
      return render.paper.path(path);
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      var ret = this.hoverPath(render).attr(render.options.hoverStyle);
      render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, ret);
      return ret;
    }
  }, {
    key: "getReferencePoints",
    value: function getReferencePoints() {
      var refPoints = [];
      var item = this.item;
      var _item$pos = _slicedToArray__default["default"](item.pos, 2),
        a = _item$pos[0],
        b = _item$pos[1];
      var height = item.height;
      refPoints.push(new Vec2(a.x, a.y));
      refPoints.push(new Vec2(b.x, b.y));
      if (RxnArrow.isElliptical(item)) {
        var middlePoint = findMiddlePoint(height, a, b);
        refPoints.push(middlePoint);
      }
      return refPoints;
    }
  }, {
    key: "makeAdditionalInfo",
    value: function makeAdditionalInfo(restruct) {
      var scaleFactor = restruct.render.options.microModeScale;
      var refPoints = this.getReferencePoints();
      var selectionSet = restruct.render.paper.set();
      refPoints.forEach(function (rp) {
        var scaledRP = Scale.modelToCanvas(rp, restruct.render.options);
        selectionSet.push(restruct.render.paper.circle(scaledRP.x, scaledRP.y, scaleFactor / 8).attr({
          fill: 'black'
        }));
      });
      return selectionSet;
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(restruct, _paper, styles) {
      var render = restruct.render;
      var options = restruct.render.options;
      var selectionSet = restruct.render.paper.set();
      selectionSet.push(render.paper.path(this.generatePath(render, options, 'selection')).attr(styles.selectionStyle));
      return selectionSet;
    }
  }, {
    key: "generatePath",
    value: function generatePath(render, options, type) {
      var path;
      var item = this.item;
      var height = RxnArrow.isElliptical(item) && item.height ? item.height * options.microModeScale : 0;
      var pos = item.pos.map(function (p) {
        return Scale.modelToCanvas(p, options) || new Vec2();
      });
      var _this$getArrowParams = this.getArrowParams(pos[0].x, pos[0].y, pos[1].x, pos[1].y),
        length = _this$getArrowParams.length,
        angle = _this$getArrowParams.angle;
      switch (type) {
        case 'selection':
          path = draw.rectangleArrowHighlightAndSelection(render.paper, {
            pos: pos,
            height: height
          }, length, angle);
          break;
        case 'arrow':
          path = draw.arrow(render.paper, _objectSpread$n(_objectSpread$n({}, item), {}, {
            pos: pos,
            height: height
          }), length, angle, options, this.isResizing);
          break;
      }
      return path;
    }
  }, {
    key: "getArrowParams",
    value: function getArrowParams(x1, y1, x2, y2) {
      var length = Math.hypot(x2 - x1, y2 - y1);
      var angle = Raphael__default["default"].angle(x1, y1, x2, y2) - 180;
      return {
        length: length,
        angle: angle
      };
    }
  }, {
    key: "show",
    value: function show(restruct, _id, options) {
      var path = this.generatePath(restruct.render, options, 'arrow');
      var offset = options.offset;
      if (offset != null) path.translateAbs(offset.x, offset.y);
      this.visel.add(path, Box2Abs.fromRelBox(util.relBox(path.getBBox())));
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }]);
  return ReRxnArrow;
}(ReObject);
function calculateDistanceToLine$1(pos, point) {
  var dist;
  if ((point.x < Math.min(pos[0].x, pos[1].x) || point.x > Math.max(pos[0].x, pos[1].x)) && (point.y < Math.min(pos[0].y, pos[1].y) || point.y > Math.max(pos[0].y, pos[1].y))) {
    dist = Math.min(Vec2.dist(pos[0], point), Vec2.dist(pos[1], point));
  } else {
    var a = Vec2.dist(pos[0], pos[1]);
    var b = Vec2.dist(pos[0], point);
    var c = Vec2.dist(pos[1], point);
    var per = (a + b + c) / 2;
    dist = 2 / a * Math.sqrt(per * (per - a) * (per - b) * (per - c));
  }
  return dist;
}
function findMiddlePoint(height, a, b) {
  if (+tfx(height) === 0) {
    var minX = Math.min(a.x, b.x);
    var minY = Math.min(a.y, b.y);
    var x = minX + Math.abs(a.x - b.x) / 2;
    var y = minY + Math.abs(a.y - b.y) / 2;
    return new Vec2(x, y);
  }
  var length = Math.hypot(b.x - a.x, b.y - a.y);
  var lengthHyp = Math.hypot(length / 2, height);
  var coordinates1 = util.calcCoordinates(a, b, lengthHyp).pos1;
  var coordinates2 = util.calcCoordinates(a, b, lengthHyp).pos2;
  if (height > 0) {
    if (b.x < a.x) {
      return new Vec2(coordinates1 === null || coordinates1 === void 0 ? void 0 : coordinates1.x, coordinates1 === null || coordinates1 === void 0 ? void 0 : coordinates1.y);
    }
    if (b.x > a.x) {
      return new Vec2(coordinates2 === null || coordinates2 === void 0 ? void 0 : coordinates2.x, coordinates2 === null || coordinates2 === void 0 ? void 0 : coordinates2.y);
    }
    if (b.x === a.x) {
      if (b.y > a.y) {
        return new Vec2(coordinates2 === null || coordinates2 === void 0 ? void 0 : coordinates2.x, coordinates2 === null || coordinates2 === void 0 ? void 0 : coordinates2.y);
      }
      if (b.y < a.y) {
        return new Vec2(coordinates1 === null || coordinates1 === void 0 ? void 0 : coordinates1.x, coordinates1 === null || coordinates1 === void 0 ? void 0 : coordinates1.y);
      }
      if (b.y === a.y) {
        return new Vec2(a.x, a.y);
      }
    }
  } else {
    if (b.x > a.x) {
      return new Vec2(coordinates1 === null || coordinates1 === void 0 ? void 0 : coordinates1.x, coordinates1 === null || coordinates1 === void 0 ? void 0 : coordinates1.y);
    }
    if (b.x < a.x) {
      return new Vec2(coordinates2 === null || coordinates2 === void 0 ? void 0 : coordinates2.x, coordinates2 === null || coordinates2 === void 0 ? void 0 : coordinates2.y);
    }
    if (b.x === a.x) {
      if (b.y > a.y) {
        return new Vec2(coordinates1 === null || coordinates1 === void 0 ? void 0 : coordinates1.x, coordinates1 === null || coordinates1 === void 0 ? void 0 : coordinates1.y);
      }
      if (b.y < a.y) {
        return new Vec2(coordinates2 === null || coordinates2 === void 0 ? void 0 : coordinates2.x, coordinates2 === null || coordinates2 === void 0 ? void 0 : coordinates2.y);
      }
      if (b.y === a.y) {
        return new Vec2(a.x, a.y);
      }
    }
  }
  return new Vec2(a.x, a.y);
}

function _callSuper$L(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$L() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$L() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$L = function _isNativeReflectConstruct() { return !!t; })(); }
var ReRxnPlus = function (_ReObject) {
  _inherits__default["default"](ReRxnPlus, _ReObject);
  function ReRxnPlus( plus) {
    var _this;
    _classCallCheck__default["default"](this, ReRxnPlus);
    _this = _callSuper$L(this, ReRxnPlus, ['rxnPlus']);
    _this.item = plus;
    return _this;
  }
  _createClass__default["default"](ReRxnPlus, [{
    key: "hoverPath",
    value: function hoverPath(render) {
      var p = Scale.modelToCanvas(this.item.pp, render.options);
      var s = render.options.microModeScale;
      return render.paper.rect(p.x - s / 4, p.y - s / 4, s / 2, s / 2, s / 8);
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      var ret = this.hoverPath(render).attr(render.options.hoverStyle);
      render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, ret);
      return ret;
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(restruct, paper, styles) {
      return this.hoverPath(restruct.render).attr(styles.selectionStyle);
    }
  }, {
    key: "show",
    value: function show(restruct, id, options) {
      var render = restruct.render;
      var centre = Scale.modelToCanvas(this.item.pp, options);
      var path = draw.plus(render.paper, centre, options);
      var offset = options.offset;
      if (offset != null) path.translateAbs(offset.x, offset.y);
      this.visel.add(path, Box2Abs.fromRelBox(util.relBox(path.getBBox())));
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }]);
  return ReRxnPlus;
}(ReObject);

function _callSuper$K(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$K() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$K() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$K = function _isNativeReflectConstruct() { return !!t; })(); }
var ReDataSGroupData = function (_ReObject) {
  _inherits__default["default"](ReDataSGroupData, _ReObject);
  function ReDataSGroupData(sgroup) {
    var _this;
    _classCallCheck__default["default"](this, ReDataSGroupData);
    _this = _callSuper$K(this, ReDataSGroupData, ['sgroupData']);
    _this.sgroup = sgroup;
    return _this;
  }
  _createClass__default["default"](ReDataSGroupData, [{
    key: "hoverPath",
    value: function hoverPath(render) {
      var box = this.sgroup.dataArea;
      var p0 = Scale.modelToCanvas(box.p0, render.options);
      var sz = Scale.modelToCanvas(box.p1, render.options).sub(p0);
      return render.paper.rect(p0.x, p0.y, sz.x, sz.y);
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      var ret = this.hoverPath(render).attr(render.options.hoverStyle);
      render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, ret);
      return ret;
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(restruct, paper, styles) {
      return this.hoverPath(restruct.render).attr(styles.selectionStyle);
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }]);
  return ReDataSGroupData;
}(ReObject);

var BracketParams = _createClass__default["default"](function BracketParams(center, bracketAngleDirection, width, height, bracketDirection) {
  _classCallCheck__default["default"](this, BracketParams);
  this.center = center;
  this.bracketAngleDirection = bracketAngleDirection;
  this.bracketDirection = bracketDirection || bracketAngleDirection.rotateSC(1, 0);
  this.width = width;
  this.height = height;
});

function _callSuper$J(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$J() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$J() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$J = function _isNativeReflectConstruct() { return !!t; })(); }
var ReSGroup = function (_ReObject) {
  _inherits__default["default"](ReSGroup, _ReObject);
  function ReSGroup(sgroup) {
    var _this;
    _classCallCheck__default["default"](this, ReSGroup);
    _this = _callSuper$J(this, ReSGroup, ['sgroup']);
    _this.item = sgroup;
    return _this;
  }
  _createClass__default["default"](ReSGroup, [{
    key: "draw",
    value:
    function draw(remol, sgroup) {
      this.render = remol.render;
      var set = this.render.paper.set();
      var atomSet = new Pile(sgroup.atoms);
      var crossBonds = SGroup.getCrossBonds(remol.molecule, atomSet);
      SGroup.bracketPos(sgroup, remol.molecule, crossBonds, remol, this.render);
      var bracketBox = sgroup.bracketBox;
      var direction = sgroup.bracketDirection;
      sgroup.areas = [bracketBox];
      if (sgroup.isExpanded()) {
        var SGroupdrawBracketsOptions = {
          set: set,
          render: this.render,
          sgroup: sgroup,
          crossBonds: crossBonds,
          atomSet: atomSet,
          bracketBox: bracketBox,
          direction: direction
        };
        switch (sgroup.type) {
          case 'MUL':
            {
              SGroupdrawBracketsOptions.lowerIndexText = sgroup.data.mul;
              break;
            }
          case 'queryComponent':
            {
              break;
            }
          case 'SRU':
            {
              var connectivity = sgroup.data.connectivity || 'eu';
              if (connectivity === 'ht') connectivity = '';
              var subscript = sgroup.data.subscript || 'n';
              SGroupdrawBracketsOptions.lowerIndexText = subscript;
              SGroupdrawBracketsOptions.upperIndexText = connectivity;
              break;
            }
          case 'SUP':
            {
              SGroupdrawBracketsOptions.lowerIndexText = sgroup.data.name;
              SGroupdrawBracketsOptions.upperIndexText = null;
              SGroupdrawBracketsOptions.indexAttribute = {
                'font-style': 'italic'
              };
              break;
            }
          case 'GEN':
            {
              break;
            }
          case 'DAT':
            {
              set = drawGroupDat(remol, sgroup);
              break;
            }
        }
        var sgroupTypesWithBrackets = ['MUL', 'SRU', 'SUP', 'GEN', 'queryComponent'];
        if (sgroupTypesWithBrackets.includes(sgroup.type)) {
          SGroupdrawBrackets(SGroupdrawBracketsOptions);
        }
      }
      return set;
    }
  }, {
    key: "getTextHighlightDimensions",
    value: function getTextHighlightDimensions() {
      var padding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var render = arguments.length > 1 ? arguments[1] : undefined;
      var startX = 0;
      var startY = 0;
      var width = 0;
      var height = 0;
      var sGroup = this.item;
      if (sGroup) {
        var _sGroup$getContracted = sGroup.getContractedPosition(render.ctab.molecule),
          atomId = _sGroup$getContracted.atomId,
          position = _sGroup$getContracted.position;
        if (sGroup !== null && sGroup !== void 0 && sGroup.isContracted() && position) {
          var reSGroupAtom = render.ctab.atoms.get(atomId);
          var sGroupTextBoundingBox = (reSGroupAtom === null || reSGroupAtom === void 0 ? void 0 : reSGroupAtom.visel.boundingBox) || (reSGroupAtom === null || reSGroupAtom === void 0 ? void 0 : reSGroupAtom.visel.oldBoundingBox);
          if (sGroupTextBoundingBox) {
            var _Scale$modelToCanvas = Scale.modelToCanvas(position, render.options),
              x = _Scale$modelToCanvas.x,
              y = _Scale$modelToCanvas.y;
            var p0 = sGroupTextBoundingBox.p0,
              p1 = sGroupTextBoundingBox.p1;
            width = p1.x - p0.x + padding * 2;
            height = p1.y - p0.y + padding * 2;
            startX = x - width / 2;
            startY = y - height / 2;
          }
        }
      }
      return {
        startX: startX,
        startY: startY,
        width: width,
        height: height
      };
    }
  }, {
    key: "getContractedSelectionContour",
    value: function getContractedSelectionContour(render) {
      var paper = render.paper,
        options = render.options;
      var fontsz = options.fontsz,
        radiusScaleFactor = options.radiusScaleFactor;
      var radius = fontsz * radiusScaleFactor * 2;
      var _this$getTextHighligh = this.getTextHighlightDimensions(fontsz / 2, render),
        startX = _this$getTextHighligh.startX,
        startY = _this$getTextHighligh.startY,
        width = _this$getTextHighligh.width,
        height = _this$getTextHighligh.height;
      return paper.rect(startX, startY, width, height, radius);
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(restruct, _paper, options) {
      var sgroup = this.item;
      var functionalGroups = restruct.molecule.functionalGroups;
      var render = restruct.render;
      if (FunctionalGroup.isContractedFunctionalGroup(sgroup === null || sgroup === void 0 ? void 0 : sgroup.id, functionalGroups)) {
        return this.getContractedSelectionContour(render).attr(options.selectionStyle);
      }
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      var options = render.options;
      var paper = render.paper;
      var sGroupItem = this.item;
      if (sGroupItem) {
        var _getHighlighPathInfo = getHighlighPathInfo(sGroupItem, render),
          a0 = _getHighlighPathInfo.a0,
          a1 = _getHighlighPathInfo.a1,
          b0 = _getHighlighPathInfo.b0,
          b1 = _getHighlighPathInfo.b1;
        var functionalGroups = render.ctab.molecule.functionalGroups;
        var set = paper.set();
        if (FunctionalGroup.isContractedFunctionalGroup(sGroupItem.id, functionalGroups)) {
          sGroupItem.hovering = this.getContractedSelectionContour(render).attr(options.hoverStyle);
        } else if (!this.selected) {
          sGroupItem.hovering = paper.path('M{0},{1}L{2},{3}L{4},{5}L{6},{7}L{0},{1}',
          tfx(a0.x), tfx(a0.y), tfx(a1.x), tfx(a1.y), tfx(b1.x), tfx(b1.y), tfx(b0.x), tfx(b0.y)).attr(options.hoverStyle);
        }
        set.push(sGroupItem.hovering);
        SGroup.getAtoms(render.ctab.molecule, sGroupItem).forEach(function (aid) {
          var _render$ctab;
          set.push(render === null || render === void 0 || (_render$ctab = render.ctab) === null || _render$ctab === void 0 || (_render$ctab = _render$ctab.atoms) === null || _render$ctab === void 0 || (_render$ctab = _render$ctab.get(aid)) === null || _render$ctab === void 0 ? void 0 : _render$ctab.makeHoverPlate(render));
        }, this);
        SGroup.getBonds(render.ctab.molecule, sGroupItem).forEach(function (bid) {
          var _render$ctab2;
          set.push(render === null || render === void 0 || (_render$ctab2 = render.ctab) === null || _render$ctab2 === void 0 || (_render$ctab2 = _render$ctab2.bonds) === null || _render$ctab2 === void 0 || (_render$ctab2 = _render$ctab2.get(bid)) === null || _render$ctab2 === void 0 ? void 0 : _render$ctab2.makeHoverPlate(render));
        }, this);
        render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, set);
      }
    }
  }, {
    key: "show",
    value: function show(restruct) {
      var render = restruct.render;
      var sgroup = this.item;
      if (sgroup && sgroup.data.fieldName !== 'MRV_IMPLICIT_H') {
        var remol = render.ctab;
        var path = this.draw(remol, sgroup);
        restruct.addReObjectPath(exports.LayerMap.data, this.visel, path, null, true);
        this.setHover(this.hover, render);
      }
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return false;
    }
  }]);
  return ReSGroup;
}(ReObject);
function SGroupdrawBrackets(_ref) {
  var set = _ref.set,
    render = _ref.render,
    sgroup = _ref.sgroup,
    crossBonds = _ref.crossBonds,
    atomSet = _ref.atomSet,
    bracketBox = _ref.bracketBox,
    direction = _ref.direction,
    lowerIndexText = _ref.lowerIndexText,
    upperIndexText = _ref.upperIndexText,
    indexAttribute = _ref.indexAttribute;
  var attachmentPoints = _toConsumableArray__default["default"](atomSet).reduce(function (arr, atomId) {
    var rgroupAttachmentPointIds = render.ctab.molecule.getRGroupAttachmentPointsByAtomId(atomId);
    return [].concat(_toConsumableArray__default["default"](arr), _toConsumableArray__default["default"](rgroupAttachmentPointIds));
  }, []);
  var crossBondsPerAtom = Object.values(crossBonds);
  var crossBondsValues = crossBondsPerAtom.flat();
  var brackets = getBracketParameters(atomSet, crossBondsPerAtom, crossBondsValues, attachmentPoints, bracketBox, direction, render, sgroup.id);
  var rightBracketIndex = -1;
  var isBracketContainAttachment = crossBondsValues.length === 2 && crossBondsPerAtom.length === 1 && !!attachmentPoints.length;
  for (var i = 0; i < brackets.length; ++i) {
    var bracket = brackets[i];
    var path = draw.bracket(render.paper, Scale.modelToCanvas(bracket.bracketAngleDirection, render.options), Scale.modelToCanvas(bracket.bracketDirection, render.options), Scale.modelToCanvas(bracket.center, render.options), bracket.width, bracket.height, render.options, isBracketContainAttachment);
    set.push(path);
    if (rightBracketIndex < 0 || brackets[rightBracketIndex].bracketAngleDirection.x < bracket.bracketAngleDirection.x || brackets[rightBracketIndex].bracketAngleDirection.x === bracket.bracketAngleDirection.x && brackets[rightBracketIndex].bracketAngleDirection.y > bracket.bracketAngleDirection.y) {
      rightBracketIndex = i;
    }
  }
  var bracketR = brackets[rightBracketIndex];
  function renderIndex(text) {
    var isLowerText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var path;
    var lowerPath;
    var bracketPoint1 = new Vec2(set[rightBracketIndex].getPath()[1][1], set[rightBracketIndex].getPath()[1][2], 0);
    var bracketPoint2 = new Vec2(set[rightBracketIndex].getPath()[2][1], set[rightBracketIndex].getPath()[2][2], 0);
    if (bracketPoint2.y === bracketPoint1.y) {
      lowerPath = bracketPoint2.x > bracketPoint1.x ? bracketPoint1 : bracketPoint2;
    } else {
      lowerPath = bracketPoint2.y > bracketPoint1.y ? bracketPoint2 : bracketPoint1;
    }
    if (isLowerText) {
      path = lowerPath;
    } else {
      path = lowerPath.x === bracketPoint1.x && lowerPath.y === bracketPoint1.y ? bracketPoint2 : bracketPoint1;
    }
    var indexPos = new Vec2(path.x, path.y);
    var indexPath = render.paper.text(indexPos.x, indexPos.y, text).attr({
      font: render.options.font,
      'font-size': render.options.fontszsub
    });
    if (indexAttribute) indexPath.attr(indexAttribute);
    var indexBox = Box2Abs.fromRelBox(util.relBox(indexPath.getBBox()));
    var t = Math.max(util.shiftRayBox(indexPos, bracketR.bracketAngleDirection.negated(), indexBox), 3) + 2;
    indexPath.translateAbs(t * bracketR.bracketAngleDirection.x, t * bracketR.bracketAngleDirection.y);
    set.push(indexPath);
  }
  if (lowerIndexText) {
    renderIndex(lowerIndexText, true);
  }
  if (upperIndexText) renderIndex(upperIndexText);
}
function showValue(paper, pos, sgroup, options) {
  var text = paper.text(pos === null || pos === void 0 ? void 0 : pos.x, pos === null || pos === void 0 ? void 0 : pos.y, sgroup.data.fieldValue).attr({
    font: options.font,
    'font-size': options.fontsz
  });
  var box = text.getBBox();
  var rect = paper.rect(box.x - 1, box.y - 1, box.width + 2, box.height + 2, 3,
  3);
  rect = sgroup.selected ? rect.attr(options.selectionStyle) : rect.attr({
    fill: '#fff',
    stroke: '#fff'
  });
  var set = paper.set();
  set.push(rect, text.toFront());
  return set;
}
function drawGroupDat(restruct, sgroup) {
  SGroup.bracketPos(sgroup, restruct.molecule);
  sgroup.areas = sgroup.bracketBox ? [sgroup.bracketBox] : [];
  if (sgroup.pp === null) sgroup.calculatePP(restruct.molecule);
  return sgroup.data.attached ? drawAttachedDat(restruct, sgroup) : drawAbsoluteDat(restruct, sgroup);
}
function drawAbsoluteDat(restruct, sgroup) {
  var _sgroup$pp;
  var render = restruct.render;
  var options = render.options;
  var paper = render.paper;
  var set = paper.set();
  var ps = sgroup === null || sgroup === void 0 || (_sgroup$pp = sgroup.pp) === null || _sgroup$pp === void 0 ? void 0 : _sgroup$pp.scaled(options.microModeScale);
  var name = showValue(paper, ps, sgroup, options);
  if (sgroup.data.context !== SgContexts.Bond) {
    var box = util.relBox(name.getBBox());
    name.translateAbs(0.5 * box.width, -0.5 * box.height);
  }
  set.push(name);
  var sbox = Box2Abs.fromRelBox(util.relBox(name.getBBox()));
  sgroup.dataArea = sbox.transform(Scale.canvasToModel, render.options);
  if (!restruct.sgroupData.has(sgroup.id)) {
    restruct.sgroupData.set(sgroup.id, new ReDataSGroupData(sgroup));
  }
  return set;
}
function drawAttachedDat(restruct, sgroup) {
  var render = restruct.render;
  var options = render.options;
  var paper = render.paper;
  var set = paper.set();
  SGroup.getAtoms(restruct, sgroup).forEach(function (aid) {
    var atom = restruct.atoms.get(aid);
    if (atom) {
      var p = Scale.modelToCanvas(atom.a.pp, options);
      var bb = atom.visel.boundingBox;
      if (bb !== null) p.x = Math.max(p.x, bb.p1.x);
      p.x += options.lineWidth;
      var nameI = showValue(paper, p, sgroup, options);
      var boxI = util.relBox(nameI.getBBox());
      nameI.translateAbs(0.5 * boxI.width, -0.3 * boxI.height);
      set.push(nameI);
      var sboxI = Box2Abs.fromRelBox(util.relBox(nameI.getBBox()));
      sboxI = sboxI.transform(Scale.canvasToModel, render.options);
      sgroup.areas.push(sboxI);
    }
  });
  return set;
}
function getBracketParameters(atomSet, crossBondsPerAtom, crossBondsValues, attachmentPoints, bracketBox, direction, render, id) {
  var mol = render.ctab.molecule;
  var brackets = [];
  var bracketDirection = direction.rotateSC(1, 0);
  if (crossBondsValues.length < 2) {
    getBracketParamersWithCrossBondsLessThan2(direction, bracketDirection, bracketBox, brackets);
  } else if (crossBondsValues.length === 2 && crossBondsPerAtom.length === 2) {
    getBracketParamersWithCrossBondsEquals2(mol, crossBondsValues, id, render, attachmentPoints, brackets);
  } else if (crossBondsValues.length === 2 && crossBondsPerAtom.length === 1) {
    getBracketParamersWithCrossBondsMoreThan2OnOneAtom(crossBondsValues, mol, attachmentPoints, render, brackets);
  } else {
    for (var i = 0; i < crossBondsValues.length; ++i) {
      var bond = mol.bonds.get(Number(crossBondsValues[i]));
      var center = bond === null || bond === void 0 ? void 0 : bond.getCenter(mol);
      var _direction = atomSet.has(bond === null || bond === void 0 ? void 0 : bond.begin) ? bond === null || bond === void 0 ? void 0 : bond.getDir(mol) : bond === null || bond === void 0 ? void 0 : bond.getDir(mol).negated();
      if (center && _direction) {
        brackets.push(new BracketParams(center, _direction, 0.2, bracketBox.sz().y));
      }
    }
  }
  return brackets;
}
function getBracketParamersWithCrossBondsMoreThan2OnOneAtom(crossBondsValues, mol, attachmentPoints, render, brackets) {
  var notTemplateShapeFirstAtom = false;
  var bondDirections = crossBondsValues.map(function (value) {
    var bond = mol.bonds.get(Number(value));
    return (bond === null || bond === void 0 ? void 0 : bond.getDir(mol)) || new Vec2();
  });
  var needNegated = Vec2.crossProduct(bondDirections[0], bondDirections[1]) > 0;
  notTemplateShapeFirstAtom = Math.abs(Number(crossBondsValues[0]) - Number(crossBondsValues[1])) === 1;
  if (notTemplateShapeFirstAtom && !needNegated) {
    crossBondsValues.reverse();
  }
  for (var i = 0; i < crossBondsValues.length; ++i) {
    var bond = mol.bonds.get(Number(crossBondsValues[i]));
    var bondDirection = (bond === null || bond === void 0 ? void 0 : bond.getDir(mol)) || new Vec2();
    var bracketDirection = void 0;
    var bracketAngleDirection = void 0;
    var attachmentDirection = void 0;
    if (attachmentPoints.length !== 2) {
      if (needNegated && notTemplateShapeFirstAtom) {
        bondDirection = bondDirection.negated();
      }
      bondDirection = i === 0 ? bondDirection : bondDirection.negated();
      bracketDirection = i === 0 ? bondDirection.rotateSC(1, 0).negated() : bondDirection.rotateSC(1, 0);
      bracketAngleDirection = bondDirection;
    } else {
      var _render$ctab$rgroupAt;
      attachmentPoints = attachmentPoints.sort(function (point1, point2) {
        return point1 - point2;
      });
      attachmentDirection = ((_render$ctab$rgroupAt = render.ctab.rgroupAttachmentPoints.get(attachmentPoints[i])) === null || _render$ctab$rgroupAt === void 0 ? void 0 : _render$ctab$rgroupAt.lineDirectionVector) || new Vec2();
      bracketDirection = attachmentDirection.negated();
      bracketAngleDirection = i === 0 ? bracketDirection.rotateSC(1, 0) : bracketDirection.rotateSC(1, 0).negated();
    }
    brackets.push(new BracketParams((bond === null || bond === void 0 ? void 0 : bond.getCenter(mol)) || new Vec2(), bracketAngleDirection, 0.2, attachmentPoints.length ? 1.8 : 1.0, bracketDirection));
  }
  return {
    crossBondsValues: crossBondsValues,
    attachmentPoints: attachmentPoints
  };
}
function getBracketParamersWithCrossBondsEquals2(mol, crossBondsValues, id, render, attachmentPoints, brackets) {
  var bond1 = mol.bonds.get(Number(crossBondsValues[0]));
  var bond2 = mol.bonds.get(Number(crossBondsValues[1]));
  if (bond1 && bond2) {
    var _mol$sGroupForest;
    var leftCenter = bond1.getCenter(mol);
    var rightCenter = bond2.getCenter(mol);
    var leftShift = -1;
    var rightShift = -1;
    var bracketShift = -1;
    var bracketShiftNegated = -1;
    var centerConnection = Vec2.centre(leftCenter, rightCenter);
    var rightDirection = Vec2.diff(rightCenter, leftCenter).normalized();
    var leftDirection = rightDirection.negated();
    var bracketDirection = rightDirection.rotateSC(1, 0);
    var bracketDirectionNegated = bracketDirection.negated();
    mol === null || mol === void 0 || (_mol$sGroupForest = mol.sGroupForest) === null || _mol$sGroupForest === void 0 || (_mol$sGroupForest = _mol$sGroupForest.children) === null || _mol$sGroupForest === void 0 || (_mol$sGroupForest = _mol$sGroupForest.get(id)) === null || _mol$sGroupForest === void 0 || _mol$sGroupForest.forEach(function (sgid) {
      var _render$ctab3, _boundingBox;
      var boundingBox = render === null || render === void 0 || (_render$ctab3 = render.ctab) === null || _render$ctab3 === void 0 || (_render$ctab3 = _render$ctab3.sgroups) === null || _render$ctab3 === void 0 || (_render$ctab3 = _render$ctab3.get(sgid)) === null || _render$ctab3 === void 0 ? void 0 : _render$ctab3.visel.boundingBox;
      boundingBox = ((_boundingBox = boundingBox) === null || _boundingBox === void 0 ? void 0 : _boundingBox.translate((render.options.offset || new Vec2()).negated()).transform(Scale.canvasToModel, render.options)) || new Box2Abs();
      leftShift = Math.max(leftShift, util.shiftRayBox(leftCenter, leftDirection, boundingBox));
      rightShift = Math.max(rightShift, util.shiftRayBox(rightCenter, rightDirection, boundingBox));
      bracketShift = Math.max(bracketShift, util.shiftRayBox(centerConnection, bracketDirection, boundingBox));
      bracketShiftNegated = Math.max(bracketShiftNegated, util.shiftRayBox(centerConnection, bracketDirectionNegated, boundingBox));
    });
    leftShift = Math.max(leftShift + 0.2, 0);
    rightShift = Math.max(rightShift + 0.2, 0);
    bracketShift = Math.max(Math.max(bracketShift, bracketShiftNegated) + 0.1, 0);
    var bracketWidth = 0.25;
    var bracketHeight = 1.5 + bracketShift;
    if (attachmentPoints.length) {
      bracketHeight = 2 + 2 * Math.sin(Math.PI / 6) + bracketShift;
    }
    brackets.push(new BracketParams(leftCenter.addScaled(leftDirection, leftShift), leftDirection, bracketWidth, bracketHeight), new BracketParams(rightCenter.addScaled(rightDirection, rightShift), rightDirection, bracketWidth, bracketHeight));
  }
}
function getBracketParamersWithCrossBondsLessThan2(direction, bracketDirection, bracketBox, brackets) {
  direction = direction || new Vec2(1, 0);
  bracketDirection = bracketDirection || direction.rotateSC(1, 0);
  var bracketWidth = Math.min(0.25, bracketBox.sz().x * 0.3);
  var leftCenter = Vec2.lc2(direction, bracketBox.p0.x, bracketDirection, 0.5 * (bracketBox.p0.y + bracketBox.p1.y));
  var rightCenter = Vec2.lc2(direction, bracketBox.p1.x, bracketDirection, 0.5 * (bracketBox.p0.y + bracketBox.p1.y));
  var bracketHeight = bracketBox.sz().y;
  brackets.push(new BracketParams(leftCenter, direction.negated(), bracketWidth, bracketHeight), new BracketParams(rightCenter, direction, bracketWidth, bracketHeight));
}
function getHighlighPathInfo(sgroup, render) {
  var options = render.options;
  var bracketBox = sgroup.bracketBox.transform(Scale.modelToCanvas, options);
  var lineWidth = options.lineWidth;
  var vext = new Vec2(lineWidth * 4, lineWidth * 6);
  bracketBox = bracketBox.extend(vext, vext);
  var direction = sgroup.bracketDirection;
  var bracketDirection = direction.rotateSC(1, 0);
  var a0 = Vec2.lc2(direction, bracketBox.p0.x, bracketDirection, bracketBox.p0.y);
  var a1 = Vec2.lc2(direction, bracketBox.p0.x, bracketDirection, bracketBox.p1.y);
  var b0 = Vec2.lc2(direction, bracketBox.p1.x, bracketDirection, bracketBox.p0.y);
  var b1 = Vec2.lc2(direction, bracketBox.p1.x, bracketDirection, bracketBox.p1.y);
  var size = options.contractedFunctionalGroupSize;
  var startX = (b0.x + a0.x) / 2 - size / 2;
  var startY = (a1.y + a0.y) / 2 - size / 2;
  var _sgroup$getContracted = sgroup.getContractedPosition(render.ctab.molecule),
    contractedPosition = _sgroup$getContracted.position;
  if (contractedPosition) {
    var shift = new Vec2(size / 2, size / 2, 0);
    var hoverPp = Vec2.diff(contractedPosition.scaled(40), shift);
    startX = hoverPp.x;
    startY = hoverPp.y;
  }
  return {
    a0: a0,
    a1: a1,
    b0: b0,
    b1: b1,
    startX: startX,
    startY: startY,
    size: size
  };
}

function ownKeys$m(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$m(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$m(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$m(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$I(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$I() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$I() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$I = function _isNativeReflectConstruct() { return !!t; })(); }
var ReSimpleObject = function (_ReObject) {
  _inherits__default["default"](ReSimpleObject, _ReObject);
  function ReSimpleObject(simpleObject) {
    var _this;
    _classCallCheck__default["default"](this, ReSimpleObject);
    _this = _callSuper$I(this, ReSimpleObject, ['simpleObject']);
    _this.item = simpleObject;
    return _this;
  }
  _createClass__default["default"](ReSimpleObject, [{
    key: "calcDistance",
    value: function calcDistance(p, s) {
      var point = new Vec2(p.x, p.y);
      var distRef = this.getReferencePointDistance(p);
      var item = this.item;
      var mode = item.mode;
      var pos = item.pos;
      var dist;
      switch (mode) {
        case exports.SimpleObjectMode.ellipse:
          {
            var rad = Vec2.diff(pos[1], pos[0]);
            var rx = rad.x / 2;
            var ry = rad.y / 2;
            var center = Vec2.sum(pos[0], new Vec2(rx, ry));
            var pointToCenter = Vec2.diff(point, center);
            if (rx !== 0 && ry !== 0) {
              dist = Math.abs(1 - pointToCenter.x * pointToCenter.x / (rx * rx) - pointToCenter.y * pointToCenter.y / (ry * ry));
            } else {
              dist = calculateDistanceToLine(pos, point);
            }
            break;
          }
        case exports.SimpleObjectMode.rectangle:
          {
            var topX = Math.min(pos[0].x, pos[1].x);
            var topY = Math.min(pos[0].y, pos[1].y);
            var bottomX = Math.max(pos[0].x, pos[1].x);
            var bottomY = Math.max(pos[0].y, pos[1].y);
            var distances = [];
            if (point.x >= topX && point.x <= bottomX) {
              if (point.y < topY) {
                distances.push(topY - point.y);
              } else if (point.y > bottomY) {
                distances.push(point.y - bottomY);
              } else {
                distances.push(point.y - topY, bottomY - point.y);
              }
            }
            if (point.x < topX && point.y < topY) {
              distances.push(Vec2.dist(new Vec2(topX, topY), point));
            }
            if (point.x > bottomX && point.y > bottomY) {
              distances.push(Vec2.dist(new Vec2(bottomX, bottomY), point));
            }
            if (point.x < topX && point.y > bottomY) {
              distances.push(Vec2.dist(new Vec2(topX, bottomY), point));
            }
            if (point.x > bottomX && point.y < topY) {
              distances.push(Vec2.dist(new Vec2(bottomX, topY), point));
            }
            if (point.y >= topY && point.y <= bottomY) {
              if (point.x < topX) {
                distances.push(topX - point.x);
              } else if (point.x > bottomX) {
                distances.push(point.x - bottomX);
              } else {
                distances.push(point.x - topX, bottomX - point.x);
              }
            }
            dist = Math.min.apply(Math, distances);
            break;
          }
        case exports.SimpleObjectMode.line:
          {
            dist = calculateDistanceToLine(pos, point);
            break;
          }
        default:
          {
            throw new Error('Unsupported shape type');
          }
      }
      var refPoint = distRef.minDist <= 8 / s ? distRef.refPoint : null;
      dist = Math.min(distRef.minDist, dist);
      return {
        minDist: dist,
        refPoint: refPoint
      };
    }
  }, {
    key: "getReferencePointDistance",
    value: function getReferencePointDistance(p) {
      var dist = [];
      var refPoints = this.getReferencePoints();
      refPoints.forEach(function (rp) {
        dist.push({
          minDist: Math.abs(Vec2.dist(p, rp)),
          refPoint: rp
        });
      });
      var minDist = dist.reduce(function (acc, current) {
        return !acc ? current : acc.minDist < current.minDist ? acc : current;
      }, null);
      return minDist;
    }
  }, {
    key: "getReferencePoints",
    value: function getReferencePoints() {
      var onlyOnObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var refPoints = [];
      switch (this.item.mode) {
        case exports.SimpleObjectMode.ellipse:
        case exports.SimpleObjectMode.rectangle:
          {
            var p0 = new Vec2(Math.min(this.item.pos[0].x, this.item.pos[1].x), Math.min(this.item.pos[0].y, this.item.pos[1].y));
            var w = Math.abs(Vec2.diff(this.item.pos[0], this.item.pos[1]).x);
            var h = Math.abs(Vec2.diff(this.item.pos[0], this.item.pos[1]).y);
            refPoints.push(new Vec2(p0.x + 0.5 * w, p0.y), new Vec2(p0.x + w, p0.y + 0.5 * h), new Vec2(p0.x + 0.5 * w, p0.y + h), new Vec2(p0.x, p0.y + 0.5 * h));
            if (!onlyOnObject || this.item.mode === exports.SimpleObjectMode.rectangle) {
              refPoints.push(p0, new Vec2(p0.x, p0.y + h), new Vec2(p0.x + w, p0.y + h), new Vec2(p0.x + w, p0.y));
            }
            break;
          }
        case exports.SimpleObjectMode.line:
          {
            this.item.pos.forEach(function (i) {
              return refPoints.push(new Vec2(i.x, i.y, 0));
            });
            break;
          }
        default:
          {
            throw new Error('Unsupported shape type');
          }
      }
      return refPoints;
    }
  }, {
    key: "getHoverPathStyle",
    value: function getHoverPathStyle(path, render, isOuterShapeOfHoverPath) {
      if (isOuterShapeOfHoverPath) {
        return path.attr(render.options.hoverStyle);
      } else {
        return path.attr(_objectSpread$m(_objectSpread$m({}, render.options.hoverStyle), {}, {
          fill: '#fff'
        }));
      }
    }
  }, {
    key: "hoverPath",
    value: function hoverPath(render) {
      var point = [];
      this.item.pos.forEach(function (p, index) {
        point[index] = Scale.modelToCanvas(p, render.options);
      });
      var scaleFactor = render.options.microModeScale;
      var paths = [];
      switch (this.item.mode) {
        case exports.SimpleObjectMode.ellipse:
          {
            var rad = Vec2.diff(point[1], point[0]);
            var rx = rad.x / 2;
            var ry = rad.y / 2;
            var outerEllipse = render.paper.ellipse(
            tfx(point[0].x + rx), tfx(point[0].y + ry), tfx(Math.abs(rx) + scaleFactor / 8), tfx(Math.abs(ry) + scaleFactor / 8));
            paths.push({
              path: this.getHoverPathStyle(outerEllipse, render, true),
              stylesApplied: true
            });
            if (Math.abs(rx) - scaleFactor / 8 > 0 && Math.abs(ry) - scaleFactor / 8 > 0) {
              var innerEllipse = render.paper.ellipse(
              tfx(point[0].x + rx), tfx(point[0].y + ry), tfx(Math.abs(rx) - scaleFactor / 8), tfx(Math.abs(ry) - scaleFactor / 8));
              paths.push({
                path: this.getHoverPathStyle(innerEllipse, render, false),
                stylesApplied: true
              });
            }
            break;
          }
        case exports.SimpleObjectMode.rectangle:
          {
            var outerRect = render.paper.rect(
            tfx(Math.min(point[0].x, point[1].x) - scaleFactor / 8), tfx(Math.min(point[0].y, point[1].y) - scaleFactor / 8), tfx(Math.max(point[0].x, point[1].x) - Math.min(point[0].x, point[1].x) + scaleFactor / 4), tfx(Math.max(point[0].y, point[1].y) - Math.min(point[0].y, point[1].y) + scaleFactor / 4));
            paths.push({
              path: this.getHoverPathStyle(outerRect, render, true),
              stylesApplied: true
            });
            if (Math.max(point[0].x, point[1].x) - Math.min(point[0].x, point[1].x) - scaleFactor / 4 > 0 && Math.max(point[0].y, point[1].y) - Math.min(point[0].y, point[1].y) - scaleFactor / 4 > 0) {
              var innerRect = render.paper.rect(
              tfx(Math.min(point[0].x, point[1].x) + scaleFactor / 8), tfx(Math.min(point[0].y, point[1].y) + scaleFactor / 8), tfx(Math.max(point[0].x, point[1].x) - Math.min(point[0].x, point[1].x) - scaleFactor / 4), tfx(Math.max(point[0].y, point[1].y) - Math.min(point[0].y, point[1].y) - scaleFactor / 4));
              paths.push({
                path: this.getHoverPathStyle(innerRect, render, false),
                stylesApplied: true
              });
            }
            break;
          }
        case exports.SimpleObjectMode.line:
          {
            var poly = [];
            var angle = Math.atan((point[1].y - point[0].y) / (point[1].x - point[0].x));
            var p0 = {
              x: 0,
              y: 0
            };
            var p1 = {
              x: 0,
              y: 0
            };
            var k = point[0].x > point[1].x ? -1 : 1;
            p0.x = point[0].x - k * (scaleFactor / 8 * Math.cos(angle));
            p0.y = point[0].y - k * (scaleFactor / 8 * Math.sin(angle));
            p1.x = point[1].x + k * (scaleFactor / 8 * Math.cos(angle));
            p1.y = point[1].y + k * (scaleFactor / 8 * Math.sin(angle));
            poly.push('M', p0.x + k * scaleFactor / 8 * Math.sin(angle), p0.y - k * scaleFactor / 8 * Math.cos(angle));
            poly.push('L', p1.x + k * scaleFactor / 8 * Math.sin(angle), p1.y - k * scaleFactor / 8 * Math.cos(angle));
            poly.push('L', p1.x - k * scaleFactor / 8 * Math.sin(angle), p1.y + k * scaleFactor / 8 * Math.cos(angle));
            poly.push('L', p0.x - k * scaleFactor / 8 * Math.sin(angle), p0.y + k * scaleFactor / 8 * Math.cos(angle));
            poly.push('L', p0.x + k * scaleFactor / 8 * Math.sin(angle), p0.y - k * scaleFactor / 8 * Math.cos(angle));
            paths.push({
              path: this.getHoverPathStyle(render.paper.path(poly), render, true),
              stylesApplied: true
            });
            break;
          }
        default:
          {
            throw new Error('Unsupported shape type');
          }
      }
      return paths;
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      var paths = this.hoverPath(render).map(function (enhPath) {
        if (!enhPath.stylesApplied) {
          return enhPath.path.attr(render.options.hoverStyle);
        }
        return enhPath.path;
      });
      render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, paths);
      return paths;
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(restruct, paper, styles) {
      var _this2 = this;
      var pos = this.item.pos.map(function (p) {
        return Scale.modelToCanvas(p, restruct.render.options) || new Vec2();
      });
      var refPoints = this.getReferencePoints();
      var scaleFactor = restruct.render.options.microModeScale;
      this.selectionSet = restruct.render.paper.set();
      this.selectionPointsSet = restruct.render.paper.set();
      this.selectionSet.push(generatePath(this.item.mode, paper, pos).attr(styles.selectionStyleSimpleObject));
      refPoints.forEach(function (rp) {
        var scaledRP = Scale.modelToCanvas(rp, restruct.render.options);
        _this2.selectionPointsSet.push(restruct.render.paper.circle(scaledRP.x, scaledRP.y, scaleFactor / 8).attr({
          fill: 'black'
        }));
      });
      restruct.addReObjectPath(exports.LayerMap.selectionPlate, this.visel, this.selectionPointsSet);
      return this.selectionSet;
    }
  }, {
    key: "togglePoints",
    value: function togglePoints(displayFlag) {
      var _this$selectionPoints, _this$selectionPoints2;
      displayFlag ? (_this$selectionPoints = this.selectionPointsSet) === null || _this$selectionPoints === void 0 ? void 0 : _this$selectionPoints.show() : (_this$selectionPoints2 = this.selectionPointsSet) === null || _this$selectionPoints2 === void 0 ? void 0 : _this$selectionPoints2.hide();
    }
  }, {
    key: "show",
    value: function show(restruct, options) {
      var render = restruct.render;
      var pos = this.item.pos.map(function (p) {
        return Scale.modelToCanvas(p, options) || new Vec2();
      });
      var path = generatePath(this.item.mode, render.paper, pos);
      var offset = options.offset;
      if (offset != null) path.translateAbs(offset.x, offset.y);
      this.visel.add(path, Box2Abs.fromRelBox(util.relBox(path.getBBox())));
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }]);
  return ReSimpleObject;
}(ReObject);
function calculateDistanceToLine(pos, point) {
  var dist;
  if ((point.x < Math.min(pos[0].x, pos[1].x) || point.x > Math.max(pos[0].x, pos[1].x)) && (point.y < Math.min(pos[0].y, pos[1].y) || point.y > Math.max(pos[0].y, pos[1].y))) {
    dist = Math.min(Vec2.dist(pos[0], point), Vec2.dist(pos[1], point));
  } else {
    var a = Vec2.dist(pos[0], pos[1]);
    var b = Vec2.dist(pos[0], point);
    var c = Vec2.dist(pos[1], point);
    var per = (a + b + c) / 2;
    dist = 2 / a * Math.sqrt(per * (per - a) * (per - b) * (per - c));
  }
  return dist;
}
function generatePath(mode, paper, pos) {
  var path;
  switch (mode) {
    case exports.SimpleObjectMode.ellipse:
      {
        path = draw.ellipse(paper, pos);
        break;
      }
    case exports.SimpleObjectMode.rectangle:
      {
        path = draw.rectangle(paper, pos);
        break;
      }
    case exports.SimpleObjectMode.line:
      {
        path = draw.line(paper, pos);
        break;
      }
    default:
      {
        throw new Error('Unsupported shape type');
      }
  }
  return path;
}

function _callSuper$H(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$H() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$H() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$H = function _isNativeReflectConstruct() { return !!t; })(); }
var ReLoop = function (_ReObject) {
  _inherits__default["default"](ReLoop, _ReObject);
  function ReLoop(loop) {
    var _this;
    _classCallCheck__default["default"](this, ReLoop);
    _this = _callSuper$H(this, ReLoop, ['loop']);
    _this.loop = loop;
    _this.centre = new Vec2();
    _this.radius = new Vec2();
    return _this;
  }
  _createClass__default["default"](ReLoop, [{
    key: "show",
    value: function show(restruct, rlid, options) {
      var _this2 = this;
      var render = restruct.render;
      var paper = render.paper;
      var molecule = restruct.molecule;
      var loop = this.loop;
      this.centre = new Vec2();
      loop.hbs.forEach(function (hbid) {
        var hb = molecule.halfBonds.get(hbid);
        var bond = restruct.bonds.get(hb.bid);
        var apos = Scale.modelToCanvas(restruct.atoms.get(hb.begin).a.pp, options);
        if (bond.b.type !== Bond.PATTERN.TYPE.AROMATIC) loop.aromatic = false;
        _this2.centre.add_(apos);
      });
      loop.convex = true;
      for (var k = 0; k < this.loop.hbs.length; ++k) {
        var hba = molecule.halfBonds.get(loop.hbs[k]);
        var hbb = molecule.halfBonds.get(loop.hbs[(k + 1) % loop.hbs.length]);
        var angle = Math.atan2(Vec2.cross(hba.dir, hbb.dir), Vec2.dot(hba.dir, hbb.dir));
        if (angle > 0) loop.convex = false;
      }
      this.centre = this.centre.scaled(1.0 / loop.hbs.length);
      this.radius = -1;
      loop.hbs.forEach(function (hbid) {
        var hb = molecule.halfBonds.get(hbid);
        var apos = Scale.modelToCanvas(restruct.atoms.get(hb.begin).a.pp, options);
        var bpos = Scale.modelToCanvas(restruct.atoms.get(hb.end).a.pp, options);
        var n = Vec2.diff(bpos, apos).rotateSC(1, 0).normalized();
        var dist = Vec2.dot(Vec2.diff(apos, _this2.centre), n);
        _this2.radius = _this2.radius < 0 ? dist : Math.min(_this2.radius, dist);
      });
      this.radius *= 0.7;
      if (!loop.aromatic) return;
      var path = null;
      if (loop.convex && options.aromaticCircle) {
        path = paper.circle(this.centre.x, this.centre.y, this.radius).attr({
          stroke: '#000',
          'stroke-width': options.lineattr['stroke-width']
        });
      } else {
        var pathStr = '';
        for (var _k = 0; _k < loop.hbs.length; ++_k) {
          var _hba = molecule.halfBonds.get(loop.hbs[_k]);
          var _hbb = molecule.halfBonds.get(loop.hbs[(_k + 1) % loop.hbs.length]);
          var _angle = Math.atan2(Vec2.cross(_hba.dir, _hbb.dir), Vec2.dot(_hba.dir, _hbb.dir));
          var halfAngle = (Math.PI - _angle) / 2;
          var dir = _hbb.dir.rotate(halfAngle);
          var pi = Scale.modelToCanvas(restruct.atoms.get(_hbb.begin).a.pp, options);
          var sin = Math.sin(halfAngle);
          var minSin = 0.1;
          if (Math.abs(sin) < minSin) sin = sin * minSin / Math.abs(sin);
          var offset = options.bondSpace / sin;
          var qi = pi.addScaled(dir, -offset);
          pathStr += _k === 0 ? 'M' : 'L';
          pathStr += tfx(qi.x) + ',' + tfx(qi.y);
        }
        pathStr += 'Z';
        path = paper.path(pathStr).attr({
          stroke: '#000',
          'stroke-width': options.lineattr['stroke-width'],
          'stroke-dasharray': '- '
        });
      }
      restruct.addReObjectPath(exports.LayerMap.data, this.visel, path, null, true);
    }
  }, {
    key: "isValid",
    value: function isValid(struct, rlid) {
      var halfBonds = struct.halfBonds;
      return this.loop.hbs.every(function (hbid) {
        return halfBonds.has(hbid) && halfBonds.get(hbid).loop === rlid;
      });
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return false;
    }
  }]);
  return ReLoop;
}(ReObject);

function ownKeys$l(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$l(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$l(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$l(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$G(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$G() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$G() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$G = function _isNativeReflectConstruct() { return !!t; })(); }
var SCALE = 40;
var ReText = function (_ReObject) {
  _inherits__default["default"](ReText, _ReObject);
  function ReText(text) {
    var _this;
    _classCallCheck__default["default"](this, ReText);
    _this = _callSuper$G(this, ReText, ['text']);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "paths", []);
    _this.item = text;
    return _this;
  }
  _createClass__default["default"](ReText, [{
    key: "getReferencePoints",
    value: function getReferencePoints() {
      if (!this.paths.length) return [];
      var _this$getRelBox = this.getRelBox(this.paths),
        p0 = _this$getRelBox.p0,
        p1 = _this$getRelBox.p1;
      var p = this.item.position;
      var width = Math.abs(Vec2.diff(p0, p1).x) / SCALE;
      var height = Math.abs(Vec2.diff(p0, p1).y) / SCALE;
      var refPoints = [];
      refPoints.push(this.item.position, new Vec2(p.x, p.y + height), new Vec2(p.x + width, p.y + height), new Vec2(p.x + width, p.y));
      return refPoints;
    }
  }, {
    key: "getVBoxObj",
    value: function getVBoxObj() {
      var _this$getReferencePoi = this.getReferencePoints(),
        _this$getReferencePoi2 = _slicedToArray__default["default"](_this$getReferencePoi, 3),
        leftTopPoint = _this$getReferencePoi2[0];
        _this$getReferencePoi2[1];
        var rightBottomPoint = _this$getReferencePoi2[2];
      return new Box2Abs(leftTopPoint, rightBottomPoint);
    }
  }, {
    key: "hoverPath",
    value: function hoverPath(render) {
      var _this$getRelBox2 = this.getRelBox(this.paths),
        p0 = _this$getRelBox2.p0,
        p1 = _this$getRelBox2.p1;
      var topLeft = p0.sub(render.options.offset);
      var _p1$sub = p1.sub(p0),
        width = _p1$sub.x,
        height = _p1$sub.y;
      return render.paper.rect(topLeft.x, topLeft.y, width, height, 5);
    }
  }, {
    key: "getRelBox",
    value: function getRelBox(paths) {
      var _this2 = this;
      var firstElOfFirstRow = paths[0][0];
      var leftEdge = firstElOfFirstRow.getBBox().x;
      var firstRow = paths[0];
      var topEdge = Math.min.apply(Math, _toConsumableArray__default["default"](firstRow.map(function (path) {
        return path.getBBox().y;
      })));
      var widestRow = paths.reduce(function (widestRow, nextRow) {
        return _this2.getRowWidth(nextRow) > _this2.getRowWidth(widestRow) ? nextRow : widestRow;
      }, paths[0]);
      var lastElOfWidestRow = widestRow[widestRow.length - 1];
      var rightEdge = lastElOfWidestRow.getBBox().x + lastElOfWidestRow.getBBox().width;
      var lastRow = paths[paths.length - 1];
      var bottomEdge = Math.max.apply(Math, _toConsumableArray__default["default"](lastRow.map(function (path) {
        return path.getBBox().y + path.getBBox().height;
      })));
      return {
        p0: new Vec2(leftEdge, topEdge),
        p1: new Vec2(rightEdge, bottomEdge)
      };
    }
  }, {
    key: "getRowWidth",
    value: function getRowWidth(row) {
      return row.reduce(function (rowWidth, nextRow) {
        rowWidth += nextRow.getBBox().width;
        return rowWidth;
      }, 0);
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      if (!this.paths.length) return null;
      var ret = this.hoverPath(render).attr(render.options.hoverStyle);
      render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, ret);
      return ret;
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(restruct, paper, options) {
      if (!this.paths.length || !paper) return null;
      return this.hoverPath(restruct.render).attr(options.selectionStyle);
    }
  }, {
    key: "show",
    value: function show(restruct, _id, options) {
      var _this3 = this;
      var render = restruct.render;
      var paper = render.paper;
      var paperScale = Scale.modelToCanvas(this.item.position, options);
      var shiftY = 0;
      this.paths = [];
      var rawContentState = this.item.content ? JSON.parse(this.item.content) : null;
      if (!rawContentState) {
        return;
      }
      rawContentState.blocks.forEach(function (block) {
        var ranges = _this3.getRanges(block, options);
        var shiftX = 0;
        var row = [];
        ranges.forEach(function (_ref) {
          var _ref2 = _slicedToArray__default["default"](_ref, 3),
            start = _ref2[0],
            end = _ref2[1],
            styles = _ref2[2];
          block.text = block.text.replace(/[^\S\r\n]/g, "\xA0");
          var path = paper.text(paperScale.x, paperScale.y, block.text.substring(start, end + 1) || "\xA0").attr(_objectSpread$l({
            font: options.font,
            'font-size': options.fontsz,
            'text-anchor': 'start',
            fill: '#000000'
          }, styles));
          path.translateAbs(shiftX, shiftY + (styles.shiftY || 0));
          row.push(path);
          shiftX += path.getBBox().width;
        });
        _this3.paths.push(row);
        var _this3$getRelBox = _this3.getRelBox([row]),
          p0 = _this3$getRelBox.p0,
          p1 = _this3$getRelBox.p1;
        shiftY += Math.abs(Vec2.diff(p0, p1).y);
      });
      this.item.setPos(this.getReferencePoints());
      render.ctab.addReObjectPath(exports.LayerMap.data, this.visel, fp.flatten(this.paths), null, true);
    }
  }, {
    key: "getRanges",
    value: function getRanges(block, options) {
      var ranges = [];
      var start = 0;
      var styles = this.getStyles(block, start, options);
      for (var i = 1; i < block.text.length; i++) {
        var nextStyles = this.getStyles(block, i, options);
        if (!fp.isEqual(styles, nextStyles)) {
          ranges.push([start, i - 1, styles]);
          styles = nextStyles;
          start = i;
        }
      }
      ranges.push([start, block.text.length - 1, styles]);
      return ranges;
    }
  }, {
    key: "getStyles",
    value: function getStyles(block, index, options) {
      var ranges = block.inlineStyleRanges.filter(function (inlineRange) {
        return inlineRange.offset <= index && index < inlineRange.offset + inlineRange.length;
      });
      var customFontSize = ranges.reduce(function (acc, range) {
        if (range.style.includes(exports.TextCommand.FontSize)) {
          var _range$style$match;
          return (_range$style$match = range.style.match(/\d+/)) === null || _range$style$match === void 0 ? void 0 : _range$style$match[0];
        }
        return acc;
      }, null);
      ranges.sort(function (_, nextRange) {
        return nextRange.style.includes(exports.TextCommand.FontSize) ? 1 : -1;
      });
      return ranges.reduce(function (styles, textRange) {
        var fontsz = customFontSize || options.fontsz;
        var fontszsub = (customFontSize || options.fontszsub) * 0.5;
        switch (textRange.style) {
          case exports.TextCommand.Bold:
            styles['font-weight'] = 'bold';
            break;
          case exports.TextCommand.Italic:
            styles['font-style'] = 'italic';
            break;
          case exports.TextCommand.Subscript:
            styles['font-size'] = fontszsub + 'px';
            styles.shiftY = fontsz / 4;
            break;
          case exports.TextCommand.Superscript:
            styles['font-size'] = fontszsub + 'px';
            styles.shiftY = -fontsz / 3;
            break;
          case "".concat(exports.TextCommand.FontSize, "_").concat(customFontSize, "px"):
            styles['font-size'] = customFontSize + 'px';
            break;
        }
        return styles;
      }, {});
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }]);
  return ReText;
}(ReObject);

function _callSuper$F(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$F() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$F() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$F = function _isNativeReflectConstruct() { return !!t; })(); }
var ReRGroupAttachmentPoint = function (_ReObject) {
  _inherits__default["default"](ReRGroupAttachmentPoint, _ReObject);
  function ReRGroupAttachmentPoint(item, reAtom) {
    var _this;
    _classCallCheck__default["default"](this, ReRGroupAttachmentPoint);
    _this = _callSuper$F(this, ReRGroupAttachmentPoint, ['rgroupAttachmentPoint']);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "lineDirectionVector", new Vec2());
    _this.item = item;
    _this.reAtom = reAtom;
    return _this;
  }
  _createClass__default["default"](ReRGroupAttachmentPoint, [{
    key: "normalizedLineDirectionVector",
    get: function get() {
      return this.lineDirectionVector.normalized();
    }
  }, {
    key: "normalizedCurveDirectionVector",
    get: function get() {
      return this.lineDirectionVector.rotate(Math.PI / 2).normalized();
    }
  }, {
    key: "startPoint",
    get: function get() {
      return this.reAtom.a.pp;
    }
  }, {
    key: "middlePoint",
    get: function get() {
      return this.outlineEndPoint.addScaled(this.normalizedLineDirectionVector, -ReRGroupAttachmentPoint.CURVE_OUTLINE_HEIGHT);
    }
  }, {
    key: "endPoint",
    get: function get() {
      return this.startPoint.add(this.lineDirectionVector);
    }
  }, {
    key: "outlineEndPoint",
    get: function get() {
      var length = this.lineDirectionVector.length() + ReRGroupAttachmentPoint.OUTLINE_PADDING;
      return this.startPoint.addScaled(this.normalizedLineDirectionVector, length);
    }
  }, {
    key: "getOutlinePoints",
    value: function getOutlinePoints() {
      var topLeftPadPoint = this.outlineEndPoint.addScaled(this.normalizedCurveDirectionVector, -ReRGroupAttachmentPoint.CURVE_OUTLINE_WIDTH / 2);
      var topLeftPoint = topLeftPadPoint.addScaled(this.normalizedCurveDirectionVector, ReRGroupAttachmentPoint.OUTLINE_PADDING);
      var topRightPadPoint = this.outlineEndPoint.addScaled(this.normalizedCurveDirectionVector, ReRGroupAttachmentPoint.CURVE_OUTLINE_WIDTH / 2);
      var topRightPoint = topRightPadPoint.addScaled(this.normalizedCurveDirectionVector, -ReRGroupAttachmentPoint.OUTLINE_PADDING);
      var middleMostLeftPadPoint = this.middlePoint.addScaled(this.normalizedCurveDirectionVector, -ReRGroupAttachmentPoint.CURVE_OUTLINE_WIDTH / 2);
      var middleMostLeftPoint = middleMostLeftPadPoint.addScaled(this.normalizedCurveDirectionVector, ReRGroupAttachmentPoint.OUTLINE_PADDING);
      var middleMostRightPadPoint = this.middlePoint.addScaled(this.normalizedCurveDirectionVector, ReRGroupAttachmentPoint.CURVE_OUTLINE_WIDTH / 2);
      var middleMostRightPoint = middleMostRightPadPoint.addScaled(this.normalizedCurveDirectionVector, -ReRGroupAttachmentPoint.OUTLINE_PADDING);
      var middleLeftPoint = this.middlePoint.addScaled(this.normalizedCurveDirectionVector, -ReRGroupAttachmentPoint.LINE_OUTLINE_WIDTH / 2);
      var middleRightPoint = this.middlePoint.addScaled(this.normalizedCurveDirectionVector, ReRGroupAttachmentPoint.LINE_OUTLINE_WIDTH / 2);
      var bottomLeftPadPoint = this.startPoint.addScaled(this.normalizedCurveDirectionVector, -ReRGroupAttachmentPoint.LINE_OUTLINE_WIDTH / 2);
      var bottomLeftPoint = bottomLeftPadPoint.addScaled(this.normalizedLineDirectionVector, ReRGroupAttachmentPoint.OUTLINE_PADDING);
      var bottomRightPadPoint = this.startPoint.addScaled(this.normalizedCurveDirectionVector, ReRGroupAttachmentPoint.LINE_OUTLINE_WIDTH / 2);
      var bottomRightPoint = bottomRightPadPoint.addScaled(this.normalizedLineDirectionVector, ReRGroupAttachmentPoint.OUTLINE_PADDING);
      return [topLeftPadPoint, topLeftPoint, topRightPoint, topRightPadPoint, middleMostRightPadPoint, middleMostRightPoint, middleRightPoint, bottomRightPoint, bottomRightPadPoint, bottomLeftPadPoint, bottomLeftPoint, middleLeftPoint, middleMostLeftPoint, middleMostLeftPadPoint];
    }
  }, {
    key: "getDistanceTo",
    value: function getDistanceTo(destination) {
      return Vec2.dist(destination, this.middlePoint);
    }
  }, {
    key: "show",
    value: function show(restruct) {
      var directionVector = this.getAttachmentPointDirectionVector(restruct.molecule);
      if (!directionVector) {
        return;
      }
      this.lineDirectionVector = directionVector;
      showAttachmentPointShape(this.reAtom, restruct.render, directionVector, restruct.addReObjectPath.bind(restruct), this.visel);
      var showLabel = isAttachmentPointLabelRequired(restruct);
      if (showLabel) {
        var labelText = this.item.type === 'primary' ? '1' : '2';
        showAttachmentPointLabel(this.reAtom, restruct.render, directionVector, restruct.addReObjectPath.bind(restruct), labelText, this.visel);
      }
    }
  }, {
    key: "getHoverPlatePath",
    value: function getHoverPlatePath(options) {
      var outlinePoints = this.getOutlinePoints();
      var scaledOutlinePoints = outlinePoints.map(function (point) {
        return Scale.modelToCanvas(point, options);
      });
      var _scaledOutlinePoints = _slicedToArray__default["default"](scaledOutlinePoints, 14),
        topLeftPadPoint = _scaledOutlinePoints[0],
        topLeftPoint = _scaledOutlinePoints[1],
        topRightPoint = _scaledOutlinePoints[2],
        topRightPadPoint = _scaledOutlinePoints[3],
        middleMostRightPadPoint = _scaledOutlinePoints[4],
        middleMostRightPoint = _scaledOutlinePoints[5],
        middleRightPoint = _scaledOutlinePoints[6],
        bottomRightPoint = _scaledOutlinePoints[7],
        bottomRightPadPoint = _scaledOutlinePoints[8],
        bottomLeftPadPoint = _scaledOutlinePoints[9],
        bottomLeftPoint = _scaledOutlinePoints[10],
        middleLeftPoint = _scaledOutlinePoints[11],
        middleMostLeftPoint = _scaledOutlinePoints[12],
        middleMostLeftPadPoint = _scaledOutlinePoints[13];
      var pathString = "\n      M ".concat(topLeftPoint.x, " ").concat(topLeftPoint.y, "\n      L ").concat(topRightPoint.x, " ").concat(topRightPoint.y, "\n      C ").concat(topRightPadPoint.x, " ").concat(topRightPadPoint.y, ", ").concat(middleMostRightPadPoint.x, " ").concat(middleMostRightPadPoint.y, ", ").concat(middleMostRightPoint.x, " ").concat(middleMostRightPoint.y, "\n      L ").concat(middleRightPoint.x, " ").concat(middleRightPoint.y, "\n      L ").concat(bottomRightPoint.x, " ").concat(bottomRightPoint.y, "\n      C ").concat(bottomRightPadPoint.x, " ").concat(bottomRightPadPoint.y, ", ").concat(bottomLeftPadPoint.x, " ").concat(bottomLeftPadPoint.y, ", ").concat(bottomLeftPoint.x, " ").concat(bottomLeftPoint.y, "\n      L ").concat(middleLeftPoint.x, " ").concat(middleLeftPoint.y, "\n      L ").concat(middleMostLeftPoint.x, " ").concat(middleMostLeftPoint.y, "\n      C ").concat(middleMostLeftPadPoint.x, " ").concat(middleMostLeftPadPoint.y, ", ").concat(topLeftPadPoint.x, " ").concat(topLeftPadPoint.y, ", ").concat(topLeftPoint.x, " ").concat(topLeftPoint.y, "\n    ");
      return pathString;
    }
  }, {
    key: "makeHoverPlate",
    value: function makeHoverPlate(render) {
      var hoverPlatePath = this.getHoverPlatePath(render.options);
      return render.paper.path(hoverPlatePath).attr(render.options.hoverStyle);
    }
  }, {
    key: "makeSelectionPlate",
    value: function makeSelectionPlate(_restruct, paper, options) {
      var hoverPlatePath = this.getHoverPlatePath(options);
      return paper.path(hoverPlatePath).attr(options.selectionStyle);
    }
  }, {
    key: "drawHover",
    value: function drawHover(render) {
      var hoverPlate = this.makeHoverPlate(render);
      render.ctab.addReObjectPath(exports.LayerMap.hovering, this.visel, hoverPlate);
      return hoverPlate;
    }
  }, {
    key: "getAttachmentPointDirectionVector",
    value: function getAttachmentPointDirectionVector(struct) {
      if (!this.reAtom.hasAttachmentPoint()) {
        return;
      }
      if (this.isTrisectionAttachmentPoint()) {
        return trisectionLargestSector(this.reAtom, struct, this.item.type);
      } else {
        var hasOnlyOneBond = this.reAtom.a.neighbors.length === 1;
        var directionVector = hasOnlyOneBond ? getAttachmentDirectionForOnlyOneBond(this.reAtom, struct) : this.reAtom.bisectLargestSector(struct);
        return directionVector;
      }
    }
  }, {
    key: "isTrisectionAttachmentPoint",
    value: function isTrisectionAttachmentPoint() {
      return this.reAtom.a.attachmentPoints === exports.AttachmentPoints.BothSides;
    }
  }], [{
    key: "isSelectable",
    value: function isSelectable() {
      return true;
    }
  }]);
  return ReRGroupAttachmentPoint;
}(ReObject);
_defineProperty__default["default"](ReRGroupAttachmentPoint, "LINE_OUTLINE_WIDTH", 0.36);
_defineProperty__default["default"](ReRGroupAttachmentPoint, "OUTLINE_PADDING", 0.15);
_defineProperty__default["default"](ReRGroupAttachmentPoint, "CURVE_OUTLINE_WIDTH", 1.0);
_defineProperty__default["default"](ReRGroupAttachmentPoint, "CURVE_OUTLINE_HEIGHT", 0.42);
function showAttachmentPointShape(atom, _ref, directionVector, addReObjectPath, visel) {
  var options = _ref.options,
    paper = _ref.paper;
  var atomPositionVector = Scale.modelToCanvas(atom.a.pp, options);
  var shiftedAtomPositionVector = atom.getShiftedSegmentPosition(options, directionVector);
  var attachmentPointEnd = atomPositionVector.addScaled(directionVector, options.microModeScale * 0.85);
  var resultShape = draw.rgroupAttachmentPoint(paper, shiftedAtomPositionVector, attachmentPointEnd, directionVector, options);
  addReObjectPath(exports.LayerMap.indices, visel, resultShape, atomPositionVector, true);
}
function trisectionLargestSector(atom, struct, attachmentPointType) {
  var _atom$getLargestSecto = atom.getLargestSectorFromNeighbors(struct),
    largestAngle = _atom$getLargestSecto.largestAngle,
    neighborAngle = _atom$getLargestSecto.neighborAngle;
  var firstTrisectorAngle = neighborAngle + largestAngle / 3;
  var secondTrisectorAngle = neighborAngle + largestAngle * 2 / 3;
  return attachmentPointType === 'primary' ? newVectorFromAngle(firstTrisectorAngle) : newVectorFromAngle(secondTrisectorAngle);
}
function newVectorFromAngle(angle) {
  return new Vec2(Math.cos(angle), Math.sin(angle));
}
function isAttachmentPointLabelRequired(restruct) {
  return restruct.molecule.atoms.some(function (_ref2) {
    var attachmentPoints = _ref2.attachmentPoints;
    return attachmentPoints === exports.AttachmentPoints.SecondSideOnly || attachmentPoints === exports.AttachmentPoints.BothSides;
  });
}
function getAttachmentDirectionForOnlyOneBond(atom, struct) {
  var _struct$bonds$get;
  var DEGREE_120_FOR_ONE_BOND = 2 * Math.PI / 3;
  var DEGREE_180_FOR_TRIPLE_BOND = Math.PI;
  var onlyNeighbor = atom.a.neighbors[0];
  var neighbour = struct.halfBonds.get(onlyNeighbor);
  var angle = neighbour.ang;
  var isTripleBond = ((_struct$bonds$get = struct.bonds.get(neighbour.bid)) === null || _struct$bonds$get === void 0 ? void 0 : _struct$bonds$get.type) === Bond.PATTERN.TYPE.TRIPLE;
  var finalAngle = angle + (isTripleBond ? DEGREE_180_FOR_TRIPLE_BOND : DEGREE_120_FOR_ONE_BOND);
  return newVectorFromAngle(finalAngle);
}
function showAttachmentPointLabel(atom, _ref3, directionVector, addReObjectPath, labelText, visel) {
  var options = _ref3.options,
    paper = _ref3.paper;
  var atomPositionVector = Scale.modelToCanvas(atom.a.pp, options);
  var labelPosition = getLabelPositionForAttachmentPoint(atomPositionVector, directionVector, options.microModeScale);
  var labelPath = draw.rgroupAttachmentPointLabel(paper, labelPosition, labelText, options, atom.color);
  addReObjectPath(exports.LayerMap.indices, visel, labelPath, atomPositionVector, true);
}
function getLabelPositionForAttachmentPoint(atomPositionVector, directionVector, shapeHeight) {
  var normal = directionVector.rotateSC(1, 0);
  return atomPositionVector.addScaled(normal, 0.17 * shapeHeight).addScaled(directionVector, shapeHeight * 0.7);
}

function ownKeys$k(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$k(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$k(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$k(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }
function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var ReStruct = function () {
  function ReStruct(molecule, render) {
    var _this = this;
    _classCallCheck__default["default"](this, ReStruct);
    _defineProperty__default["default"](this, "atoms", new Map());
    _defineProperty__default["default"](this, "bonds", new Map());
    _defineProperty__default["default"](this, "reloops", new Map());
    _defineProperty__default["default"](this, "rxnPluses", new Map());
    _defineProperty__default["default"](this, "rxnArrows", new Map());
    _defineProperty__default["default"](this, "frags", new Pool());
    _defineProperty__default["default"](this, "rgroups", new Pool());
    _defineProperty__default["default"](this, "rgroupAttachmentPoints", new Pool());
    _defineProperty__default["default"](this, "sgroups", new Map());
    _defineProperty__default["default"](this, "sgroupData", new Map());
    _defineProperty__default["default"](this, "enhancedFlags", new Map());
    _defineProperty__default["default"](this, "simpleObjects", new Map());
    _defineProperty__default["default"](this, "texts", new Map());
    _defineProperty__default["default"](this, "initialized", false);
    _defineProperty__default["default"](this, "layers", []);
    _defineProperty__default["default"](this, "connectedComponents", new Pool());
    _defineProperty__default["default"](this, "ccFragmentType", new Pool());
    _defineProperty__default["default"](this, "structChanged", false);
    _defineProperty__default["default"](this, "atomsChanged", new Map());
    _defineProperty__default["default"](this, "simpleObjectsChanged", new Map());
    _defineProperty__default["default"](this, "rxnArrowsChanged", new Map());
    _defineProperty__default["default"](this, "rxnPlusesChanged", new Map());
    _defineProperty__default["default"](this, "enhancedFlagsChanged", new Map());
    _defineProperty__default["default"](this, "bondsChanged", new Map());
    _defineProperty__default["default"](this, "textsChanged", new Map());
    _defineProperty__default["default"](this, "snappingBonds", []);
    this.render = render;
    this.molecule = molecule || new Struct();
    this.initLayers();
    this.clearMarks();
    molecule.atoms.forEach(function (atom, aid) {
      _this.atoms.set(aid, new ReAtom(atom));
    });
    molecule.bonds.forEach(function (bond, bid) {
      _this.bonds.set(bid, new ReBond(bond));
    });
    molecule.loops.forEach(function (loop, lid) {
      _this.reloops.set(lid, new ReLoop(loop));
    });
    molecule.rxnPluses.forEach(function (item, id) {
      _this.rxnPluses.set(id, new ReRxnPlus(item));
    });
    molecule.rxnArrows.forEach(function (item, id) {
      _this.rxnArrows.set(id, new ReRxnArrow(item));
    });
    molecule.simpleObjects.forEach(function (item, id) {
      _this.simpleObjects.set(id, new ReSimpleObject(item));
    });
    molecule.texts.forEach(function (item, id) {
      _this.texts.set(id, new ReText(item));
    });
    molecule.frags.forEach(function (item, id) {
      _this.frags.set(id, new ReFrag(item));
      if (item) _this.enhancedFlags.set(id, new ReEnhancedFlag());
    });
    molecule.rgroups.forEach(function (item, id) {
      _this.rgroups.set(id, new ReRGroup(item));
    });
    molecule.rgroupAttachmentPoints.forEach(function (item, id) {
      var reAtom = _this.atoms.get(item.atomId);
      assert__default["default"](reAtom != null);
      _this.rgroupAttachmentPoints.set(id, new ReRGroupAttachmentPoint(item, reAtom));
    });
    molecule.sgroups.forEach(function (item, id) {
      _this.sgroups.set(id, new ReSGroup(item));
      if (item.type === 'DAT' && !item.data.attached) {
        _this.sgroupData.set(id, new ReDataSGroupData(item));
      }
    });
  }
  _createClass__default["default"](ReStruct, [{
    key: "visibleRGroupAttachmentPoints",
    get: function get() {
      var _this2 = this;
      var sgroups = this.molecule.sgroups;
      var functionalGroups = this.molecule.functionalGroups;
      return this.rgroupAttachmentPoints.filter(function (_id, reItem) {
        var atomId = reItem.item.atomId;
        var atom = _this2.molecule.atoms.get(atomId);
        assert__default["default"](atom != null);
        return !FunctionalGroup.isAtomInContractedFunctionalGroup(atom, sgroups, functionalGroups, false);
      });
    }
  }, {
    key: "connectedComponentRemoveAtom",
    value: function connectedComponentRemoveAtom(aid, reAtom) {
      var atom = reAtom || this.atoms.get(aid);
      if (!atom || atom.component < 0) return;
      var cc = this.connectedComponents.get(atom.component);
      cc["delete"](aid);
      if (cc.size < 1) this.connectedComponents["delete"](atom.component);
      atom.component = -1;
    }
  }, {
    key: "clearConnectedComponents",
    value: function clearConnectedComponents() {
      this.connectedComponents.clear();
      this.atoms.forEach(function (atom) {
        atom.component = -1;
      });
    }
  }, {
    key: "getConnectedComponent",
    value: function getConnectedComponent(aid, adjacentComponents) {
      var _this3 = this;
      var list = Array.isArray(aid) ? Array.from(aid) : [aid];
      var ids = new Pile();
      while (list.length > 0) {
        var _aid = list.pop();
        ids.add(_aid);
        var atom = this.atoms.get(_aid);
        if (!atom) continue;
        if (atom.component >= 0) adjacentComponents.add(atom.component);
        atom.a.neighbors.forEach(function (neighbor) {
          var halfBond = _this3.molecule.halfBonds.get(neighbor);
          if (!halfBond) return;
          var neiId = halfBond.end;
          if (!ids.has(neiId)) list.push(neiId);
        });
      }
      return ids;
    }
  }, {
    key: "addConnectedComponent",
    value: function addConnectedComponent(idSet) {
      var _this4 = this;
      var compId = this.connectedComponents.add(idSet);
      var adjacentComponents = new Pile();
      var aidSet = this.getConnectedComponent(Array.from(idSet), adjacentComponents);
      adjacentComponents["delete"](compId);
      var type = -1;
      aidSet.forEach(function (aid) {
        var atom = _this4.atoms.get(aid);
        if (!atom) return;
        atom.component = compId;
        if (atom.a.rxnFragmentType !== -1) type = atom.a.rxnFragmentType;
      });
      this.ccFragmentType.set(compId, type);
      return compId;
    }
  }, {
    key: "removeConnectedComponent",
    value: function removeConnectedComponent(ccid) {
      var _this5 = this;
      this.connectedComponents.get(ccid).forEach(function (aid) {
        var atom = _this5.atoms.get(aid);
        if (atom) atom.component = -1;
      });
      return this.connectedComponents["delete"](ccid);
    }
  }, {
    key: "assignConnectedComponents",
    value: function assignConnectedComponents() {
      var _this6 = this;
      this.atoms.forEach(function (atom, aid) {
        if (atom.component >= 0) return;
        var adjacentComponents = new Pile();
        var idSet = _this6.getConnectedComponent(aid, adjacentComponents);
        adjacentComponents.forEach(function (ccid) {
          _this6.removeConnectedComponent(ccid);
        });
        _this6.addConnectedComponent(idSet);
      });
    }
  }, {
    key: "initLayers",
    value: function initLayers() {
      for (var group in exports.LayerMap) {
        this.layers[exports.LayerMap[group]] = this.render.paper.rect(0, 0, 10, 10).attr({
          "class": group + 'Layer',
          fill: '#000',
          opacity: '0.0'
        }).toFront();
      }
    }
  }, {
    key: "addReObjectPath",
    value: function addReObjectPath(group, visel, path) {
      var _this7 = this;
      var pos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var visible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      if (!path || !this.layers[group].node.parentNode) return;
      var paths = Array.isArray(path) ? path : [path];
      paths.forEach(function (path) {
        var offset = _this7.render.options.offset;
        var bb = visible ? Box2Abs.fromRelBox(util.relBox(path.getBBox())) : null;
        var ext = pos && bb ? bb.translate(pos.negated()) : null;
        if (offset !== null) {
          path.translateAbs(offset.x, offset.y);
          bb = bb ? bb.translate(offset) : null;
        }
        visel.add(path, bb, ext);
        path.insertBefore(_this7.layers[exports.LayerMap[group]]);
      });
    }
  }, {
    key: "clearMarks",
    value: function clearMarks() {
      var _this8 = this;
      Object.keys(ReStruct.maps).forEach(function (map) {
        _this8[map + 'Changed'] = new Map();
      });
      this.structChanged = false;
    }
  }, {
    key: "markItemRemoved",
    value: function markItemRemoved() {
      this.structChanged = true;
    }
  }, {
    key: "markBond",
    value: function markBond(bid, mark) {
      this.markItem('bonds', bid, mark);
    }
  }, {
    key: "markAtom",
    value: function markAtom(aid, mark) {
      this.markItem('atoms', aid, mark);
    }
  }, {
    key: "markItem",
    value: function markItem(map, id, mark) {
      var mapChanged = this[map + 'Changed'];
      var value = mapChanged.has(id) ? Math.max(mark, mapChanged.get(id)) : mark;
      mapChanged.set(id, value);
      if (this[map].has(id)) this.clearVisel(this[map].get(id).visel);
    }
  }, {
    key: "clearVisel",
    value: function clearVisel(visel) {
      visel.paths.forEach(function (path) {
        path.remove();
      });
      visel.clear();
    }
  }, {
    key: "eachItem",
    value: function eachItem(func) {
      var _this9 = this;
      Object.keys(ReStruct.maps).forEach(function (map) {
        _this9[map].forEach(func);
      });
    }
  }, {
    key: "getSelectionBoxCenter",
    value: function getSelectionBoxCenter(selection) {
      var _boundingBox, _selection$atoms;
      var boundingBox = null;
      var _iterator = _createForOfIteratorHelper$4((_selection$atoms = selection.atoms) !== null && _selection$atoms !== void 0 ? _selection$atoms : []),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var atomId = _step.value;
          var atomPositionPoint = this.atoms.get(atomId).a.pp;
          var atomBox = new Box2Abs(atomPositionPoint, atomPositionPoint);
          boundingBox = boundingBox == null ? atomBox : Box2Abs.union(boundingBox, atomBox);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var selectionExceptAtoms = _objectSpread$k({}, selection);
      delete selectionExceptAtoms.atoms;
      var selectionExceptAtomsBoundingBox = this.getBoundingBoxForSelection(selectionExceptAtoms);
      if (selectionExceptAtomsBoundingBox) {
        boundingBox = boundingBox ? Box2Abs.union(boundingBox, selectionExceptAtomsBoundingBox) : selectionExceptAtomsBoundingBox;
      }
      return (_boundingBox = boundingBox) === null || _boundingBox === void 0 ? void 0 : _boundingBox.centre();
    }
  }, {
    key: "getVBoxObj",
    value: function getVBoxObj(selection) {
      if (isSelectionEmpty(selection)) {
        selection = this.getAllElementsAsSelectionMap();
      }
      var boundingBox = this.getBoundingBoxForSelection(selection);
      boundingBox = boundingBox || new Box2Abs(0, 0, 0, 0);
      return boundingBox;
    }
  }, {
    key: "getAllElementsAsSelectionMap",
    value: function getAllElementsAsSelectionMap() {
      var _this10 = this;
      var selection = {};
      Object.keys(ReStruct.maps).forEach(function (map) {
        selection[map] = Array.from(_this10[map].keys());
      });
      return selection;
    }
  }, {
    key: "getBoundingBoxForSelection",
    value: function getBoundingBoxForSelection(selection) {
      var _this11 = this;
      var boundingBox = null;
      Object.keys(ReStruct.maps).forEach(function (elementKey) {
        var _selection$elementKey;
        (_selection$elementKey = selection[elementKey]) === null || _selection$elementKey === void 0 || _selection$elementKey.forEach(function (elementId) {
          var box = _this11[elementKey].get(elementId).getVBoxObj(_this11.render);
          if (box) {
            boundingBox = boundingBox ? Box2Abs.union(boundingBox, box) : box.clone();
          }
        });
      });
      return boundingBox;
    }
  }, {
    key: "translate",
    value: function translate(d) {
      this.eachItem(function (item) {
        return item.visel.translate(d);
      });
    }
  }, {
    key: "scale",
    value: function scale(s) {
      this.eachItem(function (item) {
        return scaleVisel(item.visel, s);
      });
    }
  }, {
    key: "clearVisels",
    value: function clearVisels() {
      var _this12 = this;
      this.eachItem(function (item) {
        return _this12.clearVisel(item.visel);
      });
    }
  }, {
    key: "update",
    value: function update(force) {
      var _this13 = this;
      force = force || !this.initialized;
      Object.keys(ReStruct.maps).forEach(function (map) {
        var mapChanged = _this13[map + 'Changed'];
        if (force) {
          _this13[map].forEach(function (_item, id) {
            return mapChanged.set(id, 1);
          });
        } else {
          mapChanged.forEach(function (_value, id) {
            if (!_this13[map].has(id)) mapChanged["delete"](id);
          });
        }
      });
      this.atomsChanged.forEach(function (_value, aid) {
        return _this13.connectedComponentRemoveAtom(aid);
      });
      var emptyFrags = this.frags.filter(function (fid, frag) {
        return !frag.calcBBox(_this13.render.ctab, fid, _this13.render);
      });
      emptyFrags.forEach(function (frag, fid) {
        _this13.clearVisel(frag.visel);
        _this13.frags["delete"](fid);
        _this13.molecule.frags["delete"](fid);
      });
      Object.keys(ReStruct.maps).forEach(function (map) {
        var mapChanged = _this13[map + 'Changed'];
        mapChanged.forEach(function (_value, id) {
          if (_this13[map].get(id).visel) {
            _this13.clearVisel(_this13[map].get(id).visel);
          }
          _this13.structChanged = _this13.structChanged || mapChanged.get(id) > 0;
        });
      });
      this.sgroups.forEach(function (sgroup) {
        _this13.clearVisel(sgroup.visel);
        sgroup.hovering = null;
        sgroup.selectionPlate = null;
      });
      this.frags.forEach(function (frag) {
        _this13.clearVisel(frag.visel);
      });
      this.rgroups.forEach(function (rgroup) {
        _this13.clearVisel(rgroup.visel);
      });
      if (force) {
        this.clearConnectedComponents();
        this.molecule.initHalfBonds();
        this.molecule.initNeighbors();
      }
      var atomsChangedArray = Array.from(this.atomsChanged.keys());
      this.molecule.updateHalfBonds(atomsChangedArray);
      this.molecule.sortNeighbors(atomsChangedArray);
      this.assignConnectedComponents();
      this.initialized = true;
      this.verifyLoops();
      var updLoops = force || this.structChanged;
      if (updLoops) this.updateLoops();
      this.showAtoms();
      this.showBonds();
      this.showRgroupAttachmentPoints();
      if (updLoops) this.showLoops();
      this.showReactionSymbols();
      this.showSGroups();
      this.showFragments();
      this.showRGroups();
      this.showEnhancedFlags();
      this.showSimpleObjects();
      this.showTexts();
      this.clearMarks();
      return true;
    }
  }, {
    key: "updateLoops",
    value: function updateLoops() {
      var _this14 = this;
      this.reloops.forEach(function (reloop) {
        _this14.clearVisel(reloop.visel);
      });
      var ret = this.molecule.findLoops();
      ret.bondsToMark.forEach(function (bid) {
        _this14.markBond(bid, 1);
      });
      ret.newLoops.forEach(function (loopId) {
        _this14.reloops.set(loopId, new ReLoop(_this14.molecule.loops.get(loopId)));
      });
    }
  }, {
    key: "showLoops",
    value: function showLoops() {
      var _this15 = this;
      var options = this.render.options;
      this.reloops.forEach(function (reloop, rlid) {
        reloop.show(_this15, rlid, options);
      });
    }
  }, {
    key: "showSimpleObjects",
    value: function showSimpleObjects() {
      var _this16 = this;
      var options = this.render.options;
      this.simpleObjectsChanged.forEach(function (_value, id) {
        var simpleObject = _this16.simpleObjects.get(id);
        if (simpleObject) simpleObject.show(_this16, options);
      });
    }
  }, {
    key: "showTexts",
    value: function showTexts() {
      var _this17 = this;
      var options = this.render.options;
      this.textsChanged.forEach(function (_value, id) {
        var text = _this17.texts.get(id);
        if (text) text.show(_this17, id, options);
      });
    }
  }, {
    key: "showReactionSymbols",
    value: function showReactionSymbols() {
      var _this18 = this;
      var options = this.render.options;
      this.rxnArrowsChanged.forEach(function (_value, id) {
        var arrow = _this18.rxnArrows.get(id);
        if (arrow) arrow.show(_this18, id, options);
      });
      this.rxnPlusesChanged.forEach(function (_value, id) {
        var plus = _this18.rxnPluses.get(id);
        if (plus) plus.show(_this18, id, options);
      });
    }
  }, {
    key: "showSGroups",
    value: function showSGroups() {
      var _this19 = this;
      this.molecule.sGroupForest.getSGroupsBFS().reverse().forEach(function (id) {
        var resgroup = _this19.sgroups.get(id);
        if (!resgroup) return;
        resgroup.show(_this19);
      });
    }
  }, {
    key: "showFragments",
    value: function showFragments() {
      var _this20 = this;
      this.frags.forEach(function (frag, id) {
        var path = frag.draw(_this20.render, id);
        if (path) {
          _this20.addReObjectPath(exports.LayerMap.data, frag.visel, path, null, true);
        }
      });
    }
  }, {
    key: "showRGroups",
    value: function showRGroups() {
      var _this21 = this;
      var options = this.render.options;
      this.rgroups.forEach(function (rgroup, id) {
        rgroup.show(_this21, id, options);
      });
    }
  }, {
    key: "loopRemove",
    value: function loopRemove(loopId) {
      var _this22 = this;
      var reloop = this.reloops.get(loopId);
      if (!reloop) {
        return;
      }
      this.clearVisel(reloop.visel);
      var bondlist = [];
      reloop.loop.hbs.forEach(function (hbid) {
        var hb = _this22.molecule.halfBonds.get(hbid);
        if (!hb) return;
        hb.loop = -1;
        _this22.markBond(hb.bid, 1);
        _this22.markAtom(hb.begin, 1);
        bondlist.push(hb.bid);
      });
      this.reloops["delete"](loopId);
      this.molecule.loops["delete"](loopId);
    }
  }, {
    key: "verifyLoops",
    value: function verifyLoops() {
      var _this23 = this;
      this.reloops.forEach(function (reloop, rlid) {
        if (!reloop.isValid(_this23.molecule, rlid)) _this23.loopRemove(rlid);
      });
    }
  }, {
    key: "getRGroupAttachmentPointsVBoxByAtomIds",
    value: function getRGroupAttachmentPointsVBoxByAtomIds(atomsIds) {
      var _this24 = this;
      var allAtomAttachmentPointsVBox = null;
      atomsIds.forEach(function (atomId) {
        var attachmentPointIds = _this24.molecule.getRGroupAttachmentPointsByAtomId(atomId);
        var oneAtomAttachmentPointsVBox = attachmentPointIds.reduce(function (previousVBox, attachmentPointId) {
          var attachmentPoint = _this24.rgroupAttachmentPoints.get(attachmentPointId);
          assert__default["default"](attachmentPoint != null);
          var currentVBox = attachmentPoint.getVBoxObj(_this24.render);
          return previousVBox && currentVBox ? Box2Abs.union(previousVBox, currentVBox) : currentVBox;
        }, null);
        if (allAtomAttachmentPointsVBox && oneAtomAttachmentPointsVBox) {
          allAtomAttachmentPointsVBox = Box2Abs.union(allAtomAttachmentPointsVBox, oneAtomAttachmentPointsVBox);
        } else {
          var _allAtomAttachmentPoi;
          allAtomAttachmentPointsVBox = (_allAtomAttachmentPoi = allAtomAttachmentPointsVBox) !== null && _allAtomAttachmentPoi !== void 0 ? _allAtomAttachmentPoi : oneAtomAttachmentPointsVBox;
        }
      });
      return allAtomAttachmentPointsVBox;
    }
  }, {
    key: "showRgroupAttachmentPoints",
    value: function showRgroupAttachmentPoints() {
      var _this25 = this;
      this.rgroupAttachmentPoints.forEach(function (_value, id) {
        var rgroupAttachmentPoint = _this25.rgroupAttachmentPoints.get(id);
        if (rgroupAttachmentPoint !== null && rgroupAttachmentPoint !== void 0 && rgroupAttachmentPoint.visel) {
          _this25.clearVisel(rgroupAttachmentPoint.visel);
        }
        var attachedAtomId = rgroupAttachmentPoint === null || rgroupAttachmentPoint === void 0 ? void 0 : rgroupAttachmentPoint.item.atomId;
        var sgroup = _this25.molecule.getGroupFromAtomId(attachedAtomId);
        var isInsideContractedSGroup = Boolean(sgroup === null || sgroup === void 0 ? void 0 : sgroup.isContracted());
        if (isInsideContractedSGroup) {
          return;
        }
        rgroupAttachmentPoint === null || rgroupAttachmentPoint === void 0 || rgroupAttachmentPoint.show(_this25);
      });
    }
  }, {
    key: "showAtoms",
    value: function showAtoms() {
      var _this26 = this;
      var options = this.render.options;
      this.atomsChanged.forEach(function (_value, aid) {
        var atom = _this26.atoms.get(aid);
        if (atom) atom.show(_this26, aid, options);
      });
    }
  }, {
    key: "showEnhancedFlags",
    value: function showEnhancedFlags() {
      var _this27 = this;
      var options = this.render.options;
      this.enhancedFlagsChanged.forEach(function (_value, chid) {
        var flag = _this27.enhancedFlags.get(chid);
        if (flag) flag.show(_this27, chid, options);
      });
    }
  }, {
    key: "showBonds",
    value: function showBonds() {
      var _this28 = this;
      var options = this.render.options;
      this.bondsChanged.forEach(function (_value, bid) {
        var bond = _this28.bonds.get(bid);
        if (bond) {
          bond.show(_this28, bid, options);
        }
      });
    }
  }, {
    key: "setSelection",
    value: function setSelection(selection) {
      var _this29 = this;
      var atoms = [];
      Object.keys(ReStruct.maps).forEach(function (map) {
        var _this29$map$values = _this29[map].values(),
          _this29$map$values2 = _slicedToArray__default["default"](_this29$map$values, 1),
          mapValues = _this29$map$values2[0];
        if (ReStruct.maps[map].isSelectable() || mapValues instanceof ReSGroup) {
          _this29[map].forEach(function (item, id) {
            var _item$item, _item$selectionPlate;
            if (item instanceof ReAtom) {
              var sgroup;
              var _iterator2 = _createForOfIteratorHelper$4(item.a.sgs.values()),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var sgId = _step2.value;
                  sgroup = sgId;
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              atoms.push({
                selected: item.selected,
                sgroup: sgroup
              });
            }
            if (item instanceof ReSGroup && FunctionalGroup.isContractedFunctionalGroup(item === null || item === void 0 || (_item$item = item.item) === null || _item$item === void 0 ? void 0 : _item$item.id, _this29.molecule.functionalGroups)) {
              var sGroupAtoms = atoms.filter(function (atom) {
                var _item$item2;
                return atom.sgroup === (item === null || item === void 0 || (_item$item2 = item.item) === null || _item$item2 === void 0 ? void 0 : _item$item2.id);
              });
              item.selected = sGroupAtoms.length > 0 && sGroupAtoms[0].selected;
            }
            var selected = selection !== null && selection !== void 0 && selection[map] ? selection[map].indexOf(id) > -1 : item.selected;
            if (selection === null) {
              selected = false;
            }
            _this29.showItemSelection(item, selected);
            (_item$selectionPlate = item.selectionPlate) === null || _item$selectionPlate === void 0 || _item$selectionPlate.toBack();
          });
        }
      });
    }
  }, {
    key: "showItemSelection",
    value: function showItemSelection(item, selected) {
      var exists = isSelectionSvgObjectExists(item);
      item.selected = selected;
      if (item instanceof ReDataSGroupData) item.sgroup.selected = selected;
      if (selected) {
        if (!exists) {
          var render = this.render;
          var options = render.options;
          var paper = render.paper;
          item.selectionPlate = item.makeSelectionPlate(this, paper, options);
          this.addReObjectPath(exports.LayerMap.selectionPlate, item.visel, item.selectionPlate);
          if (typeof item.makeAdditionalInfo === 'function') {
            item.additionalInfo = item.makeAdditionalInfo(this);
            this.addReObjectPath(exports.LayerMap.additionalInfo, item.visel, item.additionalInfo);
          }
        }
        if (item.selectionPlate) {
          var _item$additionalInfo, _item$cip;
          item.selectionPlate.show();
          (_item$additionalInfo = item.additionalInfo) === null || _item$additionalInfo === void 0 || _item$additionalInfo.show();
          (_item$cip = item.cip) === null || _item$cip === void 0 || _item$cip.rectangle.attr({
            fill: '#7f7',
            stroke: '#7f7'
          });
          if (item.togglePoints) item.togglePoints(true);
        }
      } else if (exists && item.selectionPlate) {
        var _item$additionalInfo2, _item$cip2;
        item.selectionPlate.hide();
        if (item.togglePoints) item.togglePoints(false);
        (_item$additionalInfo2 = item.additionalInfo) === null || _item$additionalInfo2 === void 0 || _item$additionalInfo2.hide();
        (_item$cip2 = item.cip) === null || _item$cip2 === void 0 || _item$cip2.rectangle.attr({
          fill: '#fff',
          stroke: '#fff'
        });
      }
    }
  }, {
    key: "addSnappingBonds",
    value: function addSnappingBonds(bondId) {
      this.snappingBonds.push(bondId);
    }
  }, {
    key: "clearSnappingBonds",
    value: function clearSnappingBonds() {
      this.snappingBonds = [];
    }
  }, {
    key: "isSnappingBond",
    value: function isSnappingBond(bondId) {
      return this.snappingBonds.includes(bondId);
    }
  }]);
  return ReStruct;
}();
_defineProperty__default["default"](ReStruct, "maps", {
  atoms: ReAtom,
  bonds: ReBond,
  rxnPluses: ReRxnPlus,
  rxnArrows: ReRxnArrow,
  frags: ReFrag,
  rgroups: ReRGroup,
  rgroupAttachmentPoints: ReRGroupAttachmentPoint,
  sgroupData: ReDataSGroupData,
  enhancedFlags: ReEnhancedFlag,
  sgroups: ReSGroup,
  reloops: ReLoop,
  simpleObjects: ReSimpleObject,
  texts: ReText
});
function isSelectionEmpty(selection) {
  if (!selection) return true;
  var anySelection = Object.keys(ReStruct.maps).some(function (map) {
    return selection[map] && selection[map].length > 0;
  });
  return !anySelection;
}
function scaleRPath(path, scaleFactor) {
  if (path.type === 'set') {
    for (var i = 0; i < path.length; ++i) scaleRPath(path[i], scaleFactor);
  } else {
    if (!(typeof path.attrs === 'undefined')) {
      if ('font-size' in path.attrs) {
        path.attr('font-size', path.attrs['font-size'] * scaleFactor);
      } else if ('stroke-width' in path.attrs) {
        path.attr('stroke-width', path.attrs['stroke-width'] * scaleFactor);
      }
    }
    path.scale(scaleFactor, scaleFactor, 0, 0);
  }
}
function scaleVisel(visel, s) {
  for (var i = 0; i < visel.paths.length; ++i) scaleRPath(visel.paths[i], s);
}
function isSelectionSvgObjectExists(item) {
  var _item$selectionPlate2, _item$selectionPlate3, _item$selectionPlate4, _item$selectionPlate$;
  return item && item.selectionPlate !== null && (!((_item$selectionPlate2 = item.selectionPlate) !== null && _item$selectionPlate2 !== void 0 && _item$selectionPlate2.items) && !((_item$selectionPlate3 = item.selectionPlate) !== null && _item$selectionPlate3 !== void 0 && _item$selectionPlate3.removed) || Array.isArray((_item$selectionPlate4 = item.selectionPlate) === null || _item$selectionPlate4 === void 0 ? void 0 : _item$selectionPlate4.items) && !((_item$selectionPlate$ = item.selectionPlate[0]) !== null && _item$selectionPlate$ !== void 0 && _item$selectionPlate$.removed));
}

var FRAC = Math.PI / 12;
function setFracAngle(angle) {
  FRAC = Math.PI / 180 * angle;
}
function calcAngle(pos0, pos1) {
  var v = Vec2.diff(pos1, pos0);
  return Math.atan2(v.y, v.x);
}
function fracAngle(angle, angle2) {
  if (angle2) angle = calcAngle(angle, angle2);
  return Math.round(angle / FRAC) * FRAC;
}
function calcNewAtomPos(pos0, pos1, ctrlKey) {
  var vector = new Vec2(1, 0).rotate(ctrlKey ? calcAngle(pos0, pos1) : fracAngle(pos0, pos1));
  vector.add_(pos0);
  return vector;
}
function degrees(angle) {
  var degree = Math.round(angle / Math.PI * 180);
  if (degree > 180) degree -= 360;else if (degree <= -180) degree += 360;
  return degree;
}
var BONDS_MERGE_ANGLE = 10;
var BONDS_MERGE_SCALE = 0.2;
function mergeBondsParams(struct1, bond1, struct2, bond2) {
  var begin1 = struct1.atoms.get(bond1.begin);
  var begin2 = struct2.atoms.get(bond2.begin);
  var end1 = struct1.atoms.get(bond1.end);
  var end2 = struct2.atoms.get(bond2.end);
  var angle = calcAngle(begin1.pp, end1.pp) - calcAngle(begin2.pp, end2.pp);
  var mergeAngle = Math.abs(degrees(angle) % 180);
  var scale = Vec2.dist(begin1.pp, end1.pp) / Vec2.dist(begin2.pp, end2.pp);
  var merged = !_.inRange(mergeAngle, BONDS_MERGE_ANGLE, 180 - BONDS_MERGE_ANGLE) && _.inRange(scale, 1 - BONDS_MERGE_SCALE, 1 + BONDS_MERGE_SCALE);
  return {
    merged: merged,
    angle: angle,
    scale: scale,
    cross: Math.abs(degrees(angle)) > 90
  };
}
var utils$1 = {
  calcAngle: calcAngle,
  fracAngle: fracAngle,
  degrees: degrees,
  setFracAngle: setFracAngle,
  mergeBondsParams: mergeBondsParams,
  calcNewAtomPos: calcNewAtomPos
};

function defaultOptions(options) {
  var scaleFactorMicro = options.microModeScale || 100;
  var scaleFactorMacro = options.macroModeScale || 200;
  if (options.rotationStep) {
    utils$1.setFracAngle(options.rotationStep);
  }
  var labelFontSize = Math.ceil(1.9 * (scaleFactorMicro / 6));
  var subFontSize = Math.ceil(0.5 * labelFontSize);
  var defaultOptions = {
    'dearomatize-on-load': false,
    ignoreChiralFlag: false,
    disableQueryElements: null,
    showAtomIds: false,
    showBondIds: false,
    showHalfBondIds: false,
    showLoopIds: false,
    showValenceWarnings: true,
    autoScale: false,
    autoScaleMargin: 0,
    maxBondLength: 0,
    atomColoring: true,
    hideImplicitHydrogen: false,
    hideTerminalLabels: false,
    carbonExplicitly: false,
    showCharge: true,
    showHydrogenLabels: exports.ShowHydrogenLabels.TerminalAndHetero,
    showValence: true,
    aromaticCircle: true,
    microModeScale: scaleFactorMicro,
    macroModeScale: scaleFactorMacro,
    zoom: 1.0,
    offset: new Vec2(),
    lineWidth: scaleFactorMicro / 20,
    bondSpace: options.doubleBondWidth || scaleFactorMicro / 7,
    stereoBond: options.stereoBondWidth || scaleFactorMicro / 7,
    subFontSize: subFontSize,
    font: '30px Arial',
    fontsz: labelFontSize,
    fontszsub: subFontSize,
    fontRLabel: labelFontSize * 1.2,
    fontRLogic: labelFontSize * 0.7,
    radiusScaleFactor: 0.38,
    lineattr: {
      stroke: '#000',
      'stroke-width': options.bondThickness || scaleFactorMicro / 20,
      'stroke-linecap': 'round',
      'stroke-linejoin': 'round'
    },
    arrowSnappingStyle: {
      fill: '#365CFF',
      stroke: '#365CFF'
    },
    bondSnappingStyle: {
      fill: '#365CFF',
      stroke: '#365CFF',
      'stroke-width': options.bondThickness * 1.5
    },
    selectionStyle: {
      fill: '#57FF8F',
      stroke: '#57FF8F'
    },
    hoverStyle: {
      stroke: '#0097A8',
      fill: '#CCFFDD',
      'stroke-width': 0.6 * scaleFactorMicro / 20
    },
    sgroupBracketStyle: {
      stroke: 'darkgray',
      'stroke-width': 0.5 * scaleFactorMicro / 20
    },
    lassoStyle: {
      stroke: 'gray',
      'stroke-width': '1px'
    },
    selectionStyleSimpleObject: {
      stroke: '#57FF8F',
      'stroke-width': scaleFactorMicro / 4,
      'stroke-linecap': 'round'
    },
    movingStyle: {
      cursor: 'all-scroll'
    },
    atomSelectionPlateRadius: labelFontSize,
    contractedFunctionalGroupSize: 50,
    previewOpacity: 0.5
  };
  return Object.assign({}, defaultOptions, options);
}

var canvasToView = function canvasToView(point, render) {
  var offset = new Vec2(render.viewBox.minX, render.viewBox.minY);
  return point.sub(offset).scaled(render.options.zoom);
};
var modelToView = function modelToView(vector, render) {
  var pointInCanvas = Scale.modelToCanvas(vector, render.options);
  return canvasToView(pointInCanvas, render);
};
var viewToCanvas = function viewToCanvas(point, render) {
  var offset = new Vec2(render.viewBox.minX, render.viewBox.minY);
  return point.scaled(1 / render.options.zoom).add(offset);
};
var pageToView = function pageToView(event, renderClientArea) {
  var _renderClientArea$get = renderClientArea.getBoundingClientRect(),
    offsetTop = _renderClientArea$get.top,
    offsetLeft = _renderClientArea$get.left;
  return new Vec2(event.clientX - offsetLeft, event.clientY - offsetTop);
};
var pageToCanvas = function pageToCanvas(event, render) {
  var pointInViewBox = pageToView(event, render.clientArea);
  return viewToCanvas(pointInViewBox, render);
};
var pageToModel = function pageToModel(event, render) {
  var pointInCanvas = pageToCanvas(event, render);
  return Scale.canvasToModel(pointInCanvas, render.options);
};
var CoordinateTransformation = {
  modelToView: modelToView,
  canvasToView: canvasToView,
  viewToCanvas: viewToCanvas,
  pageToCanvas: pageToCanvas,
  pageToModel: pageToModel
};

function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration$b(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec$b(obj, privateMap, value) { _checkPrivateRedeclaration$b(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$b(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
var _render = new WeakMap();
var _calculateOffset = new WeakSet();
var ScrollOffset = function () {
  function ScrollOffset(render) {
    _classCallCheck__default["default"](this, ScrollOffset);
    _classPrivateMethodInitSpec(this, _calculateOffset);
    _classPrivateFieldInitSpec$b(this, _render, {
      writable: true,
      value: void 0
    });
    _defineProperty__default["default"](this, "up", 0);
    _defineProperty__default["default"](this, "down", 0);
    _defineProperty__default["default"](this, "left", 0);
    _defineProperty__default["default"](this, "right", 0);
    _classPrivateFieldSet__default["default"](this, _render, render);
  }
  _createClass__default["default"](ScrollOffset, [{
    key: "getAbsViewBox",
    value: function getAbsViewBox() {
      var viewBox = _classPrivateFieldGet__default["default"](this, _render).viewBox;
      var viewBoxMinXY = new Vec2(viewBox.minX, viewBox.minY);
      var viewBoxMaxXY = new Vec2(viewBox.minX + viewBox.width, viewBox.minY + viewBox.height);
      return new Box2Abs(viewBoxMinXY, viewBoxMaxXY);
    }
  }, {
    key: "getAbsBoundingBox",
    value: function getAbsBoundingBox() {
      var protoBoundingBox = _classPrivateFieldGet__default["default"](this, _render).ctab.getVBoxObj();
      var boundingBoxMinXY = Scale.modelToCanvas(protoBoundingBox.p0, _classPrivateFieldGet__default["default"](this, _render).options);
      var boundingBoxMaxXY = Scale.modelToCanvas(protoBoundingBox.p1, _classPrivateFieldGet__default["default"](this, _render).options);
      return new Box2Abs(boundingBoxMinXY, boundingBoxMaxXY);
    }
  }, {
    key: "update",
    value: function update() {
      _classPrivateMethodGet(this, _calculateOffset, _calculateOffset2).call(this);
    }
  }, {
    key: "hasVerticalOffset",
    value: function hasVerticalOffset() {
      return this.up > 0 || this.down > 0;
    }
  }, {
    key: "hasHorizontalOffset",
    value: function hasHorizontalOffset() {
      return this.left > 0 || this.right > 0;
    }
  }]);
  return ScrollOffset;
}();
function _calculateOffset2() {
  var absBoundingBox = this.getAbsBoundingBox();
  if (absBoundingBox.hasZeroArea()) {
    this.up = 0;
    this.down = 0;
    this.left = 0;
    this.right = 0;
  } else {
    var absViewBox = this.getAbsViewBox();
    this.up = absViewBox.p0.y - absBoundingBox.p0.y;
    this.down = absBoundingBox.p1.y - absViewBox.p1.y;
    this.left = absViewBox.p0.x - absBoundingBox.p0.x;
    this.right = absBoundingBox.p1.x - absViewBox.p1.x;
  }
}

function ownKeys$j(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$j(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$j(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var Scrollbar = function () {
  function Scrollbar(render) {
    _classCallCheck__default["default"](this, Scrollbar);
    _defineProperty__default["default"](this, "bar", null);
    _defineProperty__default["default"](this, "viewBoxBeforeDrag", null);
    _defineProperty__default["default"](this, "MIN_LENGTH", 40);
    _defineProperty__default["default"](this, "RADIUS", 2);
    _defineProperty__default["default"](this, "MARGIN", 5);
    _defineProperty__default["default"](this, "WIDTH", 4);
    _defineProperty__default["default"](this, "DIST_TO_EDGE", 5);
    _defineProperty__default["default"](this, "COLOR", '#b2bbc3');
    this.render = render;
  }
  _createClass__default["default"](Scrollbar, [{
    key: "update",
    value: function update() {
      this.bar = this.hasOffset() ? this.redraw() : this.hide();
    }
  }, {
    key: "redraw",
    value: function redraw() {
      return this.bar ? this.updateAttr() : this.draw();
    }
  }, {
    key: "updateAttr",
    value: function updateAttr() {
      var _this$bar;
      var attr = this.getDynamicAttr();
      return (_this$bar = this.bar) === null || _this$bar === void 0 ? void 0 : _this$bar.attr(attr);
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this$bar2, _this$bar3;
      (_this$bar2 = this.bar) === null || _this$bar2 === void 0 || _this$bar2.undrag();
      (_this$bar3 = this.bar) === null || _this$bar3 === void 0 || _this$bar3.remove();
      return null;
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this$getDynamicAttr = this.getDynamicAttr(),
        x = _this$getDynamicAttr.x,
        y = _this$getDynamicAttr.y,
        width = _this$getDynamicAttr.width,
        height = _this$getDynamicAttr.height,
        r = _this$getDynamicAttr.r;
      var bar = this.render.paper.rect(x, y, width, height, r).attr({
        stroke: this.COLOR,
        fill: this.COLOR
      });
      bar.drag(this.onDragMove, this.onDragStart, this.onDragEnd, this, this, this);
      return bar;
    }
  }, {
    key: "onDragStart",
    value: function onDragStart(_x, _y, event) {
      this.viewBoxBeforeDrag = _objectSpread$j({}, this.render.viewBox);
      event.stopPropagation();
    }
  }, {
    key: "onDragEnd",
    value: function onDragEnd(event) {
      event.stopPropagation();
    }
  }]);
  return Scrollbar;
}();

var SCALE_FACTOR = 0.5;
var getUserFriendlyScrollOffset = function getUserFriendlyScrollOffset(offset) {
  return offset * SCALE_FACTOR;
};
var getUserFriendlyViewBoxDelta = function getUserFriendlyViewBoxDelta(delta) {
  return delta / SCALE_FACTOR;
};
var getZoomedValue = function getZoomedValue(value, renderOptions) {
  return value / renderOptions.zoom;
};

function ownKeys$i(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$i(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$i(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$E(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$E() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$E() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$E = function _isNativeReflectConstruct() { return !!t; })(); }
function _classPrivateFieldInitSpec$a(obj, privateMap, value) { _checkPrivateRedeclaration$a(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$a(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _scrollOffset$2 = new WeakMap();
var VerticalScrollbar = function (_Scrollbar) {
  _inherits__default["default"](VerticalScrollbar, _Scrollbar);
  function VerticalScrollbar(render, scrollOffset) {
    var _this;
    _classCallCheck__default["default"](this, VerticalScrollbar);
    _this = _callSuper$E(this, VerticalScrollbar, [render]);
    _classPrivateFieldInitSpec$a(_assertThisInitialized__default["default"](_this), _scrollOffset$2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet__default["default"](_assertThisInitialized__default["default"](_this), _scrollOffset$2, scrollOffset);
    return _this;
  }
  _createClass__default["default"](VerticalScrollbar, [{
    key: "hasOffset",
    value: function hasOffset() {
      return _classPrivateFieldGet__default["default"](this, _scrollOffset$2).hasVerticalOffset();
    }
  }, {
    key: "getDynamicAttr",
    value: function getDynamicAttr() {
      var minX = this.render.viewBox.minX + this.render.viewBox.width - getZoomedValue(this.DIST_TO_EDGE, this.render.options);
      var minY = this.render.viewBox.minY + _.clamp(getUserFriendlyScrollOffset(_classPrivateFieldGet__default["default"](this, _scrollOffset$2).up), getZoomedValue(this.MARGIN, this.render.options), this.render.viewBox.height - getZoomedValue(this.MIN_LENGTH + this.MARGIN, this.render.options));
      var maxY = this.render.viewBox.minY + this.render.viewBox.height - _.clamp(getUserFriendlyScrollOffset(_classPrivateFieldGet__default["default"](this, _scrollOffset$2).down), getZoomedValue(this.MARGIN, this.render.options), this.render.viewBox.height);
      var length = Math.max(maxY - minY, getZoomedValue(this.MIN_LENGTH, this.render.options));
      return {
        x: minX,
        y: minY,
        width: getZoomedValue(this.WIDTH, this.render.options),
        height: length,
        r: getZoomedValue(this.RADIUS, this.render.options)
      };
    }
  }, {
    key: "onDragMove",
    value: function onDragMove(_dx, dy, _x, _y, _event) {
      if (!this.viewBoxBeforeDrag) {
        return;
      }
      this.render.setViewBox(_objectSpread$i(_objectSpread$i({}, this.viewBoxBeforeDrag), {}, {
        minY: this.viewBoxBeforeDrag.minY + getUserFriendlyViewBoxDelta(dy)
      }));
    }
  }]);
  return VerticalScrollbar;
}(Scrollbar);

function ownKeys$h(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$h(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$h(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$D(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$D() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$D() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$D = function _isNativeReflectConstruct() { return !!t; })(); }
function _classPrivateFieldInitSpec$9(obj, privateMap, value) { _checkPrivateRedeclaration$9(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$9(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _scrollOffset$1 = new WeakMap();
var HorizontalScrollbar = function (_Scrollbar) {
  _inherits__default["default"](HorizontalScrollbar, _Scrollbar);
  function HorizontalScrollbar(render, scrollOffset) {
    var _this;
    _classCallCheck__default["default"](this, HorizontalScrollbar);
    _this = _callSuper$D(this, HorizontalScrollbar, [render]);
    _classPrivateFieldInitSpec$9(_assertThisInitialized__default["default"](_this), _scrollOffset$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet__default["default"](_assertThisInitialized__default["default"](_this), _scrollOffset$1, scrollOffset);
    return _this;
  }
  _createClass__default["default"](HorizontalScrollbar, [{
    key: "hasOffset",
    value: function hasOffset() {
      return _classPrivateFieldGet__default["default"](this, _scrollOffset$1).hasHorizontalOffset();
    }
  }, {
    key: "getDynamicAttr",
    value: function getDynamicAttr() {
      var minX = this.render.viewBox.minX + _.clamp(getUserFriendlyScrollOffset(_classPrivateFieldGet__default["default"](this, _scrollOffset$1).left), getZoomedValue(this.MARGIN, this.render.options), this.render.viewBox.width - getZoomedValue(this.MIN_LENGTH + this.MARGIN, this.render.options));
      var minY = this.render.viewBox.minY + this.render.viewBox.height - getZoomedValue(this.DIST_TO_EDGE, this.render.options);
      var maxX = this.render.viewBox.minX + this.render.viewBox.width - _.clamp(getUserFriendlyScrollOffset(_classPrivateFieldGet__default["default"](this, _scrollOffset$1).right), getZoomedValue(this.MARGIN, this.render.options), this.render.viewBox.width);
      var length = Math.max(maxX - minX, getZoomedValue(this.MIN_LENGTH, this.render.options));
      return {
        x: minX,
        y: minY,
        width: length,
        height: getZoomedValue(this.WIDTH, this.render.options),
        r: getZoomedValue(this.RADIUS, this.render.options)
      };
    }
  }, {
    key: "onDragMove",
    value: function onDragMove(dx, _dy, _x, _y, _event) {
      if (!this.viewBoxBeforeDrag) {
        return;
      }
      this.render.setViewBox(_objectSpread$h(_objectSpread$h({}, this.viewBoxBeforeDrag), {}, {
        minX: this.viewBoxBeforeDrag.minX + getUserFriendlyViewBoxDelta(dx)
      }));
    }
  }]);
  return HorizontalScrollbar;
}(Scrollbar);

function _classPrivateFieldInitSpec$8(obj, privateMap, value) { _checkPrivateRedeclaration$8(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$8(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _scrollOffset = new WeakMap();
var _verticalBar = new WeakMap();
var _horizontalBar = new WeakMap();
var ScrollbarContainer = function () {
  function ScrollbarContainer(render) {
    _classCallCheck__default["default"](this, ScrollbarContainer);
    _classPrivateFieldInitSpec$8(this, _scrollOffset, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$8(this, _verticalBar, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec$8(this, _horizontalBar, {
      writable: true,
      value: null
    });
    _classPrivateFieldSet__default["default"](this, _scrollOffset, new ScrollOffset(render));
    _classPrivateFieldSet__default["default"](this, _verticalBar, new VerticalScrollbar(render, _classPrivateFieldGet__default["default"](this, _scrollOffset)));
    _classPrivateFieldSet__default["default"](this, _horizontalBar, new HorizontalScrollbar(render, _classPrivateFieldGet__default["default"](this, _scrollOffset)));
  }
  _createClass__default["default"](ScrollbarContainer, [{
    key: "update",
    value: function update() {
      var _classPrivateFieldGet2, _classPrivateFieldGet3;
      _classPrivateFieldGet__default["default"](this, _scrollOffset).update();
      (_classPrivateFieldGet2 = _classPrivateFieldGet__default["default"](this, _verticalBar)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.update();
      (_classPrivateFieldGet3 = _classPrivateFieldGet__default["default"](this, _horizontalBar)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.update();
    }
  }]);
  return ScrollbarContainer;
}();

function ownKeys$g(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$g(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$g(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var Render = function () {
  function Render(clientArea, options, reuseRestructIfExist) {
    var _this = this,
      _global$ketcher;
    _classCallCheck__default["default"](this, Render);
    _defineProperty__default["default"](this, "skipRaphaelInitialization", false);
    _defineProperty__default["default"](this, "oldCb", null);
    _defineProperty__default["default"](this, "resizeObserver", null);
    _defineProperty__default["default"](this, "observeCanvasResize", function () {
      _this.resizeObserver = new ResizeObserver(function () {
        _this.sz = new Vec2(_this.clientArea.clientWidth, _this.clientArea.clientHeight);
        _this.resizeViewBox();
      });
      _this.resizeObserver.observe(_this.paper.canvas);
    });
    _defineProperty__default["default"](this, "unobserveCanvasResize", function () {
      var _this$resizeObserver;
      (_this$resizeObserver = _this.resizeObserver) === null || _this$resizeObserver === void 0 || _this$resizeObserver.unobserve(_this.paper.canvas);
    });
    this.userOpts = options;
    this.clientArea = clientArea;
    this.paper = new Raphael__default["default"](clientArea,
    options.width || '100%',
    options.height || '100%');
    this.sz = this.getCanvasSizeVector();
    this.options = defaultOptions(this.userOpts);
    if (reuseRestructIfExist && (_global$ketcher = global.ketcher) !== null && _global$ketcher !== void 0 && (_global$ketcher = _global$ketcher.editor) !== null && _global$ketcher !== void 0 && (_global$ketcher = _global$ketcher.render) !== null && _global$ketcher !== void 0 && _global$ketcher.ctab) {
      var _global$ketcher2;
      this.ctab = (_global$ketcher2 = global.ketcher) === null || _global$ketcher2 === void 0 || (_global$ketcher2 = _global$ketcher2.editor) === null || _global$ketcher2 === void 0 || (_global$ketcher2 = _global$ketcher2.render) === null || _global$ketcher2 === void 0 ? void 0 : _global$ketcher2.ctab;
      this.ctab.render = this;
      this.ctab.initLayers();
      this.ctab.update(true);
    } else {
      this.ctab = new ReStruct(new Struct(), this);
    }
    this.scrollbar = new ScrollbarContainer(this);
    this.setViewBox({
      minX: 0,
      minY: 0,
      width: this.sz.x,
      height: this.sz.y
    });
  }
  _createClass__default["default"](Render, [{
    key: "updateOptions",
    value: function updateOptions(opts) {
      try {
        var passedOptions = JSON.parse(opts);
        if (passedOptions && _typeof__default["default"](passedOptions) === 'object') {
          this.options = _objectSpread$g(_objectSpread$g({}, this.options), passedOptions);
          return this.options;
        }
      } catch (e) {
        KetcherLogger.error('raphaelRenderer.ts::updateOptions', e);
      }
      return false;
    }
  }, {
    key: "selectionPolygon",
    value: function selectionPolygon(polygon) {
      return draw.selectionPolygon(this.paper, polygon, this.options);
    }
  }, {
    key: "selectionLine",
    value: function selectionLine(point0, point1) {
      return draw.selectionLine(this.paper, point0, point1, this.options);
    }
  }, {
    key: "selectionRectangle",
    value: function selectionRectangle(point0, point1) {
      return draw.selectionRectangle(this.paper, point0, point1, this.options);
    }
  }, {
    key: "page2obj",
    value: function page2obj(event) {
      return CoordinateTransformation.pageToModel(event, this);
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom, event) {
      var zoomedWidth = this.sz.x / zoom;
      var zoomedHeight = this.sz.y / zoom;
      var _ref = event ? this.zoomOnMouse(event, zoomedWidth, zoomedHeight) : this.zoomOnCanvasCenter(zoomedWidth, zoomedHeight),
        _ref2 = _slicedToArray__default["default"](_ref, 2),
        viewBoxX = _ref2[0],
        viewBoxY = _ref2[1];
      this.setViewBox({
        minX: viewBoxX,
        minY: viewBoxY,
        width: zoomedWidth,
        height: zoomedHeight
      });
      this.options.zoom = zoom;
    }
  }, {
    key: "getCanvasSizeVector",
    value: function getCanvasSizeVector() {
      return new Vec2(this.clientArea.clientWidth, this.clientArea.clientHeight);
    }
  }, {
    key: "resizeViewBox",
    value: function resizeViewBox() {
      this.sz = this.getCanvasSizeVector();
      var newWidth = this.sz.x / this.options.zoom;
      var newHeight = this.sz.y / this.options.zoom;
      this.setViewBox(function (prev) {
        return _objectSpread$g(_objectSpread$g({}, prev), {}, {
          width: newWidth,
          height: newHeight
        });
      });
    }
  }, {
    key: "zoomOnCanvasCenter",
    value: function zoomOnCanvasCenter(zoomedWidth, zoomedHeight) {
      var fixedPoint = new Vec2(this.viewBox.minX + this.viewBox.width / 2, this.viewBox.minY + this.viewBox.height / 2);
      var viewBoxX = fixedPoint.x - zoomedWidth / 2;
      var viewBoxY = fixedPoint.y - zoomedHeight / 2;
      return [viewBoxX, viewBoxY];
    }
  }, {
    key: "zoomOnMouse",
    value: function zoomOnMouse(event, zoomedWidth, zoomedHeight) {
      var fixedPoint = CoordinateTransformation.pageToCanvas(event, this);
      var widthRatio = (fixedPoint.x - this.viewBox.minX) / this.viewBox.width;
      var heightRatio = (fixedPoint.y - this.viewBox.minY) / this.viewBox.height;
      var viewBoxX = fixedPoint.x - zoomedWidth * widthRatio;
      var viewBoxY = fixedPoint.y - zoomedHeight * heightRatio;
      return [viewBoxX, viewBoxY];
    }
  }, {
    key: "setViewBox",
    value: function setViewBox(arg) {
      var newViewBox = typeof arg === 'function' ? arg(this.viewBox) : arg;
      this.viewBox = newViewBox;
      this.paper.canvas.setAttribute('viewBox', "".concat(newViewBox.minX, " ").concat(newViewBox.minY, " ").concat(newViewBox.width, " ").concat(newViewBox.height));
      this.scrollbar.update();
    }
  }, {
    key: "setMolecule",
    value: function setMolecule(struct) {
      var _this2 = this;
      var forceUpdateWithTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.paper.clear();
      this.ctab = new ReStruct(struct, this);
      this.options.offset = new Vec2();
      if (forceUpdateWithTimeout) {
        setTimeout(function () {
          _this2.update(true);
        }, 0);
      } else {
        this.update(false);
      }
    }
  }, {
    key: "update",
    value: function update() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var viewSz = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      viewSz = viewSz || new Vec2(this.clientArea.clientWidth || 100, this.clientArea.clientHeight || 100);
      var changes = this.ctab.update(force);
      this.ctab.setSelection();
      if (changes) {
        var bb = this.ctab.getVBoxObj().transform(Scale.modelToCanvas, this.options).translate(this.options.offset || new Vec2());
        if (this.options.downScale) {
          this.ctab.molecule.rescale();
        }
        var isAutoScale = this.options.autoScale || this.options.downScale;
        if (!isAutoScale) {
          if (!this.oldCb) this.oldCb = new Box2Abs();
          this.scrollbar.update();
          this.options.offset = this.options.offset || new Vec2();
        } else {
          var sz1 = bb.sz();
          var marg = this.options.autoScaleMargin;
          var mv = new Vec2(marg, marg);
          var csz = viewSz;
          if (marg && (csz.x < 2 * marg + 1 || csz.y < 2 * marg + 1)) {
            throw new Error('View box too small for the given margin');
          }
          var rescale = this.options.rescaleAmount || Math.max(sz1.x / (csz.x - 2 * marg), sz1.y / (csz.y - 2 * marg));
          var isForceDownscale = this.options.downScale && rescale < 1;
          var isBondsLengthFit = this.options.maxBondLength / rescale > 1;
          if (isBondsLengthFit || isForceDownscale) {
            rescale = 1;
          }
          var sz2 = sz1.add(mv.scaled(2 * rescale));
          this.paper.setViewBox(bb.pos().x - marg * rescale - (csz.x * rescale - sz2.x) / 2, bb.pos().y - marg * rescale - (csz.y * rescale - sz2.y) / 2, csz.x * rescale, csz.y * rescale);
        }
        notifyRenderComplete();
      }
    }
  }]);
  return Render;
}();

function ownKeys$f(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$f(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$f(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var renderCache = new Map();
var previousOptions;
var MIN_ATTACHMENT_POINT_SIZE = 8;
var attachmentPointRegExp = /^R[1-8]$/;
var RenderStruct = function () {
  function RenderStruct() {
    _classCallCheck__default["default"](this, RenderStruct);
  }
  _createClass__default["default"](RenderStruct, null, [{
    key: "prepareStruct",
    value:
    function prepareStruct(struct) {
      if (struct.sgroups.size > 0) {
        var newStruct = struct.clone();
        convertAllSGroupAttachmentPointsToRGroupAttachmentPoints(newStruct);
        newStruct.sgroups["delete"](0);
        return newStruct;
      }
      return struct;
    }
  }, {
    key: "removeSmallAttachmentPointLabelsInModal",
    value: function removeSmallAttachmentPointLabelsInModal(render) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!options.labelInMonomerConnectionsModal) {
        return;
      }
      render.ctab.atoms.forEach(function (atom) {
        if (!atom.label) {
          return;
        }
        var isAttachmentPointAtom = attachmentPointRegExp.test(atom.label.text);
        if (!isAttachmentPointAtom) {
          return;
        }
        var isSmall = atom.label.path.node.getBoundingClientRect().width < MIN_ATTACHMENT_POINT_SIZE;
        if (isSmall) {
          atom.label.path.node.remove();
        }
      });
    }
  }, {
    key: "render",
    value: function render(el, struct) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (el && struct) {
        var _options$cachePrefix = options.cachePrefix,
          cachePrefix = _options$cachePrefix === void 0 ? '' : _options$cachePrefix,
          _options$needCache = options.needCache,
          needCache = _options$needCache === void 0 ? true : _options$needCache;
        var cacheKey = "".concat(cachePrefix).concat(struct.name);
        if (!_.isEqual(previousOptions, options)) {
          renderCache.clear();
          previousOptions = options;
        }
        if (renderCache.has(cacheKey) && needCache) {
          el.innerHTML = renderCache.get(cacheKey);
          return;
        }
        var preparedStruct = this.prepareStruct(struct);
        preparedStruct.initHalfBonds();
        preparedStruct.initNeighbors();
        preparedStruct.setImplicitHydrogen();
        preparedStruct.markFragments();
        var rnd = new Render(el, _objectSpread$f({
          autoScale: true
        }, options));
        preparedStruct.rescale();
        rnd.setMolecule(preparedStruct);
        this.removeSmallAttachmentPointLabelsInModal(rnd, options);
        if (needCache) {
          renderCache.set(cacheKey, rnd.clientArea.innerHTML);
        }
      }
    }
  }]);
  return RenderStruct;
}();
function convertAllSGroupAttachmentPointsToRGroupAttachmentPoints(struct) {
  struct.sgroups.forEach(function (sgroup) {
    sgroup.getAttachmentPoints().forEach(function (attachmentPoint) {
      var attachmentPointAtom = struct.atoms.get(attachmentPoint.atomId);
      attachmentPointAtom.setRGAttachmentPointForDisplayPurpose();
      var rgroupAttachmentPoint = attachmentPoint.convertToRGroupAttachmentPointForDisplayPurpose(attachmentPoint.atomId);
      struct.rgroupAttachmentPoints.add(rgroupAttachmentPoint);
    });
  });
}

var SequenceRenderer = function () {
  function SequenceRenderer() {
    _classCallCheck__default["default"](this, SequenceRenderer);
  }
  _createClass__default["default"](SequenceRenderer, null, [{
    key: "show",
    value: function show(chainsCollection) {
      SequenceRenderer.chainsCollection = chainsCollection;
      this.removeEmptyNodes();
      this.showNodes(SequenceRenderer.chainsCollection);
      this.showBonds(SequenceRenderer.chainsCollection);
    }
  }, {
    key: "removeEmptyNodes",
    value: function removeEmptyNodes() {
      SequenceRenderer.emptySequenceItemRenderers.forEach(function (emptySequenceItemRenderer) {
        emptySequenceItemRenderer.remove();
        SequenceRenderer.emptySequenceItemRenderers = [];
      });
    }
  }, {
    key: "showNodes",
    value: function showNodes(chainsCollection) {
      var _firstNode$monomer$re;
      var firstNode = chainsCollection.firstNode;
      var currentChainStartPosition = firstNode ? BaseMonomerRenderer.getScaledMonomerPosition(firstNode.monomer.position, (_firstNode$monomer$re = firstNode.monomer.renderer) === null || _firstNode$monomer$re === void 0 ? void 0 : _firstNode$monomer$re.monomerSize) : new Vec2(41.5, 41.5);
      var currentMonomerIndexInChain = 0;
      var currentMonomerIndexOverall = 0;
      var editor = CoreEditor.provideEditorInstance();
      var isEditMode = editor.mode instanceof SequenceMode && editor.mode.isEditMode;
      if (isEditMode) {
        chainsCollection.chains.forEach(function (chain) {
          var emptySequenceNode = new EmptySequenceNode();
          var emptySubChain = new EmptySubChain();
          emptySubChain.add(emptySequenceNode);
          chain.subChains.push(emptySubChain);
        });
      }
      chainsCollection.chains.forEach(function (chain) {
        currentMonomerIndexInChain = 0;
        chain.subChains.forEach(function (subChain) {
          subChain.nodes.forEach(function (node) {
            var _node$monomer;
            var renderer = SequenceNodeRendererFactory.fromNode(node, currentChainStartPosition, currentMonomerIndexInChain, currentMonomerIndexInChain + 1 + (isEditMode ? 1 : 0) === chain.subChains.reduce(function (prev, curr) {
              return prev + curr.nodes.length;
            }, 0), subChain, currentMonomerIndexOverall === SequenceRenderer.caretPosition, node.monomer.renderer);
            renderer.show();
            (_node$monomer = node.monomer) === null || _node$monomer === void 0 || _node$monomer.setRenderer(renderer);
            currentMonomerIndexInChain++;
            currentMonomerIndexOverall++;
            if (node instanceof EmptySequenceNode) {
              SequenceRenderer.emptySequenceItemRenderers.push(renderer);
              node.setRenderer(renderer);
            }
          });
        });
        currentChainStartPosition = SequenceRenderer.getNextChainPosition(currentChainStartPosition, chain);
      });
      if (this.caretPosition > currentMonomerIndexOverall) {
        this.setCaretPosition(currentMonomerIndexOverall);
      }
      this.lastChainStartPosition = currentChainStartPosition;
    }
  }, {
    key: "getNextChainPosition",
    value: function getNextChainPosition(currentChainStartPosition, lastChain) {
      return new Vec2(currentChainStartPosition.x, currentChainStartPosition.y + 75 + 47 * Math.floor((lastChain.length - 1) / 30));
    }
  }, {
    key: "showBonds",
    value: function showBonds(chainsCollection) {
      var handledMonomersToAttachmentPoints = new Map();
      chainsCollection.chains.forEach(function (chain) {
        chain.forEachNode(function (_ref) {
          var node = _ref.node,
            subChain = _ref.subChain;
          if (node instanceof EmptySequenceNode) {
            return;
          }
          if (!handledMonomersToAttachmentPoints.has(node.monomer)) {
            handledMonomersToAttachmentPoints.set(node.monomer, new Set());
          }
          node.monomer.forEachBond(function (polymerBond, attachmentPointName) {
            if (!polymerBond.isSideChainConnection) {
              polymerBond.setRenderer(new BackBoneBondSequenceRenderer(polymerBond));
              subChain.bonds.push(polymerBond);
              return;
            }
            var handledAttachmentPoints = handledMonomersToAttachmentPoints.get(node.monomer);
            if (handledAttachmentPoints.has(attachmentPointName)) {
              return;
            }
            var anotherMonomer = polymerBond.getAnotherMonomer(node.monomer);
            if (node.monomer instanceof Sugar && getRnaBaseFromSugar(node.monomer) === anotherMonomer || anotherMonomer instanceof Sugar && getRnaBaseFromSugar(anotherMonomer) === node.monomer) {
              return;
            }
            var bondRenderer;
            if (anotherMonomer instanceof RNABase) {
              var connectedSugar = getSugarFromRnaBase(anotherMonomer);
              bondRenderer = new PolymerBondSequenceRenderer(new PolymerBond$1(node.monomer, connectedSugar));
            } else {
              bondRenderer = new PolymerBondSequenceRenderer(polymerBond);
            }
            bondRenderer.show();
            polymerBond.setRenderer(bondRenderer);
            subChain.bonds.push(polymerBond);
            handledAttachmentPoints.add(attachmentPointName);
            if (!handledMonomersToAttachmentPoints.get(anotherMonomer)) {
              handledMonomersToAttachmentPoints.set(anotherMonomer, new Set());
            }
            var anotherMonomerHandledAttachmentPoints = handledMonomersToAttachmentPoints.get(anotherMonomer);
            anotherMonomerHandledAttachmentPoints.add(anotherMonomer === null || anotherMonomer === void 0 ? void 0 : anotherMonomer.getAttachmentPointByBond(polymerBond));
          });
        });
        if (chain.isCyclic) {
          var _chain$firstMonomer;
          var polymerBond = (_chain$firstMonomer = chain.firstMonomer) === null || _chain$firstMonomer === void 0 ? void 0 : _chain$firstMonomer.attachmentPointsToBonds.R1;
          var bondRenderer = new PolymerBondSequenceRenderer(polymerBond, chain.firstNode, chain.lastNode);
          bondRenderer.show();
          polymerBond.setRenderer(bondRenderer);
        }
      });
    }
  }, {
    key: "setCaretPosition",
    value: function setCaretPosition(caretPosition) {
      var _subChainNode$rendere, _subChainNode$rendere2;
      var oldSubChainNode = SequenceRenderer.currentEdittingNode;
      if (oldSubChainNode) {
        var _oldSubChainNode$rend, _oldSubChainNode$rend2;
        assert__default["default"](oldSubChainNode.renderer instanceof BaseSequenceItemRenderer);
        oldSubChainNode.renderer.isEditingSymbol = false;
        (_oldSubChainNode$rend = oldSubChainNode.renderer) === null || _oldSubChainNode$rend === void 0 || _oldSubChainNode$rend.remove();
        (_oldSubChainNode$rend2 = oldSubChainNode.renderer) === null || _oldSubChainNode$rend2 === void 0 || _oldSubChainNode$rend2.show();
      }
      SequenceRenderer.caretPosition = caretPosition;
      var subChainNode = SequenceRenderer.currentEdittingNode;
      if (!subChainNode) {
        return;
      }
      assert__default["default"](subChainNode.renderer instanceof BaseSequenceItemRenderer);
      subChainNode.renderer.isEditingSymbol = true;
      (_subChainNode$rendere = subChainNode.renderer) === null || _subChainNode$rendere === void 0 || _subChainNode$rendere.remove();
      (_subChainNode$rendere2 = subChainNode.renderer) === null || _subChainNode$rendere2 === void 0 || _subChainNode$rendere2.show();
    }
  }, {
    key: "forEachNode",
    value: function forEachNode(forEachCallback) {
      var nodeIndexOverall = 0;
      this.chainsCollection.chains.forEach(function (chain, chainIndex) {
        chain.subChains.forEach(function (subChain, subChainIndex) {
          subChain.nodes.forEach(function (node, nodeIndex) {
            forEachCallback({
              chainIndex: chainIndex,
              subChainIndex: subChainIndex,
              nodeIndex: nodeIndex,
              nodeIndexOverall: nodeIndexOverall,
              node: node,
              subChain: subChain,
              chain: chain
            });
            nodeIndexOverall++;
          });
        });
      });
    }
  }, {
    key: "setCaretPositionBySequenceItemRenderer",
    value: function setCaretPositionBySequenceItemRenderer(sequenceItemRenderer) {
      var newCaretPosition = -1;
      SequenceRenderer.forEachNode(function (_ref2) {
        var node = _ref2.node,
          nodeIndexOverall = _ref2.nodeIndexOverall;
        if (node.renderer === sequenceItemRenderer) {
          newCaretPosition = nodeIndexOverall;
        }
      });
      this.setCaretPosition(newCaretPosition);
    }
  }, {
    key: "setCaretPositionByMonomer",
    value: function setCaretPositionByMonomer(monomer) {
      var newCaretPosition = -1;
      SequenceRenderer.forEachNode(function (_ref3) {
        var node = _ref3.node,
          nodeIndexOverall = _ref3.nodeIndexOverall;
        if (node.monomer === monomer) {
          newCaretPosition = nodeIndexOverall;
        }
      });
      this.setCaretPosition(newCaretPosition);
    }
  }, {
    key: "getMonomersByCaretPositionRange",
    value: function getMonomersByCaretPositionRange(startCaretPosition, endCaretPosition) {
      var _this = this;
      var monomers = [];
      SequenceRenderer.forEachNode(function (_ref4) {
        var node = _ref4.node,
          nodeIndexOverall = _ref4.nodeIndexOverall;
        if (startCaretPosition <= nodeIndexOverall && nodeIndexOverall < (endCaretPosition || _this.caretPosition)) {
          monomers.push(node.monomer);
        }
      });
      return monomers;
    }
  }, {
    key: "moveCaretForward",
    value: function moveCaretForward() {
      return new RestoreSequenceCaretPositionCommand(this.caretPosition, this.nextCaretPosition || this.caretPosition);
    }
  }, {
    key: "moveCaretBack",
    value: function moveCaretBack() {
      return new RestoreSequenceCaretPositionCommand(this.caretPosition, this.previousCaretPosition === undefined ? this.caretPosition : this.previousCaretPosition);
    }
  }, {
    key: "hasNewChain",
    get: function get() {
      return SequenceRenderer.newChainCaretPosition !== undefined;
    }
  }, {
    key: "moveCaretToNewChain",
    value: function moveCaretToNewChain() {
      this.setCaretPosition(SequenceRenderer.newChainCaretPosition === undefined ? -1 : SequenceRenderer.newChainCaretPosition);
    }
  }, {
    key: "currentChainIndex",
    get: function get() {
      var _this2 = this;
      var currentChainIndex = -1;
      SequenceRenderer.forEachNode(function (_ref5) {
        var nodeIndexOverall = _ref5.nodeIndexOverall,
          chainIndex = _ref5.chainIndex;
        if (nodeIndexOverall === _this2.caretPosition) {
          currentChainIndex = chainIndex;
        }
      });
      return currentChainIndex;
    }
  }, {
    key: "newChainCaretPosition",
    get: function get() {
      var lastNodeCaretPosition = SequenceRenderer.lastNodeCaretPosition;
      if (lastNodeCaretPosition === undefined) {
        return undefined;
      }
      var lastChain = SequenceRenderer.getChainByPointer(lastNodeCaretPosition);
      return lastChain.isEmpty ? lastNodeCaretPosition : undefined;
    }
  }, {
    key: "lastNodeCaretPosition",
    get: function get() {
      if (SequenceRenderer.chainsCollection.chains.length === 0) {
        return undefined;
      }
      var lastNodeIndex = -1;
      SequenceRenderer.forEachNode(function () {
        lastNodeIndex++;
      });
      return lastNodeIndex === -1 ? undefined : lastNodeIndex;
    }
  }, {
    key: "getNodeByPointer",
    value: function getNodeByPointer(sequencePointer) {
      if (sequencePointer === undefined) return;
      var nodeToReturn;
      SequenceRenderer.forEachNode(function (_ref6) {
        var node = _ref6.node,
          nodeIndexOverall = _ref6.nodeIndexOverall;
        if (nodeIndexOverall === sequencePointer) {
          nodeToReturn = node;
        }
      });
      return nodeToReturn;
    }
  }, {
    key: "getChainByPointer",
    value: function getChainByPointer(sequencePointer) {
      var chainToReturn;
      SequenceRenderer.forEachNode(function (_ref7) {
        var chain = _ref7.chain,
          nodeIndexOverall = _ref7.nodeIndexOverall;
        if (nodeIndexOverall === sequencePointer) {
          chainToReturn = chain;
        }
      });
      return chainToReturn;
    }
  }, {
    key: "currentEdittingNode",
    get: function get() {
      return SequenceRenderer.getNodeByPointer(this.caretPosition);
    }
  }, {
    key: "previousFromCurrentEdittingMonomer",
    get: function get() {
      return SequenceRenderer.getNodeByPointer(SequenceRenderer.previousCaretPosition);
    }
  }, {
    key: "currentChain",
    get: function get() {
      return SequenceRenderer.chainsCollection.chains[SequenceRenderer.currentChainIndex];
    }
  }, {
    key: "previousChain",
    get: function get() {
      return SequenceRenderer.chainsCollection.chains[SequenceRenderer.currentChainIndex - 1];
    }
  }, {
    key: "getLastNonEmptyNode",
    value: function getLastNonEmptyNode(chain) {
      var subChainBeforeLast = chain.subChains[chain.subChains.length - 2];
      return subChainBeforeLast.nodes[subChainBeforeLast.nodes.length - 1];
    }
  }, {
    key: "getLastNode",
    value: function getLastNode(chain) {
      var lastSubChain = chain.subChains[chain.subChains.length - 1];
      return lastSubChain.nodes[lastSubChain.nodes.length - 1];
    }
  }, {
    key: "nextNode",
    get: function get() {
      return SequenceRenderer.getNodeByPointer(SequenceRenderer.nextCaretPosition);
    }
  }, {
    key: "previousNode",
    get: function get() {
      return SequenceRenderer.getNodeByPointer(SequenceRenderer.previousCaretPosition);
    }
  }, {
    key: "nextNodeInSameChain",
    get: function get() {
      if (SequenceRenderer.nextCaretPosition !== SequenceRenderer.caretPosition) {
        return;
      }
      return SequenceRenderer.getNodeByPointer(SequenceRenderer.nextCaretPosition);
    }
  }, {
    key: "previousNodeInSameChain",
    get: function get() {
      return SequenceRenderer.getPreviousNodeInSameChain(SequenceRenderer.currentEdittingNode);
    }
  }, {
    key: "nextCaretPosition",
    get: function get() {
      var nodeOnNextPosition = SequenceRenderer.getNodeByPointer(this.caretPosition + 1);
      return nodeOnNextPosition ? this.caretPosition + 1 : undefined;
    }
  }, {
    key: "previousCaretPosition",
    get: function get() {
      var nodeOnPreviousPosition = SequenceRenderer.getNodeByPointer(this.caretPosition - 1);
      return nodeOnPreviousPosition ? this.caretPosition - 1 : undefined;
    }
  }, {
    key: "lastChain",
    get: function get() {
      return SequenceRenderer.chainsCollection.chains[SequenceRenderer.chainsCollection.chains.length - 1];
    }
  }, {
    key: "startNewSequence",
    value: function startNewSequence() {
      var chain = new Chain();
      var emptySequenceNode = new EmptySequenceNode();
      var emptySubChain = new EmptySubChain();
      emptySubChain.add(emptySequenceNode);
      chain.subChains.push(emptySubChain);
      var renderer = SequenceNodeRendererFactory.fromNode(emptySequenceNode, this.lastChainStartPosition, 0, false, emptySubChain, true);
      renderer.show();
      emptySequenceNode.setRenderer(renderer);
      SequenceRenderer.emptySequenceItemRenderers.push(renderer);
      SequenceRenderer.chainsCollection.chains.push(chain);
    }
  }, {
    key: "getPreviousNodeInSameChain",
    value: function getPreviousNodeInSameChain(nodeToCompare) {
      var previousNode;
      var previousNodeChainIndex = -1;
      var nodeToReturn;
      SequenceRenderer.forEachNode(function (_ref8) {
        var node = _ref8.node,
          chainIndex = _ref8.chainIndex;
        if (nodeToCompare === node && chainIndex === previousNodeChainIndex) {
          nodeToReturn = previousNode;
        }
        previousNodeChainIndex = chainIndex;
        previousNode = node;
      });
      return nodeToReturn;
    }
  }, {
    key: "getNextNodeInSameChain",
    value: function getNextNodeInSameChain(nodeToCompare) {
      var previousNode;
      var previousNodeChainIndex = -1;
      var nodeToReturn;
      SequenceRenderer.forEachNode(function (_ref9) {
        var node = _ref9.node,
          chainIndex = _ref9.chainIndex;
        if (nodeToCompare === previousNode && chainIndex === previousNodeChainIndex) {
          nodeToReturn = node;
        }
        previousNodeChainIndex = chainIndex;
        previousNode = node;
      });
      return nodeToReturn;
    }
  }, {
    key: "getPreviousNode",
    value: function getPreviousNode(nodeToCompare) {
      var previousNode;
      var nodeToReturn;
      SequenceRenderer.forEachNode(function (_ref10) {
        var node = _ref10.node;
        if (nodeToCompare === node) {
          nodeToReturn = previousNode;
        }
        previousNode = node;
      });
      return nodeToReturn;
    }
  }, {
    key: "getNextNode",
    value: function getNextNode(nodeToCompare) {
      var previousNode;
      var nodeToReturn;
      SequenceRenderer.forEachNode(function (_ref11) {
        var node = _ref11.node;
        if (previousNode === nodeToCompare) {
          nodeToReturn = node;
        }
        previousNode = node;
      });
      return nodeToReturn;
    }
  }, {
    key: "shiftArrowSelectionInEditMode",
    value: function shiftArrowSelectionInEditMode(event) {
      var editor = CoreEditor.provideEditorInstance();
      var selectDrawingEntities = function selectDrawingEntities(selectedNode) {
        var drawingEntities = editor.drawingEntitiesManager.getAllSelectedEntities(selectedNode.monomer);
        var modelChanges = editor.drawingEntitiesManager.addDrawingEntitiesToSelection(drawingEntities);
        return modelChanges;
      };
      var modelChanges = new Command();
      var arrowKey = event.code;
      if (arrowKey === 'ArrowRight') {
        var _modelChanges = selectDrawingEntities(this.currentEdittingNode);
        _modelChanges.addOperation(this.moveCaretForward());
      } else if (arrowKey === 'ArrowLeft') {
        var _modelChanges2;
        if (this.previousNodeInSameChain) {
          _modelChanges2 = selectDrawingEntities(this.previousNodeInSameChain);
        } else if (SequenceRenderer.previousChain) {
          var previousChainLastEmptyNode = SequenceRenderer.getLastNode(SequenceRenderer.previousChain);
          _modelChanges2 = selectDrawingEntities(previousChainLastEmptyNode);
        }
        _modelChanges2.addOperation(this.moveCaretBack());
      }
      editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "unselectEmptySequenceNodes",
    value: function unselectEmptySequenceNodes() {
      var command = new Command();
      var editor = CoreEditor.provideEditorInstance();
      SequenceRenderer.forEachNode(function (_ref12) {
        var node = _ref12.node;
        if (node instanceof EmptySequenceNode) {
          command.merge(editor.drawingEntitiesManager.unselectDrawingEntity(node.monomer));
        }
      });
      return command;
    }
  }, {
    key: "selections",
    get: function get() {
      var selections = [];
      var lastSelectionRangeIndex = -1;
      var previousNode;
      SequenceRenderer.forEachNode(function (_ref13) {
        var node = _ref13.node,
          nodeIndexOverall = _ref13.nodeIndexOverall;
        if (node.monomer.selected) {
          var _previousNode;
          if (!((_previousNode = previousNode) !== null && _previousNode !== void 0 && _previousNode.monomer.selected)) {
            lastSelectionRangeIndex = selections.push([]) - 1;
          }
          selections[lastSelectionRangeIndex].push({
            node: node,
            nodeIndexOverall: nodeIndexOverall
          });
        }
        previousNode = node;
      });
      return selections;
    }
  }]);
  return SequenceRenderer;
}();
_defineProperty__default["default"](SequenceRenderer, "caretPosition", -1);
_defineProperty__default["default"](SequenceRenderer, "emptySequenceItemRenderers", []);

function _callSuper$C(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$C() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$C() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$C = function _isNativeReflectConstruct() { return !!t; })(); }
var naturalAnalogues = _.uniq([].concat(_toConsumableArray__default["default"](rnaDnaNaturalAnalogues), _toConsumableArray__default["default"](peptideNaturalAnalogues)));
var Direction;
(function (Direction) {
  Direction["Left"] = "left";
  Direction["Right"] = "right";
})(Direction || (Direction = {}));
var SequenceMode = function (_BaseMode) {
  _inherits__default["default"](SequenceMode, _BaseMode);
  function SequenceMode(previousMode) {
    var _this;
    _classCallCheck__default["default"](this, SequenceMode);
    _this = _callSuper$C(this, SequenceMode, ['sequence-layout-mode', previousMode]);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "_isEditMode", false);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "selectionStarted", false);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "selectionStartCaretPosition", -1);
    return _this;
  }
  _createClass__default["default"](SequenceMode, [{
    key: "isEditMode",
    get: function get() {
      return this._isEditMode;
    },
    set: function set(isEditMode) {
      this._isEditMode = isEditMode;
    }
  }, {
    key: "initialize",
    value: function initialize() {
      var _chainsCollection$fir;
      var needScroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var command = _get__default["default"](_getPrototypeOf__default["default"](SequenceMode.prototype), "initialize", this).call(this);
      var editor = CoreEditor.provideEditorInstance();
      editor.drawingEntitiesManager.clearCanvas();
      var modelChanges = editor.drawingEntitiesManager.reArrangeChains(editor.canvas.width.baseVal.value, true, false);
      var zoom = ZoomTool.instance;
      editor.renderersContainer.update(modelChanges);
      var chainsCollection = editor.drawingEntitiesManager.applyMonomersSequenceLayout();
      var firstMonomerPosition = (_chainsCollection$fir = chainsCollection.firstNode) === null || _chainsCollection$fir === void 0 || (_chainsCollection$fir = _chainsCollection$fir.monomer.renderer) === null || _chainsCollection$fir === void 0 ? void 0 : _chainsCollection$fir.scaledMonomerPosition;
      if (firstMonomerPosition && needScroll) {
        zoom.scrollTo(firstMonomerPosition);
      }
      modelChanges.merge(command);
      return modelChanges;
    }
  }, {
    key: "turnOnEditMode",
    value: function turnOnEditMode(sequenceItemRenderer) {
      var editor = CoreEditor.provideEditorInstance();
      this.isEditMode = true;
      this.initialize(false);
      if (sequenceItemRenderer) {
        SequenceRenderer.setCaretPositionByMonomer(sequenceItemRenderer.node.monomer);
        SequenceRenderer.moveCaretForward();
      }
      editor.events.toggleSequenceEditMode.dispatch(true);
    }
  }, {
    key: "turnOffEditMode",
    value: function turnOffEditMode() {
      if (!this.isEditMode) return;
      var editor = CoreEditor.provideEditorInstance();
      this.isEditMode = false;
      this.initialize(false);
      editor.events.toggleSequenceEditMode.dispatch(false);
    }
  }, {
    key: "onKeyDown",
    value: function () {
      var _onKeyDown = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee(event) {
        var _this2 = this;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.isEditMode) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              _context.next = 4;
              return new Promise(function (resolve) {
                setTimeout(function () {
                  var _this2$keyboardEventH;
                  var hotKeys = initHotKeys(_this2.keyboardEventHandlers);
                  var shortcutKey = keyNorm.lookup(hotKeys, event);
                  var editor = CoreEditor.provideEditorInstance();
                  (_this2$keyboardEventH = _this2.keyboardEventHandlers[shortcutKey]) === null || _this2$keyboardEventH === void 0 || _this2$keyboardEventH.handler(event);
                  editor.events.mouseLeaveSequenceItem.dispatch();
                  resolve();
                }, 0);
              });
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function onKeyDown(_x) {
        return _onKeyDown.apply(this, arguments);
      }
      return onKeyDown;
    }()
  }, {
    key: "startNewSequence",
    value: function startNewSequence() {
      if (!this.isEditMode) {
        this.turnOnEditMode();
      }
      if (!SequenceRenderer.hasNewChain) {
        SequenceRenderer.startNewSequence();
      }
      SequenceRenderer.moveCaretToNewChain();
    }
  }, {
    key: "click",
    value: function click(event) {
      var _event$target;
      var eventData = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.__data__;
      var isClickedOnEmptyPlace = !(eventData instanceof BaseRenderer);
      var isClickedOnSequenceItem = eventData instanceof BaseSequenceItemRenderer;
      if (isClickedOnEmptyPlace) {
        this.turnOffEditMode();
      }
      if (this.isEditMode && isClickedOnSequenceItem) {
        SequenceRenderer.setCaretPositionBySequenceItemRenderer(eventData);
        this.unselectAllEntities();
      }
    }
  }, {
    key: "mousedown",
    value: function mousedown(event) {
      var _event$target2;
      var eventData = (_event$target2 = event.target) === null || _event$target2 === void 0 ? void 0 : _event$target2.__data__;
      var isEventOnSequenceItem = eventData instanceof BaseSequenceItemRenderer;
      if (this.isEditMode && isEventOnSequenceItem && !event.shiftKey) {
        SequenceRenderer.setCaretPositionBySequenceItemRenderer(eventData);
        this.unselectAllEntities();
        this.selectionStarted = true;
        this.selectionStartCaretPosition = SequenceRenderer.caretPosition;
      }
    }
  }, {
    key: "mousemove",
    value: function mousemove(event) {
      var _event$target3;
      var eventData = (_event$target3 = event.target) === null || _event$target3 === void 0 ? void 0 : _event$target3.__data__;
      var isEventOnSequenceItem = eventData instanceof BaseSequenceItemRenderer;
      if (this.isEditMode && isEventOnSequenceItem && this.selectionStarted) {
        var modelChanges = new Command();
        var editor = CoreEditor.provideEditorInstance();
        SequenceRenderer.setCaretPositionBySequenceItemRenderer(eventData);
        var startCaretPosition = this.selectionStartCaretPosition;
        var endCaretPosition = SequenceRenderer.caretPosition;
        if (this.selectionStartCaretPosition > SequenceRenderer.caretPosition) {
          startCaretPosition = SequenceRenderer.caretPosition;
          endCaretPosition = this.selectionStartCaretPosition;
        }
        var monomers = SequenceRenderer.getMonomersByCaretPositionRange(startCaretPosition, endCaretPosition);
        var drawingEntities = monomers.reduce(function (drawingEntities, monomer) {
          return drawingEntities.concat(editor.drawingEntitiesManager.getAllSelectedEntities(monomer));
        }, []);
        modelChanges.merge(editor.drawingEntitiesManager.selectDrawingEntities(drawingEntities));
        var moveCaretOperation = new RestoreSequenceCaretPositionCommand(this.selectionStartCaretPosition, SequenceRenderer.caretPosition);
        modelChanges.addOperation(moveCaretOperation);
        editor.renderersContainer.update(modelChanges);
      }
    }
  }, {
    key: "mouseup",
    value: function mouseup() {
      if (this.selectionStarted) {
        this.selectionStarted = false;
      }
    }
  }, {
    key: "bondNodesThroughNewPhosphate",
    value: function bondNodesThroughNewPhosphate(position, previousNode, nextNode) {
      var editor = CoreEditor.provideEditorInstance();
      var phosphateLibraryItem = getRnaPartLibraryItem(editor, RNA_DNA_NON_MODIFIED_PART.PHOSPHATE);
      assert__default["default"](phosphateLibraryItem);
      var modelChanges = editor.drawingEntitiesManager.addMonomer(phosphateLibraryItem, position);
      var additionalPhosphate = modelChanges.operations[0].monomer;
      modelChanges.merge(editor.drawingEntitiesManager.createPolymerBond(previousNode.lastMonomerInNode, additionalPhosphate, exports.AttachmentPointName.R2, exports.AttachmentPointName.R1));
      modelChanges.merge(editor.drawingEntitiesManager.createPolymerBond(additionalPhosphate, nextNode.firstMonomerInNode, exports.AttachmentPointName.R2, exports.AttachmentPointName.R1));
      return modelChanges;
    }
  }, {
    key: "handlePeptideNodeAddition",
    value: function handlePeptideNodeAddition(enteredSymbol, currentNode, previousNodeInSameChain, newNodePosition) {
      if (!peptideNaturalAnalogues.includes(enteredSymbol)) {
        return undefined;
      }
      var modelChanges = new Command();
      var editor = CoreEditor.provideEditorInstance();
      var newPeptideLibraryItem = getPeptideLibraryItem(editor, enteredSymbol);
      assert__default["default"](newPeptideLibraryItem);
      var peptideAddCommand = editor.drawingEntitiesManager.addMonomer(newPeptideLibraryItem, newNodePosition);
      var newPeptide = peptideAddCommand.operations[0].monomer;
      modelChanges.merge(peptideAddCommand);
      if (!(currentNode instanceof EmptySequenceNode)) {
        if (previousNodeInSameChain) {
          var r2Bond = previousNodeInSameChain === null || previousNodeInSameChain === void 0 ? void 0 : previousNodeInSameChain.lastMonomerInNode.attachmentPointsToBonds.R2;
          assert__default["default"](r2Bond);
          modelChanges.merge(editor.drawingEntitiesManager.deletePolymerBond(r2Bond));
        }
        modelChanges.merge(editor.drawingEntitiesManager.createPolymerBond(newPeptide, currentNode === null || currentNode === void 0 ? void 0 : currentNode.firstMonomerInNode, exports.AttachmentPointName.R2, exports.AttachmentPointName.R1));
      }
      if (previousNodeInSameChain) {
        modelChanges.merge(editor.drawingEntitiesManager.createPolymerBond(previousNodeInSameChain.lastMonomerInNode, newPeptide, exports.AttachmentPointName.R2, exports.AttachmentPointName.R1));
      }
      return modelChanges;
    }
  }, {
    key: "handleRnaDnaNodeAddition",
    value: function handleRnaDnaNodeAddition(enteredSymbol, currentNode, previousNodeInSameChain, newNodePosition) {
      if (!rnaDnaNaturalAnalogues.includes(enteredSymbol)) {
        return undefined;
      }
      var modelChanges = new Command();
      var editor = CoreEditor.provideEditorInstance();
      var _ref = currentNode instanceof Nucleotide || currentNode instanceof Nucleoside ? Nucleotide.createOnCanvas(enteredSymbol, newNodePosition) : Nucleoside.createOnCanvas(enteredSymbol, newNodePosition),
        addedNodeModelChanges = _ref.modelChanges,
        nodeToAdd = _ref.node;
      modelChanges.merge(addedNodeModelChanges);
      if (!(currentNode instanceof EmptySequenceNode)) {
        if (previousNodeInSameChain) {
          var r2Bond = previousNodeInSameChain === null || previousNodeInSameChain === void 0 ? void 0 : previousNodeInSameChain.lastMonomerInNode.attachmentPointsToBonds.R2;
          assert__default["default"](r2Bond);
          modelChanges.merge(editor.drawingEntitiesManager.deletePolymerBond(r2Bond));
        }
        modelChanges.merge(editor.drawingEntitiesManager.createPolymerBond(nodeToAdd.lastMonomerInNode, currentNode === null || currentNode === void 0 ? void 0 : currentNode.firstMonomerInNode, exports.AttachmentPointName.R2, exports.AttachmentPointName.R1));
      }
      if (previousNodeInSameChain instanceof Nucleoside) {
        modelChanges.merge(this.bondNodesThroughNewPhosphate(newNodePosition, previousNodeInSameChain, nodeToAdd));
      } else if (previousNodeInSameChain) {
        modelChanges.merge(editor.drawingEntitiesManager.createPolymerBond(previousNodeInSameChain.lastMonomerInNode, nodeToAdd.firstMonomerInNode, exports.AttachmentPointName.R2, exports.AttachmentPointName.R1));
      }
      return modelChanges;
    }
  }, {
    key: "finishNodesDeletion",
    value: function finishNodesDeletion(modelChanges, previousCaretPosition, newCaretPosition) {
      var editor = CoreEditor.provideEditorInstance();
      var history = new EditorHistory(editor);
      var moveCaretOperation = new RestoreSequenceCaretPositionCommand(previousCaretPosition, _.isNumber(newCaretPosition) ? newCaretPosition : SequenceRenderer.caretPosition);
      modelChanges.addOperation(new ReinitializeSequenceModeCommand());
      editor.renderersContainer.update(modelChanges);
      modelChanges.addOperation(moveCaretOperation);
      history.update(modelChanges);
      this.selectionStartCaretPosition = -1;
    }
  }, {
    key: "handleNodesDeletion",
    value: function handleNodesDeletion(selections) {
      var _this3 = this;
      var editor = CoreEditor.provideEditorInstance();
      var modelChanges = new Command();
      selections.forEach(function (selectionRange) {
        var selectionStartNode = selectionRange[0].node;
        var selectionEndNode = selectionRange[selectionRange.length - 1].node;
        var isPhosphateAdditionalyDeleted = false;
        var nodeBeforeSelection = SequenceRenderer.getPreviousNode(selectionStartNode);
        var nodeAfterSelection = SequenceRenderer.getNextNode(selectionEndNode);
        var nodeInSameChainBeforeSelection = SequenceRenderer.getPreviousNodeInSameChain(selectionStartNode);
        if (!nodeInSameChainBeforeSelection && nodeAfterSelection) {
          modelChanges.merge(editor.drawingEntitiesManager.moveMonomer(nodeAfterSelection.monomer, selectionStartNode.monomer.position));
        }
        if (!nodeBeforeSelection || nodeBeforeSelection instanceof EmptySequenceNode) {
          return;
        }
        if (nodeBeforeSelection instanceof Nucleotide && !(nodeAfterSelection instanceof Nucleotide) && !(nodeAfterSelection instanceof Nucleoside)) {
          modelChanges.merge(editor.drawingEntitiesManager.deleteMonomer(nodeBeforeSelection.lastMonomerInNode));
          isPhosphateAdditionalyDeleted = true;
        }
        if (!nodeAfterSelection || nodeAfterSelection instanceof EmptySequenceNode) {
          return;
        }
        if (nodeBeforeSelection instanceof Nucleoside && (nodeAfterSelection instanceof Nucleotide || nodeAfterSelection instanceof Nucleoside)) {
          modelChanges.merge(_this3.bondNodesThroughNewPhosphate(_this3.getNewSequenceItemPosition(nodeBeforeSelection), nodeBeforeSelection, nodeAfterSelection));
        } else {
          modelChanges.merge(editor.drawingEntitiesManager.createPolymerBond(isPhosphateAdditionalyDeleted ? nodeBeforeSelection.firstMonomerInNode : nodeBeforeSelection.lastMonomerInNode, nodeAfterSelection.firstMonomerInNode, exports.AttachmentPointName.R2, exports.AttachmentPointName.R1));
        }
      });
      return modelChanges;
    }
  }, {
    key: "keyboardEventHandlers",
    get: function get() {
      var _this4 = this;
      var deleteNode = function deleteNode(direction) {
        var editor = CoreEditor.provideEditorInstance();
        var nodeToDelete = direction === Direction.Left ? SequenceRenderer.previousNode : SequenceRenderer.getNodeByPointer(SequenceRenderer.caretPosition);
        var caretPosition = direction === Direction.Left ? SequenceRenderer.previousCaretPosition : SequenceRenderer.caretPosition;
        var selections = SequenceRenderer.selections;
        var modelChanges = new Command();
        var nodesToDelete;
        if (selections.length) {
          modelChanges.merge(_this4.deleteSelectedDrawingEntities());
          nodesToDelete = selections;
        } else if (nodeToDelete) {
          nodeToDelete.monomers.forEach(function (monomer) {
            modelChanges.merge(editor.drawingEntitiesManager.deleteMonomer(monomer));
          });
          nodesToDelete = [[{
            node: nodeToDelete,
            nodeIndexOverall: caretPosition
          }]];
        } else {
          return;
        }
        modelChanges.merge(_this4.handleNodesDeletion(nodesToDelete));
        _this4.finishNodesDeletion(modelChanges, nodesToDelete[0][0].nodeIndexOverall, nodesToDelete[0][0].nodeIndexOverall);
        if (SequenceRenderer.caretPosition === 0 && SequenceRenderer.chainsCollection.chains.length === 0) {
          _this4.startNewSequence();
        }
      };
      return {
        "delete": {
          shortcut: ['Delete'],
          handler: function handler() {
            return deleteNode(Direction.Right);
          }
        },
        backspace: {
          shortcut: ['Backspace'],
          handler: function handler() {
            return deleteNode(Direction.Left);
          }
        },
        'turn-off-edit-mode': {
          shortcut: ['Escape'],
          handler: function handler() {
            _this4.turnOffEditMode();
          }
        },
        'start-new-sequence': {
          shortcut: ['Enter'],
          handler: function handler() {
            _this4.unselectAllEntities();
            _this4.startNewSequence();
          }
        },
        'move-caret-forward': {
          shortcut: ['ArrowRight'],
          handler: function handler() {
            SequenceRenderer.moveCaretForward();
          }
        },
        'move-caret-back': {
          shortcut: ['ArrowLeft'],
          handler: function handler() {
            SequenceRenderer.moveCaretBack();
          }
        },
        'add-sequence-item': {
          shortcut: [].concat(_toConsumableArray__default["default"](naturalAnalogues), _toConsumableArray__default["default"](naturalAnalogues.map(function (naturalAnalogue) {
            return naturalAnalogue.toLowerCase();
          }))),
          handler: function handler(event) {
            var selections = SequenceRenderer.selections;
            if (selections.length > 1) {
              return;
            }
            if (selections.length === 1) {
              var deletionModelChanges = _this4.deleteSelectedDrawingEntities();
              deletionModelChanges.merge(_this4.handleNodesDeletion(selections));
              _this4.finishNodesDeletion(deletionModelChanges, SequenceRenderer.caretPosition, selections[0][0].nodeIndexOverall);
            }
            var enteredSymbol = event.code.replace('Key', '');
            var editor = CoreEditor.provideEditorInstance();
            var history = new EditorHistory(editor);
            var currentNode = SequenceRenderer.currentEdittingNode;
            var previousNode = SequenceRenderer.previousFromCurrentEdittingMonomer;
            var nodeBeforePreviousNode = previousNode ? SequenceRenderer.getPreviousNodeInSameChain(previousNode) : undefined;
            var previousNodeInSameChain = SequenceRenderer.previousNodeInSameChain;
            var newNodePosition = _this4.getNewSequenceItemPosition(previousNode, nodeBeforePreviousNode);
            var modelChanges;
            if (editor.sequenceTypeEnterMode === exports.SequenceType.PEPTIDE) {
              modelChanges = _this4.handlePeptideNodeAddition(enteredSymbol, currentNode, previousNodeInSameChain, newNodePosition);
            } else {
              modelChanges = _this4.handleRnaDnaNodeAddition(enteredSymbol, currentNode, previousNodeInSameChain, newNodePosition);
            }
            if (!modelChanges) {
              return;
            }
            modelChanges.addOperation(new ReinitializeSequenceModeCommand());
            editor.renderersContainer.update(modelChanges);
            modelChanges.addOperation(SequenceRenderer.moveCaretForward());
            history.update(modelChanges);
          }
        },
        'sequence-edit-select': {
          shortcut: ['Shift+ArrowLeft', 'Shift+ArrowRight'],
          handler: function handler(event) {
            var arrowKey = event.key;
            if (SequenceRenderer.caretPosition === 0 && arrowKey === 'ArrowLeft') {
              return;
            }
            _this4.selectionStartCaretPosition = _this4.selectionStartCaretPosition !== -1 ? _this4.selectionStartCaretPosition : SequenceRenderer.caretPosition;
            SequenceRenderer.shiftArrowSelectionInEditMode(event);
          }
        }
      };
    }
  }, {
    key: "deleteSelectedDrawingEntities",
    value: function deleteSelectedDrawingEntities() {
      var editor = CoreEditor.provideEditorInstance();
      var modelChanges = new Command();
      editor.drawingEntitiesManager.selectedEntities.forEach(function (_ref2) {
        var _ref3 = _slicedToArray__default["default"](_ref2, 2),
          entity = _ref3[1];
        modelChanges.merge(editor.drawingEntitiesManager.deleteDrawingEntity(entity));
      });
      return modelChanges;
    }
  }, {
    key: "getNewSequenceItemPosition",
    value: function getNewSequenceItemPosition(previousNode, nodeBeforePreviousNode) {
      var offsetFromPrevious = new Vec2(1, 1);
      if (previousNode && !(previousNode instanceof EmptySequenceNode)) {
        return previousNode.lastMonomerInNode.position.add(offsetFromPrevious);
      } else if (nodeBeforePreviousNode) {
        return nodeBeforePreviousNode.lastMonomerInNode.position.add(offsetFromPrevious);
      } else {
        return new Vec2(0, 0);
      }
    }
  }, {
    key: "unselectAllEntities",
    value: function unselectAllEntities() {
      var editor = CoreEditor.provideEditorInstance();
      var modelChanges = editor.drawingEntitiesManager.unselectAllDrawingEntities();
      modelChanges.merge(SequenceRenderer.unselectEmptySequenceNodes());
      editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.turnOffEditMode();
    }
  }]);
  return SequenceMode;
}(BaseMode);

function _callSuper$B(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$B() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$B() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$B = function _isNativeReflectConstruct() { return !!t; })(); }
var SnakeMode = function (_BaseMode) {
  _inherits__default["default"](SnakeMode, _BaseMode);
  function SnakeMode(previousMode) {
    _classCallCheck__default["default"](this, SnakeMode);
    return _callSuper$B(this, SnakeMode, ['snake-layout-mode', previousMode]);
  }
  _createClass__default["default"](SnakeMode, [{
    key: "initialize",
    value: function initialize() {
      var command = _get__default["default"](_getPrototypeOf__default["default"](SnakeMode.prototype), "initialize", this).call(this);
      var editor = CoreEditor.provideEditorInstance();
      var modelChanges = editor.drawingEntitiesManager.reArrangeChains(editor.canvas.width.baseVal.value, true);
      editor.drawingEntitiesManager.applyFlexLayoutMode();
      command.merge(modelChanges);
      editor.renderersContainer.update(modelChanges);
      command.setUndoOperationReverse();
      return command;
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(_event) {}
  }]);
  return SnakeMode;
}(BaseMode);

var modesMap = {
  'flex-layout-mode': FlexMode,
  'snake-layout-mode': SnakeMode,
  'sequence-layout-mode': SequenceMode
};

function _callSuper$A(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$A() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$A() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$A = function _isNativeReflectConstruct() { return !!t; })(); }
var LINE_FROM_MONOMER_LENGTH = 15;
var VERTICAL_LINE_LENGTH = 21;
var RNA_CHAIN_VERTICAL_LINE_LENGTH = 74;
var CORNER_LENGTH = 4;
var DOUBLE_CORNER_LENGTH = CORNER_LENGTH * 2;
var LINE_DIRECTION;
(function (LINE_DIRECTION) {
  LINE_DIRECTION["Horizontal"] = "Horizontal";
  LINE_DIRECTION["Vertical"] = "Vertical";
})(LINE_DIRECTION || (LINE_DIRECTION = {}));
var PolymerBondRenderer = function (_BaseRenderer) {
  _inherits__default["default"](PolymerBondRenderer, _BaseRenderer);
  function PolymerBondRenderer(polymerBond) {
    var _this;
    _classCallCheck__default["default"](this, PolymerBondRenderer);
    _this = _callSuper$A(this, PolymerBondRenderer, [polymerBond]);
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "path", '');
    _defineProperty__default["default"](_assertThisInitialized__default["default"](_this), "previousStateOfIsMonomersOnSameHorisontalLine", false);
    _this.polymerBond = polymerBond;
    _this.polymerBond.setRenderer(_assertThisInitialized__default["default"](_this));
    _this.editorEvents = exports.editorEvents;
    return _this;
  }
  _createClass__default["default"](PolymerBondRenderer, [{
    key: "attachmentPointsForSnakeBond",
    get: function get() {
      return ['R1', 'R2'];
    }
  }, {
    key: "isSnakeBondAvailableForMonomer",
    value: function isSnakeBondAvailableForMonomer(monomer) {
      return monomer instanceof Peptide || monomer instanceof Chem || monomer instanceof Sugar || monomer instanceof Phosphate;
    }
  }, {
    key: "isSnake",
    get: function get() {
      var _this$polymerBond$sec;
      if (!this.isSnakeBondAvailableForMonomer(this.polymerBond.firstMonomer) || this.polymerBond.secondMonomer && !this.isSnakeBondAvailableForMonomer(this.polymerBond.secondMonomer) || this.polymerBond.secondMonomer && this.polymerBond.firstMonomer.isMonomerTypeDifferentForChaining(this.polymerBond.secondMonomer)) {
        return false;
      }
      var firstMonomerAttachmentPoint = this.polymerBond.firstMonomer.getAttachmentPointByBond(this.polymerBond);
      var secondMonomerAttachmentPoint = (_this$polymerBond$sec = this.polymerBond.secondMonomer) === null || _this$polymerBond$sec === void 0 ? void 0 : _this$polymerBond$sec.getAttachmentPointByBond(this.polymerBond);
      var firstMonomerPotentialAttachmentPoint = this.polymerBond.firstMonomer.getPotentialAttachmentPointByBond(this.polymerBond);
      var isAttachmentPointsEnabledForSnakeBond = this.attachmentPointsForSnakeBond.includes(firstMonomerAttachmentPoint) && this.attachmentPointsForSnakeBond.includes(secondMonomerAttachmentPoint) || this.attachmentPointsForSnakeBond.includes(firstMonomerPotentialAttachmentPoint);
      var isSameAttachmentPoints = firstMonomerAttachmentPoint === secondMonomerAttachmentPoint;
      var editor = CoreEditor.provideEditorInstance();
      return (editor === null || editor === void 0 ? void 0 : editor.mode) instanceof SnakeMode && isAttachmentPointsEnabledForSnakeBond && !isSameAttachmentPoints;
    }
  }, {
    key: "rootBBox",
    get: function get() {
      var _this$rootElement;
      var rootNode = (_this$rootElement = this.rootElement) === null || _this$rootElement === void 0 ? void 0 : _this$rootElement.node();
      if (!rootNode) return;
      return rootNode.getBBox();
    }
  }, {
    key: "width",
    get: function get() {
      var _this$rootBBox;
      return ((_this$rootBBox = this.rootBBox) === null || _this$rootBBox === void 0 ? void 0 : _this$rootBBox.width) || 0;
    }
  }, {
    key: "height",
    get: function get() {
      var _this$rootBBox2;
      return ((_this$rootBBox2 = this.rootBBox) === null || _this$rootBBox2 === void 0 ? void 0 : _this$rootBBox2.height) || 0;
    }
  }, {
    key: "scaledPosition",
    get: function get() {
      var startPositionInPixels = Coordinates.modelToCanvas(this.polymerBond.startPosition);
      var endPositionInPixels = Coordinates.modelToCanvas(this.polymerBond.endPosition);
      return {
        startPosition: startPositionInPixels,
        endPosition: endPositionInPixels
      };
    }
  }, {
    key: "moveSelection",
    value: function moveSelection() {
      if (this.previousStateOfIsMonomersOnSameHorisontalLine !== this.isMonomersOnSameHorizontalLine()) {
        this.remove();
        this.show();
      } else {
        assert__default["default"](this.rootElement);
        this.moveStart();
        this.moveEnd();
      }
      this.previousStateOfIsMonomersOnSameHorisontalLine = this.isMonomersOnSameHorizontalLine();
    }
  }, {
    key: "appendBond",
    value: function appendBond(rootElement) {
      if (this.isSnake && !this.isMonomersOnSameHorizontalLine()) {
        this.appendSnakeBond(rootElement);
      } else {
        this.appendBondGraph(rootElement);
      }
      return this.bodyElement;
    }
  }, {
    key: "appendSnakeBond",
    value: function appendSnakeBond(rootElement) {
      var startPosition = this.scaledPosition.startPosition;
      var endPosition = this.scaledPosition.endPosition;
      this.updateSnakeBondPath(startPosition, endPosition);
      this.bodyElement = rootElement.append('path').attr('stroke', this.polymerBond.finished ? '#333333' : '#0097A8').attr('stroke-width', 1).attr('class', 'selection-area').attr('d', this.path).attr('fill-opacity', 0).attr('pointer-events', 'stroke');
      return this.bodyElement;
    }
  }, {
    key: "getMonomerWidth",
    value: function getMonomerWidth() {
      var _this$polymerBond$fir, _this$polymerBond$fir2;
      return (_this$polymerBond$fir = (_this$polymerBond$fir2 = this.polymerBond.firstMonomer.renderer) === null || _this$polymerBond$fir2 === void 0 ? void 0 : _this$polymerBond$fir2.monomerSize.width) !== null && _this$polymerBond$fir !== void 0 ? _this$polymerBond$fir : 0;
    }
  }, {
    key: "getMonomerHeight",
    value: function getMonomerHeight() {
      var _this$polymerBond$fir3, _this$polymerBond$fir4;
      return (_this$polymerBond$fir3 = (_this$polymerBond$fir4 = this.polymerBond.firstMonomer.renderer) === null || _this$polymerBond$fir4 === void 0 ? void 0 : _this$polymerBond$fir4.monomerSize.height) !== null && _this$polymerBond$fir3 !== void 0 ? _this$polymerBond$fir3 : 0;
    }
  }, {
    key: "isMonomersOnSameHorizontalLine",
    value: function isMonomersOnSameHorizontalLine() {
      return Boolean(this.polymerBond.secondMonomer && this.polymerBond.firstMonomer.position.y - this.polymerBond.secondMonomer.position.y < 0.5 && this.polymerBond.firstMonomer.position.y - this.polymerBond.secondMonomer.position.y > -0.5);
    }
  }, {
    key: "updateSnakeBondPath",
    value: function updateSnakeBondPath(startPosition, endPosition) {
      var reCheckAttachmentpoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var isR1TheCurrentAttachmentpointOfFirstMonomer = this.polymerBond.firstMonomer.getAttachmentPointByBond(this.polymerBond) === 'R1' || this.polymerBond.firstMonomer.getPotentialAttachmentPointByBond(this.polymerBond) === 'R1';
      var isBondConnectedWithNucleotide = this.polymerBond.firstMonomer.isMonomerInRnaChainRow;
      var verticalLineLength = isBondConnectedWithNucleotide ? RNA_CHAIN_VERTICAL_LINE_LENGTH : VERTICAL_LINE_LENGTH;
      if (this.isSecondMonomerBottomRight(startPosition, endPosition)) {
        if (isR1TheCurrentAttachmentpointOfFirstMonomer && reCheckAttachmentpoint) {
          this.updateSnakeBondPath(endPosition, startPosition, false);
          return;
        }
        this.addLine(LINE_DIRECTION.Horizontal, LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth() / 2, startPosition);
        this.addLineFromLeftToBottom();
        this.addLine(LINE_DIRECTION.Vertical, endPosition.y - startPosition.y - CORNER_LENGTH * 2);
        this.addLineFromTopToRight();
        this.addLine(LINE_DIRECTION.Horizontal, endPosition.x - startPosition.x - CORNER_LENGTH * 2 - LINE_FROM_MONOMER_LENGTH - this.getMonomerWidth() / 2);
      } else if (this.isSecondMonomerTopRight(startPosition, endPosition)) {
        if (isR1TheCurrentAttachmentpointOfFirstMonomer && reCheckAttachmentpoint) {
          this.updateSnakeBondPath(endPosition, startPosition, false);
          return;
        }
        this.addLine(LINE_DIRECTION.Horizontal, LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth() / 2, startPosition);
        this.addLineFromLeftToTop();
        this.addLine(LINE_DIRECTION.Vertical, endPosition.y - startPosition.y - CORNER_LENGTH * 2 + this.getMonomerHeight() / 2);
        this.addLineFromBottomToRight();
        this.addLine(LINE_DIRECTION.Horizontal, endPosition.x - startPosition.x - CORNER_LENGTH * 2 - LINE_FROM_MONOMER_LENGTH - this.getMonomerWidth() / 2);
      } else if (this.isSecondMonomerBottomLeft(startPosition, endPosition)) {
        if (isR1TheCurrentAttachmentpointOfFirstMonomer && reCheckAttachmentpoint) {
          this.updateSnakeBondPath(endPosition, startPosition, false);
          return;
        }
        this.addLine(LINE_DIRECTION.Horizontal, LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth() / 2, startPosition);
        this.addLineFromLeftToBottom();
        this.addLine(LINE_DIRECTION.Vertical, verticalLineLength);
        this.addLineFromTopToLeft();
        this.addLine(LINE_DIRECTION.Horizontal, -(startPosition.x - endPosition.x + LINE_FROM_MONOMER_LENGTH * 2 + this.getMonomerWidth()));
        this.addLineFromRightToBottom();
        this.addLine(LINE_DIRECTION.Vertical, endPosition.y - startPosition.y - CORNER_LENGTH * 4 - verticalLineLength);
        this.addLineFromTopToRight();
        this.addLine(LINE_DIRECTION.Horizontal, LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth() / 2);
      } else if (this.isSecondMonomerTopLeft(startPosition, endPosition)) {
        if (isR1TheCurrentAttachmentpointOfFirstMonomer && reCheckAttachmentpoint) {
          this.updateSnakeBondPath(endPosition, startPosition, false);
          return;
        }
        this.addLine(LINE_DIRECTION.Horizontal, LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth() / 2, startPosition);
        this.addLineFromLeftToBottom();
        this.addLine(LINE_DIRECTION.Vertical, this.getMonomerHeight());
        this.addLineFromTopToLeft();
        this.addLine(LINE_DIRECTION.Horizontal, -(startPosition.x - endPosition.x + LINE_FROM_MONOMER_LENGTH * 2 + this.getMonomerWidth()));
        this.addLineFromRightToUp();
        this.addLine(LINE_DIRECTION.Vertical, endPosition.y - startPosition.y - this.getMonomerHeight());
        this.addLineFromBottomToRight();
        this.addLine(LINE_DIRECTION.Horizontal, LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth() / 2);
      } else if (this.isSecondMonomerLeft(startPosition, endPosition)) {
        if (isR1TheCurrentAttachmentpointOfFirstMonomer && reCheckAttachmentpoint) {
          this.updateSnakeBondPath(endPosition, startPosition, false);
          return;
        }
        this.addLine(LINE_DIRECTION.Horizontal, LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth() / 2, startPosition);
        this.addLineFromLeftToBottom();
        this.addLine(LINE_DIRECTION.Vertical, endPosition.y - startPosition.y + this.getMonomerHeight());
        this.addLineFromTopToLeft();
        this.addLine(LINE_DIRECTION.Horizontal, -(startPosition.x - endPosition.x + LINE_FROM_MONOMER_LENGTH * 2 + this.getMonomerWidth()));
        this.addLineFromRightToUp();
        this.addLine(LINE_DIRECTION.Vertical, -this.getMonomerHeight());
        this.addLineFromBottomToRight();
        this.addLine(LINE_DIRECTION.Horizontal, LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth() / 2);
      } else {
        this.addRandomLine(startPosition, endPosition);
      }
    }
  }, {
    key: "isSecondMonomerTopRight",
    value: function isSecondMonomerTopRight(startPosition, endPosition) {
      return startPosition.y - endPosition.y > DOUBLE_CORNER_LENGTH && endPosition.x - startPosition.x > DOUBLE_CORNER_LENGTH + LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth();
    }
  }, {
    key: "isSecondMonomerBottomRight",
    value: function isSecondMonomerBottomRight(startPosition, endPosition) {
      return endPosition.y - startPosition.y > DOUBLE_CORNER_LENGTH && endPosition.x - startPosition.x > DOUBLE_CORNER_LENGTH + LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth();
    }
  }, {
    key: "isSecondMonomerBottomLeft",
    value: function isSecondMonomerBottomLeft(startPosition, endPosition) {
      return endPosition.y - startPosition.y >= 2 * (VERTICAL_LINE_LENGTH + DOUBLE_CORNER_LENGTH) && endPosition.x - startPosition.x <= DOUBLE_CORNER_LENGTH + LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth();
    }
  }, {
    key: "isSecondMonomerTopLeft",
    value: function isSecondMonomerTopLeft(startPosition, endPosition) {
      return startPosition.y - endPosition.y > 0 && endPosition.x - startPosition.x <= DOUBLE_CORNER_LENGTH + LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth();
    }
  }, {
    key: "isSecondMonomerLeft",
    value: function isSecondMonomerLeft(startPosition, endPosition) {
      return startPosition.y - endPosition.y < 0 && startPosition.y - endPosition.y > -2 * (VERTICAL_LINE_LENGTH + DOUBLE_CORNER_LENGTH) && endPosition.x - startPosition.x <= DOUBLE_CORNER_LENGTH + LINE_FROM_MONOMER_LENGTH + this.getMonomerWidth();
    }
  }, {
    key: "addLineFromTopToRight",
    value: function addLineFromTopToRight() {
      this.path = "".concat(this.path, " c 0,4.418 3.582,").concat(CORNER_LENGTH, " ").concat(CORNER_LENGTH, ",").concat(CORNER_LENGTH);
    }
  }, {
    key: "addLineFromLeftToTop",
    value: function addLineFromLeftToTop() {
      this.path = "".concat(this.path, " c 4.418,0 ").concat(CORNER_LENGTH, ",-3.582 ").concat(CORNER_LENGTH, ",-").concat(CORNER_LENGTH);
    }
  }, {
    key: "addLineFromBottomToRight",
    value: function addLineFromBottomToRight() {
      this.path = "".concat(this.path, " c 0,-4.418 3.582,-").concat(CORNER_LENGTH, " ").concat(CORNER_LENGTH, ",-").concat(CORNER_LENGTH);
    }
  }, {
    key: "addLineFromLeftToBottom",
    value: function addLineFromLeftToBottom() {
      this.path = "".concat(this.path, " c 4.418,0 ").concat(CORNER_LENGTH, ",3.582 ").concat(CORNER_LENGTH, ",").concat(CORNER_LENGTH);
    }
  }, {
    key: "addLineFromTopToLeft",
    value: function addLineFromTopToLeft() {
      this.path = "".concat(this.path, " c 0,4.418 -3.582,").concat(CORNER_LENGTH, " -").concat(CORNER_LENGTH, ",").concat(CORNER_LENGTH);
    }
  }, {
    key: "addLineFromRightToUp",
    value: function addLineFromRightToUp() {
      this.path = "".concat(this.path, " c -4.418,0 -").concat(CORNER_LENGTH, ",-3.582 -").concat(CORNER_LENGTH, ",-").concat(CORNER_LENGTH);
    }
  }, {
    key: "addLineFromRightToBottom",
    value: function addLineFromRightToBottom() {
      this.path = "".concat(this.path, " c -4.418,0 -").concat(CORNER_LENGTH, ",3.582 -").concat(CORNER_LENGTH, ",").concat(CORNER_LENGTH);
    }
  }, {
    key: "addLine",
    value: function addLine(isHorisontal, length, startPosition) {
      var start = startPosition ? "M ".concat(Math.round(startPosition.x), ",").concat(Math.round(startPosition.y)) : this.path;
      var line = isHorisontal === LINE_DIRECTION.Horizontal ? "l".concat(length, ", 0") : "l 0, ".concat(length);
      this.path = "".concat(start, " ").concat(line);
    }
  }, {
    key: "addRandomLine",
    value: function addRandomLine(startPosition, endPosition) {
      var start = "M ".concat(Math.round(startPosition.x), ",").concat(Math.round(startPosition.y));
      var line = "L ".concat(Math.round(endPosition.x), ",").concat(Math.round(endPosition.y));
      this.path = "".concat(start, " ").concat(line);
    }
  }, {
    key: "appendBondGraph",
    value: function appendBondGraph(rootElement) {
      this.bodyElement = rootElement.append('line').attr('stroke', this.polymerBond.finished ? '#333333' : '#0097A8').attr('stroke-width', 1).attr('class', 'selection-area').attr('x1', this.scaledPosition.startPosition.x).attr('y1', this.scaledPosition.startPosition.y).attr('x2', this.scaledPosition.endPosition.x).attr('y2', this.scaledPosition.endPosition.y).attr('pointer-events', 'stroke');
      return this.bodyElement;
    }
  }, {
    key: "appendRootElement",
    value: function appendRootElement() {
      var _this2 = this;
      return this.canvas.insert('g', ":first-child").data([this]).on('mouseover', function (event) {
        _this2.editorEvents.mouseOverPolymerBond.dispatch(event);
        _this2.editorEvents.mouseOverDrawingEntity.dispatch(event);
      }).on('mouseout', function (event) {
        _this2.editorEvents.mouseLeavePolymerBond.dispatch(event);
        _this2.editorEvents.mouseLeaveDrawingEntity.dispatch(event);
      }).attr('pointer-events', 'stroke');
    }
  }, {
    key: "show",
    value: function show() {
      this.rootElement = this.rootElement || this.appendRootElement();
      this.appendBond(this.rootElement);
      this.appendHoverAreaElement();
      this.drawSelection();
    }
  }, {
    key: "drawSelection",
    value: function drawSelection() {
      if (this.polymerBond.selected) {
        var _this$selectionElemen;
        (_this$selectionElemen = this.selectionElement) === null || _this$selectionElemen === void 0 || _this$selectionElemen.remove();
        if (this.isSnake && !this.isMonomersOnSameHorizontalLine()) {
          var _this$rootElement2;
          this.selectionElement = (_this$rootElement2 = this.rootElement) === null || _this$rootElement2 === void 0 ? void 0 : _this$rootElement2.insert('path', ':first-child').attr('stroke', '#57FF8F').attr('stroke-width', 10).attr('fill-opacity', 0).attr('d', this.path);
        } else {
          var _this$rootElement3;
          this.selectionElement = (_this$rootElement3 = this.rootElement) === null || _this$rootElement3 === void 0 ? void 0 : _this$rootElement3.insert('line', ':first-child').attr('stroke', '#57FF8F').attr('x1', this.scaledPosition.startPosition.x).attr('y1', this.scaledPosition.startPosition.y).attr('x2', this.scaledPosition.endPosition.x).attr('y2', this.scaledPosition.endPosition.y).attr('stroke-width', '5');
        }
      } else {
        var _this$selectionElemen2;
        (_this$selectionElemen2 = this.selectionElement) === null || _this$selectionElemen2 === void 0 || _this$selectionElemen2.remove();
      }
    }
  }, {
    key: "moveEnd",
    value: function moveEnd() {
      if (this.isSnake && !this.isMonomersOnSameHorizontalLine()) {
        this.moveSnakeBondEnd();
      } else {
        this.moveGraphBondEnd();
      }
    }
  }, {
    key: "moveSnakeBondEnd",
    value: function moveSnakeBondEnd() {
      var _this$selectionElemen3;
      var startPosition = this.scaledPosition.startPosition;
      var endPosition = this.scaledPosition.endPosition;
      this.updateSnakeBondPath(startPosition, endPosition);
      assert__default["default"](this.bodyElement);
      assert__default["default"](this.hoverAreaElement);
      this.bodyElement.attr('d', this.path);
      this.hoverAreaElement.attr('d', this.path);
      (_this$selectionElemen3 = this.selectionElement) === null || _this$selectionElemen3 === void 0 || _this$selectionElemen3.attr('d', this.path);
    }
  }, {
    key: "moveGraphBondEnd",
    value: function moveGraphBondEnd() {
      var _this$selectionElemen4;
      assert__default["default"](this.bodyElement);
      assert__default["default"](this.hoverAreaElement);
      this.bodyElement.attr('x2', this.scaledPosition.endPosition.x).attr('y2', this.scaledPosition.endPosition.y);
      this.hoverAreaElement.attr('x2', this.scaledPosition.endPosition.x).attr('y2', this.scaledPosition.endPosition.y);
      (_this$selectionElemen4 = this.selectionElement) === null || _this$selectionElemen4 === void 0 || (_this$selectionElemen4 = _this$selectionElemen4.attr('x2', this.scaledPosition.endPosition.x)) === null || _this$selectionElemen4 === void 0 || _this$selectionElemen4.attr('y2', this.scaledPosition.endPosition.y);
    }
  }, {
    key: "moveStart",
    value: function moveStart() {
      if (this.isSnake && !this.isMonomersOnSameHorizontalLine()) {
        this.moveSnakeBondStart();
      } else {
        this.moveGraphBondStart();
      }
    }
  }, {
    key: "moveSnakeBondStart",
    value: function moveSnakeBondStart() {
      var _this$selectionElemen5;
      var startPosition = this.scaledPosition.startPosition;
      var endPosition = this.scaledPosition.endPosition;
      this.updateSnakeBondPath(startPosition, endPosition);
      assert__default["default"](this.bodyElement);
      assert__default["default"](this.hoverAreaElement);
      this.bodyElement.attr('d', this.path);
      this.hoverAreaElement.attr('d', this.path);
      (_this$selectionElemen5 = this.selectionElement) === null || _this$selectionElemen5 === void 0 || _this$selectionElemen5.attr('d', this.path);
    }
  }, {
    key: "moveGraphBondStart",
    value: function moveGraphBondStart() {
      var _this$selectionElemen6;
      assert__default["default"](this.bodyElement);
      assert__default["default"](this.hoverAreaElement);
      this.bodyElement.attr('x1', this.scaledPosition.startPosition.x).attr('y1', this.scaledPosition.startPosition.y);
      this.hoverAreaElement.attr('x1', this.scaledPosition.startPosition.x).attr('y1', this.scaledPosition.startPosition.y);
      (_this$selectionElemen6 = this.selectionElement) === null || _this$selectionElemen6 === void 0 || (_this$selectionElemen6 = _this$selectionElemen6.attr('x1', this.scaledPosition.startPosition.x)) === null || _this$selectionElemen6 === void 0 || _this$selectionElemen6.attr('y1', this.scaledPosition.startPosition.y);
    }
  }, {
    key: "appendHoverAreaElement",
    value: function appendHoverAreaElement() {
      if (this.isSnake && !this.isMonomersOnSameHorizontalLine()) {
        var _this$rootElement4;
        this.hoverAreaElement = (_this$rootElement4 = this.rootElement) === null || _this$rootElement4 === void 0 ? void 0 : _this$rootElement4.append('path').attr('stroke', 'transparent').attr('d', this.path).attr('fill-opacity', 0).attr('stroke-width', '10');
      } else {
        var _this$rootElement5;
        this.hoverAreaElement = (_this$rootElement5 = this.rootElement) === null || _this$rootElement5 === void 0 ? void 0 : _this$rootElement5.append('line').attr('stroke', 'transparent').attr('x1', this.scaledPosition.startPosition.x).attr('y1', this.scaledPosition.startPosition.y).attr('x2', this.scaledPosition.endPosition.x).attr('y2', this.scaledPosition.endPosition.y).attr('stroke-width', '10');
      }
    }
  }, {
    key: "appendHover",
    value: function appendHover() {
      assert__default["default"](this.bodyElement);
      this.bodyElement.attr('stroke', '#0097A8').attr('pointer-events', 'none');
      if (this.polymerBond.selected) {
        assert__default["default"](this.hoverAreaElement);
        this.hoverAreaElement.attr('stroke', '#CCFFDD');
      }
    }
  }, {
    key: "removeHover",
    value: function removeHover() {
      assert__default["default"](this.bodyElement);
      assert__default["default"](this.hoverAreaElement);
      this.bodyElement.attr('stroke', '#333333').attr('pointer-events', 'stroke');
      return this.hoverAreaElement.attr('stroke', 'transparent');
    }
  }]);
  return PolymerBondRenderer;
}(BaseRenderer);

var PolymerBond = function () {
  function PolymerBond(editor) {
    var _this = this;
    _classCallCheck__default["default"](this, PolymerBond);
    _defineProperty__default["default"](this, "isBondConnectionModalOpen", false);
    _defineProperty__default["default"](this, "handleBondCreation", function (payload) {
      assert__default["default"](_this.bondRenderer);
      var secondMonomer = payload.secondMonomer,
        firstSelectedAttachmentPoint = payload.firstSelectedAttachmentPoint,
        secondSelectedAttachmentPoint = payload.secondSelectedAttachmentPoint;
      var modelChanges = _this.editor.drawingEntitiesManager.finishPolymerBondCreation(_this.bondRenderer.polymerBond, secondMonomer, firstSelectedAttachmentPoint, secondSelectedAttachmentPoint);
      _this.history.update(modelChanges);
      _this.editor.renderersContainer.update(modelChanges);
      if (firstSelectedAttachmentPoint === secondSelectedAttachmentPoint) {
        _this.editor.events.error.dispatch('You have connected monomers with attachment points of the same group');
      }
      _this.isBondConnectionModalOpen = false;
      _this.editor.renderersContainer.deletePolymerBond(_this.bondRenderer.polymerBond, false, false);
      _this.bondRenderer = undefined;
    });
    _defineProperty__default["default"](this, "handleBondCreationCancellation", function (secondMonomer) {
      if (!_this.bondRenderer) {
        return;
      }
      var modelChanges = _this.editor.drawingEntitiesManager.cancelPolymerBondCreation(_this.bondRenderer.polymerBond, secondMonomer);
      _this.editor.renderersContainer.update(modelChanges);
      _this.isBondConnectionModalOpen = false;
      _this.bondRenderer = undefined;
    });
    this.editor = editor;
    this.editor = editor;
    this.history = new EditorHistory(this.editor);
  }
  _createClass__default["default"](PolymerBond, [{
    key: "mouseDownAttachmentPoint",
    value: function mouseDownAttachmentPoint(event) {
      var selectedRenderer = event.target.__data__;
      if (selectedRenderer instanceof BaseMonomerRenderer && !selectedRenderer.monomer.isAttachmentPointUsed(event.attachmentPointName)) {
        selectedRenderer.monomer.setChosenFirstAttachmentPoint(event.attachmentPointName);
      }
    }
  }, {
    key: "removeBond",
    value: function removeBond() {
      if (this.bondRenderer) {
        var modelChanges = this.editor.drawingEntitiesManager.cancelPolymerBondCreation(this.bondRenderer.polymerBond);
        this.editor.renderersContainer.update(modelChanges);
        this.bondRenderer = undefined;
      }
    }
  }, {
    key: "mousedown",
    value: function mousedown(event) {
      var selectedRenderer = event.target.__data__;
      if (selectedRenderer instanceof BaseMonomerRenderer) {
        var startAttachmentPoint = selectedRenderer.monomer.startBondAttachmentPoint;
        if (!startAttachmentPoint) {
          this.editor.events.error.dispatch("Selected monomer doesn't have any free attachment points");
          return;
        }
        var _this$editor$drawingE = this.editor.drawingEntitiesManager.startPolymerBondCreation(selectedRenderer.monomer, selectedRenderer.monomer.position, Coordinates.canvasToModel(this.editor.lastCursorPositionOfCanvas)),
          polymerBond = _this$editor$drawingE.polymerBond,
          modelChanges = _this$editor$drawingE.command;
        this.editor.renderersContainer.update(modelChanges);
        this.bondRenderer = polymerBond.renderer;
      }
    }
  }, {
    key: "mousemove",
    value: function mousemove() {
      if (this.bondRenderer) {
        var modelChanges = this.editor.drawingEntitiesManager.movePolymerBond(this.bondRenderer.polymerBond, Coordinates.canvasToModel(this.editor.lastCursorPositionOfCanvas));
        this.editor.renderersContainer.update(modelChanges);
      }
    }
  }, {
    key: "mouseLeavePolymerBond",
    value: function mouseLeavePolymerBond(event) {
      var renderer = event.target.__data__;
      if (this.bondRenderer || !renderer.polymerBond) return;
      var modelChanges = this.editor.drawingEntitiesManager.hidePolymerBondInformation(renderer.polymerBond);
      this.editor.renderersContainer.markForRecalculateBegin();
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "mouseOverPolymerBond",
    value: function mouseOverPolymerBond(event) {
      if (this.bondRenderer) return;
      var renderer = event.target.__data__;
      var modelChanges = this.editor.drawingEntitiesManager.showPolymerBondInformation(renderer.polymerBond);
      this.editor.renderersContainer.markForRecalculateBegin();
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "mouseOverMonomer",
    value: function mouseOverMonomer(event) {
      var renderer = event.target.__data__;
      var modelChanges;
      if (this.bondRenderer) {
        var _this$bondRenderer, _this$bondRenderer2, _this$bondRenderer3;
        if (((_this$bondRenderer = this.bondRenderer) === null || _this$bondRenderer === void 0 ? void 0 : _this$bondRenderer.polymerBond.firstMonomer) === renderer.monomer) {
          return;
        }
        var shouldCalculateBonds = !this.shouldInvokeModal((_this$bondRenderer2 = this.bondRenderer) === null || _this$bondRenderer2 === void 0 ? void 0 : _this$bondRenderer2.polymerBond.firstMonomer, renderer.monomer, false);
        modelChanges = this.editor.drawingEntitiesManager.intendToFinishBondCreation(renderer.monomer, (_this$bondRenderer3 = this.bondRenderer) === null || _this$bondRenderer3 === void 0 ? void 0 : _this$bondRenderer3.polymerBond, shouldCalculateBonds);
      } else {
        modelChanges = this.editor.drawingEntitiesManager.intendToStartBondCreation(renderer.monomer);
      }
      this.editor.renderersContainer.markForRecalculateBegin();
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "mouseOverAttachmentPoint",
    value: function mouseOverAttachmentPoint(event) {
      var renderer = event.target.__data__;
      var modelChanges;
      if (this.bondRenderer) {
        var _this$bondRenderer4, _this$bondRenderer5, _this$bondRenderer6;
        if (((_this$bondRenderer4 = this.bondRenderer) === null || _this$bondRenderer4 === void 0 ? void 0 : _this$bondRenderer4.polymerBond.firstMonomer) === renderer.monomer) {
          return;
        }
        var shouldCalculateBonds = !this.shouldInvokeModal((_this$bondRenderer5 = this.bondRenderer) === null || _this$bondRenderer5 === void 0 ? void 0 : _this$bondRenderer5.polymerBond.firstMonomer, renderer.monomer, false);
        modelChanges = this.editor.drawingEntitiesManager.intendToFinishAttachmenPointBondCreation(renderer.monomer, (_this$bondRenderer6 = this.bondRenderer) === null || _this$bondRenderer6 === void 0 ? void 0 : _this$bondRenderer6.polymerBond, event.attachmentPointName, shouldCalculateBonds);
      } else {
        modelChanges = this.editor.drawingEntitiesManager.intendToStartAttachmenPointBondCreation(renderer.monomer, event.attachmentPointName);
      }
      this.editor.renderersContainer.markForRecalculateBegin();
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "mouseLeaveMonomer",
    value: function mouseLeaveMonomer(event) {
      var _this$bondRenderer7;
      var renderer = event.target.__data__;
      if (renderer !== ((_this$bondRenderer7 = this.bondRenderer) === null || _this$bondRenderer7 === void 0 || (_this$bondRenderer7 = _this$bondRenderer7.polymerBond) === null || _this$bondRenderer7 === void 0 || (_this$bondRenderer7 = _this$bondRenderer7.firstMonomer) === null || _this$bondRenderer7 === void 0 ? void 0 : _this$bondRenderer7.renderer) && !this.isBondConnectionModalOpen) {
        var _this$bondRenderer8;
        var modelChanges = this.editor.drawingEntitiesManager.cancelIntentionToFinishBondCreation(renderer.monomer, (_this$bondRenderer8 = this.bondRenderer) === null || _this$bondRenderer8 === void 0 ? void 0 : _this$bondRenderer8.polymerBond);
        this.editor.renderersContainer.markForRecalculateBegin();
        this.editor.renderersContainer.update(modelChanges);
      }
    }
  }, {
    key: "mouseLeaveAttachmentPoint",
    value: function mouseLeaveAttachmentPoint(event) {
      var _this$bondRenderer9;
      if (this.isBondConnectionModalOpen) {
        return;
      }
      var renderer = event.target.__data__;
      if (renderer !== ((_this$bondRenderer9 = this.bondRenderer) === null || _this$bondRenderer9 === void 0 || (_this$bondRenderer9 = _this$bondRenderer9.polymerBond) === null || _this$bondRenderer9 === void 0 || (_this$bondRenderer9 = _this$bondRenderer9.firstMonomer) === null || _this$bondRenderer9 === void 0 ? void 0 : _this$bondRenderer9.renderer)) {
        var _this$bondRenderer10;
        var modelChanges = this.editor.drawingEntitiesManager.cancelIntentionToFinishBondCreation(renderer.monomer, (_this$bondRenderer10 = this.bondRenderer) === null || _this$bondRenderer10 === void 0 ? void 0 : _this$bondRenderer10.polymerBond);
        this.editor.renderersContainer.markForRecalculateBegin();
        this.editor.renderersContainer.update(modelChanges);
      }
    }
  }, {
    key: "mouseUpAttachmentPoint",
    value: function mouseUpAttachmentPoint(event) {
      var _this$bondRenderer11;
      var renderer = event.target.__data__;
      var isFirstMonomerHovered = renderer === ((_this$bondRenderer11 = this.bondRenderer) === null || _this$bondRenderer11 === void 0 || (_this$bondRenderer11 = _this$bondRenderer11.polymerBond) === null || _this$bondRenderer11 === void 0 || (_this$bondRenderer11 = _this$bondRenderer11.firstMonomer) === null || _this$bondRenderer11 === void 0 ? void 0 : _this$bondRenderer11.renderer);
      if (this.bondRenderer && !isFirstMonomerHovered) {
        var _this$bondRenderer12;
        var firstMonomer = (_this$bondRenderer12 = this.bondRenderer) === null || _this$bondRenderer12 === void 0 || (_this$bondRenderer12 = _this$bondRenderer12.polymerBond) === null || _this$bondRenderer12 === void 0 ? void 0 : _this$bondRenderer12.firstMonomer;
        var secondMonomer = renderer.monomer;
        if (secondMonomer.isAttachmentPointUsed(event.attachmentPointName)) {
          this.mouseup();
          return;
        }
        for (var attachmentPoint in secondMonomer.attachmentPointsToBonds) {
          var bond = secondMonomer.attachmentPointsToBonds[attachmentPoint];
          if (!bond) {
            continue;
          }
          var alreadyHasBond = bond.firstMonomer === firstMonomer && bond.secondMonomer === secondMonomer || bond.firstMonomer === secondMonomer && bond.secondMonomer === firstMonomer;
          if (alreadyHasBond) {
            this.editor.events.error.dispatch("There can't be more than 1 bond between the first and the second monomer");
            return;
          }
        }
        secondMonomer.setChosenSecondAttachmentPoint(event.attachmentPointName);
        var showModal = this.shouldInvokeModal(firstMonomer, secondMonomer);
        if (showModal) {
          this.isBondConnectionModalOpen = true;
          this.editor.events.openMonomerConnectionModal.dispatch({
            firstMonomer: firstMonomer,
            secondMonomer: secondMonomer
          });
          return;
        }
        var modelChanges = this.finishBondCreation(renderer.monomer);
        this.history.update(modelChanges);
        this.editor.renderersContainer.update(modelChanges);
        this.editor.renderersContainer.deletePolymerBond(this.bondRenderer.polymerBond, false, false);
        this.bondRenderer = undefined;
        event.stopPropagation();
      }
    }
  }, {
    key: "finishBondCreation",
    value: function finishBondCreation(secondMonomer) {
      assert__default["default"](this.bondRenderer);
      if (!secondMonomer.hasFreeAttachmentPoint) {
        this.editor.events.error.dispatch("Monomers don't have any connection point available");
        return this.editor.drawingEntitiesManager.cancelPolymerBondCreation(this.bondRenderer.polymerBond);
      }
      var firstMonomerAttachmentPoint = this.bondRenderer.polymerBond.firstMonomer.getPotentialAttachmentPointByBond(this.bondRenderer.polymerBond);
      var secondMonomerAttachmentPoint = secondMonomer.getPotentialAttachmentPointByBond(this.bondRenderer.polymerBond);
      assert__default["default"](firstMonomerAttachmentPoint);
      assert__default["default"](secondMonomerAttachmentPoint);
      if (firstMonomerAttachmentPoint === secondMonomerAttachmentPoint) {
        this.editor.events.error.dispatch('You have connected monomers with attachment points of the same group');
      }
      return this.editor.drawingEntitiesManager.finishPolymerBondCreation(this.bondRenderer.polymerBond, secondMonomer, firstMonomerAttachmentPoint, secondMonomerAttachmentPoint);
    }
  }, {
    key: "mouseup",
    value: function mouseup() {
      if (this.isBondConnectionModalOpen) {
        return;
      }
      this.removeBond();
    }
  }, {
    key: "mouseUpMonomer",
    value: function mouseUpMonomer(event) {
      var _this$bondRenderer13;
      var renderer = event.target.__data__;
      var isFirstMonomerHovered = renderer === ((_this$bondRenderer13 = this.bondRenderer) === null || _this$bondRenderer13 === void 0 || (_this$bondRenderer13 = _this$bondRenderer13.polymerBond) === null || _this$bondRenderer13 === void 0 || (_this$bondRenderer13 = _this$bondRenderer13.firstMonomer) === null || _this$bondRenderer13 === void 0 ? void 0 : _this$bondRenderer13.renderer);
      if (this.bondRenderer && !isFirstMonomerHovered) {
        var _this$bondRenderer14;
        var firstMonomer = (_this$bondRenderer14 = this.bondRenderer) === null || _this$bondRenderer14 === void 0 || (_this$bondRenderer14 = _this$bondRenderer14.polymerBond) === null || _this$bondRenderer14 === void 0 ? void 0 : _this$bondRenderer14.firstMonomer;
        var secondMonomer = renderer.monomer;
        for (var attachmentPoint in secondMonomer.attachmentPointsToBonds) {
          var bond = secondMonomer.attachmentPointsToBonds[attachmentPoint];
          if (!bond) {
            continue;
          }
          var alreadyHasBond = bond.firstMonomer === firstMonomer && bond.secondMonomer === secondMonomer || bond.firstMonomer === secondMonomer && bond.secondMonomer === firstMonomer;
          if (alreadyHasBond) {
            this.editor.events.error.dispatch("There can't be more than 1 bond between the first and the second monomer");
            return;
          }
        }
        var showModal = this.shouldInvokeModal(firstMonomer, secondMonomer);
        if (showModal) {
          this.isBondConnectionModalOpen = true;
          this.editor.events.openMonomerConnectionModal.dispatch({
            firstMonomer: firstMonomer,
            secondMonomer: secondMonomer
          });
          return;
        }
        var modelChanges = this.finishBondCreation(renderer.monomer);
        this.editor.renderersContainer.update(modelChanges);
        this.editor.renderersContainer.deletePolymerBond(this.bondRenderer.polymerBond, false, false);
        this.bondRenderer = undefined;
        this.history.update(modelChanges);
        event.stopPropagation();
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeBond();
    }
  }, {
    key: "shouldInvokeModal",
    value: function shouldInvokeModal(firstMonomer, secondMonomer) {
      var checkForPotentialBonds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      if (!secondMonomer.hasFreeAttachmentPoint) {
        return false;
      }
      if (firstMonomer.chosenFirstAttachmentPointForBond !== null && secondMonomer.chosenSecondAttachmentPointForBond !== null) {
        return false;
      }
      if (checkForPotentialBonds && (!firstMonomer.hasPotentialBonds() || !secondMonomer.hasPotentialBonds())) {
        return true;
      }
      if (firstMonomer.unUsedAttachmentPointsNamesList.length === 1 && secondMonomer.unUsedAttachmentPointsNamesList.length === 1) {
        return false;
      }
      if (firstMonomer instanceof Chem || secondMonomer instanceof Chem) {
        return true;
      }
      var rnaMonomerClasses = [Sugar, RNABase, Phosphate];
      var firstMonomerIsRNA = rnaMonomerClasses.find(function (RNAClass) {
        return firstMonomer instanceof RNAClass;
      });
      var secondMonomerIsRNA = rnaMonomerClasses.find(function (RNAClass) {
        return secondMonomer instanceof RNAClass;
      });
      if (firstMonomerIsRNA && secondMonomer instanceof Peptide || secondMonomerIsRNA && firstMonomer instanceof Peptide) {
        return true;
      }
      if (secondMonomer instanceof Peptide && firstMonomer instanceof Peptide) {
        var hasPlentyAttachmentPoints = firstMonomer.listOfAttachmentPoints.length > 2 || secondMonomer.listOfAttachmentPoints.length > 2;
        var hasPlentyFreeAttachmentPoints = firstMonomer.unUsedAttachmentPointsNamesList.length > 1 || secondMonomer.unUsedAttachmentPointsNamesList.length > 1;
        var BothR1AttachmentPointUsed = firstMonomer.isAttachmentPointUsed(exports.AttachmentPointName.R1) && secondMonomer.isAttachmentPointUsed(exports.AttachmentPointName.R1);
        var BothR2AttachmentPointUsed = firstMonomer.isAttachmentPointUsed(exports.AttachmentPointName.R2) && secondMonomer.isAttachmentPointUsed(exports.AttachmentPointName.R2);
        var R1AndR2AttachmentPointUsed = firstMonomer.isAttachmentPointUsed(exports.AttachmentPointName.R2) && firstMonomer.isAttachmentPointUsed(exports.AttachmentPointName.R1) || secondMonomer.isAttachmentPointUsed(exports.AttachmentPointName.R2) && secondMonomer.isAttachmentPointUsed(exports.AttachmentPointName.R1);
        if (hasPlentyAttachmentPoints && hasPlentyFreeAttachmentPoints && (BothR1AttachmentPointUsed || BothR2AttachmentPointUsed || R1AndR2AttachmentPointUsed)) {
          return true;
        }
      }
      return false;
    }
  }]);
  return PolymerBond;
}();

var MONOMER_CONST = {
  AMINO_ACID: 'AminoAcid',
  PEPTIDE: 'PEPTIDE',
  CHEM: 'CHEM',
  RNA: 'RNA',
  DNA: 'DNA',
  MODDNA: 'MODDNA',
  R: 'R',
  P: 'P',
  SUGAR: 'SUGAR',
  BASE: 'BASE',
  PHOSPHATE: 'PHOSPHATE'
};
var monomerFactory = function monomerFactory(monomer) {
  var Monomer;
  var MonomerRenderer;
  var ketMonomerClass;
  if (monomer.props.MonomerType === MONOMER_CONST.CHEM || monomer.props.MonomerType === MONOMER_CONST.RNA && (monomer.props.MonomerClass === MONOMER_CONST.MODDNA || monomer.props.MonomerClass === MONOMER_CONST.DNA)) {
    Monomer = Chem;
    MonomerRenderer = ChemRenderer;
    ketMonomerClass = 'CHEM';
  } else if (monomer.props.MonomerType === MONOMER_CONST.PEPTIDE) {
    Monomer = Peptide;
    MonomerRenderer = PeptideRenderer;
    ketMonomerClass = 'AminoAcid';
  } else {
    if (monomer.props.MonomerNaturalAnalogCode === MONOMER_CONST.R) {
      Monomer = Sugar;
      MonomerRenderer = SugarRenderer;
      ketMonomerClass = 'Sugar';
    } else if (monomer.props.MonomerNaturalAnalogCode === MONOMER_CONST.P) {
      Monomer = Phosphate;
      MonomerRenderer = PhosphateRenderer;
      ketMonomerClass = 'Phosphate';
    } else {
      Monomer = RNABase;
      MonomerRenderer = RNABaseRenderer;
      ketMonomerClass = 'Base';
    }
  }
  return [Monomer, MonomerRenderer, ketMonomerClass];
};

var MonomerTool = function () {
  function MonomerTool(editor, monomer) {
    _classCallCheck__default["default"](this, MonomerTool);
    _defineProperty__default["default"](this, "MONOMER_PREVIEW_SCALE_FACTOR", 0.8);
    _defineProperty__default["default"](this, "MONOMER_PREVIEW_OFFSET_X", 30);
    _defineProperty__default["default"](this, "MONOMER_PREVIEW_OFFSET_Y", 30);
    this.editor = editor;
    this.monomer = monomer;
    this.editor = editor;
    this.monomer = monomer;
    this.history = new EditorHistory(this.editor);
  }
  _createClass__default["default"](MonomerTool, [{
    key: "mousedown",
    value: function mousedown() {
      assert__default["default"](this.monomerPreviewRenderer);
      var position = Coordinates.canvasToModel(new Vec2(this.editor.lastCursorPositionOfCanvas.x, this.editor.lastCursorPositionOfCanvas.y));
      var modelChanges = this.editor.drawingEntitiesManager.addMonomer(this.monomer,
      position);
      this.history.update(modelChanges);
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "mousemove",
    value: function mousemove() {
      var _this$monomerPreview, _this$monomerPreviewR;
      var position = Coordinates.canvasToModel(new Vec2(this.editor.lastCursorPosition.x + this.MONOMER_PREVIEW_OFFSET_X, this.editor.lastCursorPosition.y + this.MONOMER_PREVIEW_OFFSET_Y));
      (_this$monomerPreview = this.monomerPreview) === null || _this$monomerPreview === void 0 || _this$monomerPreview.moveAbsolute(position);
      (_this$monomerPreviewR = this.monomerPreviewRenderer) === null || _this$monomerPreviewR === void 0 || _this$monomerPreviewR.move();
    }
  }, {
    key: "mouseLeaveClientArea",
    value: function mouseLeaveClientArea() {
      this.hidePreview();
    }
  }, {
    key: "mouseover",
    value: function mouseover() {
      if (!this.monomerPreview) {
        var _this$monomerPreviewR2;
        var _monomerFactory = monomerFactory(this.monomer),
          _monomerFactory2 = _slicedToArray__default["default"](_monomerFactory, 2),
          Monomer = _monomerFactory2[0],
          MonomerRenderer = _monomerFactory2[1];
        this.monomerPreview = new Monomer(this.monomer);
        this.monomerPreviewRenderer = new MonomerRenderer(this.monomerPreview, this.MONOMER_PREVIEW_SCALE_FACTOR, false);
        (_this$monomerPreviewR2 = this.monomerPreviewRenderer) === null || _this$monomerPreviewR2 === void 0 || _this$monomerPreviewR2.show(this.editor.theme);
      }
    }
  }, {
    key: "hidePreview",
    value: function hidePreview() {
      var _this$monomerPreviewR3;
      (_this$monomerPreviewR3 = this.monomerPreviewRenderer) === null || _this$monomerPreviewR3 === void 0 || _this$monomerPreviewR3.remove();
      this.monomerPreviewRenderer = undefined;
      this.monomerPreview = undefined;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.hidePreview();
    }
  }]);
  return MonomerTool;
}();

var RNA_MONOMER_DISTANCE = 22.5;
var RnaPresetTool = function () {
  function RnaPresetTool(editor, preset) {
    _classCallCheck__default["default"](this, RnaPresetTool);
    _defineProperty__default["default"](this, "MONOMER_PREVIEW_SCALE_FACTOR", 0.5);
    _defineProperty__default["default"](this, "MONOMER_PREVIEW_OFFSET_X", 30);
    _defineProperty__default["default"](this, "MONOMER_PREVIEW_OFFSET_Y", 30);
    _defineProperty__default["default"](this, "RNA_BASE_PREVIEW_OFFSET_X", 1);
    _defineProperty__default["default"](this, "RNA_BASE_PREVIEW_OFFSET_Y", 20);
    _defineProperty__default["default"](this, "PHOSPHATE_PREVIEW_OFFSET_X", 18);
    this.editor = editor;
    this.editor = editor;
    if (preset !== null && preset !== void 0 && preset.base) {
      this.rnaBase = preset === null || preset === void 0 ? void 0 : preset.base;
    }
    if (preset !== null && preset !== void 0 && preset.phosphate) {
      this.phosphate = preset === null || preset === void 0 ? void 0 : preset.phosphate;
    }
    if (preset !== null && preset !== void 0 && preset.sugar) {
      this.sugar = preset === null || preset === void 0 ? void 0 : preset.sugar;
    }
    this.history = new EditorHistory(this.editor);
  }
  _createClass__default["default"](RnaPresetTool, [{
    key: "mousedown",
    value: function mousedown() {
      var _this$sugarPreviewRen;
      if (!this.sugar || !this.sugarPreviewRenderer) {
        this.editor.events.error.dispatch('No sugar in RNA preset found');
        return;
      }
      var _this$editor$drawingE = this.editor.drawingEntitiesManager.addRnaPreset({
          sugar: this.sugar,
          sugarPosition: Coordinates.canvasToModel(new Vec2(this.editor.lastCursorPositionOfCanvas.x, this.editor.lastCursorPositionOfCanvas.y)),
          phosphate: this.phosphate,
          phosphatePosition: this.phosphatePreviewRenderer ? Coordinates.canvasToModel(new Vec2(this.editor.lastCursorPositionOfCanvas.x + ((_this$sugarPreviewRen = this.sugarPreviewRenderer) === null || _this$sugarPreviewRen === void 0 ? void 0 : _this$sugarPreviewRen.width) + RNA_MONOMER_DISTANCE, this.editor.lastCursorPositionOfCanvas.y)) : undefined,
          rnaBase: this.rnaBase,
          rnaBasePosition: this.rnaBasePreviewRenderer ? Coordinates.canvasToModel(new Vec2(this.editor.lastCursorPositionOfCanvas.x, this.editor.lastCursorPositionOfCanvas.y + this.sugarPreviewRenderer.height + RNA_MONOMER_DISTANCE)) : undefined
        }),
        modelChanges = _this$editor$drawingE.command;
      this.history.update(modelChanges);
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "mousemove",
    value: function mousemove() {
      var _this$sugarPreview, _this$rnaBasePreview, _this$phosphatePrevie, _this$rnaBasePreviewR, _this$phosphatePrevie2, _this$sugarPreviewRen2;
      (_this$sugarPreview = this.sugarPreview) === null || _this$sugarPreview === void 0 || _this$sugarPreview.moveAbsolute(Coordinates.canvasToModel(new Vec2(this.editor.lastCursorPosition.x + this.MONOMER_PREVIEW_OFFSET_X, this.editor.lastCursorPosition.y + this.MONOMER_PREVIEW_OFFSET_Y)));
      (_this$rnaBasePreview = this.rnaBasePreview) === null || _this$rnaBasePreview === void 0 || _this$rnaBasePreview.moveAbsolute(Coordinates.canvasToModel(new Vec2(this.editor.lastCursorPosition.x + this.MONOMER_PREVIEW_OFFSET_X + this.RNA_BASE_PREVIEW_OFFSET_X, this.editor.lastCursorPosition.y + this.MONOMER_PREVIEW_OFFSET_Y + this.RNA_BASE_PREVIEW_OFFSET_Y)));
      (_this$phosphatePrevie = this.phosphatePreview) === null || _this$phosphatePrevie === void 0 || _this$phosphatePrevie.moveAbsolute(Coordinates.canvasToModel(new Vec2(this.editor.lastCursorPosition.x + this.MONOMER_PREVIEW_OFFSET_X + this.PHOSPHATE_PREVIEW_OFFSET_X, this.editor.lastCursorPosition.y + this.MONOMER_PREVIEW_OFFSET_Y)));
      (_this$rnaBasePreviewR = this.rnaBasePreviewRenderer) === null || _this$rnaBasePreviewR === void 0 || _this$rnaBasePreviewR.move();
      (_this$phosphatePrevie2 = this.phosphatePreviewRenderer) === null || _this$phosphatePrevie2 === void 0 || _this$phosphatePrevie2.move();
      (_this$sugarPreviewRen2 = this.sugarPreviewRenderer) === null || _this$sugarPreviewRen2 === void 0 || _this$sugarPreviewRen2.move();
    }
  }, {
    key: "mouseLeaveClientArea",
    value: function mouseLeaveClientArea() {
      var _this$sugarPreviewRen3, _this$phosphatePrevie3, _this$rnaBasePreviewR2;
      (_this$sugarPreviewRen3 = this.sugarPreviewRenderer) === null || _this$sugarPreviewRen3 === void 0 || _this$sugarPreviewRen3.remove();
      this.sugarPreviewRenderer = undefined;
      this.sugarPreview = undefined;
      (_this$phosphatePrevie3 = this.phosphatePreviewRenderer) === null || _this$phosphatePrevie3 === void 0 || _this$phosphatePrevie3.remove();
      this.phosphatePreviewRenderer = undefined;
      this.phosphatePreview = undefined;
      (_this$rnaBasePreviewR2 = this.rnaBasePreviewRenderer) === null || _this$rnaBasePreviewR2 === void 0 || _this$rnaBasePreviewR2.remove();
      this.rnaBasePreviewRenderer = undefined;
      this.rnaBasePreview = undefined;
    }
  }, {
    key: "mouseover",
    value: function mouseover() {
      var _this$sugarPreviewRen4;
      if (!this.sugar) {
        this.editor.events.error.dispatch('No sugar in RNA preset found');
        return;
      }
      if (this.sugarPreview) {
        return;
      }
      var _monomerFactory = monomerFactory(this.sugar),
        _monomerFactory2 = _slicedToArray__default["default"](_monomerFactory, 2),
        Sugar = _monomerFactory2[0],
        SugarRenderer = _monomerFactory2[1];
      this.sugarPreview = new Sugar(this.sugar);
      this.sugarPreviewRenderer = new SugarRenderer(this.sugarPreview, this.MONOMER_PREVIEW_SCALE_FACTOR);
      (_this$sugarPreviewRen4 = this.sugarPreviewRenderer) === null || _this$sugarPreviewRen4 === void 0 || _this$sugarPreviewRen4.show(this.editor.theme);
      if (this.rnaBase) {
        var _this$rnaBasePreviewR3;
        var _monomerFactory3 = monomerFactory(this.rnaBase),
          _monomerFactory4 = _slicedToArray__default["default"](_monomerFactory3, 2),
          RNABase = _monomerFactory4[0],
          RNABaseRenderer = _monomerFactory4[1];
        this.rnaBasePreview = new RNABase(this.rnaBase);
        this.rnaBasePreviewRenderer = new RNABaseRenderer(this.rnaBasePreview, this.MONOMER_PREVIEW_SCALE_FACTOR);
        (_this$rnaBasePreviewR3 = this.rnaBasePreviewRenderer) === null || _this$rnaBasePreviewR3 === void 0 || _this$rnaBasePreviewR3.show(this.editor.theme);
      }
      if (this.phosphate) {
        var _this$phosphatePrevie4;
        var _monomerFactory5 = monomerFactory(this.phosphate),
          _monomerFactory6 = _slicedToArray__default["default"](_monomerFactory5, 2),
          Phosphate = _monomerFactory6[0],
          PhosphateRenderer = _monomerFactory6[1];
        this.phosphatePreview = new Phosphate(this.phosphate);
        this.phosphatePreviewRenderer = new PhosphateRenderer(this.phosphatePreview, this.MONOMER_PREVIEW_SCALE_FACTOR);
        (_this$phosphatePrevie4 = this.phosphatePreviewRenderer) === null || _this$phosphatePrevie4 === void 0 || _this$phosphatePrevie4.show(this.editor.theme);
      }
    }
  }]);
  return RnaPresetTool;
}();

var EraserTool = function () {
  function EraserTool(editor) {
    _classCallCheck__default["default"](this, EraserTool);
    this.editor = editor;
    this.editor = editor;
    this.history = new EditorHistory(editor);
    if (this.editor.drawingEntitiesManager.selectedEntities.length && !(this.editor.mode instanceof SequenceMode)) {
      var modelChanges = this.editor.drawingEntitiesManager.deleteSelectedEntities();
      this.history.update(modelChanges);
      this.editor.renderersContainer.update(modelChanges);
    }
  }
  _createClass__default["default"](EraserTool, [{
    key: "mousedown",
    value: function mousedown(event) {
      var selectedItemRenderer = event.target.__data__;
      if (selectedItemRenderer instanceof BaseSequenceRenderer) {
        return;
      }
      if (selectedItemRenderer instanceof BaseRenderer) {
        var modelChanges = this.editor.drawingEntitiesManager.deleteDrawingEntity(selectedItemRenderer.drawingEntity);
        this.history.update(modelChanges);
        this.editor.renderersContainer.update(modelChanges);
      }
    }
  }, {
    key: "mouseOverDrawingEntity",
    value: function mouseOverDrawingEntity(event) {
      var renderer = event.target.__data__;
      var modelChanges = this.editor.drawingEntitiesManager.intendToSelectDrawingEntity(renderer.drawingEntity);
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "mouseLeaveDrawingEntity",
    value: function mouseLeaveDrawingEntity(event) {
      var renderer = event.target.__data__;
      var modelChanges = this.editor.drawingEntitiesManager.cancelIntentionToSelectDrawingEntity(renderer.drawingEntity);
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);
  return EraserTool;
}();

var SelectRectangle = function () {
  function SelectRectangle(editor) {
    _classCallCheck__default["default"](this, SelectRectangle);
    _defineProperty__default["default"](this, "mousePositionAfterMove", new Vec2(0, 0, 0));
    _defineProperty__default["default"](this, "mousePositionBeforeMove", new Vec2(0, 0, 0));
    _defineProperty__default["default"](this, "previousSelectedEntities", []);
    this.editor = editor;
    this.editor = editor;
    this.history = new EditorHistory(this.editor);
    this.destroy();
    this.createBrush();
  }
  _createClass__default["default"](SelectRectangle, [{
    key: "createBrush",
    value: function createBrush() {
      var _this = this;
      this.brushArea = d3.select(this.editor.canvas).insert('g', ':first-child').attr('id', 'rectangle-selection-area');
      this.brush = d3.brush();
      var brushed = function brushed(mo) {
        _this.setSelectedEntities();
        if (mo.selection) {
          var _this$brush;
          _this.brushArea.call((_this$brush = _this.brush) === null || _this$brush === void 0 ? void 0 : _this$brush.clear);
        }
      };
      var onBrush = function onBrush(brushEvent) {
        var selection = brushEvent.selection;
        var editor = CoreEditor.provideEditorInstance();
        if (!selection || editor.isSequenceEditMode) return;
        requestAnimationFrame(function () {
          var topLeftPoint = Coordinates.viewToCanvas(new Vec2(selection[0][0], selection[0][1]));
          var bottomRightPoint = Coordinates.viewToCanvas(new Vec2(selection[1][0], selection[1][1]));
          var modelChanges = _this.editor.drawingEntitiesManager.selectIfLocatedInRectangle(topLeftPoint, bottomRightPoint, _this.previousSelectedEntities, brushEvent.sourceEvent.shiftKey);
          _this.editor.renderersContainer.update(modelChanges);
        });
      };
      this.brush.on('brush', onBrush);
      this.brush.on('end', brushed);
      this.brushArea.call(this.brush);
      this.brushArea.select('rect.selection').style('fill', 'transparent').style('stroke', 'darkgrey');
      var handleResizeCanvas = function handleResizeCanvas() {
        var canvas = _this.editor.canvas;
        if (canvas.clientWidth === 0 || canvas.clientHeight === 0) {
          return;
        }
        _this.brush.extent([[0, 0], [canvas.width.baseVal.value, canvas.height.baseVal.value]]).keyModifiers(false).filter(function (e) {
          e.preventDefault();
          if (e.shiftKey) {
            e.stopPropagation();
          }
          return true;
        });
        _this.brushArea.call(_this.brush);
      };
      var canvasElement = this.editor.canvas;
      if (canvasElement) {
        this.canvasResizeObserver = new ResizeObserver(handleResizeCanvas);
        this.canvasResizeObserver.observe(canvasElement);
      }
    }
  }, {
    key: "mousedown",
    value: function mousedown(event) {
      var editor = CoreEditor.provideEditorInstance();
      if (editor.mode instanceof SequenceMode && editor.mode.isEditMode) {
        return;
      }
      var renderer = event.target.__data__;
      this.mousePositionAfterMove = this.editor.lastCursorPositionOfCanvas;
      this.mousePositionBeforeMove = this.editor.lastCursorPositionOfCanvas;
      var ModKey = reactDeviceDetect.isMacOs ? event.metaKey : event.ctrlKey;
      var modelChanges;
      if (renderer instanceof BaseRenderer && !event.shiftKey && !ModKey) {
        this.moveStarted = true;
        if (renderer.drawingEntity.selected && !(this.editor.mode instanceof SequenceMode)) {
          return;
        }
        var drawingEntities = this.editor.drawingEntitiesManager.getAllSelectedEntities(renderer.drawingEntity, false);
        modelChanges = this.editor.drawingEntitiesManager.selectDrawingEntities(drawingEntities);
      } else if (renderer instanceof BaseRenderer && event.shiftKey) {
        if (renderer.drawingEntity.selected) {
          return;
        }
        var _drawingEntities = this.editor.drawingEntitiesManager.getAllSelectedEntities(renderer.drawingEntity);
        modelChanges = this.editor.drawingEntitiesManager.addDrawingEntitiesToSelection(_drawingEntities);
      } else if (renderer instanceof BaseSequenceItemRenderer && ModKey) {
        var _drawingEntities2 = renderer.currentSubChain.nodes.map(function (node) {
          if (node instanceof Nucleoside) {
            return [node.sugar, node.rnaBase];
          } else if (node instanceof Nucleotide) {
            return [node.sugar, node.rnaBase, node.phosphate];
          } else {
            return node.monomer;
          }
        }).flat();
        _drawingEntities2 = _drawingEntities2.concat(renderer.currentSubChain.bonds);
        modelChanges = this.editor.drawingEntitiesManager.selectDrawingEntities(_drawingEntities2);
      } else {
        modelChanges = this.editor.drawingEntitiesManager.unselectAllDrawingEntities();
      }
      this.editor.renderersContainer.update(modelChanges);
      this.setSelectedEntities();
    }
  }, {
    key: "mousemove",
    value: function mousemove() {
      var _this2 = this;
      if (this.editor.mode instanceof SequenceMode) {
        return;
      }
      if (this.moveStarted) {
        var modelChanges = this.editor.drawingEntitiesManager.moveSelectedDrawingEntities(Coordinates.canvasToModel(new Vec2(this.editor.lastCursorPositionOfCanvas.x - this.mousePositionAfterMove.x, this.editor.lastCursorPositionOfCanvas.y - this.mousePositionAfterMove.y)));
        this.mousePositionAfterMove = this.editor.lastCursorPositionOfCanvas;
        requestAnimationFrame(function () {
          _this2.editor.renderersContainer.update(modelChanges);
        });
      }
    }
  }, {
    key: "mouseup",
    value: function mouseup(event) {
      var _renderer$drawingEnti;
      var renderer = event.target.__data__;
      if (this.moveStarted && (_renderer$drawingEnti = renderer.drawingEntity) !== null && _renderer$drawingEnti !== void 0 && _renderer$drawingEnti.selected) {
        this.moveStarted = false;
        if (Vec2.diff(this.mousePositionAfterMove, this.mousePositionBeforeMove).length() === 0) {
          return;
        }
        var modelChanges = this.editor.drawingEntitiesManager.moveSelectedDrawingEntities(new Vec2(0, 0), Coordinates.canvasToModel(new Vec2(this.mousePositionAfterMove.x - this.mousePositionBeforeMove.x, this.mousePositionAfterMove.y - this.mousePositionBeforeMove.y)));
        this.history.update(modelChanges);
      }
    }
  }, {
    key: "mouseOverDrawingEntity",
    value: function mouseOverDrawingEntity(event) {
      var renderer = event.target.__data__;
      var modelChanges = this.editor.drawingEntitiesManager.intendToSelectDrawingEntity(renderer.drawingEntity);
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "mouseLeaveDrawingEntity",
    value: function mouseLeaveDrawingEntity(event) {
      var renderer = event.target.__data__;
      var modelChanges = this.editor.drawingEntitiesManager.cancelIntentionToSelectDrawingEntity(renderer.drawingEntity);
      this.editor.renderersContainer.update(modelChanges);
    }
  }, {
    key: "setSelectedEntities",
    value: function setSelectedEntities() {
      this.previousSelectedEntities = this.editor.drawingEntitiesManager.allEntities.filter(function (_ref) {
        var _ref2 = _slicedToArray__default["default"](_ref, 2),
          drawingEntity = _ref2[1];
        return drawingEntity.selected;
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$canvasResizeObs;
      if (this.brush) {
        this.brushArea.remove();
        this.brush = null;
        this.brushArea = null;
      }
      (_this$canvasResizeObs = this.canvasResizeObserver) === null || _this$canvasResizeObs === void 0 || _this$canvasResizeObs.disconnect();
      if (!(this.editor.selectedTool instanceof EraserTool)) {
        var modelChanges = this.editor.drawingEntitiesManager.unselectAllDrawingEntities();
        this.editor.renderersContainer.update(modelChanges);
      }
    }
  }]);
  return SelectRectangle;
}();

var ClearTool = function () {
  function ClearTool(editor) {
    _classCallCheck__default["default"](this, ClearTool);
    this.editor = editor;
    this.editor = editor;
    this.history = new EditorHistory(editor);
    var modelChanges = this.editor.drawingEntitiesManager.deleteAllEntities();
    this.editor.renderersContainer.update(modelChanges);
    if (editor.mode instanceof SequenceMode) {
      modelChanges.addOperation(new ReinitializeSequenceModeCommand());
    }
    this.history.update(modelChanges);
  }
  _createClass__default["default"](ClearTool, [{
    key: "destroy",
    value: function destroy() {}
  }]);
  return ClearTool;
}();

var toolsMap = {
  monomer: MonomerTool,
  preset: RnaPresetTool,
  'select-rectangle': SelectRectangle,
  'bond-single': PolymerBond,
  erase: EraserTool,
  clear: ClearTool
};

var RenderersManager = function () {
  function RenderersManager(_ref) {
    var theme = _ref.theme;
    _classCallCheck__default["default"](this, RenderersManager);
    _defineProperty__default["default"](this, "monomers", new Map());
    _defineProperty__default["default"](this, "polymerBonds", new Map());
    _defineProperty__default["default"](this, "needRecalculateMonomersEnumeration", false);
    _defineProperty__default["default"](this, "needRecalculateMonomersBeginning", false);
    this.theme = theme;
  }
  _createClass__default["default"](RenderersManager, [{
    key: "hoverDrawingEntity",
    value: function hoverDrawingEntity(drawingEntity) {
      assert__default["default"](drawingEntity.baseRenderer);
      drawingEntity.baseRenderer.redrawHover();
    }
  }, {
    key: "selectDrawingEntity",
    value: function selectDrawingEntity(drawingEntity) {
      assert__default["default"](drawingEntity.baseRenderer);
      drawingEntity.baseRenderer.drawSelection();
    }
  }, {
    key: "moveDrawingEntity",
    value: function moveDrawingEntity(drawingEntity) {
      assert__default["default"](drawingEntity.baseRenderer);
      drawingEntity.baseRenderer.moveSelection();
      drawingEntity.baseRenderer.drawSelection();
    }
  }, {
    key: "markForReEnumeration",
    value: function markForReEnumeration() {
      this.needRecalculateMonomersEnumeration = true;
    }
  }, {
    key: "markForRecalculateBegin",
    value: function markForRecalculateBegin() {
      this.needRecalculateMonomersBeginning = true;
    }
  }, {
    key: "addMonomer",
    value: function addMonomer(monomer, callback) {
      var _monomerFactory = monomerFactory(monomer.monomerItem),
        _monomerFactory2 = _slicedToArray__default["default"](_monomerFactory, 2),
        MonomerRenderer = _monomerFactory2[1];
      var monomerRenderer = new MonomerRenderer(monomer);
      this.monomers.set(monomer.id, monomerRenderer);
      monomerRenderer.show(this.theme);
      this.markForReEnumeration();
      this.markForRecalculateBegin();
      if (callback) {
        callback();
      }
    }
  }, {
    key: "moveMonomer",
    value: function moveMonomer(monomer) {
      var _monomer$renderer, _monomer$renderer2;
      (_monomer$renderer = monomer.renderer) === null || _monomer$renderer === void 0 || _monomer$renderer.move();
      (_monomer$renderer2 = monomer.renderer) === null || _monomer$renderer2 === void 0 || _monomer$renderer2.drawSelection();
    }
  }, {
    key: "redrawDrawingEntity",
    value: function redrawDrawingEntity(drawingEntity) {
      var _drawingEntity$baseRe, _drawingEntity$baseRe2;
      (_drawingEntity$baseRe = drawingEntity.baseRenderer) === null || _drawingEntity$baseRe === void 0 || _drawingEntity$baseRe.remove();
      (_drawingEntity$baseRe2 = drawingEntity.baseRenderer) === null || _drawingEntity$baseRe2 === void 0 || _drawingEntity$baseRe2.show(this.theme);
    }
  }, {
    key: "deleteAllDrawingEntities",
    value: function deleteAllDrawingEntities() {
      this.monomers.forEach(function (monomerRenderer) {
        monomerRenderer.remove();
      });
      this.polymerBonds.forEach(function (polymerBondRenderer) {
        polymerBondRenderer.remove();
      });
    }
  }, {
    key: "deleteMonomer",
    value: function deleteMonomer(monomer) {
      var _monomer$renderer3;
      (_monomer$renderer3 = monomer.renderer) === null || _monomer$renderer3 === void 0 || _monomer$renderer3.remove();
      this.monomers["delete"](monomer.id);
      this.markForReEnumeration();
      this.markForRecalculateBegin();
    }
  }, {
    key: "addPolymerBond",
    value: function addPolymerBond(polymerBond) {
      var _polymerBondRenderer$;
      var polymerBondRenderer = new PolymerBondRenderer(polymerBond);
      this.polymerBonds.set(polymerBond.id, polymerBondRenderer);
      polymerBondRenderer.show();
      (_polymerBondRenderer$ = polymerBondRenderer.polymerBond.firstMonomer.renderer) === null || _polymerBondRenderer$ === void 0 || _polymerBondRenderer$.redrawAttachmentPoints();
      this.markForReEnumeration();
      this.markForRecalculateBegin();
    }
  }, {
    key: "movePolymerBond",
    value: function movePolymerBond(polymerBond) {
      var _polymerBond$renderer, _polymerBond$renderer2, _polymerBond$renderer3;
      (_polymerBond$renderer = polymerBond.renderer) === null || _polymerBond$renderer === void 0 || _polymerBond$renderer.moveStart();
      (_polymerBond$renderer2 = polymerBond.renderer) === null || _polymerBond$renderer2 === void 0 || _polymerBond$renderer2.moveEnd();
      (_polymerBond$renderer3 = polymerBond.renderer) === null || _polymerBond$renderer3 === void 0 || _polymerBond$renderer3.drawSelection();
      if (polymerBond.firstMonomer.chosenFirstAttachmentPointForBond) {
        var _polymerBond$firstMon;
        (_polymerBond$firstMon = polymerBond.firstMonomer.renderer) === null || _polymerBond$firstMon === void 0 || _polymerBond$firstMon.redrawAttachmentPointsCoordinates();
      }
    }
  }, {
    key: "showPolymerBondInformation",
    value: function showPolymerBondInformation(polymerBond) {
      var _polymerBond$renderer4, _polymerBond$firstMon2, _polymerBond$firstMon3, _polymerBond$secondMo, _polymerBond$secondMo2;
      (_polymerBond$renderer4 = polymerBond.renderer) === null || _polymerBond$renderer4 === void 0 || _polymerBond$renderer4.redrawHover();
      (_polymerBond$firstMon2 = polymerBond.firstMonomer.renderer) === null || _polymerBond$firstMon2 === void 0 || _polymerBond$firstMon2.redrawAttachmentPoints();
      (_polymerBond$firstMon3 = polymerBond.firstMonomer.renderer) === null || _polymerBond$firstMon3 === void 0 || _polymerBond$firstMon3.redrawHover();
      (_polymerBond$secondMo = polymerBond.secondMonomer) === null || _polymerBond$secondMo === void 0 || (_polymerBond$secondMo = _polymerBond$secondMo.renderer) === null || _polymerBond$secondMo === void 0 || _polymerBond$secondMo.redrawAttachmentPoints();
      (_polymerBond$secondMo2 = polymerBond.secondMonomer) === null || _polymerBond$secondMo2 === void 0 || (_polymerBond$secondMo2 = _polymerBond$secondMo2.renderer) === null || _polymerBond$secondMo2 === void 0 || _polymerBond$secondMo2.redrawHover();
    }
  }, {
    key: "deletePolymerBond",
    value: function deletePolymerBond(polymerBond) {
      var _polymerBond$renderer5, _polymerBond$firstMon4, _polymerBond$firstMon5, _polymerBond$secondMo3, _polymerBond$secondMo4;
      var recalculateEnumeration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var recalculateBeginning = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      (_polymerBond$renderer5 = polymerBond.renderer) === null || _polymerBond$renderer5 === void 0 || _polymerBond$renderer5.remove();
      polymerBond === null || polymerBond === void 0 || (_polymerBond$firstMon4 = polymerBond.firstMonomer) === null || _polymerBond$firstMon4 === void 0 || (_polymerBond$firstMon4 = _polymerBond$firstMon4.renderer) === null || _polymerBond$firstMon4 === void 0 || (_polymerBond$firstMon5 = _polymerBond$firstMon4.redrawAttachmentPoints) === null || _polymerBond$firstMon5 === void 0 || _polymerBond$firstMon5.call(_polymerBond$firstMon4);
      polymerBond === null || polymerBond === void 0 || (_polymerBond$secondMo3 = polymerBond.secondMonomer) === null || _polymerBond$secondMo3 === void 0 || (_polymerBond$secondMo3 = _polymerBond$secondMo3.renderer) === null || _polymerBond$secondMo3 === void 0 || (_polymerBond$secondMo4 = _polymerBond$secondMo3.redrawAttachmentPoints) === null || _polymerBond$secondMo4 === void 0 || _polymerBond$secondMo4.call(_polymerBond$secondMo3);
      this.polymerBonds["delete"](polymerBond.id);
      if (recalculateEnumeration) {
        this.markForReEnumeration();
      }
      if (recalculateBeginning) {
        this.markForRecalculateBegin();
      }
    }
  }, {
    key: "recalculatePeptideChainEnumeration",
    value: function recalculatePeptideChainEnumeration(peptideRenderer) {
      var _currentEnumeration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var currentEnumeration = _currentEnumeration;
      var stack = [{
        monomerRenderer: peptideRenderer
      }];
      while (stack.length > 0) {
        var stackItem = stack.pop();
        assert__default["default"](stackItem);
        var monomerRenderer = stackItem.monomerRenderer;
        monomerRenderer.setEnumeration(currentEnumeration);
        monomerRenderer.redrawEnumeration();
        var nextMonomer = getNextMonomerInChain(monomerRenderer.monomer);
        if (!(nextMonomer instanceof Peptide)) {
          return;
        }
        var isR2R1Connection = checkIsR2R1Connection(monomerRenderer.monomer, nextMonomer);
        if (!isR2R1Connection) {
          return;
        }
        assert__default["default"](nextMonomer.renderer);
        stack.push({
          monomerRenderer: nextMonomer.renderer
        });
        currentEnumeration++;
      }
    }
  }, {
    key: "recalculateRnaChainEnumeration",
    value: function recalculateRnaChainEnumeration(rnaComponentRenderer) {
      var _currentEnumeration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var currentEnumeration = _currentEnumeration;
      var stack = [{
        monomerRenderer: rnaComponentRenderer
      }];
      while (stack.length > 0) {
        var stackItem = stack.pop();
        assert__default["default"](stackItem);
        var monomerRenderer = stackItem.monomerRenderer;
        if (monomerRenderer instanceof SugarRenderer) {
          var rnaBaseMonomer = getRnaBaseFromSugar(monomerRenderer.monomer);
          if (rnaBaseMonomer instanceof RNABase) {
            var _rnaBaseMonomer$rende, _rnaBaseMonomer$rende2;
            (_rnaBaseMonomer$rende = rnaBaseMonomer.renderer) === null || _rnaBaseMonomer$rende === void 0 || _rnaBaseMonomer$rende.setEnumeration(currentEnumeration);
            (_rnaBaseMonomer$rende2 = rnaBaseMonomer.renderer) === null || _rnaBaseMonomer$rende2 === void 0 || _rnaBaseMonomer$rende2.redrawEnumeration();
            currentEnumeration++;
          }
        }
        var nextMonomer = getNextMonomerInChain(monomerRenderer.monomer);
        if (!(nextMonomer instanceof Sugar) && !(nextMonomer instanceof Phosphate)) {
          return;
        }
        var isR2R1Connection = checkIsR2R1Connection(monomerRenderer.monomer, nextMonomer);
        if (!isR2R1Connection || !(nextMonomer.renderer instanceof BaseMonomerRenderer)) {
          return;
        }
        stack.push({
          monomerRenderer: nextMonomer.renderer
        });
      }
    }
  }, {
    key: "recalculatePeptideEnumeration",
    value: function recalculatePeptideEnumeration(peptideRenderer) {
      if (!peptideRenderer.monomer.hasBonds) {
        peptideRenderer.setEnumeration(null);
        peptideRenderer.redrawEnumeration();
      }
      if (!isMonomerBeginningOfChain(peptideRenderer.monomer, [Peptide])) return;
      this.recalculatePeptideChainEnumeration(peptideRenderer);
    }
  }, {
    key: "recalculateRnaEnumeration",
    value: function recalculateRnaEnumeration(rnaComponentRenderer) {
      if (!isMonomerBeginningOfChain(rnaComponentRenderer.monomer, [Phosphate, Sugar])) return;
      this.recalculateRnaChainEnumeration(rnaComponentRenderer);
    }
  }, {
    key: "recalculateMonomersEnumeration",
    value: function recalculateMonomersEnumeration() {
      var _this = this;
      this.monomers.forEach(function (monomerRenderer) {
        if (monomerRenderer instanceof PeptideRenderer) {
          _this.recalculatePeptideEnumeration(monomerRenderer);
        }
        if (monomerRenderer instanceof PhosphateRenderer || monomerRenderer instanceof SugarRenderer) {
          _this.recalculateRnaEnumeration(monomerRenderer);
        }
        if (monomerRenderer instanceof RNABaseRenderer && !monomerRenderer.monomer.isAttachmentPointUsed(exports.AttachmentPointName.R1)) {
          monomerRenderer.setEnumeration(null);
          monomerRenderer.redrawEnumeration();
        }
      });
      this.needRecalculateMonomersEnumeration = false;
    }
  }, {
    key: "isOnlyPartOfRnaChain",
    value: function isOnlyPartOfRnaChain(sugar) {
      var phosphate = getNextMonomerInChain(sugar);
      var nextMonomerAfterPhospate = getNextMonomerInChain(phosphate);
      return !sugar.attachmentPointsToBonds.R1 && !nextMonomerAfterPhospate;
    }
  }, {
    key: "recalculateMonomersBeginning",
    value: function recalculateMonomersBeginning() {
      var _this2 = this;
      this.monomers.forEach(function (monomerRenderer) {
        if (monomerRenderer instanceof PeptideRenderer) {
          if (monomerRenderer.enumeration === 1) {
            monomerRenderer.setBeginning(monomerRenderer.CHAIN_BEGINNING);
          } else {
            monomerRenderer.setBeginning(null);
          }
          monomerRenderer.reDrawChainBeginning();
        }
        if (monomerRenderer instanceof SugarRenderer) {
          var _rnaBaseMonomer$rende3;
          var rnaBaseMonomer = getRnaBaseFromSugar(monomerRenderer.monomer);
          if (rnaBaseMonomer instanceof RNABase && ((_rnaBaseMonomer$rende3 = rnaBaseMonomer.renderer) === null || _rnaBaseMonomer$rende3 === void 0 ? void 0 : _rnaBaseMonomer$rende3.enumeration) === 1 && !_this2.isOnlyPartOfRnaChain(monomerRenderer.monomer)) {
            monomerRenderer.setBeginning(monomerRenderer.CHAIN_BEGINNING);
          } else {
            monomerRenderer.setBeginning(null);
          }
          monomerRenderer.reDrawChainBeginning();
        }
      });
      this.needRecalculateMonomersBeginning = false;
    }
  }, {
    key: "finishPolymerBondCreation",
    value: function finishPolymerBondCreation(polymerBond) {
      var _polymerBond$firstMon6, _polymerBond$firstMon7, _polymerBond$firstMon8, _polymerBond$secondMo5, _polymerBond$secondMo6, _polymerBond$secondMo7, _polymerBond$renderer6;
      assert__default["default"](polymerBond.secondMonomer);
      var polymerBondRenderer = new PolymerBondRenderer(polymerBond);
      this.polymerBonds.set(polymerBond.id, polymerBondRenderer);
      this.markForReEnumeration();
      this.markForRecalculateBegin();
      (_polymerBond$firstMon6 = polymerBond.firstMonomer.renderer) === null || _polymerBond$firstMon6 === void 0 || _polymerBond$firstMon6.redrawAttachmentPoints();
      (_polymerBond$firstMon7 = polymerBond.firstMonomer.renderer) === null || _polymerBond$firstMon7 === void 0 || _polymerBond$firstMon7.drawSelection();
      (_polymerBond$firstMon8 = polymerBond.firstMonomer.renderer) === null || _polymerBond$firstMon8 === void 0 || _polymerBond$firstMon8.redrawHover();
      (_polymerBond$secondMo5 = polymerBond.secondMonomer.renderer) === null || _polymerBond$secondMo5 === void 0 || _polymerBond$secondMo5.redrawAttachmentPoints();
      (_polymerBond$secondMo6 = polymerBond.secondMonomer.renderer) === null || _polymerBond$secondMo6 === void 0 || _polymerBond$secondMo6.drawSelection();
      (_polymerBond$secondMo7 = polymerBond.secondMonomer.renderer) === null || _polymerBond$secondMo7 === void 0 || _polymerBond$secondMo7.redrawHover();
      (_polymerBond$renderer6 = polymerBond.renderer) === null || _polymerBond$renderer6 === void 0 || _polymerBond$renderer6.show();
    }
  }, {
    key: "cancelPolymerBondCreation",
    value: function cancelPolymerBondCreation(polymerBond, secondMonomer) {
      var _polymerBond$firstMon9, _polymerBond$firstMon10, _polymerBond$firstMon11, _secondMonomer$render, _secondMonomer$render2, _secondMonomer$render3;
      this.deletePolymerBond(polymerBond);
      (_polymerBond$firstMon9 = polymerBond.firstMonomer.renderer) === null || _polymerBond$firstMon9 === void 0 || _polymerBond$firstMon9.redrawAttachmentPoints();
      (_polymerBond$firstMon10 = polymerBond.firstMonomer.renderer) === null || _polymerBond$firstMon10 === void 0 || _polymerBond$firstMon10.drawSelection();
      (_polymerBond$firstMon11 = polymerBond.firstMonomer.renderer) === null || _polymerBond$firstMon11 === void 0 || _polymerBond$firstMon11.redrawHover();
      secondMonomer === null || secondMonomer === void 0 || (_secondMonomer$render = secondMonomer.renderer) === null || _secondMonomer$render === void 0 || _secondMonomer$render.redrawAttachmentPoints();
      secondMonomer === null || secondMonomer === void 0 || (_secondMonomer$render2 = secondMonomer.renderer) === null || _secondMonomer$render2 === void 0 || _secondMonomer$render2.drawSelection();
      secondMonomer === null || secondMonomer === void 0 || (_secondMonomer$render3 = secondMonomer.renderer) === null || _secondMonomer$render3 === void 0 || _secondMonomer$render3.redrawHover();
    }
  }, {
    key: "hoverMonomer",
    value: function hoverMonomer(monomer, needRedrawAttachmentPoints) {
      this.hoverDrawingEntity(monomer);
      if (needRedrawAttachmentPoints) {
        var _monomer$renderer4;
        (_monomer$renderer4 = monomer.renderer) === null || _monomer$renderer4 === void 0 || _monomer$renderer4.redrawAttachmentPoints();
      }
    }
  }, {
    key: "hoverAttachmentPoint",
    value: function hoverAttachmentPoint(monomer, attachmentPointName) {
      var _monomer$renderer5, _monomer$renderer6;
      this.hoverDrawingEntity(monomer);
      (_monomer$renderer5 = monomer.renderer) === null || _monomer$renderer5 === void 0 || _monomer$renderer5.hoverAttachmenPoint(attachmentPointName);
      (_monomer$renderer6 = monomer.renderer) === null || _monomer$renderer6 === void 0 || _monomer$renderer6.updateAttachmentPoints();
    }
  }, {
    key: "update",
    value: function update(modelChanges) {
      modelChanges === null || modelChanges === void 0 || modelChanges.execute(this);
      this.runPostRenderMethods();
      notifyRenderComplete();
    }
  }, {
    key: "runPostRenderMethods",
    value: function runPostRenderMethods() {
      if (this.needRecalculateMonomersEnumeration) {
        this.recalculateMonomersEnumeration();
      }
      if (this.needRecalculateMonomersBeginning) {
        this.recalculateMonomersBeginning();
      }
    }
  }]);
  return RenderersManager;
}();

var MonomerAddOperation = function () {
  function MonomerAddOperation(addMonomerChangeModel, deleteMonomerChangeModel, callback) {
    _classCallCheck__default["default"](this, MonomerAddOperation);
    this.addMonomerChangeModel = addMonomerChangeModel;
    this.deleteMonomerChangeModel = deleteMonomerChangeModel;
    this.callback = callback;
    this.monomer = this.addMonomerChangeModel();
  }
  _createClass__default["default"](MonomerAddOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      this.monomer = this.addMonomerChangeModel(this.monomer);
      renderersManager.addMonomer(this.monomer, this.callback);
    }
  }, {
    key: "invert",
    value: function invert(renderersManager) {
      if (this.monomer) {
        this.deleteMonomerChangeModel(this.monomer);
        renderersManager.deleteMonomer(this.monomer);
      }
    }
  }]);
  return MonomerAddOperation;
}();
var MonomerMoveOperation = function () {
  function MonomerMoveOperation(monomerMoveModelChange, invertMonomerMoveModelChange) {
    _classCallCheck__default["default"](this, MonomerMoveOperation);
    this.monomerMoveModelChange = monomerMoveModelChange;
    this.invertMonomerMoveModelChange = invertMonomerMoveModelChange;
    this.monomer = this.monomerMoveModelChange();
  }
  _createClass__default["default"](MonomerMoveOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      this.monomer = this.monomerMoveModelChange();
      renderersManager.moveMonomer(this.monomer);
    }
  }, {
    key: "invert",
    value: function invert(renderersManager) {
      this.monomer = this.invertMonomerMoveModelChange();
      renderersManager.moveMonomer(this.monomer);
    }
  }]);
  return MonomerMoveOperation;
}();
var MonomerHoverOperation = function () {
  function MonomerHoverOperation(peptide, needRedrawAttachmentPoints) {
    _classCallCheck__default["default"](this, MonomerHoverOperation);
    this.peptide = peptide;
    this.needRedrawAttachmentPoints = needRedrawAttachmentPoints;
  }
  _createClass__default["default"](MonomerHoverOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      renderersManager.hoverMonomer(this.peptide, this.needRedrawAttachmentPoints);
    }
  }, {
    key: "invert",
    value: function invert() {}
  }]);
  return MonomerHoverOperation;
}();
var AttachmentPointHoverOperation = function () {
  function AttachmentPointHoverOperation(peptide, attachmentPointName) {
    _classCallCheck__default["default"](this, AttachmentPointHoverOperation);
    this.peptide = peptide;
    this.attachmentPointName = attachmentPointName;
  }
  _createClass__default["default"](AttachmentPointHoverOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      renderersManager.hoverAttachmentPoint(this.peptide, this.attachmentPointName);
    }
  }, {
    key: "invert",
    value: function invert() {}
  }]);
  return AttachmentPointHoverOperation;
}();
var MonomerDeleteOperation = function () {
  function MonomerDeleteOperation(monomer, addMonomerChangeModel, deleteMonomerChangeModel, callback) {
    _classCallCheck__default["default"](this, MonomerDeleteOperation);
    this.addMonomerChangeModel = addMonomerChangeModel;
    this.deleteMonomerChangeModel = deleteMonomerChangeModel;
    this.callback = callback;
    this.monomer = monomer;
  }
  _createClass__default["default"](MonomerDeleteOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      this.deleteMonomerChangeModel(this.monomer);
      renderersManager.deleteMonomer(this.monomer);
    }
  }, {
    key: "invert",
    value: function invert(renderersManager) {
      this.monomer = this.addMonomerChangeModel(this.monomer);
      renderersManager.addMonomer(this.monomer, this.callback);
    }
  }]);
  return MonomerDeleteOperation;
}();

var DrawingEntityHoverOperation = function () {
  function DrawingEntityHoverOperation(drawingEntity) {
    _classCallCheck__default["default"](this, DrawingEntityHoverOperation);
    this.drawingEntity = drawingEntity;
  }
  _createClass__default["default"](DrawingEntityHoverOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      renderersManager.hoverDrawingEntity(this.drawingEntity);
    }
  }, {
    key: "invert",
    value: function invert() {}
  }]);
  return DrawingEntityHoverOperation;
}();
var DrawingEntitySelectOperation = function () {
  function DrawingEntitySelectOperation(drawingEntity) {
    _classCallCheck__default["default"](this, DrawingEntitySelectOperation);
    this.drawingEntity = drawingEntity;
  }
  _createClass__default["default"](DrawingEntitySelectOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      renderersManager.selectDrawingEntity(this.drawingEntity);
    }
  }, {
    key: "invert",
    value: function invert() {}
  }]);
  return DrawingEntitySelectOperation;
}();
var DrawingEntityMoveOperation = function () {
  function DrawingEntityMoveOperation(moveDrawingEntityChangeModel, invertMoveDrawingEntityChangeModel, redoDrawingEntityChangeModel, drawingEntity) {
    _classCallCheck__default["default"](this, DrawingEntityMoveOperation);
    _defineProperty__default["default"](this, "wasInverted", false);
    this.moveDrawingEntityChangeModel = moveDrawingEntityChangeModel;
    this.invertMoveDrawingEntityChangeModel = invertMoveDrawingEntityChangeModel;
    this.redoDrawingEntityChangeModel = redoDrawingEntityChangeModel;
    this.drawingEntity = drawingEntity;
  }
  _createClass__default["default"](DrawingEntityMoveOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      this.wasInverted ? this.redoDrawingEntityChangeModel() : this.moveDrawingEntityChangeModel();
      renderersManager.moveDrawingEntity(this.drawingEntity);
    }
  }, {
    key: "invert",
    value: function invert(renderersManager) {
      this.invertMoveDrawingEntityChangeModel();
      renderersManager.moveDrawingEntity(this.drawingEntity);
      this.wasInverted = true;
    }
  }]);
  return DrawingEntityMoveOperation;
}();
var DrawingEntityRedrawOperation = function () {
  function DrawingEntityRedrawOperation(drawingEntityRedrawModelChange, invertDrawingEntityRedrawModelChange) {
    _classCallCheck__default["default"](this, DrawingEntityRedrawOperation);
    this.drawingEntityRedrawModelChange = drawingEntityRedrawModelChange;
    this.invertDrawingEntityRedrawModelChange = invertDrawingEntityRedrawModelChange;
  }
  _createClass__default["default"](DrawingEntityRedrawOperation, [{
    key: "execute",
    value: function execute(renderersManager) {
      var drawingEntity = this.drawingEntityRedrawModelChange();
      renderersManager.redrawDrawingEntity(drawingEntity);
    }
  }, {
    key: "invert",
    value: function invert(renderersManager) {
      var drawingEntity = this.invertDrawingEntityRedrawModelChange();
      renderersManager.redrawDrawingEntity(drawingEntity);
    }
  }]);
  return DrawingEntityRedrawOperation;
}();

exports.ChemicalMimeType = void 0;
(function (ChemicalMimeType) {
  ChemicalMimeType["Mol"] = "chemical/x-mdl-molfile";
  ChemicalMimeType["Rxn"] = "chemical/x-mdl-rxnfile";
  ChemicalMimeType["DaylightSmiles"] = "chemical/x-daylight-smiles";
  ChemicalMimeType["ExtendedSmiles"] = "chemical/x-chemaxon-cxsmiles";
  ChemicalMimeType["DaylightSmarts"] = "chemical/x-daylight-smarts";
  ChemicalMimeType["InChI"] = "chemical/x-inchi";
  ChemicalMimeType["InChIAuxInfo"] = "chemical/x-inchi-aux";
  ChemicalMimeType["InChIKey"] = "chemical/x-inchi-key";
  ChemicalMimeType["CDX"] = "chemical/x-cdx";
  ChemicalMimeType["CDXML"] = "chemical/x-cdxml";
  ChemicalMimeType["CML"] = "chemical/x-cml";
  ChemicalMimeType["KET"] = "chemical/x-indigo-ket";
  ChemicalMimeType["UNKNOWN"] = "chemical/x-unknown";
  ChemicalMimeType["SDF"] = "chemical/x-sdf";
  ChemicalMimeType["FASTA"] = "chemical/x-fasta";
  ChemicalMimeType["SEQUENCE"] = "chemical/x-sequence";
})(exports.ChemicalMimeType || (exports.ChemicalMimeType = {}));

var SupportedFormatProperties = _createClass__default["default"](function SupportedFormatProperties(name, mime, extensions, supportsCoords, options) {
  _classCallCheck__default["default"](this, SupportedFormatProperties);
  this.name = name;
  this.mime = mime;
  this.extensions = extensions;
  this.supportsCoords = supportsCoords || false;
  this.options = options || {};
});

var formatProperties = {
  molAuto: new SupportedFormatProperties(
  'MDL Molfile Auto Format detect', exports.ChemicalMimeType.Mol, ['.mol'], true, {
    'molfile-saving-mode': 'auto'
  }),
  mol: new SupportedFormatProperties('MDL Molfile V2000', exports.ChemicalMimeType.Mol, ['.mol'], true),
  molV3000: new SupportedFormatProperties('MDL Molfile V3000', exports.ChemicalMimeType.Mol, ['.mol'], true, {
    'molfile-saving-mode': '3000'
  }),
  rxn: new SupportedFormatProperties('MDL Rxnfile V2000', exports.ChemicalMimeType.Rxn, ['.rxn'], true),
  rxnV3000: new SupportedFormatProperties('MDL Rxnfile V3000', exports.ChemicalMimeType.Rxn, ['.rxn'], true, {
    'molfile-saving-mode': '3000'
  }),
  smiles: new SupportedFormatProperties('Daylight SMILES', exports.ChemicalMimeType.DaylightSmiles, ['.smi', '.smiles'], true),
  smilesExt: new SupportedFormatProperties('Extended SMILES', exports.ChemicalMimeType.ExtendedSmiles, ['.cxsmi', '.cxsmiles']),
  smarts: new SupportedFormatProperties('Daylight SMARTS', exports.ChemicalMimeType.DaylightSmarts, ['.smarts']),
  inChI: new SupportedFormatProperties('InChI', exports.ChemicalMimeType.InChI, ['.inchi']),
  inChIAuxInfo: new SupportedFormatProperties('InChI AuxInfo', exports.ChemicalMimeType.InChIAuxInfo, ['.inchi']),
  inChIKey: new SupportedFormatProperties('InChIKey', exports.ChemicalMimeType.InChIKey, ['.inchikey']),
  cml: new SupportedFormatProperties('CML', exports.ChemicalMimeType.CML, ['.cml', '.mrv'], true),
  ket: new SupportedFormatProperties('Ket Format', exports.ChemicalMimeType.KET, ['.ket']),
  cdxml: new SupportedFormatProperties('CDXML', exports.ChemicalMimeType.CDXML, ['.cdxml'], true),
  cdx: new SupportedFormatProperties('Base64 CDX', exports.ChemicalMimeType.CDX, ['.b64cdx'], true),
  binaryCdx: new SupportedFormatProperties('CDX', exports.ChemicalMimeType.CDX, ['.cdx'], true),
  sdf: new SupportedFormatProperties('SDF V2000', exports.ChemicalMimeType.SDF, ['.sdf'], true),
  sdfV3000: new SupportedFormatProperties('SDF V3000', exports.ChemicalMimeType.SDF, ['.sdf'], true, {
    'molfile-saving-mode': '3000'
  }),
  fasta: new SupportedFormatProperties('FASTA', exports.ChemicalMimeType.FASTA, ['.fasta'], true),
  sequence: new SupportedFormatProperties('SEQUENCE', exports.ChemicalMimeType.SEQUENCE, ['.seq'], false, {}),
  unknown: new SupportedFormatProperties('Unknown', exports.ChemicalMimeType.UNKNOWN, ['.'], true)
};
var imgFormatProperties = {
  svg: {
    extension: '.svg',
    name: 'SVG Document'
  },
  png: {
    extension: '.png',
    name: 'PNG Image'
  }
};
function getPropertiesByImgFormat(format) {
  return imgFormatProperties[format];
}
function getPropertiesByFormat(format) {
  return formatProperties[format];
}
function getFormatMimeTypeByFileName(fileName) {
  var fileExtension = '.' + fileName.split('.').pop();
  var format = Object.values(formatProperties).find(function (properties) {
    return properties.extensions.includes(fileExtension);
  });
  return format === null || format === void 0 ? void 0 : format.mime;
}

exports.SupportedFormat = void 0;
(function (SupportedFormat) {
  SupportedFormat["mol"] = "mol";
  SupportedFormat["molV3000"] = "molV3000";
  SupportedFormat["molAuto"] = "molAuto";
  SupportedFormat["rxn"] = "rxn";
  SupportedFormat["rxnV3000"] = "rxnV3000";
  SupportedFormat["smiles"] = "smiles";
  SupportedFormat["smilesExt"] = "smilesExt";
  SupportedFormat["smarts"] = "smarts";
  SupportedFormat["inChI"] = "inChI";
  SupportedFormat["inChIAuxInfo"] = "inChIAuxInfo";
  SupportedFormat["inChIKey"] = "inChIKey";
  SupportedFormat["cml"] = "cml";
  SupportedFormat["ket"] = "ket";
  SupportedFormat["cdxml"] = "cdxml";
  SupportedFormat["cdx"] = "cdx";
  SupportedFormat["binaryCdx"] = "binaryCdx";
  SupportedFormat["sdf"] = "sdf";
  SupportedFormat["sdfV3000"] = "sdfV3000";
  SupportedFormat["fasta"] = "fasta";
  SupportedFormat["sequence"] = "sequence";
  SupportedFormat["unknown"] = "unknown";
})(exports.SupportedFormat || (exports.SupportedFormat = {}));

var customizer = function customizer(value) {
  if (_typeof__default["default"](value) === 'object' && value.y) {
    var clonedValue = _.cloneDeep(value);
    clonedValue.y = -clonedValue.y;
    return clonedValue;
  }
};
var getNodeWithInvertedYCoord = function getNodeWithInvertedYCoord(node) {
  return _.cloneDeepWith(node, customizer);
};
var setMonomerTemplatePrefix = function setMonomerTemplatePrefix(templateName) {
  return "monomerTemplate-".concat(templateName);
};
var setMonomerPrefix = function setMonomerPrefix(monomerId) {
  return "monomer".concat(monomerId);
};
var getKetRef = function getKetRef(entityId) {
  return {
    $ref: entityId
  };
};
var rotateCoordAxisBy180Degrees = function rotateCoordAxisBy180Degrees(position, axis) {
  var rotatedPosition = {
    x: position.x,
    y: position.y
  };
  rotatedPosition[axis] = -rotatedPosition[axis];
  return new Vec2(rotatedPosition.x, rotatedPosition.y);
};
var switchIntoChemistryCoordSystem = function switchIntoChemistryCoordSystem(position) {
  return rotateCoordAxisBy180Degrees(position, exports.Axis.y);
};
var populateStructWithSelection = function populateStructWithSelection(populatedStruct, selection) {
  if (!selection) {
    return populatedStruct;
  }
  Object.keys(selection).forEach(function (entity) {
    var _populatedStruct$enti;
    var selectedEntities = selection[entity];
    (_populatedStruct$enti = populatedStruct[entity]) === null || _populatedStruct$enti === void 0 || _populatedStruct$enti.forEach(function (value, key) {
      if (typeof value.setInitiallySelected === 'function') {
        value.setInitiallySelected(selectedEntities.includes(key) || undefined);
      }
    });
  });
  return populatedStruct;
};

function arrowToKet(arrowNode) {
  return {
    type: 'arrow',
    data: getNodeWithInvertedYCoord(arrowNode.data),
    selected: arrowNode.selected
  };
}
function plusToKet(plusNode) {
  var coord = plusNode.center;
  return {
    type: 'plus',
    location: [coord.x, -coord.y, coord.z],
    prop: plusNode.data,
    selected: plusNode.selected
  };
}

function headerToKet(struct) {
  var header = {};
  ifDef(header, 'moleculeName', struct.name, '');
  ifDef(header, 'creatorProgram', null, '');
  ifDef(header, 'comment', null, '');
  return Object.keys(header).length !== 0 ? header : null;
}

function ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function fromRlabel(rg) {
  var res = [];
  var rgi;
  var val;
  for (rgi = 0; rgi < 32; rgi++) {
    if (rg & 1 << rgi) {
      val = rgi + 1;
      res.push(val);
    }
  }
  return res;
}
function moleculeToKet(struct, monomer) {
  var body = {
    atoms: Array.from(struct.atoms.values()).map(function (atom) {
      if (atom.label === 'R#' && !monomer) return rglabelToKet(atom);
      return atomToKet(atom, monomer);
    })
  };
  if (struct.bonds.size !== 0) {
    body.bonds = Array.from(struct.bonds.values()).map(bondToKet);
  }
  if (struct.sgroups.size !== 0) {
    body.sgroups = Array.from(struct.sgroups.values()).map(function (sGroup) {
      return sgroupToKet(struct, sGroup);
    });
  }
  var fragment = struct.frags.get(0);
  if (fragment) {
    ifDef(body, 'stereoFlagPosition', fragment.stereoFlagPosition, null);
    if (fragment.properties) {
      body.properties = fragment.properties;
    }
  }
  return _objectSpread$e({
    type: 'molecule'
  }, body);
}
function atomToKet(source, monomer) {
  var result = {};
  if (source.label !== 'L#') {
    var _monomer$monomerItem$;
    ifDef(result, 'label', source.label === 'R#' && monomer ? (_monomer$monomerItem$ = monomer.monomerItem.props.MonomerCaps) === null || _monomer$monomerItem$ === void 0 ? void 0 : _monomer$monomerItem$[convertAttachmentPointNumberToLabel(source.rglabel)] : source.label);
    ifDef(result, 'mapping', parseInt(source.aam), 0);
  } else if (source.atomList) {
    result.type = 'atom-list';
    ifDef(result, 'elements', source.atomList.labelList());
    ifDef(result, 'notList', source.atomList.notList, false);
  }
  ifDef(result, 'alias', source.alias);
  var position = switchIntoChemistryCoordSystem(new Vec2(source.pp.x, source.pp.y, source.pp.z));
  ifDef(result, 'location', [position.x, position.y, position.z]);
  ifDef(result, 'charge', source.charge);
  ifDef(result, 'explicitValence', source.explicitValence, -1);
  ifDef(result, 'isotope', source.isotope);
  ifDef(result, 'radical', source.radical, 0);
  ifDef(result, 'attachmentPoints', source.attachmentPoints, 0);
  ifDef(result, 'cip', source.cip, '');
  ifDef(result, 'selected', source.getInitiallySelected());
  ifDef(result, 'stereoLabel', source.stereoLabel, null);
  ifDef(result, 'stereoParity', source.stereoCare, 0);
  ifDef(result, 'weight', source.weight, 0);
  ifDef(result, 'ringBondCount', source.ringBondCount, 0);
  ifDef(result, 'substitutionCount', source.substitutionCount, 0);
  ifDef(result, 'unsaturatedAtom', !!source.unsaturatedAtom, false);
  ifDef(result, 'hCount', source.hCount, 0);
  if (Object.values(source.queryProperties).some(function (property) {
    return property !== null;
  })) {
    result.queryProperties = {};
    Object.keys(source.queryProperties).forEach(function (name) {
      ifDef(result.queryProperties, name, source.queryProperties[name]);
    });
  }
  ifDef(result, 'invRet', source.invRet, 0);
  ifDef(result, 'exactChangeFlag', !!source.exactChangeFlag, false);
  ifDef(result, 'implicitHCount', source.implicitHCount);
  return result;
}
function rglabelToKet(source) {
  var result = {
    type: 'rg-label'
  };
  var position = switchIntoChemistryCoordSystem(new Vec2(source.pp.x, source.pp.y, source.pp.z));
  ifDef(result, 'location', [position.x, position.y, position.z]);
  ifDef(result, 'attachmentPoints', source.attachmentPoints, 0);
  var refsToRGroups = fromRlabel(source.rglabel).map(function (rgnumber) {
    return "rg-".concat(rgnumber);
  });
  ifDef(result, '$refs', refsToRGroups);
  ifDef(result, 'selected', source.getInitiallySelected());
  return result;
}
function bondToKet(source) {
  var result = {};
  if (source.customQuery) {
    ifDef(result, 'atoms', [source.begin, source.end]);
    ifDef(result, 'customQuery', source.customQuery);
  } else {
    ifDef(result, 'type', source.type);
    ifDef(result, 'atoms', [source.begin, source.end]);
    ifDef(result, 'stereo', source.stereo, 0);
    ifDef(result, 'topology', source.topology, 0);
    ifDef(result, 'center', source.reactingCenterStatus, 0);
    ifDef(result, 'cip', source.cip, '');
  }
  ifDef(result, 'selected', source.getInitiallySelected());
  return result;
}
function sgroupToKet(struct, source) {
  var result = {};
  ifDef(result, 'type', source.type);
  ifDef(result, 'atoms', source.atoms);
  switch (source.type) {
    case 'GEN':
      break;
    case 'MUL':
      {
        ifDef(result, 'mul', source.data.mul || 1);
        break;
      }
    case 'queryComponent':
      {
        break;
      }
    case 'SRU':
      {
        ifDef(result, 'subscript', source.data.subscript || 'n');
        ifDef(result, 'connectivity', source.data.connectivity.toUpperCase() || 'ht');
        break;
      }
    case 'SUP':
      {
        ifDef(result, 'name', source.data.name || '');
        ifDef(result, 'expanded', source.data.expanded);
        ifDef(result, 'id', source.id);
        ifDef(result, 'attachmentPoints', source.getAttachmentPoints().map(sgroupAttachmentPointToKet), []);
        break;
      }
    case 'DAT':
      {
        var data = source.data;
        ifDef(result, 'placement', data.absolute, true);
        ifDef(result, 'display', data.attached, false);
        ifDef(result, 'context', data.context);
        ifDef(result, 'fieldName', data.fieldName);
        ifDef(result, 'fieldData', data.fieldValue);
        ifDef(result, 'bonds', SGroup.getBonds(struct, source));
        break;
      }
  }
  return result;
}
function sgroupAttachmentPointToKet(source) {
  var result = {};
  ifDef(result, 'attachmentAtom', source.atomId);
  ifDef(result, 'leavingAtom', source.leaveAtomId);
  ifDef(result, 'attachmentId', source.attachmentId);
  return result;
}

function mergeFragmentsToStruct(ketItem, struct) {
  var atomsOffset = 0;
  if (ketItem.fragments) {
    ketItem.fragments.forEach(function (fragment) {
      var _fragment$atoms, _fragment$bonds, _fragment$atoms2;
      (_fragment$atoms = fragment.atoms) === null || _fragment$atoms === void 0 || _fragment$atoms.forEach(function (atom) {
        return struct.atoms.add(atomToStruct(atom));
      });
      (_fragment$bonds = fragment.bonds) === null || _fragment$bonds === void 0 || _fragment$bonds.forEach(function (bond) {
        return struct.bonds.add(bondToStruct(bond, atomsOffset));
      });
      atomsOffset += ((_fragment$atoms2 = fragment.atoms) === null || _fragment$atoms2 === void 0 ? void 0 : _fragment$atoms2.length) || 0;
    });
  }
  return struct;
}

function toRlabel(values) {
  var res = 0;
  values.forEach(function (val) {
    var rgi = val - 1;
    res |= 1 << rgi;
  });
  return res;
}
function moleculeToStruct(ketItem) {
  var struct = mergeFragmentsToStruct(ketItem, new Struct());
  if (ketItem.atoms) {
    ketItem.atoms.forEach(function (atom) {
      var atomId = null;
      if (atom.type === 'rg-label') {
        atomId = struct.atoms.add(rglabelToStruct(atom));
      }
      if (!atom.type || atom.type === 'atom-list') {
        atomId = struct.atoms.add(atomToStruct(atom));
      }
      if (atomId !== null) {
        addRGroupAttachmentPointsToStruct(struct, atomId, atom.attachmentPoints, atom.selected);
      }
    });
  }
  if (ketItem.bonds) {
    ketItem.bonds.forEach(function (bond) {
      return struct.bonds.add(bondToStruct(bond));
    });
  }
  if (ketItem.sgroups) {
    ketItem.sgroups.forEach(function (sgroupData) {
      var sgroup = sgroupToStruct(sgroupData);
      var id = struct.sgroups.add(sgroup);
      sgroup.id = id;
    });
  }
  struct.initHalfBonds();
  struct.initNeighbors();
  struct.markFragments(ketItem.properties);
  struct.bindSGroupsToFunctionalGroups();
  return struct;
}
function atomToStruct(source) {
  var params = {};
  var queryAttribute = ['aromaticity', 'ringMembership', 'connectivity', 'ringSize', 'chirality', 'customQuery'];
  if (source.type === 'atom-list') {
    params.label = 'L#';
    var ids = source.elements.map(function (el) {
      var _Elements$get;
      return (_Elements$get = Elements.get(el)) === null || _Elements$get === void 0 ? void 0 : _Elements$get.number;
    }).filter(function (id) {
      return id;
    });
    ifDef(params, 'atomList', {
      ids: ids,
      notList: source.notList
    });
  } else {
    ifDef(params, 'label', source.label);
    ifDef(params, 'aam', source.mapping);
  }
  ifDef(params, 'alias', source.alias);
  ifDef(params, 'pp', {
    x: source.location[0],
    y: -source.location[1],
    z: source.location[2] || 0.0
  });
  ifDef(params, 'charge', source.charge);
  ifDef(params, 'explicitValence', source.explicitValence);
  ifDef(params, 'isotope', source.isotope);
  ifDef(params, 'radical', source.radical);
  ifDef(params, 'cip', source.cip);
  ifDef(params, 'attachmentPoints', source.attachmentPoints);
  ifDef(params, 'stereoLabel', source.stereoLabel);
  ifDef(params, 'stereoParity', source.stereoParity);
  ifDef(params, 'weight', source.weight);
  ifDef(params, 'ringBondCount', source.ringBondCount);
  ifDef(params, 'substitutionCount', source.substitutionCount);
  ifDef(params, 'unsaturatedAtom', Number(Boolean(source.unsaturatedAtom)));
  ifDef(params, 'hCount', source.hCount);
  if (source.queryProperties && Object.values(source.queryProperties).some(function (property) {
    return property !== null;
  })) {
    params.queryProperties = {};
    queryAttribute.forEach(function (attributeName) {
      ifDef(params.queryProperties, attributeName, source.queryProperties[attributeName]);
    });
  }
  ifDef(params, 'invRet', source.invRet);
  ifDef(params, 'exactChangeFlag', Number(Boolean(source.exactChangeFlag)));
  ifDef(params, 'implicitHCount', source.implicitHCount);
  var newAtom = new Atom(params);
  newAtom.setInitiallySelected(source.selected);
  return newAtom;
}
function rglabelToStruct(source) {
  var _source$$refs$map, _source$$refs;
  var params = {};
  params.label = 'R#';
  ifDef(params, 'pp', {
    x: source.location[0],
    y: -source.location[1],
    z: source.location[2] || 0.0
  });
  ifDef(params, 'attachmentPoints', source.attachmentPoints);
  var rglabel = toRlabel((_source$$refs$map = (_source$$refs = source.$refs) === null || _source$$refs === void 0 ? void 0 : _source$$refs.map(function (el) {
    return parseInt(el.slice(3));
  })) !== null && _source$$refs$map !== void 0 ? _source$$refs$map : []);
  ifDef(params, 'rglabel', rglabel);
  var newAtom = new Atom(params);
  newAtom.setInitiallySelected(source.selected);
  return newAtom;
}
function addRGroupAttachmentPointsToStruct(struct, attachedAtomId, attachmentPoints, initiallySelected) {
  var rgroupAttachmentPoints = [];
  if (attachmentPoints === exports.AttachmentPoints.FirstSideOnly) {
    rgroupAttachmentPoints.push(new RGroupAttachmentPoint(attachedAtomId, 'primary', initiallySelected));
  } else if (attachmentPoints === exports.AttachmentPoints.SecondSideOnly) {
    rgroupAttachmentPoints.push(new RGroupAttachmentPoint(attachedAtomId, 'secondary', initiallySelected));
  } else if (attachmentPoints === exports.AttachmentPoints.BothSides) {
    rgroupAttachmentPoints.push(new RGroupAttachmentPoint(attachedAtomId, 'primary', initiallySelected));
    rgroupAttachmentPoints.push(new RGroupAttachmentPoint(attachedAtomId, 'secondary', initiallySelected));
  }
  rgroupAttachmentPoints.forEach(function (rgroupAttachmentPoint) {
    struct.rgroupAttachmentPoints.add(rgroupAttachmentPoint);
  });
}
function bondToStruct(source) {
  var atomOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var params = {};
  ifDef(params, 'type', source.type);
  ifDef(params, 'topology', source.topology);
  ifDef(params, 'reactingCenterStatus', source.center);
  ifDef(params, 'stereo', source.stereo);
  ifDef(params, 'cip', source.cip);
  ifDef(params, 'customQuery', source.customQuery);
  ifDef(params, 'begin', source.atoms[0] + atomOffset);
  ifDef(params, 'end', source.atoms[1] + atomOffset);
  ifDef(params, 'initiallySelected', source.selected);
  var newBond = new Bond(params);
  newBond.setInitiallySelected(source.selected);
  return newBond;
}
function sgroupToStruct(source) {
  var sgroup = new SGroup(source.type);
  ifDef(sgroup, 'atoms', source.atoms);
  switch (source.type) {
    case 'GEN':
      break;
    case 'MUL':
      {
        ifDef(sgroup.data, 'mul', source.mul);
        break;
      }
    case 'SRU':
      {
        ifDef(sgroup.data, 'subscript', source.subscript);
        ifDef(sgroup.data, 'connectivity', source.connectivity.toLowerCase());
        break;
      }
    case 'SUP':
      {
        var _source$attachmentPoi;
        ifDef(sgroup.data, 'name', source.name);
        ifDef(sgroup.data, 'expanded', source.expanded);
        ifDef(sgroup, 'id', source.id);
        (_source$attachmentPoi = source.attachmentPoints) === null || _source$attachmentPoi === void 0 || _source$attachmentPoi.forEach(function (sourceAttachmentPoint) {
          sgroup.addAttachmentPoint(sgroupAttachmentPointToStruct(sourceAttachmentPoint));
        });
        break;
      }
    case 'DAT':
      {
        ifDef(sgroup.data, 'absolute', source.placement);
        ifDef(sgroup.data, 'attached', source.display);
        ifDef(sgroup.data, 'context', source.context);
        ifDef(sgroup.data, 'fieldName', source.fieldName);
        ifDef(sgroup.data, 'fieldValue', source.fieldData);
        break;
      }
  }
  return sgroup;
}
function sgroupAttachmentPointToStruct(source) {
  var atomId = source.attachmentAtom;
  var leavingAtomId = source.leavingAtom;
  var attachmentId = source.attachmentId;
  return new SGroupAttachmentPoint(atomId, leavingAtomId, attachmentId);
}

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }
function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function prepareStructForKet(struct) {
  var ketNodes = [];
  var rgFrags = new Set();
  var _iterator = _createForOfIteratorHelper$3(struct.rgroups.entries()),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray__default["default"](_step.value, 2),
        rgnumber = _step$value[0],
        rgroup = _step$value[1];
      rgroup.frags.forEach(function (frid) {
        return rgFrags.add(frid);
      });
      var fragsAtoms = Array.from(rgroup.frags.values()).reduce(function (res, frid) {
        return res.union(struct.getFragmentIds(frid));
      }, new Pile());
      ketNodes.push({
        type: 'rgroup',
        fragment: struct.clone(fragsAtoms),
        center: getFragmentCenter(struct, fragsAtoms),
        data: {
          rgnumber: rgnumber,
          rgroup: rgroup
        }
      });
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var filteredFragmentIds = Array.from(struct.frags.keys()).filter(function (fid) {
    return !rgFrags.has(fid);
  });
  addMolecules(ketNodes, filteredFragmentIds, struct);
  struct.rxnArrows.forEach(function (item) {
    ketNodes.push({
      type: 'arrow',
      center: item.pos[0],
      data: {
        mode: item.mode,
        pos: item.pos,
        height: item.height
      },
      selected: item.getInitiallySelected()
    });
  });
  struct.rxnPluses.forEach(function (item) {
    ketNodes.push({
      type: 'plus',
      center: item.pp,
      data: {},
      selected: item.getInitiallySelected()
    });
  });
  struct.simpleObjects.forEach(function (item) {
    ketNodes.push({
      type: 'simpleObject',
      center: item.pos[0],
      data: {
        mode: item.mode,
        pos: item.pos
      },
      selected: item.getInitiallySelected()
    });
  });
  struct.texts.forEach(function (item) {
    ketNodes.push({
      type: 'text',
      center: item.position,
      data: {
        content: item.content,
        position: item.position,
        pos: item.pos
      },
      selected: item.getInitiallySelected()
    });
  });
  ketNodes.forEach(function (ketNode) {
    if (ketNode.fragment) {
      var sgroups = Array.from(ketNode.fragment.sgroups.values());
      var filteredSGroups = sgroups.filter(function (sg) {
        return sg.atoms.every(function (atom) {
          return atom !== undefined;
        });
      });
      var filteredSGroupsMap = new Pool();
      filteredSGroups.forEach(function (sg, index) {
        filteredSGroupsMap.set(index, sg);
      });
      ketNode.fragment.sgroups = filteredSGroupsMap;
    }
  });
  return ketNodes;
}
function getFragmentCenter(struct, atomSet) {
  var bb = struct.getCoordBoundingBox(atomSet);
  return Vec2.centre(bb.min, bb.max);
}
function addMolecules(ketNodes, fragmentIds, struct) {
  var sGroupFragmentsMap = generateSGroupFragmentsMap(ketNodes, fragmentIds, struct);
  var mergedFragments = Pile.unionIntersections(Array.from(sGroupFragmentsMap.values()));
  mergedFragments.forEach(function (fragments) {
    var atomSet = new Pile();
    fragments.forEach(function (fragmentId) {
      atomSet = atomSet.union(struct.getFragmentIds(fragmentId));
    });
    ketNodes.push({
      type: 'molecule',
      fragment: struct.clone(atomSet),
      center: getFragmentCenter(struct, atomSet)
    });
  });
}
function generateSGroupFragmentsMap(ketNodes, fragmentIds, struct) {
  var sGroupFragmentsMap = new Map();
  fragmentIds.forEach(function (fragmentId) {
    var atomsInFragment = struct.getFragmentIds(fragmentId);
    var hasAtomInSGroup = false;
    atomsInFragment.forEach(function (atomId) {
      var _struct$atoms$get;
      (_struct$atoms$get = struct.atoms.get(atomId)) === null || _struct$atoms$get === void 0 || _struct$atoms$get.sgs.forEach(function (sGroupId) {
        hasAtomInSGroup = true;
        var fragmentSet = sGroupFragmentsMap.get(sGroupId);
        if (fragmentSet) {
          fragmentSet.add(fragmentId);
        } else {
          sGroupFragmentsMap.set(sGroupId, new Pile([fragmentId]));
        }
      });
    });
    if (!hasAtomInSGroup) {
      ketNodes.push({
        type: 'molecule',
        fragment: struct.clone(atomsInFragment),
        center: getFragmentCenter(struct, atomsInFragment)
      });
    }
  });
  return sGroupFragmentsMap;
}

function ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function rgroupToKet(struct, data) {
  var body = _objectSpread$d({
    rlogic: rgroupLogicToKet(data.rgnumber, data.rgroup)
  }, moleculeToKet(struct));
  return _objectSpread$d(_objectSpread$d({}, body), {}, {
    type: 'rgroup'
  });
}
function rgroupLogicToKet(rgnumber, rglogic) {
  var result = {};
  ifDef(result, 'number', rgnumber);
  ifDef(result, 'range', rglogic.range, '');
  ifDef(result, 'resth', rglogic.resth, false);
  ifDef(result, 'ifthen', rglogic.ifthen, 0);
  return result;
}

function rgroupToStruct(ketItem) {
  var struct = moleculeToStruct(ketItem);
  var rgroup = rgroupLogicToStruct(ketItem.rlogic);
  struct.frags.forEach(function (_value, key) {
    rgroup.frags.add(key);
  });
  if (ketItem.rlogic) struct.rgroups.set(ketItem.rlogic.number, rgroup);
  return struct;
}
function rgroupLogicToStruct(rglogic) {
  var params = {};
  ifDef(params, 'range', rglogic.range);
  ifDef(params, 'resth', rglogic.resth);
  ifDef(params, 'ifthen', rglogic.ifthen);
  return new RGroup(params);
}

function rxnToStruct(ketItem, struct) {
  if (ketItem.type === 'arrow') {
    var arrow = new RxnArrow(getNodeWithInvertedYCoord(ketItem.data));
    arrow.setInitiallySelected(ketItem.selected);
    struct.rxnArrows.add(arrow);
  } else {
    var plus = new RxnPlus({
      pp: {
        x: ketItem.location[0],
        y: -ketItem.location[1],
        z: ketItem.location[2]
      }
    });
    plus.setInitiallySelected(ketItem.selected);
    struct.rxnPluses.add(plus);
  }
  return struct;
}

function simpleObjectToKet(simpleObjectNode) {
  return {
    type: 'simpleObject',
    data: getNodeWithInvertedYCoord(simpleObjectNode.data),
    selected: simpleObjectNode.selected
  };
}

function simpleObjectToStruct(ketItem, struct) {
  var object = ketItem.data.mode === 'circle' ? circleToEllipse(ketItem) : ketItem.data;
  var simpleObject = new SimpleObject(getNodeWithInvertedYCoord(object));
  simpleObject.setInitiallySelected(ketItem.selected);
  struct.simpleObjects.add(simpleObject);
  return struct;
}
function circleToEllipse(ketItem) {
  var radius = Vec2.dist(ketItem.data.pos[1], ketItem.data.pos[0]);
  var pos0 = ketItem.data.pos[0];
  return {
    mode: exports.SimpleObjectMode.ellipse,
    pos: [{
      x: pos0.x - Math.abs(radius),
      y: pos0.y - Math.abs(radius),
      z: pos0.z - Math.abs(radius)
    }, {
      x: pos0.x + Math.abs(radius),
      y: pos0.y + Math.abs(radius),
      z: pos0.z + Math.abs(radius)
    }]
  };
}

function textToKet(textNode) {
  return {
    type: 'text',
    data: getNodeWithInvertedYCoord(textNode.data),
    selected: textNode.selected
  };
}

function textToStruct(ketItem, struct) {
  var text = new Text(getNodeWithInvertedYCoord(ketItem.data));
  text.setInitiallySelected(ketItem.selected);
  struct.texts.add(text);
  return struct;
}

function monomerToDrawingEntity(node, template, struct, drawingEntitiesManager) {
  var position = switchIntoChemistryCoordSystem(new Vec2(node.position.x, node.position.y));
  return drawingEntitiesManager.addMonomer({
    struct: struct,
    label: template.alias || template.id,
    colorScheme: undefined,
    favorite: false,
    props: {
      id: template.id,
      Name: template.fullName || template.name || template.alias || template.id,
      MonomerNaturalAnalogCode: template.naturalAnalogShort,
      MonomerName: template.fullName || template.name || template.alias || template.id,
      MonomerFullName: template.fullName,
      MonomerType: template.classHELM,
      MonomerClass: template["class"],
      MonomerCaps: {}
    },
    attachmentPoints: template.attachmentPoints,
    seqId: node.seqid
  }, position);
}

function polymerBondToDrawingEntity(connection, drawingEntitiesManager, monomerIdsMap) {
  var command = new Command();
  assert__default["default"](connection.endpoint1.monomerId);
  assert__default["default"](connection.endpoint2.monomerId);
  var firstMonomer = drawingEntitiesManager.monomers.get(Number(monomerIdsMap[connection.endpoint1.monomerId]));
  var secondMonomer = drawingEntitiesManager.monomers.get(Number(monomerIdsMap[connection.endpoint2.monomerId]));
  assert__default["default"](firstMonomer);
  assert__default["default"](secondMonomer);
  assert__default["default"](connection.endpoint1.attachmentPointId);
  assert__default["default"](connection.endpoint2.attachmentPointId);
  command.merge(drawingEntitiesManager.createPolymerBond(firstMonomer, secondMonomer, connection.endpoint1.attachmentPointId, connection.endpoint2.attachmentPointId));
  return command;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var e=/https?|ftp|gopher|file/;function o(o){"string"==typeof o&&(o=g(o));var r=function(t,e,o){var r=t.auth,a=t.hostname,s=t.protocol||"",p=t.pathname||"",n=t.hash||"",h=t.query||"",c=!1;r=r?encodeURIComponent(r).replace(/%3A/i,":")+"@":"",t.host?c=r+t.host:a&&(c=r+(~a.indexOf(":")?"["+a+"]":a),t.port&&(c+=":"+t.port)),h&&"object"==typeof h&&(h=e.encode(h));var l=t.search||h&&"?"+h||"";return s&&":"!==s.substr(-1)&&(s+=":"),t.slashes||(!s||o.test(s))&&!1!==c?(c="//"+(c||""),p&&"/"!==p[0]&&(p="/"+p)):c||(c=""),n&&"#"!==n[0]&&(n="#"+n),l&&"?"!==l[0]&&(l="?"+l),{protocol:s,host:c,pathname:p=p.replace(/[?#]/g,encodeURIComponent),search:l=l.replace("#","%23"),hash:n}}(o,t__default["default"],e);return ""+r.protocol+r.host+r.pathname+r.search+r.hash}var r="http://",a="w.w",s=r+a,p=/^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i,n=/https?|ftp|gopher|file/;function h(t,e){var a="string"==typeof t?g(t):t;t="object"==typeof t?o(t):t;var h=g(e),c="";a.protocol&&!a.slashes&&(c=a.protocol,t=t.replace(a.protocol,""),c+="/"===e[0]||"/"===t[0]?"/":""),c&&h.protocol&&(c="",h.slashes||(c=h.protocol,e=e.replace(h.protocol,"")));var l=t.match(p);l&&!h.protocol&&(t=t.substr((c=l[1]+(l[2]||"")).length),/^\/\/[^/]/.test(e)&&(c=c.slice(0,-1)));var i=new URL(t,s+"/"),u=new URL(e,i).toString().replace(s,""),f=h.protocol||a.protocol;return f+=a.slashes||h.slashes?"//":"",!c&&f?u=u.replace(r,f):c&&(u=u.replace(r,"")),n.test(u)||~e.indexOf(".")||"/"===t.slice(-1)||"/"===e.slice(-1)||"/"!==u.slice(-1)||(u=u.slice(0,-1)),c&&(u=c+("/"===u[0]?u.substr(1):u)),u}function c(t,e){return g(h(t,e))}function l(){}l.prototype.parse=g,l.prototype.format=o,l.prototype.resolve=h,l.prototype.resolveObject=h;var i=/^https?|ftp|gopher|file/,u=/^(.*?)([#?].*)/,f=/^([a-z0-9.+-]*:)(\/{0,3})(.*)/i,m=/^([a-z0-9.+-]*:)?\/\/\/*/i,v=/^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;function g(e,r,p){if(void 0===r&&(r=!1),void 0===p&&(p=!1),e&&"object"==typeof e&&e instanceof l)return e;var n=(e=e.trim()).match(u);e=n?n[1].replace(/\\/g,"/")+n[2]:e.replace(/\\/g,"/"),v.test(e)&&"/"!==e.slice(-1)&&(e+="/");var h=!/(^javascript)/.test(e)&&e.match(f),c=m.test(e),g="";h&&(i.test(h[1])||(g=h[1].toLowerCase(),e=""+h[2]+h[3]),h[2]||(c=!1,i.test(h[1])?(g=h[1],e=""+h[3]):e="//"+h[3]),3!==h[2].length&&1!==h[2].length||(g=h[1],e="/"+h[3]));var d,y=(n?n[1]:e).match(/^https?:\/\/[^/]+(:[0-9]+)(?=\/|$)/),b=y&&y[1],C=new l,U="",w="";try{d=new URL(e);}catch(t){U=t,g||p||!/^\/\//.test(e)||/^\/\/.+[@.]/.test(e)||(w="/",e=e.substr(1));try{d=new URL(e,s);}catch(t){return C.protocol=g,C.href=g,C}}C.slashes=c&&!w,C.host=d.host===a?"":d.host,C.hostname=d.hostname===a?"":d.hostname.replace(/(\[|\])/g,""),C.protocol=U?g||null:d.protocol,C.search=d.search.replace(/\\/g,"%5C"),C.hash=d.hash.replace(/\\/g,"%5C");var j=e.split("#");!C.search&&~j[0].indexOf("?")&&(C.search="?"),C.hash||""!==j[1]||(C.hash="#"),C.query=r?t__default["default"].decode(d.search.substr(1)):C.search.substr(1),C.pathname=w+(h?function(t){return t.replace(/['^|`]/g,function(t){return "%"+t.charCodeAt().toString(16).toUpperCase()}).replace(/((?:%[0-9A-F]{2})+)/g,function(t,e){try{return decodeURIComponent(e).split("").map(function(t){var e=t.charCodeAt();return e>256||/^[a-z0-9]$/i.test(t)?t:"%"+e.toString(16).toUpperCase()}).join("")}catch(t){return e}})}(d.pathname):d.pathname),"about:"===C.protocol&&"blank"===C.pathname&&(C.protocol="",C.pathname=""),U&&"/"!==e[0]&&(C.pathname=C.pathname.substr(1)),g&&!i.test(g)&&"/"!==e.slice(-1)&&"/"===C.pathname&&(C.pathname=""),C.path=C.pathname+C.search,C.auth=[d.username,d.password].map(decodeURIComponent).filter(Boolean).join(":"),C.port=d.port,b&&!C.host.endsWith(b)&&(C.host+=b,C.port=b.slice(1)),C.href=w?""+C.pathname+C.search+C.hash:o(C);var R=/^(file)/.test(C.href)?["host","hostname"]:[];return Object.keys(C).forEach(function(t){~R.indexOf(t)||(C[t]=C[t]||null);}),C}

var dist = /*#__PURE__*/Object.freeze({
  __proto__: null,
  parse: g,
  format: o,
  resolve: h,
  resolveObject: c,
  Url: l
});

var urilib = /*@__PURE__*/getAugmentedNamespace(dist);

var helpers = createCommonjsModule(function (module, exports) {



var ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, path, name, argument) {
  if(Array.isArray(path)){
    this.path = path;
    this.property = path.reduce(function(sum, item){
      return sum + makeSuffix(item);
    }, 'instance');
  }else if(path !== undefined){
    this.property = path;
  }
  if (message) {
    this.message = message;
  }
  if (schema) {
    var id = schema.$id || schema.id;
    this.schema = id || schema;
  }
  if (instance !== undefined) {
    this.instance = instance;
  }
  this.name = name;
  this.argument = argument;
  this.stack = this.toString();
};

ValidationError.prototype.toString = function toString() {
  return this.property + ' ' + this.message;
};

var ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {
  this.instance = instance;
  this.schema = schema;
  this.options = options;
  this.path = ctx.path;
  this.propertyPath = ctx.propertyPath;
  this.errors = [];
  this.throwError = options && options.throwError;
  this.throwFirst = options && options.throwFirst;
  this.throwAll = options && options.throwAll;
  this.disableFormat = options && options.disableFormat === true;
};

ValidatorResult.prototype.addError = function addError(detail) {
  var err;
  if (typeof detail == 'string') {
    err = new ValidationError(detail, this.instance, this.schema, this.path);
  } else {
    if (!detail) throw new Error('Missing error detail');
    if (!detail.message) throw new Error('Missing error message');
    if (!detail.name) throw new Error('Missing validator type');
    err = new ValidationError(detail.message, this.instance, this.schema, this.path, detail.name, detail.argument);
  }

  this.errors.push(err);
  if (this.throwFirst) {
    throw new ValidatorResultError(this);
  }else if(this.throwError){
    throw err;
  }
  return err;
};

ValidatorResult.prototype.importErrors = function importErrors(res) {
  if (typeof res == 'string' || (res && res.validatorType)) {
    this.addError(res);
  } else if (res && res.errors) {
    this.errors = this.errors.concat(res.errors);
  }
};

function stringizer (v,i){
  return i+': '+v.toString()+'\n';
}
ValidatorResult.prototype.toString = function toString(res) {
  return this.errors.map(stringizer).join('');
};

Object.defineProperty(ValidatorResult.prototype, "valid", { get: function() {
  return !this.errors.length;
} });

module.exports.ValidatorResultError = ValidatorResultError;
function ValidatorResultError(result) {
  if(Error.captureStackTrace){
    Error.captureStackTrace(this, ValidatorResultError);
  }
  this.instance = result.instance;
  this.schema = result.schema;
  this.options = result.options;
  this.errors = result.errors;
}
ValidatorResultError.prototype = new Error();
ValidatorResultError.prototype.constructor = ValidatorResultError;
ValidatorResultError.prototype.name = "Validation Error";

/**
 * Describes a problem with a Schema which prevents validation of an instance
 * @name SchemaError
 * @constructor
 */
var SchemaError = exports.SchemaError = function SchemaError (msg, schema) {
  this.message = msg;
  this.schema = schema;
  Error.call(this, msg);
  Error.captureStackTrace(this, SchemaError);
};
SchemaError.prototype = Object.create(Error.prototype,
  {
    constructor: {value: SchemaError, enumerable: false},
    name: {value: 'SchemaError', enumerable: false},
  });

var SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, path, base, schemas) {
  this.schema = schema;
  this.options = options;
  if(Array.isArray(path)){
    this.path = path;
    this.propertyPath = path.reduce(function(sum, item){
      return sum + makeSuffix(item);
    }, 'instance');
  }else {
    this.propertyPath = path;
  }
  this.base = base;
  this.schemas = schemas;
};

SchemaContext.prototype.resolve = function resolve (target) {
  return urilib.resolve(this.base, target);
};

SchemaContext.prototype.makeChild = function makeChild(schema, propertyName){
  var path = (propertyName===undefined) ? this.path : this.path.concat([propertyName]);
  var id = schema.$id || schema.id;
  var base = urilib.resolve(this.base, id||'');
  var ctx = new SchemaContext(schema, this.options, path, base, Object.create(this.schemas));
  if(id && !ctx.schemas[base]){
    ctx.schemas[base] = schema;
  }
  return ctx;
};

var FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {
  // 7.3.1. Dates, Times, and Duration
  'date-time': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\.\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,
  'date': /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,
  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,
  'duration': /P(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S)|\d+(D|M(\d+D)?|Y(\d+M(\d+D)?)?)(T\d+(H(\d+M(\d+S)?)?|M(\d+S)?|S))?|\d+W)/i,

  // 7.3.2. Email Addresses
  // TODO: fix the email production
  'email': /^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/,
  'idn-email': /^("(?:[!#-\[\]-\u{10FFFF}]|\\[\t -\u{10FFFF}])*"|[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*)@([!#-'*+\-/-9=?A-Z\^-\u{10FFFF}](?:\.?[!#-'*+\-/-9=?A-Z\^-\u{10FFFF}])*|\[[!-Z\^-\u{10FFFF}]*\])$/u,

  // 7.3.3. Hostnames

  // 7.3.4. IP Addresses
  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
  // FIXME whitespace is invalid
  'ipv6': /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,

  // 7.3.5. Resource Identifiers
  // TODO: A more accurate regular expression for "uri" goes:
  // [A-Za-z][+\-.0-9A-Za-z]*:((/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?)?#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])|/?%[0-9A-Fa-f]{2}|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*(#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?)?
  'uri': /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
  'uri-reference': /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/,
  'iri': /^[a-zA-Z][a-zA-Z0-9+.-]*:[^\s]*$/,
  'iri-reference': /^(((([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|(([A-Za-z][+\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~-\u{10FFFF}]|[A-Za-z][+\-.0-9A-Za-z]*[!$&-*,;=@_~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~-\u{10FFFF}])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*)?|([A-Za-z][+\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~-\u{10FFFF}]|[/?])|\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|([A-Za-z][+\-.0-9A-Za-z]*:)?\/((%[0-9A-Fa-f]{2}|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)(:\d*)?[/?]|[!$&-.0-;=?-Z_a-z~-\u{10FFFF}])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~-\u{10FFFF}])*|\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~-\u{10FFFF}])+(:\d*)?|(\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?:\d*|\[(([Vv][0-9A-Fa-f]+\.[!$&-.0-;=A-Z_a-z~-\u{10FFFF}]+)?|[.0-:A-Fa-f]+)\])?)?|[A-Za-z][+\-.0-9A-Za-z]*:?)?$/u,
  'uuid': /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,

  // 7.3.6. uri-template
  'uri-template': /(%[0-9a-f]{2}|[!#$&(-;=?@\[\]_a-z~]|\{[!#&+,./;=?@|]?(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?(,(%[0-9a-f]{2}|[0-9_a-z])(\.?(%[0-9a-f]{2}|[0-9_a-z]))*(:[1-9]\d{0,3}|\*)?)*\})*/iu,

  // 7.3.7. JSON Pointers
  'json-pointer': /^(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*$/iu,
  'relative-json-pointer': /^\d+(#|(\/([\x00-\x2e0-@\[-}\x7f]|~[01])*)*)$/iu,

  // hostname regex from: http://stackoverflow.com/a/1420225/5628
  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,
  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/,

  'utc-millisec': function (input) {
    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);
  },

  // 7.3.8. regex
  'regex': function (input) {
    var result = true;
    try {
      new RegExp(input);
    } catch (e) {
      result = false;
    }
    return result;
  },

  // Other definitions
  // "style" was removed from JSON Schema in draft-4 and is deprecated
  'style': /[\r\n\t ]*[^\r\n\t ][^:]*:[\r\n\t ]*[^\r\n\t ;]*[\r\n\t ]*;?/,
  // "color" was removed from JSON Schema in draft-4 and is deprecated
  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,
  'phone': /^\+(?:[0-9] ?){6,14}[0-9]$/,
  'alpha': /^[a-zA-Z]+$/,
  'alphanumeric': /^[a-zA-Z0-9]+$/,
};

FORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;
FORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];

exports.isFormat = function isFormat (input, format, validator) {
  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {
    if (FORMAT_REGEXPS[format] instanceof RegExp) {
      return FORMAT_REGEXPS[format].test(input);
    }
    if (typeof FORMAT_REGEXPS[format] === 'function') {
      return FORMAT_REGEXPS[format](input);
    }
  } else if (validator && validator.customFormats &&
      typeof validator.customFormats[format] === 'function') {
    return validator.customFormats[format](input);
  }
  return true;
};

var makeSuffix = exports.makeSuffix = function makeSuffix (key) {
  key = key.toString();
  // This function could be capable of outputting valid a ECMAScript string, but the
  // resulting code for testing which form to use would be tens of thousands of characters long
  // That means this will use the name form for some illegal forms
  if (!key.match(/[.\s\[\]]/) && !key.match(/^[\d]/)) {
    return '.' + key;
  }
  if (key.match(/^\d+$/)) {
    return '[' + key + ']';
  }
  return '[' + JSON.stringify(key) + ']';
};

exports.deepCompareStrict = function deepCompareStrict (a, b) {
  if (typeof a !== typeof b) {
    return false;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    return a.every(function (v, i) {
      return deepCompareStrict(a[i], b[i]);
    });
  }
  if (typeof a === 'object') {
    if (!a || !b) {
      return a === b;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    return aKeys.every(function (v) {
      return deepCompareStrict(a[v], b[v]);
    });
  }
  return a === b;
};

function deepMerger (target, dst, e, i) {
  if (typeof e === 'object') {
    dst[i] = deepMerge(target[i], e);
  } else {
    if (target.indexOf(e) === -1) {
      dst.push(e);
    }
  }
}

function copyist (src, dst, key) {
  dst[key] = src[key];
}

function copyistWithDeepMerge (target, src, dst, key) {
  if (typeof src[key] !== 'object' || !src[key]) {
    dst[key] = src[key];
  }
  else {
    if (!target[key]) {
      dst[key] = src[key];
    } else {
      dst[key] = deepMerge(target[key], src[key]);
    }
  }
}

function deepMerge (target, src) {
  var array = Array.isArray(src);
  var dst = array && [] || {};

  if (array) {
    target = target || [];
    dst = dst.concat(target);
    src.forEach(deepMerger.bind(null, target, dst));
  } else {
    if (target && typeof target === 'object') {
      Object.keys(target).forEach(copyist.bind(null, target, dst));
    }
    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));
  }

  return dst;
}

module.exports.deepMerge = deepMerge;

/**
 * Validates instance against the provided schema
 * Implements URI+JSON Pointer encoding, e.g. "%7e"="~0"=>"~", "~1"="%2f"=>"/"
 * @param o
 * @param s The path to walk o along
 * @return any
 */
exports.objectGetPath = function objectGetPath(o, s) {
  var parts = s.split('/').slice(1);
  var k;
  while (typeof (k=parts.shift()) == 'string') {
    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));
    if (!(n in o)) return;
    o = o[n];
  }
  return o;
};

function pathEncoder (v) {
  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');
}
/**
 * Accept an Array of property names and return a JSON Pointer URI fragment
 * @param Array a
 * @return {String}
 */
exports.encodePath = function encodePointer(a){
  // ~ must be encoded explicitly because hacks
  // the slash is encoded by encodeURIComponent
  return a.map(pathEncoder).join('');
};


/**
 * Calculate the number of decimal places a number uses
 * We need this to get correct results out of multipleOf and divisibleBy
 * when either figure is has decimal places, due to IEEE-754 float issues.
 * @param number
 * @returns {number}
 */
exports.getDecimalPlaces = function getDecimalPlaces(number) {

  var decimalPlaces = 0;
  if (isNaN(number)) return decimalPlaces;

  if (typeof number !== 'number') {
    number = Number(number);
  }

  var parts = number.toString().split('e');
  if (parts.length === 2) {
    if (parts[1][0] !== '-') {
      return decimalPlaces;
    } else {
      decimalPlaces = Number(parts[1].slice(1));
    }
  }

  var decimalParts = parts[0].split('.');
  if (decimalParts.length === 2) {
    decimalPlaces += decimalParts[1].length;
  }

  return decimalPlaces;
};

exports.isSchema = function isSchema(val){
  return (typeof val === 'object' && val) || (typeof val === 'boolean');
};
});

/** @type ValidatorResult */
var ValidatorResult$1 = helpers.ValidatorResult;
/** @type SchemaError */
var SchemaError$1 = helpers.SchemaError;

var attribute = {};

attribute.ignoreProperties = {
  // informative properties
  'id': true,
  'default': true,
  'description': true,
  'title': true,
  // arguments to other properties
  'additionalItems': true,
  'then': true,
  'else': true,
  // special-handled properties
  '$schema': true,
  '$ref': true,
  'extends': true,
};

/**
 * @name validators
 */
var validators = attribute.validators = {};

/**
 * Validates whether the instance if of a certain type
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {ValidatorResult|null}
 */
validators.type = function validateType (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var types = Array.isArray(schema.type) ? schema.type : [schema.type];
  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {
    var list = types.map(function (v) {
      if(!v) return;
      var id = v.$id || v.id;
      return id ? ('<' + id + '>') : (v+'');
    });
    result.addError({
      name: 'type',
      argument: list,
      message: "is not of a type(s) " + list,
    });
  }
  return result;
};

function testSchemaNoThrow(instance, options, ctx, callback, schema){
  var throwError = options.throwError;
  var throwAll = options.throwAll;
  options.throwError = false;
  options.throwAll = false;
  var res = this.validateSchema(instance, schema, options, ctx);
  options.throwError = throwError;
  options.throwAll = throwAll;

  if (!res.valid && callback instanceof Function) {
    callback(res);
  }
  return res.valid;
}

/**
 * Validates whether the instance matches some of the given schemas
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {ValidatorResult|null}
 */
validators.anyOf = function validateAnyOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var inner = new ValidatorResult$1(instance, schema, options, ctx);
  if (!Array.isArray(schema.anyOf)){
    throw new SchemaError$1("anyOf must be an array");
  }
  if (!schema.anyOf.some(
    testSchemaNoThrow.bind(
      this, instance, options, ctx, function(res){inner.importErrors(res);}
    ))) {
    var list = schema.anyOf.map(function (v, i) {
      var id = v.$id || v.id;
      if(id) return '<' + id + '>';
      return (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
    });
    if (options.nestedErrors) {
      result.importErrors(inner);
    }
    result.addError({
      name: 'anyOf',
      argument: list,
      message: "is not any of " + list.join(','),
    });
  }
  return result;
};

/**
 * Validates whether the instance matches every given schema
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.allOf = function validateAllOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema.allOf)){
    throw new SchemaError$1("allOf must be an array");
  }
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var self = this;
  schema.allOf.forEach(function(v, i){
    var valid = self.validateSchema(instance, v, options, ctx);
    if(!valid.valid){
      var id = v.$id || v.id;
      var msg = id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
      result.addError({
        name: 'allOf',
        argument: { id: msg, length: valid.errors.length, valid: valid },
        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',
      });
      result.importErrors(valid);
    }
  });
  return result;
};

/**
 * Validates whether the instance matches exactly one of the given schemas
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.oneOf = function validateOneOf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema.oneOf)){
    throw new SchemaError$1("oneOf must be an array");
  }
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var inner = new ValidatorResult$1(instance, schema, options, ctx);
  var count = schema.oneOf.filter(
    testSchemaNoThrow.bind(
      this, instance, options, ctx, function(res) {inner.importErrors(res);}
    ) ).length;
  var list = schema.oneOf.map(function (v, i) {
    var id = v.$id || v.id;
    return id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';
  });
  if (count!==1) {
    if (options.nestedErrors) {
      result.importErrors(inner);
    }
    result.addError({
      name: 'oneOf',
      argument: list,
      message: "is not exactly one from " + list.join(','),
    });
  }
  return result;
};

/**
 * Validates "then" or "else" depending on the result of validating "if"
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null}
 */
validators.if = function validateIf (instance, schema, options, ctx) {
  // Ignore undefined instances
  if (instance === undefined) return null;
  if (!helpers.isSchema(schema.if)) throw new Error('Expected "if" keyword to be a schema');
  var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var res;
  if(ifValid){
    if (schema.then === undefined) return;
    if (!helpers.isSchema(schema.then)) throw new Error('Expected "then" keyword to be a schema');
    res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));
    result.importErrors(res);
  }else {
    if (schema.else === undefined) return;
    if (!helpers.isSchema(schema.else)) throw new Error('Expected "else" keyword to be a schema');
    res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));
    result.importErrors(res);
  }
  return result;
};

function getEnumerableProperty(object, key){
  // Determine if `key` shows up in `for(var key in object)`
  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does
  if(Object.hasOwnProperty.call(object, key)) return object[key];
  // Test `key in object` as an optimization; false means it won't
  if(!(key in object)) return;
  while( (object = Object.getPrototypeOf(object)) ){
    if(Object.propertyIsEnumerable.call(object, key)) return object[key];
  }
}

/**
 * Validates propertyNames
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.propertyNames = function validatePropertyNames (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var subschema = schema.propertyNames!==undefined ? schema.propertyNames : {};
  if(!helpers.isSchema(subschema)) throw new SchemaError$1('Expected "propertyNames" to be a schema (object or boolean)');

  for (var property in instance) {
    if(getEnumerableProperty(instance, property) !== undefined){
      var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));
      result.importErrors(res);
    }
  }

  return result;
};

/**
 * Validates properties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.properties = function validateProperties (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var properties = schema.properties || {};
  for (var property in properties) {
    var subschema = properties[property];
    if(subschema===undefined){
      continue;
    }else if(subschema===null){
      throw new SchemaError$1('Unexpected null, expected schema in "properties"');
    }
    if (typeof options.preValidateProperty == 'function') {
      options.preValidateProperty(instance, property, subschema, options, ctx);
    }
    var prop = getEnumerableProperty(instance, property);
    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));
    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
    result.importErrors(res);
  }
  return result;
};

/**
 * Test a specific property within in instance against the additionalProperties schema attribute
 * This ignores properties with definitions in the properties schema attribute, but no other attributes.
 * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)
 * @private
 * @return {boolean}
 */
function testAdditionalProperty (instance, schema, options, ctx, property, result) {
  if(!this.types.object(instance)) return;
  if (schema.properties && schema.properties[property] !== undefined) {
    return;
  }
  if (schema.additionalProperties === false) {
    result.addError({
      name: 'additionalProperties',
      argument: property,
      message: "is not allowed to have the additional property " + JSON.stringify(property),
    });
  } else {
    var additionalProperties = schema.additionalProperties || {};

    if (typeof options.preValidateProperty == 'function') {
      options.preValidateProperty(instance, property, additionalProperties, options, ctx);
    }

    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));
    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
    result.importErrors(res);
  }
}

/**
 * Validates patternProperties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var patternProperties = schema.patternProperties || {};

  for (var property in instance) {
    var test = true;
    for (var pattern in patternProperties) {
      var subschema = patternProperties[pattern];
      if(subschema===undefined){
        continue;
      }else if(subschema===null){
        throw new SchemaError$1('Unexpected null, expected schema in "patternProperties"');
      }
      try {
        var regexp = new RegExp(pattern, 'u');
      } catch(_e) {
        // In the event the stricter handling causes an error, fall back on the forgiving handling
        // DEPRECATED
        regexp = new RegExp(pattern);
      }
      if (!regexp.test(property)) {
        continue;
      }
      test = false;

      if (typeof options.preValidateProperty == 'function') {
        options.preValidateProperty(instance, property, subschema, options, ctx);
      }

      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));
      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;
      result.importErrors(res);
    }
    if (test) {
      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
    }
  }

  return result;
};

/**
 * Validates additionalProperties
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {
  if(!this.types.object(instance)) return;
  // if patternProperties is defined then we'll test when that one is called instead
  if (schema.patternProperties) {
    return null;
  }
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  for (var property in instance) {
    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);
  }
  return result;
};

/**
 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minProperties = function validateMinProperties (instance, schema, options, ctx) {
  if (!this.types.object(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var keys = Object.keys(instance);
  if (!(keys.length >= schema.minProperties)) {
    result.addError({
      name: 'minProperties',
      argument: schema.minProperties,
      message: "does not meet minimum property length of " + schema.minProperties,
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {
  if (!this.types.object(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var keys = Object.keys(instance);
  if (!(keys.length <= schema.maxProperties)) {
    result.addError({
      name: 'maxProperties',
      argument: schema.maxProperties,
      message: "does not meet maximum property length of " + schema.maxProperties,
    });
  }
  return result;
};

/**
 * Validates items when instance is an array
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.items = function validateItems (instance, schema, options, ctx) {
  var self = this;
  if (!this.types.array(instance)) return;
  if (schema.items===undefined) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  instance.every(function (value, i) {
    if(Array.isArray(schema.items)){
      var items =  schema.items[i]===undefined ? schema.additionalItems : schema.items[i];
    }else {
      var items = schema.items;
    }
    if (items === undefined) {
      return true;
    }
    if (items === false) {
      result.addError({
        name: 'items',
        message: "additionalItems not permitted",
      });
      return false;
    }
    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));
    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;
    result.importErrors(res);
    return true;
  });
  return result;
};

/**
 * Validates the "contains" keyword
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {String|null|ValidatorResult}
 */
validators.contains = function validateContains (instance, schema, options, ctx) {
  var self = this;
  if (!this.types.array(instance)) return;
  if (schema.contains===undefined) return;
  if (!helpers.isSchema(schema.contains)) throw new Error('Expected "contains" keyword to be a schema');
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var count = instance.some(function (value, i) {
    var res = self.validateSchema(value, schema.contains, options, ctx.makeChild(schema.contains, i));
    return res.errors.length===0;
  });
  if(count===false){
    result.addError({
      name: 'contains',
      argument: schema.contains,
      message: "must contain an item matching given schema",
    });
  }
  return result;
};

/**
 * Validates minimum and exclusiveMinimum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minimum = function validateMinimum (instance, schema, options, ctx) {
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {
    if(!(instance > schema.minimum)){
      result.addError({
        name: 'minimum',
        argument: schema.minimum,
        message: "must be greater than " + schema.minimum,
      });
    }
  } else {
    if(!(instance >= schema.minimum)){
      result.addError({
        name: 'minimum',
        argument: schema.minimum,
        message: "must be greater than or equal to " + schema.minimum,
      });
    }
  }
  return result;
};

/**
 * Validates maximum and exclusiveMaximum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maximum = function validateMaximum (instance, schema, options, ctx) {
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {
    if(!(instance < schema.maximum)){
      result.addError({
        name: 'maximum',
        argument: schema.maximum,
        message: "must be less than " + schema.maximum,
      });
    }
  } else {
    if(!(instance <= schema.maximum)){
      result.addError({
        name: 'maximum',
        argument: schema.maximum,
        message: "must be less than or equal to " + schema.maximum,
      });
    }
  }
  return result;
};

/**
 * Validates the number form of exclusiveMinimum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.exclusiveMinimum = function validateExclusiveMinimum (instance, schema, options, ctx) {
  // Support the boolean form of exclusiveMinimum, which is handled by the "minimum" keyword.
  if(typeof schema.exclusiveMinimum === 'boolean') return;
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var valid = instance > schema.exclusiveMinimum;
  if (!valid) {
    result.addError({
      name: 'exclusiveMinimum',
      argument: schema.exclusiveMinimum,
      message: "must be strictly greater than " + schema.exclusiveMinimum,
    });
  }
  return result;
};

/**
 * Validates the number form of exclusiveMaximum when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.exclusiveMaximum = function validateExclusiveMaximum (instance, schema, options, ctx) {
  // Support the boolean form of exclusiveMaximum, which is handled by the "maximum" keyword.
  if(typeof schema.exclusiveMaximum === 'boolean') return;
  if (!this.types.number(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var valid = instance < schema.exclusiveMaximum;
  if (!valid) {
    result.addError({
      name: 'exclusiveMaximum',
      argument: schema.exclusiveMaximum,
      message: "must be strictly less than " + schema.exclusiveMaximum,
    });
  }
  return result;
};

/**
 * Perform validation for multipleOf and divisibleBy, which are essentially the same.
 * @param instance
 * @param schema
 * @param validationType
 * @param errorMessage
 * @returns {String|null}
 */
var validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {
  if (!this.types.number(instance)) return;

  var validationArgument = schema[validationType];
  if (validationArgument == 0) {
    throw new SchemaError$1(validationType + " cannot be zero");
  }

  var result = new ValidatorResult$1(instance, schema, options, ctx);

  var instanceDecimals = helpers.getDecimalPlaces(instance);
  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);

  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);
  var multiplier = Math.pow(10, maxDecimals);

  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {
    result.addError({
      name: validationType,
      argument:  validationArgument,
      message: errorMessage + JSON.stringify(validationArgument),
    });
  }

  return result;
};

/**
 * Validates divisibleBy when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {
  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "multipleOf", "is not a multiple of (divisible by) ");
};

/**
 * Validates multipleOf when the type of the instance value is a number.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {
  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, "divisibleBy", "is not divisible by (multiple of) ");
};

/**
 * Validates whether the instance value is present.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.required = function validateRequired (instance, schema, options, ctx) {
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  if (instance === undefined && schema.required === true) {
    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts
    result.addError({
      name: 'required',
      message: "is required",
    });
  } else if (this.types.object(instance) && Array.isArray(schema.required)) {
    schema.required.forEach(function(n){
      if(getEnumerableProperty(instance, n)===undefined){
        result.addError({
          name: 'required',
          argument: n,
          message: "requires property " + JSON.stringify(n),
        });
      }
    });
  }
  return result;
};

/**
 * Validates whether the instance value matches the regular expression, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.pattern = function validatePattern (instance, schema, options, ctx) {
  if (!this.types.string(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var pattern = schema.pattern;
  try {
    var regexp = new RegExp(pattern, 'u');
  } catch(_e) {
    // In the event the stricter handling causes an error, fall back on the forgiving handling
    // DEPRECATED
    regexp = new RegExp(pattern);
  }
  if (!instance.match(regexp)) {
    result.addError({
      name: 'pattern',
      argument: schema.pattern,
      message: "does not match pattern " + JSON.stringify(schema.pattern.toString()),
    });
  }
  return result;
};

/**
 * Validates whether the instance value is of a certain defined format or a custom
 * format.
 * The following formats are supported for string types:
 *   - date-time
 *   - date
 *   - time
 *   - ip-address
 *   - ipv6
 *   - uri
 *   - color
 *   - host-name
 *   - alpha
 *   - alpha-numeric
 *   - utc-millisec
 * @param instance
 * @param schema
 * @param [options]
 * @param [ctx]
 * @return {String|null}
 */
validators.format = function validateFormat (instance, schema, options, ctx) {
  if (instance===undefined) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {
    result.addError({
      name: 'format',
      argument: schema.format,
      message: "does not conform to the " + JSON.stringify(schema.format) + " format",
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at least of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minLength = function validateMinLength (instance, schema, options, ctx) {
  if (!this.types.string(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var hsp = instance.match(/[\uDC00-\uDFFF]/g);
  var length = instance.length - (hsp ? hsp.length : 0);
  if (!(length >= schema.minLength)) {
    result.addError({
      name: 'minLength',
      argument: schema.minLength,
      message: "does not meet minimum length of " + schema.minLength,
    });
  }
  return result;
};

/**
 * Validates whether the instance value is at most of a certain length, when the instance value is a string.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxLength = function validateMaxLength (instance, schema, options, ctx) {
  if (!this.types.string(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  // TODO if this was already computed in "minLength", use that value instead of re-computing
  var hsp = instance.match(/[\uDC00-\uDFFF]/g);
  var length = instance.length - (hsp ? hsp.length : 0);
  if (!(length <= schema.maxLength)) {
    result.addError({
      name: 'maxLength',
      argument: schema.maxLength,
      message: "does not meet maximum length of " + schema.maxLength,
    });
  }
  return result;
};

/**
 * Validates whether instance contains at least a minimum number of items, when the instance is an Array.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.minItems = function validateMinItems (instance, schema, options, ctx) {
  if (!this.types.array(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  if (!(instance.length >= schema.minItems)) {
    result.addError({
      name: 'minItems',
      argument: schema.minItems,
      message: "does not meet minimum length of " + schema.minItems,
    });
  }
  return result;
};

/**
 * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.
 * @param instance
 * @param schema
 * @return {String|null}
 */
validators.maxItems = function validateMaxItems (instance, schema, options, ctx) {
  if (!this.types.array(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  if (!(instance.length <= schema.maxItems)) {
    result.addError({
      name: 'maxItems',
      argument: schema.maxItems,
      message: "does not meet maximum length of " + schema.maxItems,
    });
  }
  return result;
};

/**
 * Deep compares arrays for duplicates
 * @param v
 * @param i
 * @param a
 * @private
 * @return {boolean}
 */
function testArrays (v, i, a) {
  var j, len = a.length;
  for (j = i + 1, len; j < len; j++) {
    if (helpers.deepCompareStrict(v, a[j])) {
      return false;
    }
  }
  return true;
}

/**
 * Validates whether there are no duplicates, when the instance is an Array.
 * @param instance
 * @return {String|null}
 */
validators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {
  if (schema.uniqueItems!==true) return;
  if (!this.types.array(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  if (!instance.every(testArrays)) {
    result.addError({
      name: 'uniqueItems',
      message: "contains duplicate item",
    });
  }
  return result;
};

/**
 * Validate for the presence of dependency properties, if the instance is an object.
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {null|ValidatorResult}
 */
validators.dependencies = function validateDependencies (instance, schema, options, ctx) {
  if (!this.types.object(instance)) return;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  for (var property in schema.dependencies) {
    if (instance[property] === undefined) {
      continue;
    }
    var dep = schema.dependencies[property];
    var childContext = ctx.makeChild(dep, property);
    if (typeof dep == 'string') {
      dep = [dep];
    }
    if (Array.isArray(dep)) {
      dep.forEach(function (prop) {
        if (instance[prop] === undefined) {
          result.addError({
            // FIXME there's two different "dependencies" errors here with slightly different outputs
            // Can we make these the same? Or should we create different error types?
            name: 'dependencies',
            argument: childContext.propertyPath,
            message: "property " + prop + " not found, required by " + childContext.propertyPath,
          });
        }
      });
    } else {
      var res = this.validateSchema(instance, dep, options, childContext);
      if(result.instance !== res.instance) result.instance = res.instance;
      if (res && res.errors.length) {
        result.addError({
          name: 'dependencies',
          argument: childContext.propertyPath,
          message: "does not meet dependency required by " + childContext.propertyPath,
        });
        result.importErrors(res);
      }
    }
  }
  return result;
};

/**
 * Validates whether the instance value is one of the enumerated values.
 *
 * @param instance
 * @param schema
 * @return {ValidatorResult|null}
 */
validators['enum'] = function validateEnum (instance, schema, options, ctx) {
  if (instance === undefined) {
    return null;
  }
  if (!Array.isArray(schema['enum'])) {
    throw new SchemaError$1("enum expects an array", schema);
  }
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {
    result.addError({
      name: 'enum',
      argument: schema['enum'],
      message: "is not one of enum values: " + schema['enum'].map(String).join(','),
    });
  }
  return result;
};

/**
 * Validates whether the instance exactly matches a given value
 *
 * @param instance
 * @param schema
 * @return {ValidatorResult|null}
 */
validators['const'] = function validateEnum (instance, schema, options, ctx) {
  if (instance === undefined) {
    return null;
  }
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  if (!helpers.deepCompareStrict(schema['const'], instance)) {
    result.addError({
      name: 'const',
      argument: schema['const'],
      message: "does not exactly match expected constant: " + schema['const'],
    });
  }
  return result;
};

/**
 * Validates whether the instance if of a prohibited type.
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @return {null|ValidatorResult}
 */
validators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {
  var self = this;
  if(instance===undefined) return null;
  var result = new ValidatorResult$1(instance, schema, options, ctx);
  var notTypes = schema.not || schema.disallow;
  if(!notTypes) return null;
  if(!Array.isArray(notTypes)) notTypes=[notTypes];
  notTypes.forEach(function (type) {
    if (self.testType(instance, schema, options, ctx, type)) {
      var id = type && (type.$id || type.id);
      var schemaId = id || type;
      result.addError({
        name: 'not',
        argument: schemaId,
        message: "is of prohibited type " + schemaId,
      });
    }
  });
  return result;
};

var attribute_1 = attribute;

var SchemaScanResult_1 = SchemaScanResult;
function SchemaScanResult(found, ref){
  this.id = found;
  this.ref = ref;
}

/**
 * Adds a schema with a certain urn to the Validator instance.
 * @param string uri
 * @param object schema
 * @return {Object}
 */
var scan_1 = function scan(base, schema){
  function scanSchema(baseuri, schema){
    if(!schema || typeof schema!='object') return;
    // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined
    if(schema.$ref){
      var resolvedUri = urilib.resolve(baseuri, schema.$ref);
      ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri]+1 : 0;
      return;
    }
    var id = schema.$id || schema.id;
    var ourBase = id ? urilib.resolve(baseuri, id) : baseuri;
    if (ourBase) {
      // If there's no fragment, append an empty one
      if(ourBase.indexOf('#')<0) ourBase += '#';
      if(found[ourBase]){
        if(!helpers.deepCompareStrict(found[ourBase], schema)){
          throw new Error('Schema <'+ourBase+'> already exists with different definition');
        }
        return found[ourBase];
      }
      found[ourBase] = schema;
      // strip trailing fragment
      if(ourBase[ourBase.length-1]=='#'){
        found[ourBase.substring(0, ourBase.length-1)] = schema;
      }
    }
    scanArray(ourBase+'/items', (Array.isArray(schema.items)?schema.items:[schema.items]));
    scanArray(ourBase+'/extends', (Array.isArray(schema.extends)?schema.extends:[schema.extends]));
    scanSchema(ourBase+'/additionalItems', schema.additionalItems);
    scanObject(ourBase+'/properties', schema.properties);
    scanSchema(ourBase+'/additionalProperties', schema.additionalProperties);
    scanObject(ourBase+'/definitions', schema.definitions);
    scanObject(ourBase+'/patternProperties', schema.patternProperties);
    scanObject(ourBase+'/dependencies', schema.dependencies);
    scanArray(ourBase+'/disallow', schema.disallow);
    scanArray(ourBase+'/allOf', schema.allOf);
    scanArray(ourBase+'/anyOf', schema.anyOf);
    scanArray(ourBase+'/oneOf', schema.oneOf);
    scanSchema(ourBase+'/not', schema.not);
  }
  function scanArray(baseuri, schemas){
    if(!Array.isArray(schemas)) return;
    for(var i=0; i<schemas.length; i++){
      scanSchema(baseuri+'/'+i, schemas[i]);
    }
  }
  function scanObject(baseuri, schemas){
    if(!schemas || typeof schemas!='object') return;
    for(var p in schemas){
      scanSchema(baseuri+'/'+p, schemas[p]);
    }
  }

  var found = {};
  var ref = {};
  scanSchema(base, schema);
  return new SchemaScanResult(found, ref);
};

var scan = {
	SchemaScanResult: SchemaScanResult_1,
	scan: scan_1
};

var scanSchema = scan.scan;
var ValidatorResult = helpers.ValidatorResult;
var ValidatorResultError = helpers.ValidatorResultError;
var SchemaError = helpers.SchemaError;
var SchemaContext = helpers.SchemaContext;
//var anonymousBase = 'vnd.jsonschema:///';
var anonymousBase = '/';

/**
 * Creates a new Validator object
 * @name Validator
 * @constructor
 */
var Validator = function Validator () {
  // Allow a validator instance to override global custom formats or to have their
  // own custom formats.
  this.customFormats = Object.create(Validator.prototype.customFormats);
  this.schemas = {};
  this.unresolvedRefs = [];

  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.
  this.types = Object.create(types);
  this.attributes = Object.create(attribute_1.validators);
};

// Allow formats to be registered globally.
Validator.prototype.customFormats = {};

// Hint at the presence of a property
Validator.prototype.schemas = null;
Validator.prototype.types = null;
Validator.prototype.attributes = null;
Validator.prototype.unresolvedRefs = null;

/**
 * Adds a schema with a certain urn to the Validator instance.
 * @param schema
 * @param urn
 * @return {Object}
 */
Validator.prototype.addSchema = function addSchema (schema, base) {
  var self = this;
  if (!schema) {
    return null;
  }
  var scan = scanSchema(base||anonymousBase, schema);
  var ourUri = base || schema.$id || schema.id;
  for(var uri in scan.id){
    this.schemas[uri] = scan.id[uri];
  }
  for(var uri in scan.ref){
    // If this schema is already defined, it will be filtered out by the next step
    this.unresolvedRefs.push(uri);
  }
  // Remove newly defined schemas from unresolvedRefs
  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){
    return typeof self.schemas[uri]==='undefined';
  });
  return this.schemas[ourUri];
};

Validator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {
  if(!Array.isArray(schemas)) return;
  for(var i=0; i<schemas.length; i++){
    this.addSubSchema(baseuri, schemas[i]);
  }
};

Validator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {
  if(!schemas || typeof schemas!='object') return;
  for(var p in schemas){
    this.addSubSchema(baseuri, schemas[p]);
  }
};



/**
 * Sets all the schemas of the Validator instance.
 * @param schemas
 */
Validator.prototype.setSchemas = function setSchemas (schemas) {
  this.schemas = schemas;
};

/**
 * Returns the schema of a certain urn
 * @param urn
 */
Validator.prototype.getSchema = function getSchema (urn) {
  return this.schemas[urn];
};

/**
 * Validates instance against the provided schema
 * @param instance
 * @param schema
 * @param [options]
 * @param [ctx]
 * @return {Array}
 */
Validator.prototype.validate = function validate (instance, schema, options, ctx) {
  if((typeof schema !== 'boolean' && typeof schema !== 'object') || schema === null){
    throw new SchemaError('Expected `schema` to be an object or boolean');
  }
  if (!options) {
    options = {};
  }
  // This section indexes subschemas in the provided schema, so they don't need to be added with Validator#addSchema
  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI
  var id = schema.$id || schema.id;
  var base = urilib.resolve(options.base||anonymousBase, id||'');
  if(!ctx){
    ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));
    if (!ctx.schemas[base]) {
      ctx.schemas[base] = schema;
    }
    var found = scanSchema(base, schema);
    for(var n in found.id){
      var sch = found.id[n];
      ctx.schemas[n] = sch;
    }
  }
  if(options.required && instance===undefined){
    var result = new ValidatorResult(instance, schema, options, ctx);
    result.addError('is required, but is undefined');
    return result;
  }
  var result = this.validateSchema(instance, schema, options, ctx);
  if (!result) {
    throw new Error('Result undefined');
  }else if(options.throwAll && result.errors.length){
    throw new ValidatorResultError(result);
  }
  return result;
};

/**
* @param Object schema
* @return mixed schema uri or false
*/
function shouldResolve(schema) {
  var ref = (typeof schema === 'string') ? schema : schema.$ref;
  if (typeof ref=='string') return ref;
  return false;
}

/**
 * Validates an instance against the schema (the actual work horse)
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @private
 * @return {ValidatorResult}
 */
Validator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {
  var result = new ValidatorResult(instance, schema, options, ctx);

  // Support for the true/false schemas
  if(typeof schema==='boolean') {
    if(schema===true){
      // `true` is always valid
      schema = {};
    }else if(schema===false){
      // `false` is always invalid
      schema = {type: []};
    }
  }else if(!schema){
    // This might be a string
    throw new Error("schema is undefined");
  }

  if (schema['extends']) {
    if (Array.isArray(schema['extends'])) {
      var schemaobj = {schema: schema, ctx: ctx};
      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));
      schema = schemaobj.schema;
      schemaobj.schema = null;
      schemaobj.ctx = null;
      schemaobj = null;
    } else {
      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));
    }
  }

  // If passed a string argument, load that schema URI
  var switchSchema = shouldResolve(schema);
  if (switchSchema) {
    var resolved = this.resolve(schema, switchSchema, ctx);
    var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);
    return this.validateSchema(instance, resolved.subschema, options, subctx);
  }

  var skipAttributes = options && options.skipAttributes || [];
  // Validate each schema attribute against the instance
  for (var key in schema) {
    if (!attribute_1.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {
      var validatorErr = null;
      var validator = this.attributes[key];
      if (validator) {
        validatorErr = validator.call(this, instance, schema, options, ctx);
      } else if (options.allowUnknownAttributes === false) {
        // This represents an error with the schema itself, not an invalid instance
        throw new SchemaError("Unsupported attribute: " + key, schema);
      }
      if (validatorErr) {
        result.importErrors(validatorErr);
      }
    }
  }

  if (typeof options.rewrite == 'function') {
    var value = options.rewrite.call(this, instance, schema, options, ctx);
    result.instance = value;
  }
  return result;
};

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {
  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));
};

/**
* @private
* @param Object schema
* @param SchemaContext ctx
* @returns Object schema or resolved schema
*/
Validator.prototype.superResolve = function superResolve (schema, ctx) {
  var ref = shouldResolve(schema);
  if(ref) {
    return this.resolve(schema, ref, ctx).subschema;
  }
  return schema;
};

/**
* @private
* @param Object schema
* @param Object switchSchema
* @param SchemaContext ctx
* @return Object resolved schemas {subschema:String, switchSchema: String}
* @throws SchemaError
*/
Validator.prototype.resolve = function resolve (schema, switchSchema, ctx) {
  switchSchema = ctx.resolve(switchSchema);
  // First see if the schema exists under the provided URI
  if (ctx.schemas[switchSchema]) {
    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};
  }
  // Else try walking the property pointer
  var parsed = urilib.parse(switchSchema);
  var fragment = parsed && parsed.hash;
  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);
  if (!document || !ctx.schemas[document]) {
    throw new SchemaError("no such schema <" + switchSchema + ">", schema);
  }
  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));
  if(subschema===undefined){
    throw new SchemaError("no such schema " + fragment + " located in <" + document + ">", schema);
  }
  return {subschema: subschema, switchSchema: switchSchema};
};

/**
 * Tests whether the instance if of a certain type.
 * @private
 * @param instance
 * @param schema
 * @param options
 * @param ctx
 * @param type
 * @return {boolean}
 */
Validator.prototype.testType = function validateType (instance, schema, options, ctx, type) {
  if(type===undefined){
    return;
  }else if(type===null){
    throw new SchemaError('Unexpected null in "type" keyword');
  }
  if (typeof this.types[type] == 'function') {
    return this.types[type].call(this, instance);
  }
  if (type && typeof type == 'object') {
    var res = this.validateSchema(instance, type, options, ctx);
    return res === undefined || !(res && res.errors.length);
  }
  // Undefined or properties not on the list are acceptable, same as not being defined
  return true;
};

var types = Validator.prototype.types = {};
types.string = function testString (instance) {
  return typeof instance == 'string';
};
types.number = function testNumber (instance) {
  // isFinite returns false for NaN, Infinity, and -Infinity
  return typeof instance == 'number' && isFinite(instance);
};
types.integer = function testInteger (instance) {
  return (typeof instance == 'number') && instance % 1 === 0;
};
types.boolean = function testBoolean (instance) {
  return typeof instance == 'boolean';
};
types.array = function testArray (instance) {
  return Array.isArray(instance);
};
types['null'] = function testNull (instance) {
  return instance === null;
};
types.date = function testDate (instance) {
  return instance instanceof Date;
};
types.any = function testAny (instance) {
  return true;
};
types.object = function testObject (instance) {
  // TODO: fix this - see #15
  return instance && (typeof instance === 'object') && !(Array.isArray(instance)) && !(instance instanceof Date);
};

var validator = Validator;

var lib = createCommonjsModule(function (module) {

var Validator = module.exports.Validator = validator;

module.exports.ValidatorResult = helpers.ValidatorResult;
module.exports.ValidatorResultError = helpers.ValidatorResultError;
module.exports.ValidationError = helpers.ValidationError;
module.exports.SchemaError = helpers.SchemaError;
module.exports.SchemaScanResult = scan.SchemaScanResult;
module.exports.scan = scan.scan;

module.exports.validate = function (instance, schema, options) {
  var v = new Validator();
  return v.validate(instance, schema, options);
};
});

var $schema = "http://json-schema.org/draft-07/schema#";
var title = "ket";
var description = "Ketcher format schema";
var type = "object";
var required = [
	"root"
];
var properties = {
	root: {
		type: "object",
		required: [
			"nodes"
		],
		properties: {
			nodes: {
				type: "array",
				minItems: 0,
				items: {
					oneOf: [
						{
							$ref: "#/definitions/simpleObject"
						},
						{
							$ref: "#/definitions/text"
						},
						{
							$ref: "#/definitions/arrow"
						},
						{
							$ref: "#/definitions/plus"
						},
						{
							type: "object",
							required: [
								"$ref"
							],
							properties: {
								$ref: {
									type: "string",
									pattern: "^(mol\\d+|rg[1-9]\\d*)"
								}
							}
						}
					]
				}
			}
		}
	}
};
var patternProperties = {
	"^rg[1-9]\\d*": {
		$ref: "#/definitions/rgroup"
	},
	"^mol\\d+": {
		$ref: "#/definitions/molecule"
	},
	"^header$": {
		$ref: "#/definitions/header"
	}
};
var additionalProperties = false;
var definitions = {
	header: {
		type: "object",
		properties: {
			moleculeName: {
				type: "string"
			}
		}
	},
	rsite: {
		type: "object",
		required: [
			"type",
			"location"
		],
		properties: {
			type: {
				"const": "rg-label"
			},
			location: {
				type: "array",
				minItems: 2,
				maxItems: 3,
				items: {
					type: "number"
				}
			},
			$refs: {
				type: "array",
				items: {
					type: "string",
					pattern: "^rg-[1-9]\\d*"
				}
			},
			attachmentPoints: {
				type: "integer",
				"enum": [
					0,
					1,
					2,
					3
				]
			}
		}
	},
	atom: {
		type: "object",
		required: [
			"label"
		],
		properties: {
			label: {
				type: "string"
			},
			alias: {
				type: "string"
			},
			location: {
				type: "array",
				minItems: 2,
				maxItems: 3,
				items: {
					type: "number"
				}
			},
			selected: {
				type: "boolean"
			},
			charge: {
				type: "integer",
				minimum: -1000,
				maximum: 1000
			},
			explicitValence: {
				type: "integer",
				"enum": [
					-1,
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					7,
					8,
					9,
					10,
					11,
					12
				]
			},
			isotope: {
				type: "integer",
				minimum: 0,
				maximum: 1000
			},
			radical: {
				type: "integer",
				"enum": [
					0,
					2,
					1,
					3
				]
			},
			attachmentPoints: {
				type: "integer",
				"enum": [
					0,
					1,
					2,
					3
				]
			},
			stereoLabel: {
				type: "string",
				pattern: "(?:(?:^&|or)[0-9]+$)|(?:^abs$)"
			},
			stereoParity: {
				type: "integer",
				"enum": [
					0,
					1,
					2,
					3
				]
			},
			ringBondCount: {
				type: "integer",
				"enum": [
					0,
					-2,
					-1,
					2,
					3,
					4,
					5,
					6,
					7,
					8,
					9
				]
			},
			substitutionCount: {
				type: "integer",
				"enum": [
					0,
					-2,
					-1,
					1,
					2,
					3,
					4,
					5,
					6,
					7,
					8,
					9
				]
			},
			unsaturatedAtom: {
				type: "boolean"
			},
			hCount: {
				type: "integer",
				"enum": [
					-1,
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					7,
					8,
					9,
					10
				]
			},
			implicitHCount: {
				type: "integer",
				"enum": [
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					7,
					8,
					9
				]
			},
			mapping: {
				type: "integer",
				minimum: 0
			},
			invRet: {
				type: "integer",
				"enum": [
					0,
					1,
					2
				]
			},
			exactChangeFlag: {
				type: "boolean"
			},
			cip: {
				type: "string",
				"enum": [
					"R",
					"S",
					"r",
					"s"
				]
			},
			queryProperties: {
				type: "object",
				properties: {
					aromaticity: {
						type: "string",
						"enum": [
							"aromatic",
							"aliphatic"
						]
					},
					ringMembership: {
						type: "integer",
						minimum: 0,
						maximum: 9
					},
					ringSize: {
						type: "integer",
						minimum: 0,
						maximum: 9
					},
					connectivity: {
						type: "integer",
						minimum: 0,
						maximum: 9
					},
					chirality: {
						type: "string",
						"enum": [
							"clockwise",
							"anticlockwise"
						]
					},
					customQuery: {
						type: "string"
					}
				}
			}
		},
		additionalProperties: false
	},
	atomlist: {
		type: "object",
		required: [
			"type",
			"location"
		],
		properties: {
			type: {
				"enum": [
					"atom-list"
				]
			},
			notList: {
				type: "boolean"
			},
			location: {
				type: "array",
				minItems: 2,
				maxItems: 3,
				items: {
					type: "number"
				}
			},
			elements: {
				type: "array",
				minItems: 1,
				items: {
					type: "string",
					minLength: 1
				}
			},
			attachmentPoints: {
				type: "integer",
				"enum": [
					0,
					1,
					2,
					3
				]
			}
		}
	},
	bond: {
		type: "object",
		required: [
			"atoms"
		],
		properties: {
			atoms: {
				type: "array",
				minItems: 2,
				maxItems: 2,
				uniqueItems: true,
				items: {
					type: "integer",
					minimum: 0
				}
			},
			selected: {
				type: "boolean"
			},
			stereobox: {
				type: "integer",
				"enum": [
					0,
					1
				]
			},
			cip: {
				type: "string",
				"enum": [
					"Z",
					"E"
				]
			}
		},
		oneOf: [
			{
				required: [
					"type"
				],
				properties: {
					type: {
						type: "integer",
						"enum": [
							1,
							2,
							3,
							4,
							5,
							6,
							7,
							8,
							9,
							10,
							11,
							12
						]
					},
					stereo: {
						type: "integer",
						"enum": [
							0,
							1,
							3,
							4,
							6
						]
					},
					topology: {
						type: "integer",
						"enum": [
							0,
							1,
							2
						]
					},
					center: {
						type: "integer",
						"enum": [
							0,
							-1,
							1,
							2,
							4,
							8,
							12
						]
					}
				}
			},
			{
				required: [
					"customQuery"
				],
				properties: {
					customQuery: {
						type: "string"
					}
				}
			}
		]
	},
	rgroup: {
		type: "object",
		required: [
			"rlogic",
			"type"
		],
		properties: {
			type: {
				"const": "rgroup"
			},
			rlogic: {
				type: "object",
				required: [
					"number"
				],
				properties: {
					number: {
						type: "integer",
						minimum: 1
					},
					range: {
						type: "string",
						maxLength: 50,
						"default": ""
					},
					resth: {
						type: "boolean",
						"default": false
					},
					ifthen: {
						type: "integer",
						minimum: 0,
						"default": 0
					}
				}
			},
			fragments: {
				type: "array",
				items: {
					$ref: "#/definitions/structure"
				}
			}
		},
		anyOf: [
			{
				required: [
					"fragments"
				]
			},
			{
				$ref: "#/definitions/structure"
			}
		]
	},
	molecule: {
		type: "object",
		required: [
			"type"
		],
		properties: {
			type: {
				"const": "molecule"
			}
		},
		allOf: [
			{
				$ref: "#/definitions/structure"
			}
		]
	},
	structure: {
		type: "object",
		required: [
			"atoms"
		],
		properties: {
			stereoFlagPosition: {
				type: "object",
				required: [
					"x",
					"y"
				],
				properties: {
					x: {
						type: "number"
					},
					y: {
						type: "number"
					}
				}
			},
			properties: {
				type: "array",
				items: {
					type: "object",
					properties: {
						key: {
							type: "string"
						},
						value: {
							type: "string"
						}
					}
				}
			},
			atoms: {
				type: "array",
				items: {
					oneOf: [
						{
							$ref: "#/definitions/atom"
						},
						{
							$ref: "#/definitions/rsite"
						},
						{
							$ref: "#/definitions/atomlist"
						}
					]
				}
			},
			bonds: {
				type: "array",
				items: {
					$ref: "#/definitions/bond"
				}
			},
			highlight: {
				$ref: "#/definitions/subset"
			},
			selection: {
				$ref: "#/definitions/subset"
			},
			sgroups: {
				$ref: "#/definitions/sgroups"
			}
		}
	},
	subset: {
		type: "array",
		minItems: 1,
		maxItems: 2,
		items: {
			oneOf: [
				{
					type: "object",
					required: [
						"entityType",
						"items"
					],
					properties: {
						entityType: {
							type: "string",
							"const": "atoms"
						},
						items: {
							type: "array",
							uniqueItems: true,
							items: {
								type: "integer",
								minimum: 0
							}
						}
					}
				},
				{
					type: "object",
					required: [
						"entityType",
						"items"
					],
					properties: {
						entityType: {
							type: "string",
							"const": "bonds"
						},
						items: {
							type: "array",
							uniqueItems: true,
							items: {
								type: "integer",
								minimum: 0
							}
						}
					}
				}
			]
		}
	},
	sgroups: {
		type: "array",
		items: {
			required: [
				"atoms",
				"type"
			],
			type: "object",
			properties: {
				atoms: {
					type: "array",
					items: {
						type: "integer",
						minimum: 0
					}
				},
				type: {
					type: "string",
					"enum": [
						"GEN",
						"MUL",
						"SRU",
						"SUP",
						"DAT",
						"queryComponent"
					]
				}
			},
			"if": {
				properties: {
					type: {
						"const": "DAT"
					}
				}
			},
			then: {
				properties: {
					context: {
						"enum": [
							"Fragment",
							"Multifragment",
							"Bond",
							"Atom",
							"Group"
						]
					},
					fieldName: {
						type: "string"
					},
					fieldValue: {
						type: "string",
						minLength: 1
					},
					display: {
						type: "boolean"
					},
					placement: {
						type: "boolean"
					},
					bonds: {
						type: "array",
						items: {
							type: "integer",
							minimum: 0
						}
					}
				}
			}
		}
	},
	plus: {
		type: "object",
		required: [
			"type",
			"location"
		],
		properties: {
			type: {
				"const": "plus"
			},
			location: {
				type: "array",
				minItems: 2,
				maxItems: 3,
				items: {
					type: "number"
				}
			},
			selected: {
				type: "boolean"
			}
		}
	},
	arrow: {
		type: "object",
		required: [
			"type",
			"data"
		],
		properties: {
			type: {
				"const": "arrow"
			},
			data: {
				type: "object",
				required: [
					"mode"
				],
				properties: {
					mode: {
						type: "string"
					},
					pos: {
						type: "array",
						items: {
							type: "object",
							required: [
								"x",
								"y"
							],
							properties: {
								x: {
									type: "number"
								},
								y: {
									type: "number"
								},
								z: {
									type: "number"
								}
							}
						}
					},
					height: {
						type: "number"
					}
				}
			},
			selected: {
				type: "boolean"
			}
		}
	},
	simpleObject: {
		type: "object",
		required: [
			"type",
			"data"
		],
		properties: {
			type: {
				"const": "simpleObject"
			},
			data: {
				type: "object",
				required: [
					"mode"
				],
				properties: {
					mode: {
						type: "string",
						"enum": [
							"line",
							"rectangle",
							"circle",
							"ellipse",
							"polyline"
						]
					}
				},
				"if": {
					properties: {
						mode: {
							"const": "polyline"
						}
					}
				},
				then: {
					required: [
						"pos"
					],
					properties: {
						pos: {
							type: "array",
							minItems: 2,
							items: {
								type: "object",
								required: [
									"x",
									"y"
								],
								properties: {
									x: {
										type: "number"
									},
									y: {
										type: "number"
									},
									z: {
										type: "number"
									}
								}
							}
						}
					}
				},
				"else": {
					required: [
						"pos"
					],
					properties: {
						pos: {
							type: "array",
							minItems: 2,
							maxItems: 2,
							items: {
								type: "object",
								required: [
									"x",
									"y"
								],
								properties: {
									x: {
										type: "number"
									},
									y: {
										type: "number"
									},
									z: {
										type: "number"
									}
								}
							}
						}
					}
				}
			},
			selected: {
				type: "boolean"
			}
		}
	},
	text: {
		type: "object",
		required: [
			"type",
			"data"
		],
		properties: {
			type: {
				"const": "text"
			},
			data: {
				type: "object",
				required: [
					"content"
				],
				properties: {
					content: {
						type: "string"
					},
					pos: {
						type: "array",
						items: {
							type: "object",
							properties: {
								x: {
									type: "number"
								},
								y: {
									type: "number"
								},
								z: {
									type: "number"
								}
							}
						}
					}
				}
			},
			selected: {
				type: "boolean"
			}
		}
	}
};
var schema = {
	$schema: $schema,
	title: title,
	description: description,
	type: type,
	required: required,
	properties: properties,
	patternProperties: patternProperties,
	additionalProperties: additionalProperties,
	definitions: definitions
};

function validate(ket) {
  var validator = new lib.Validator();
  return validator.validate(ket, schema).valid;
}

var MacromoleculesConverter = function () {
  function MacromoleculesConverter() {
    _classCallCheck__default["default"](this, MacromoleculesConverter);
  }
  _createClass__default["default"](MacromoleculesConverter, null, [{
    key: "convertMonomerToMonomerMicromolecule",
    value: function convertMonomerToMonomerMicromolecule(monomer, struct) {
      var monomerMicromolecule = new MonomerMicromolecule(SGroup.TYPES.SUP, monomer);
      var sgroupId = struct.sgroups.add(monomerMicromolecule);
      monomerMicromolecule.data.name = monomer.monomerItem.label;
      monomerMicromolecule.data.expanded = false;
      monomerMicromolecule.id = sgroupId;
      monomerMicromolecule.pp = monomer.position;
      return monomerMicromolecule;
    }
  }, {
    key: "addMonomerAtomToStruct",
    value: function addMonomerAtomToStruct(atom, monomer, monomerMicromolecule, struct) {
      var atomClone = atom.clone();
      atomClone.pp = monomer.position.add(atom.pp);
      atomClone.sgs = new Pile([monomerMicromolecule.id]);
      atomClone.fragment = -1;
      var atomId = struct.atoms.add(atomClone);
      monomerMicromolecule.atoms.push(atomId);
      if (atom.rglabel) {
        monomerMicromolecule.addAttachmentPoint(new SGroupAttachmentPoint(atomId, undefined, undefined));
      }
      return {
        atomId: atomId,
        atom: atomClone
      };
    }
  }, {
    key: "convertAttachmentPointNameToNumber",
    value: function convertAttachmentPointNameToNumber(attachmentPointName) {
      return 0 | 1 << Number(attachmentPointName === null || attachmentPointName === void 0 ? void 0 : attachmentPointName.replace('R', '')) - 1;
    }
  }, {
    key: "findAttachmentPointAtom",
    value: function findAttachmentPointAtom(polymerBond, monomer, struct, sgroup, fragmentId) {
      var attachmentPointName = monomer.getAttachmentPointByBond(polymerBond);
      assert__default["default"](attachmentPointName);
      var attachmentPointNumber = MacromoleculesConverter.convertAttachmentPointNameToNumber(attachmentPointName);
      return sgroup ? sgroup.atoms.find(function (atomId) {
        var _struct$atoms$get;
        return Number((_struct$atoms$get = struct.atoms.get(atomId)) === null || _struct$atoms$get === void 0 ? void 0 : _struct$atoms$get.rglabel) === attachmentPointNumber;
      }) : struct.atoms.find(function (atomId) {
        var atom = struct.atoms.get(atomId);
        return atom.fragment === fragmentId && Number(atom.rglabel) === attachmentPointNumber;
      });
    }
  }, {
    key: "convertDrawingEntitiesToStruct",
    value: function convertDrawingEntitiesToStruct(drawingEntitiesManager, struct, reStruct) {
      var _this = this;
      var monomerToSgroup = new Map();
      var monomerToFragmentId = new Map();
      drawingEntitiesManager.micromoleculesHiddenEntities.mergeInto(struct);
      drawingEntitiesManager.clearMicromoleculesHiddenEntities();
      drawingEntitiesManager.monomers.forEach(function (monomer) {
        if (monomer.monomerItem.props.isMicromoleculeFragment) {
          monomer.monomerItem.struct.mergeInto(struct);
          monomerToFragmentId.set(monomer, struct.frags.size - 1);
        } else {
          var atomIdsMap = {};
          var monomerMicromolecule = _this.convertMonomerToMonomerMicromolecule(monomer, struct);
          monomerToSgroup.set(monomer, monomerMicromolecule);
          reStruct === null || reStruct === void 0 || reStruct.sgroups.set(monomerMicromolecule.id, new ReSGroup(monomerMicromolecule));
          monomer.monomerItem.struct.atoms.forEach(function (oldAtom, oldAtomId) {
            var _this$addMonomerAtomT = _this.addMonomerAtomToStruct(oldAtom, monomer, monomerMicromolecule, struct),
              atom = _this$addMonomerAtomT.atom,
              atomId = _this$addMonomerAtomT.atomId;
            atomIdsMap[oldAtomId] = atomId;
            reStruct === null || reStruct === void 0 || reStruct.atoms.set(atomId, new ReAtom(atom));
          });
          struct.sGroupForest.insert(monomerMicromolecule);
          monomer.monomerItem.struct.bonds.forEach(function (bond) {
            var bondClone = bond.clone();
            bondClone.begin = atomIdsMap[bondClone.begin];
            bondClone.end = atomIdsMap[bondClone.end];
            var bondId = struct.bonds.add(bondClone);
            reStruct === null || reStruct === void 0 || reStruct.bonds.set(bondId, new ReBond(bondClone));
          });
          struct.functionalGroups.add(new FunctionalGroup(monomerMicromolecule));
        }
      });
      var conversionErrorMessage = '';
      drawingEntitiesManager.polymerBonds.forEach(function (polymerBond) {
        assert__default["default"](polymerBond.secondMonomer);
        var beginAtom = _this.findAttachmentPointAtom(polymerBond, polymerBond.firstMonomer, struct, monomerToSgroup.get(polymerBond.firstMonomer), monomerToFragmentId.get(polymerBond.firstMonomer));
        var endAtom = _this.findAttachmentPointAtom(polymerBond, polymerBond.secondMonomer, struct, monomerToSgroup.get(polymerBond.secondMonomer), monomerToFragmentId.get(polymerBond.secondMonomer));
        if (!beginAtom || !endAtom) {
          conversionErrorMessage = 'There is no atom for provided attachment point. Bond between monomers was not created.';
          return;
        }
        var bond = new Bond({
          type: Bond.PATTERN.TYPE.SINGLE,
          begin: beginAtom,
          end: endAtom
        });
        var bondId = struct.bonds.add(bond);
        reStruct === null || reStruct === void 0 || reStruct.bonds.set(bondId, new ReBond(bond));
      });
      return {
        struct: struct,
        reStruct: reStruct,
        conversionErrorMessage: conversionErrorMessage
      };
    }
  }, {
    key: "convertMonomerMicromoleculeToMonomer",
    value: function convertMonomerMicromoleculeToMonomer(monomerMicromolecule, drawingEntitiesManager, sgroupToMonomer) {
      var command = new Command();
      var monomerAdditionCommand = drawingEntitiesManager.addMonomer(monomerMicromolecule.monomer.monomerItem, monomerMicromolecule.pp);
      command.merge(monomerAdditionCommand);
      sgroupToMonomer.set(monomerMicromolecule, monomerAdditionCommand.operations[0].monomer);
      return command;
    }
  }, {
    key: "convertFragmentToChem",
    value: function convertFragmentToChem(fragmentNumber, fragmentStruct, drawingEntitiesManager) {
      var fragmentBbox = fragmentStruct.getCoordBoundingBox();
      return drawingEntitiesManager.addMonomer({
        struct: fragmentStruct,
        label: 'F' + fragmentNumber,
        colorScheme: undefined,
        favorite: false,
        props: {
          Name: 'F' + fragmentNumber,
          MonomerNaturalAnalogCode: '',
          MonomerName: 'F' + fragmentNumber,
          MonomerType: MONOMER_CONST.CHEM,
          isMicromoleculeFragment: true
        }
      }, new Vec2(fragmentBbox.max.x - (fragmentBbox.max.x - fragmentBbox.min.x) / 2, fragmentBbox.max.y - (fragmentBbox.max.y - fragmentBbox.min.y) / 2));
    }
  }, {
    key: "getAttachmentPointLabel",
    value: function getAttachmentPointLabel(atom) {
      var attachmentPointLabel = '';
      var atomRglabel = Number(atom.rglabel);
      assert__default["default"](Number.isInteger(atomRglabel));
      for (var rgi = 0; rgi < 32; rgi++) {
        if (atomRglabel & 1 << rgi) {
          attachmentPointLabel = 'R' + (rgi + 1).toString();
        }
      }
      return attachmentPointLabel;
    }
  }, {
    key: "getFragmentsGroupedBySgroup",
    value: function getFragmentsGroupedBySgroup(struct) {
      var groupedFragments = [];
      struct.frags.forEach(function (_fragment, fragmentId) {
        var isAlreadyGrouped = groupedFragments.find(function (fragmentsGroup) {
          return fragmentsGroup.includes(fragmentId);
        });
        if (isAlreadyGrouped) {
          return;
        }
        var fragmentSgroups = new Set();
        struct.atoms.forEach(function (atom, atomId) {
          if (atom.fragment !== fragmentId) return;
          var sgroup = struct.getGroupFromAtomId(atomId);
          if (sgroup) {
            fragmentSgroups.add(sgroup);
          }
        });
        var lastFragmentGroupIndex = groupedFragments.push([fragmentId]) - 1;
        fragmentSgroups.forEach(function (sgroup) {
          sgroup.atoms.forEach(function (aid) {
            var _struct$atoms$get2;
            var atomFragmentId = (_struct$atoms$get2 = struct.atoms.get(aid)) === null || _struct$atoms$get2 === void 0 ? void 0 : _struct$atoms$get2.fragment;
            if (atomFragmentId && !groupedFragments[lastFragmentGroupIndex].includes(atomFragmentId)) {
              groupedFragments[lastFragmentGroupIndex].push(atomFragmentId);
            }
          });
        });
      });
      return groupedFragments;
    }
  }, {
    key: "convertStructToDrawingEntities",
    value: function convertStructToDrawingEntities(struct, drawingEntitiesManager) {
      var _this2 = this;
      var sgroupToMonomer = new Map();
      var fragmentIdToMonomer = new Map();
      var command = new Command();
      struct.sgroups.forEach(function (sgroup) {
        if (sgroup instanceof MonomerMicromolecule) {
          command.merge(_this2.convertMonomerMicromoleculeToMonomer(sgroup, drawingEntitiesManager, sgroupToMonomer));
        }
      });
      var fragments = this.getFragmentsGroupedBySgroup(struct);
      var fragmentNumber = 1;
      fragments.forEach(function (_fragment, fragmentId) {
        var fragmentStruct = struct.getFragment(_fragment, false);
        var monomerAddCommand = _this2.convertFragmentToChem(fragmentNumber, fragmentStruct, drawingEntitiesManager);
        fragmentIdToMonomer.set(fragmentId, monomerAddCommand.operations[0].monomer);
        command.merge(monomerAddCommand);
        fragmentNumber++;
      });
      struct.bonds.forEach(function (bond) {
        var beginAtom = struct.atoms.get(bond.begin);
        var endAtom = struct.atoms.get(bond.end);
        var beginAtomSgroup = struct.getGroupFromAtomId(bond.begin);
        var endAtomSgroup = struct.getGroupFromAtomId(bond.end);
        var beginAtomAttachmentPointNumber = MacromoleculesConverter.getAttachmentPointLabel(beginAtom);
        var endAtomAttachmentPointNumber = MacromoleculesConverter.getAttachmentPointLabel(endAtom);
        if (beginAtomAttachmentPointNumber && endAtomAttachmentPointNumber && (beginAtomSgroup || endAtomSgroup)) {
          var firstMonomer = beginAtomSgroup instanceof MonomerMicromolecule ? sgroupToMonomer.get(beginAtomSgroup) : fragmentIdToMonomer.get(beginAtom.fragment);
          var secondMonomer = endAtomSgroup instanceof MonomerMicromolecule ? sgroupToMonomer.get(endAtomSgroup) : fragmentIdToMonomer.get(endAtom.fragment);
          assert__default["default"](firstMonomer);
          assert__default["default"](secondMonomer);
          command.merge(drawingEntitiesManager.createPolymerBond(firstMonomer, secondMonomer, beginAtomAttachmentPointNumber, endAtomAttachmentPointNumber));
        }
      });
      drawingEntitiesManager.setMicromoleculesHiddenEntities(struct);
      return {
        drawingEntitiesManager: drawingEntitiesManager,
        modelChanges: command
      };
    }
  }]);
  return MacromoleculesConverter;
}();

function ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function parseNode(node, struct) {
  var type = node.type;
  switch (type) {
    case 'arrow':
      {
        rxnToStruct(node, struct);
        break;
      }
    case 'plus':
      {
        rxnToStruct(node, struct);
        break;
      }
    case 'simpleObject':
      {
        simpleObjectToStruct(node, struct);
        break;
      }
    case 'molecule':
      {
        var currentStruct = moleculeToStruct(node);
        if (node.stereoFlagPosition) {
          var fragment = currentStruct.frags.get(0);
          fragment.stereoFlagPosition = new Vec2(node.stereoFlagPosition);
        }
        currentStruct.mergeInto(struct);
        break;
      }
    case 'rgroup':
      {
        rgroupToStruct(node).mergeInto(struct);
        break;
      }
    case 'text':
      {
        textToStruct(node, struct);
        break;
      }
  }
}
var KetSerializer = function () {
  function KetSerializer() {
    _classCallCheck__default["default"](this, KetSerializer);
  }
  _createClass__default["default"](KetSerializer, [{
    key: "deserializeMicromolecules",
    value: function deserializeMicromolecules(content) {
      var ket = JSON.parse(content);
      if (!validate(ket)) {
        throw new Error('Cannot deserialize input JSON.');
      }
      return this.fillStruct(ket);
    }
  }, {
    key: "fillStruct",
    value: function fillStruct(ket) {
      var resultingStruct = new Struct();
      var nodes = ket.root.nodes;
      Object.keys(nodes).forEach(function (i) {
        if (nodes[i].type) parseNode(nodes[i], resultingStruct);else if (nodes[i].$ref) parseNode(ket[nodes[i].$ref], resultingStruct);
      });
      resultingStruct.name = ket.header ? ket.header.moleculeName : null;
      return resultingStruct;
    }
  }, {
    key: "serializeMicromolecules",
    value: function serializeMicromolecules(struct, monomer) {
      var result = {
        root: {
          nodes: []
        }
      };
      var header = headerToKet(struct);
      if (header) result.header = header;
      var ketNodes = prepareStructForKet(struct);
      var moleculeId = 0;
      ketNodes.forEach(function (item) {
        switch (item.type) {
          case 'molecule':
            {
              result.root.nodes.push({
                $ref: "mol".concat(moleculeId)
              });
              result["mol".concat(moleculeId++)] = moleculeToKet(item.fragment, monomer);
              break;
            }
          case 'rgroup':
            {
              result.root.nodes.push({
                $ref: "rg".concat(item.data.rgnumber)
              });
              result["rg".concat(item.data.rgnumber)] = rgroupToKet(item.fragment, item.data);
              break;
            }
          case 'plus':
            {
              result.root.nodes.push(plusToKet(item));
              break;
            }
          case 'arrow':
            {
              result.root.nodes.push(arrowToKet(item));
              break;
            }
          case 'simpleObject':
            {
              result.root.nodes.push(simpleObjectToKet(item));
              break;
            }
          case 'text':
            {
              result.root.nodes.push(textToKet(item));
              break;
            }
        }
      });
      return JSON.stringify(result, null, 4);
    }
  }, {
    key: "validateMonomerNodeTemplate",
    value: function validateMonomerNodeTemplate(node, parsedFileContent, editor) {
      var template = parsedFileContent[setMonomerTemplatePrefix(node.templateId)];
      if (!template) {
        editor.events.error.dispatch('Error during file parsing');
        return true;
      }
      return false;
    }
  }, {
    key: "validateConnectionTypeAndEndpoints",
    value: function validateConnectionTypeAndEndpoints(connection, editor) {
      if (connection.connectionType !== 'single' || !connection.endpoint1.monomerId || !connection.endpoint2.monomerId || !connection.endpoint1.attachmentPointId || !connection.endpoint2.attachmentPointId) {
        editor.events.error.dispatch('Error during file parsing');
        return true;
      }
      return false;
    }
  }, {
    key: "parseAndValidateMacromolecules",
    value: function parseAndValidateMacromolecules(fileContent) {
      var _this = this,
        _parsedFileContent$ro;
      var editor = CoreEditor.provideEditorInstance();
      var parsedFileContent;
      try {
        parsedFileContent = JSON.parse(fileContent);
      } catch (e) {
        KetcherLogger.error('ketSerializer.ts::KetSerializer::parseAndValidateMacromolecules', e);
        return {
          error: true
        };
      }
      var error = false;
      parsedFileContent.root.nodes.forEach(function (node) {
        var nodeDefinition = parsedFileContent[node.$ref];
        if ((nodeDefinition === null || nodeDefinition === void 0 ? void 0 : nodeDefinition.type) === 'monomer') {
          error = _this.validateMonomerNodeTemplate(nodeDefinition, parsedFileContent, editor);
        }
      });
      if (error) {
        return {
          error: true
        };
      }
      (_parsedFileContent$ro = parsedFileContent.root.connections) === null || _parsedFileContent$ro === void 0 || _parsedFileContent$ro.forEach(function (connection) {
        _this.validateConnectionTypeAndEndpoints(connection, editor);
      });
      return {
        error: error,
        parsedFileContent: parsedFileContent
      };
    }
  }, {
    key: "deserializeToStruct",
    value: function deserializeToStruct(fileContent) {
      var struct = new Struct();
      var deserializedContent = this.deserializeToDrawingEntities(fileContent);
      assert__default["default"](deserializedContent);
      MacromoleculesConverter.convertDrawingEntitiesToStruct(deserializedContent === null || deserializedContent === void 0 ? void 0 : deserializedContent.drawingEntitiesManager, struct);
      return struct;
    }
  }, {
    key: "filterMacromoleculesContent",
    value: function filterMacromoleculesContent(parsedFileContent) {
      var _parsedFileContent$ro2;
      var fileContentForMicromolecules = _objectSpread$c(_objectSpread$c({}, parsedFileContent), {}, {
        root: {
          nodes: parsedFileContent.root.nodes.filter(function (node) {
            var nodeDefinition = parsedFileContent[node.$ref];
            return (nodeDefinition === null || nodeDefinition === void 0 ? void 0 : nodeDefinition.type) !== 'monomer' && (nodeDefinition === null || nodeDefinition === void 0 ? void 0 : nodeDefinition.type) !== 'group';
          })
        }
      });
      parsedFileContent.root.nodes.forEach(function (node) {
        var nodeDefinition = parsedFileContent[node.$ref];
        if ((nodeDefinition === null || nodeDefinition === void 0 ? void 0 : nodeDefinition.type) === 'monomer' || (nodeDefinition === null || nodeDefinition === void 0 ? void 0 : nodeDefinition.type) === 'group') {
          fileContentForMicromolecules[node.$ref] = undefined;
        }
      });
      (_parsedFileContent$ro2 = parsedFileContent.root.templates) === null || _parsedFileContent$ro2 === void 0 || _parsedFileContent$ro2.forEach(function (template) {
        fileContentForMicromolecules[template.$ref] = undefined;
      });
      return fileContentForMicromolecules;
    }
  }, {
    key: "deserializeToDrawingEntities",
    value: function deserializeToDrawingEntities(fileContent) {
      var _this2 = this,
        _parsedFileContent$ro3;
      var _this$parseAndValidat = this.parseAndValidateMacromolecules(fileContent),
        hasValidationErrors = _this$parseAndValidat.error,
        parsedFileContent = _this$parseAndValidat.parsedFileContent;
      if (hasValidationErrors || !parsedFileContent) return;
      var command = new Command();
      var drawingEntitiesManager = new DrawingEntitiesManager();
      var monomerIdsMap = {};
      parsedFileContent.root.nodes.forEach(function (node) {
        var nodeDefinition = parsedFileContent[node.$ref];
        switch (nodeDefinition === null || nodeDefinition === void 0 ? void 0 : nodeDefinition.type) {
          case 'monomer':
            {
              var _template$attachmentP;
              var template = parsedFileContent[setMonomerTemplatePrefix(nodeDefinition.templateId)];
              assert__default["default"](template);
              var struct = _this2.fillStruct({
                root: {
                  nodes: [{
                    $ref: 'mol0'
                  }]
                },
                mol0: _objectSpread$c(_objectSpread$c({}, template), {}, {
                  type: 'molecule'
                }),
                header: {
                  moleculeName: template.fullName
                }
              });
              var monomerAdditionCommand = monomerToDrawingEntity(nodeDefinition, template, struct, drawingEntitiesManager);
              var monomer = monomerAdditionCommand.operations[0].monomer;
              monomerIdsMap[node.$ref] = monomer === null || monomer === void 0 ? void 0 : monomer.id;
              var _BaseMonomer$getAttac = BaseMonomer.getAttachmentPointDictFromMonomerDefinition(template.attachmentPoints || []),
                attachmentPointsList = _BaseMonomer$getAttac.attachmentPointsList;
              (_template$attachmentP = template.attachmentPoints) === null || _template$attachmentP === void 0 || _template$attachmentP.forEach(function (attachmentPoint, attachmentPointIndex) {
                var _attachmentPoint$leav;
                var firstAtomInLeavingGroup = (_attachmentPoint$leav = attachmentPoint.leavingGroup) === null || _attachmentPoint$leav === void 0 ? void 0 : _attachmentPoint$leav.atoms[0];
                var leavingGroupAtom = monomer.monomerItem.struct.atoms.get(_.isNumber(firstAtomInLeavingGroup) ? firstAtomInLeavingGroup : attachmentPoint.attachmentAtom);
                assert__default["default"](leavingGroupAtom);
                leavingGroupAtom.rglabel = (0 | 1 << Number((attachmentPoint.label ? attachmentPoint.label : attachmentPointsList[attachmentPointIndex]).replace('R', '')) - 1).toString();
                assert__default["default"](monomer.monomerItem.props.MonomerCaps);
                monomer.monomerItem.props.MonomerCaps[convertAttachmentPointNumberToLabel(Number(leavingGroupAtom.rglabel))] = leavingGroupAtom.label;
                leavingGroupAtom.label = 'R#';
              });
              command.merge(monomerAdditionCommand);
              break;
            }
        }
      });
      var fileContentForMicromolecules = this.filterMacromoleculesContent(parsedFileContent);
      var deserializedMicromolecules = this.deserializeMicromolecules(JSON.stringify(fileContentForMicromolecules));
      var fragmentNumber = 1;
      var fragments = MacromoleculesConverter.getFragmentsGroupedBySgroup(deserializedMicromolecules);
      fragments.forEach(function (_fragment) {
        var fragmentStruct = deserializedMicromolecules.getFragment(_fragment, false);
        var fragmentBbox = fragmentStruct.getCoordBoundingBox();
        var monomerAdditionCommand = drawingEntitiesManager.addMonomer({
          struct: fragmentStruct,
          label: 'F' + fragmentNumber,
          colorScheme: undefined,
          favorite: false,
          props: {
            Name: 'F' + fragmentNumber,
            MonomerNaturalAnalogCode: '',
            MonomerName: 'F' + fragmentNumber,
            MonomerType: MONOMER_CONST.CHEM,
            isMicromoleculeFragment: true
          }
        }, new Vec2(fragmentBbox.max.x - (fragmentBbox.max.x - fragmentBbox.min.x) / 2, fragmentBbox.max.y - (fragmentBbox.max.y - fragmentBbox.min.y) / 2));
        command.merge(monomerAdditionCommand);
        fragmentNumber++;
      });
      (_parsedFileContent$ro3 = parsedFileContent.root.connections) === null || _parsedFileContent$ro3 === void 0 || _parsedFileContent$ro3.forEach(function (connection) {
        switch (connection.connectionType) {
          case 'single':
            {
              var bondAdditionCommand = polymerBondToDrawingEntity(connection, drawingEntitiesManager, monomerIdsMap);
              command.merge(bondAdditionCommand);
              break;
            }
        }
      });
      drawingEntitiesManager.setMicromoleculesHiddenEntities(deserializedMicromolecules);
      return {
        modelChanges: command,
        drawingEntitiesManager: drawingEntitiesManager
      };
    }
  }, {
    key: "deserialize",
    value: function deserialize(fileContent) {
      return this.deserializeToStruct(fileContent);
    }
  }, {
    key: "serializeMacromolecules",
    value: function serializeMacromolecules(struct, drawingEntitiesManager) {
      var _this3 = this;
      var fileContent = {
        root: {
          nodes: [],
          connections: [],
          templates: []
        }
      };
      drawingEntitiesManager.monomers.forEach(function (monomer) {
        if (monomer instanceof Chem && monomer.monomerItem.props.isMicromoleculeFragment) {
          monomer.monomerItem.struct.mergeInto(struct);
        } else {
          var templateId = monomer.monomerItem.props.id || getMonomerUniqueKey(monomer.monomerItem);
          var monomerName = setMonomerPrefix(monomer.id);
          var position = switchIntoChemistryCoordSystem(new Vec2(monomer.position.x, monomer.position.y));
          fileContent[monomerName] = {
            type: 'monomer',
            id: monomer.id.toString(),
            position: {
              x: position.x,
              y: position.y
            },
            alias: monomer.label,
            templateId: templateId,
            seqid: monomer.monomerItem.seqId
          };
          fileContent.root.nodes.push(getKetRef(monomerName));
          var _monomerFactory = monomerFactory(monomer.monomerItem),
            _monomerFactory2 = _slicedToArray__default["default"](_monomerFactory, 3),
            monomerClass = _monomerFactory2[2];
          var templateNameWithPrefix = setMonomerTemplatePrefix(templateId);
          if (!fileContent[templateNameWithPrefix]) {
            fileContent[templateNameWithPrefix] = _objectSpread$c(_objectSpread$c({}, JSON.parse(_this3.serializeMicromolecules(monomer.monomerItem.struct, monomer)).mol0), {}, {
              type: 'monomerTemplate',
              "class": monomer.monomerItem.props.MonomerClass || monomerClass,
              classHELM: monomer.monomerItem.props.MonomerType,
              id: templateId,
              fullName: monomer.monomerItem.props.Name,
              alias: monomer.monomerItem.label,
              attachmentPoints: monomer.monomerItem.attachmentPoints
            });
            if (monomer.monomerItem.props.MonomerType !== 'CHEM') {
              fileContent[templateNameWithPrefix].naturalAnalogShort = monomer.monomerItem.props.MonomerNaturalAnalogCode;
            }
            fileContent.root.templates.push(getKetRef(templateNameWithPrefix));
          }
        }
      });
      drawingEntitiesManager.polymerBonds.forEach(function (polymerBond) {
        var _polymerBond$secondMo;
        assert__default["default"](polymerBond.secondMonomer);
        if (polymerBond.firstMonomer.monomerItem.props.isMicromoleculeFragment || polymerBond.secondMonomer.monomerItem.props.isMicromoleculeFragment) {
          return;
        }
        fileContent.root.connections.push({
          connectionType: 'single',
          endpoint1: {
            monomerId: setMonomerPrefix(polymerBond.firstMonomer.id),
            attachmentPointId: polymerBond.firstMonomer.getAttachmentPointByBond(polymerBond)
          },
          endpoint2: {
            monomerId: setMonomerPrefix(polymerBond.secondMonomer.id),
            attachmentPointId: (_polymerBond$secondMo = polymerBond.secondMonomer) === null || _polymerBond$secondMo === void 0 ? void 0 : _polymerBond$secondMo.getAttachmentPointByBond(polymerBond)
          }
        });
      });
      drawingEntitiesManager.micromoleculesHiddenEntities.mergeInto(struct);
      return {
        serializedMacromolecules: fileContent,
        micromoleculesStruct: struct
      };
    }
  }, {
    key: "serialize",
    value: function serialize(struct) {
      var drawingEntitiesManager = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new DrawingEntitiesManager();
      var selection = arguments.length > 2 ? arguments[2] : undefined;
      struct.enableInitiallySelected();
      var populatedStruct = populateStructWithSelection(struct, selection);
      MacromoleculesConverter.convertStructToDrawingEntities(populatedStruct, drawingEntitiesManager);
      var _this$serializeMacrom = this.serializeMacromolecules(new Struct(), drawingEntitiesManager),
        serializedMacromolecules = _this$serializeMacrom.serializedMacromolecules,
        micromoleculesStruct = _this$serializeMacrom.micromoleculesStruct;
      var serializedMicromoleculesStruct = JSON.parse(this.serializeMicromolecules(micromoleculesStruct));
      micromoleculesStruct.disableInitiallySelected();
      var fileContent = _objectSpread$c(_objectSpread$c({}, serializedMicromoleculesStruct), serializedMacromolecules);
      fileContent.root.nodes = [].concat(_toConsumableArray__default["default"](serializedMacromolecules.root.nodes), _toConsumableArray__default["default"](serializedMicromoleculesStruct.root.nodes));
      return JSON.stringify(fileContent, null, 4);
    }
  }]);
  return KetSerializer;
}();

function paddedNum(number, width, precision) {
  number = parseFloat(number);
  var numStr = number.toFixed(precision || 0).replace(',', '.');
  if (numStr.length > width) throw new Error('number does not fit');
  return numStr.padStart(width);
}
function parseDecimalInt(str) {
  var val = parseInt(str, 10);
  return isNaN(val) ? 0 : val;
}
function partitionLine$1( str, parts, withspace) {
  var res = [];
  for (var i = 0, shift = 0; i < parts.length; ++i) {
    res.push(str.slice(shift, shift + parts[i]));
    if (withspace) shift++;
    shift += parts[i];
  }
  return res;
}
function partitionLineFixed( str, itemLength, withspace) {
  var res = [];
  for (var shift = 0; shift < str.length; shift += itemLength) {
    res.push(str.slice(shift, shift + itemLength));
    if (withspace) shift++;
  }
  return res;
}
var fmtInfo = {
  bondTypeMap: {
    1: Bond.PATTERN.TYPE.SINGLE,
    2: Bond.PATTERN.TYPE.DOUBLE,
    3: Bond.PATTERN.TYPE.TRIPLE,
    4: Bond.PATTERN.TYPE.AROMATIC,
    5: Bond.PATTERN.TYPE.SINGLE_OR_DOUBLE,
    6: Bond.PATTERN.TYPE.SINGLE_OR_AROMATIC,
    7: Bond.PATTERN.TYPE.DOUBLE_OR_AROMATIC,
    8: Bond.PATTERN.TYPE.ANY,
    9: Bond.PATTERN.TYPE.DATIVE,
    10: Bond.PATTERN.TYPE.HYDROGEN
  },
  bondStereoMap: {
    0: Bond.PATTERN.STEREO.NONE,
    1: Bond.PATTERN.STEREO.UP,
    4: Bond.PATTERN.STEREO.EITHER,
    6: Bond.PATTERN.STEREO.DOWN,
    3: Bond.PATTERN.STEREO.CIS_TRANS
  },
  v30bondStereoMap: {
    0: Bond.PATTERN.STEREO.NONE,
    1: Bond.PATTERN.STEREO.UP,
    2: Bond.PATTERN.STEREO.EITHER,
    3: Bond.PATTERN.STEREO.DOWN
  },
  bondTopologyMap: {
    0: Bond.PATTERN.TOPOLOGY.EITHER,
    1: Bond.PATTERN.TOPOLOGY.RING,
    2: Bond.PATTERN.TOPOLOGY.CHAIN
  },
  countsLinePartition: [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 6],
  atomLinePartition: [10, 10, 10, 1, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
  bondLinePartition: [3, 3, 3, 3, 3, 3, 3],
  atomListHeaderPartition: [3, 1, 1, 4, 1, 1],
  atomListHeaderLength: 11,
  atomListHeaderItemLength: 4,
  chargeMap: [null, +3, +2, +1, null, -1, -2, -3],
  valenceMap: [undefined, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0],
  implicitHydrogenMap: [undefined, 0, 1, 2, 3, 4],
  v30atomPropMap: {
    CHG: 'charge',
    RAD: 'radical',
    MASS: 'isotope',
    VAL: 'explicitValence',
    HCOUNT: 'hCount',
    INVRET: 'invRet',
    SUBST: 'substitutionCount',
    UNSAT: 'unsaturatedAtom',
    RBCNT: 'ringBondCount'
  },
  rxnItemsPartition: [3, 3, 3]
};
var FRAGMENT = {
  NONE: 0,
  REACTANT: 1,
  PRODUCT: 2,
  AGENT: 3
};
function rxnMerge(mols, nReactants, nProducts, nAgents, shouldReactionRelayout) {
  var ret = new Struct();
  var bbReact = [];
  var bbAgent = [];
  var bbProd = [];
  var molReact = [];
  var molAgent = [];
  var molProd = [];
  var j;
  var bondLengthData = {
    cnt: 0,
    totalLength: 0
  };
  for (j = 0; j < mols.length; ++j) {
    var mol = mols[j];
    var bondLengthDataMol = mol.getBondLengthData();
    bondLengthData.cnt += bondLengthDataMol.cnt;
    bondLengthData.totalLength += bondLengthDataMol.totalLength;
  }
  {
    var avgBondLength = 1 / (bondLengthData.cnt === 0 ? 1 : bondLengthData.totalLength / bondLengthData.cnt);
    for (j = 0; j < mols.length; ++j) {
      mol = mols[j];
      mol.scale(avgBondLength);
    }
  }
  for (j = 0; j < mols.length; ++j) {
    mol = mols[j];
    var bb = mol.getCoordBoundingBoxObj();
    if (!bb) continue;
    var fragmentType = j < nReactants ? FRAGMENT.REACTANT
    : j < nReactants + nProducts ? FRAGMENT.PRODUCT : FRAGMENT.AGENT;
    if (fragmentType === FRAGMENT.REACTANT) {
      bbReact.push(bb);
      molReact.push(mol);
    } else if (fragmentType === FRAGMENT.AGENT) {
      bbAgent.push(bb);
      molAgent.push(mol);
    } else if (fragmentType === FRAGMENT.PRODUCT) {
      bbProd.push(bb);
      molProd.push(mol);
    }
    mol.atoms.forEach(function (atom) {
      atom.rxnFragmentType = fragmentType;
    });
  }
  function shiftMol(ret, mol, bb, xorig, over) {
    var d = new Vec2(xorig - bb.min.x, over ? 1 - bb.min.y : -(bb.min.y + bb.max.y) / 2);
    mol.atoms.forEach(function (atom) {
      atom.pp.add_(d);
    });
    mol.sgroups.forEach(function (item) {
      if (item.pp) item.pp.add_(d);
    });
    bb.min.add_(d);
    bb.max.add_(d);
    mol.mergeInto(ret);
    return bb.max.x - bb.min.x;
  }
  if (shouldReactionRelayout) {
    var xorig = 0;
    for (j = 0; j < molReact.length; ++j) {
      xorig += shiftMol(ret, molReact[j], bbReact[j], xorig, false) + 2.0;
    }
    xorig += 2.0;
    for (j = 0; j < molAgent.length; ++j) {
      xorig += shiftMol(ret, molAgent[j], bbAgent[j], xorig, true) + 2.0;
    }
    xorig += 2.0;
    for (j = 0; j < molProd.length; ++j) {
      xorig += shiftMol(ret, molProd[j], bbProd[j], xorig, false) + 2.0;
    }
  } else {
    for (j = 0; j < molReact.length; ++j) molReact[j].mergeInto(ret);
    for (j = 0; j < molAgent.length; ++j) molAgent[j].mergeInto(ret);
    for (j = 0; j < molProd.length; ++j) molProd[j].mergeInto(ret);
  }
  var bb1;
  var bb2;
  var x;
  var y;
  var bbReactAll = null;
  var bbProdAll = null;
  for (j = 0; j < bbReact.length - 1; ++j) {
    bb1 = bbReact[j];
    bb2 = bbReact[j + 1];
    x = (bb1.max.x + bb2.min.x) / 2;
    y = (bb1.max.y + bb1.min.y + bb2.max.y + bb2.min.y) / 4;
    ret.rxnPluses.add(new RxnPlus({
      pp: new Vec2(x, y)
    }));
  }
  for (j = 0; j < bbReact.length; ++j) {
    if (j === 0) {
      bbReactAll = {};
      bbReactAll.max = new Vec2(bbReact[j].max);
      bbReactAll.min = new Vec2(bbReact[j].min);
    } else {
      bbReactAll.max = Vec2.max(bbReactAll.max, bbReact[j].max);
      bbReactAll.min = Vec2.min(bbReactAll.min, bbReact[j].min);
    }
  }
  for (j = 0; j < bbProd.length - 1; ++j) {
    bb1 = bbProd[j];
    bb2 = bbProd[j + 1];
    x = (bb1.max.x + bb2.min.x) / 2;
    y = (bb1.max.y + bb1.min.y + bb2.max.y + bb2.min.y) / 4;
    ret.rxnPluses.add(new RxnPlus({
      pp: new Vec2(x, y)
    }));
  }
  for (j = 0; j < bbProd.length; ++j) {
    if (j === 0) {
      bbProdAll = {};
      bbProdAll.max = new Vec2(bbProd[j].max);
      bbProdAll.min = new Vec2(bbProd[j].min);
    } else {
      bbProdAll.max = Vec2.max(bbProdAll.max, bbProd[j].max);
      bbProdAll.min = Vec2.min(bbProdAll.min, bbProd[j].min);
    }
  }
  bb1 = bbReactAll;
  bb2 = bbProdAll;
  var defaultArrowLength = 2;
  if (!bb1 && !bb2) {
    ret.rxnArrows.add(new RxnArrow({
      mode: 'open-angle',
      pos: [new Vec2(0, 0), new Vec2(defaultArrowLength, 0)]
    }));
  } else {
    var v1 = bb1 ? new Vec2(bb1.max.x, (bb1.max.y + bb1.min.y) / 2) : null;
    var v2 = bb2 ? new Vec2(bb2.min.x, (bb2.max.y + bb2.min.y) / 2) : null;
    var defaultOffset = 3;
    if (!v1) v1 = new Vec2(v2.x - defaultOffset, v2.y);
    if (!v2) v2 = new Vec2(v1.x + defaultOffset, v1.y);
    var arrowCenter = Vec2.lc2(v1, 0.5, v2, 0.5);
    var arrowStart = new Vec2(arrowCenter.x - 0.5 * defaultArrowLength, arrowCenter.y, arrowCenter.z);
    var arrowEnd = new Vec2(arrowCenter.x + 0.5 * defaultArrowLength, arrowCenter.y, arrowCenter.z);
    ret.rxnArrows.add(new RxnArrow({
      mode: 'open-angle',
      pos: [arrowStart, arrowEnd]
    }));
  }
  ret.isReaction = true;
  return ret;
}
function rgMerge(scaffold, rgroups) {
  var ret = new Struct();
  scaffold.mergeInto(ret, null, null, false, true);
  Object.keys(rgroups).forEach(function (id) {
    var rgid = parseInt(id, 10);
    var _loop = function _loop() {
      var ctab = rgroups[rgid][j];
      ctab.rgroups.set(rgid, new RGroup());
      var frag = new Fragment();
      var frid = ctab.frags.add(frag);
      ctab.rgroups.get(rgid).frags.add(frid);
      ctab.atoms.forEach(function (atom) {
        atom.fragment = frid;
      });
      ctab.mergeInto(ret);
    };
    for (var j = 0; j < rgroups[rgid].length; ++j) {
      _loop();
    }
  });
  return ret;
}
var utils = {
  fmtInfo: fmtInfo,
  paddedNum: paddedNum,
  parseDecimalInt: parseDecimalInt,
  partitionLine: partitionLine$1,
  partitionLineFixed: partitionLineFixed,
  rxnMerge: rxnMerge,
  rgMerge: rgMerge
};

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }
function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function readKeyValuePairs(str, valueString) {
  var ret = new Pool();
  var partition = utils.partitionLineFixed(str, 3, true);
  var count = utils.parseDecimalInt(partition[0]);
  for (var i = 0; i < count; ++i) {
    var key = utils.parseDecimalInt(partition[2 * i + 1]) - 1;
    var value = valueString ? partition[2 * i + 2].trim() : utils.parseDecimalInt(partition[2 * i + 2]);
    ret.set(key, value);
  }
  return ret;
}
function readKeyMultiValuePairs(str, valueString) {
  var ret = [];
  var partition = utils.partitionLineFixed(str, 3, true);
  var count = utils.parseDecimalInt(partition[0]);
  for (var i = 0; i < count; ++i) {
    ret.push([
    utils.parseDecimalInt(partition[2 * i + 1]) - 1, valueString ? partition[2 * i + 2].trim() : utils.parseDecimalInt(partition[2 * i + 2])
    ]);
  }
  return ret;
}
function postLoadMul(sgroup, mol, atomMap) {
  sgroup.data.mul = sgroup.data.subscript - 0;
  var atomReductionMap = {};
  sgroup.atoms = SGroup.filterAtoms(sgroup.atoms, atomMap);
  sgroup.patoms = SGroup.filterAtoms(sgroup.patoms, atomMap);
  for (var k = 1; k < sgroup.data.mul; ++k) {
    for (var m = 0; m < sgroup.patoms.length; ++m) {
      var raid = sgroup.atoms[k * sgroup.patoms.length + m];
      if (raid < 0) continue;
      if (sgroup.patoms[m] < 0) throw new Error('parent atom missing');
      atomReductionMap[raid] = sgroup.patoms[m];
    }
  }
  sgroup.patoms = SGroup.removeNegative(sgroup.patoms);
  var patomsMap = identityMap(sgroup.patoms);
  var bondsToRemove = [];
  mol.bonds.forEach(function (bond, bid) {
    var beginIn = (bond.begin in atomReductionMap);
    var endIn = (bond.end in atomReductionMap);
    if (beginIn && endIn || beginIn && bond.end in patomsMap || endIn && bond.begin in patomsMap) {
      bondsToRemove.push(bid);
    }
    else if (beginIn) bond.begin = atomReductionMap[bond.begin];else if (endIn) bond.end = atomReductionMap[bond.end];
  }, sgroup);
  for (var b = 0; b < bondsToRemove.length; ++b) {
    mol.bonds["delete"](bondsToRemove[b]);
  }
  for (var a in atomReductionMap) {
    mol.atoms["delete"](+a);
    atomMap[a] = -1;
  }
  sgroup.atoms = sgroup.patoms;
  sgroup.patoms = null;
}
function postLoadSru(sgroup) {
  sgroup.data.connectivity = (sgroup.data.connectivity || 'EU').trim().toLowerCase();
}
function postLoadSup(sgroup) {
  sgroup.data.name = (sgroup.data.subscript || '').trim();
  sgroup.data.subscript = '';
}
function postLoadGen(_sgroup, _mol, _atomMap) {
}
function postLoadDat(sgroup, mol) {
  if (!sgroup.data.absolute) {
    sgroup.pp = sgroup.pp.add(SGroup.getMassCentre(mol, sgroup.atoms));
  }
}
function postLoadMon(_sgroup) {
}
function postLoadMer(_sgroup) {
}
function postLoadCop(_sgroup) {
}
function postLoadCro(_sgroup) {
}
function postLoadMod(_sgroup) {
}
function postLoadGra(_sgroup) {
}
function postLoadCom(_sgroup) {
}
function postLoadMix(_sgroup) {
}
function postLoadFor(_sgroup) {
}
function postLoadAny(_sgroup) {
}
function loadSGroup(mol, sg, atomMap) {
  var postLoadMap = {
    SUP: postLoadSup,
    MUL: postLoadMul,
    SRU: postLoadSru,
    MON: postLoadMon,
    MER: postLoadMer,
    COP: postLoadCop,
    CRO: postLoadCro,
    MOD: postLoadMod,
    GRA: postLoadGra,
    COM: postLoadCom,
    MIX: postLoadMix,
    FOR: postLoadFor,
    DAT: postLoadDat,
    ANY: postLoadAny,
    GEN: postLoadGen
  };
  sg.id = mol.sgroups.add(sg);
  postLoadMap[sg.type](sg, mol, atomMap);
  for (var s = 0; s < sg.atoms.length; ++s) {
    if (mol.atoms.has(sg.atoms[s])) mol.atoms.get(sg.atoms[s]).sgs.add(sg.id);
  }
  if (sg.type === 'DAT') mol.sGroupForest.insert(sg, -1, []);else mol.sGroupForest.insert(sg);
  return sg.id;
}
function initSGroup(sGroups, propData) {
  var kv = readKeyValuePairs(propData, true);
  var _iterator = _createForOfIteratorHelper$2(kv),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray__default["default"](_step.value, 2),
        key = _step$value[0],
        type = _step$value[1];
      var sg = new SGroup(type);
      sg.number = key;
      sGroups[key] = sg;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function applySGroupProp(sGroups, propName, propData, numeric, core) {
  var kv = readKeyValuePairs(propData, !numeric);
  var _iterator2 = _createForOfIteratorHelper$2(kv.keys()),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var key = _step2.value;
      (core ? sGroups[key] : sGroups[key].data)[propName] = kv.get(key);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
function applySGroupArrayProp(sGroups, propName, propData, shift) {
  var sid = utils.parseDecimalInt(propData.slice(1, 4)) - 1;
  var num = utils.parseDecimalInt(propData.slice(4, 8));
  var part = toIntArray(utils.partitionLineFixed(propData.slice(8), 3, true));
  if (part.length !== num) throw new Error('File format invalid');
  if (shift) part = part.map(function (v) {
    return v + shift;
  });
  sGroups[sid][propName] = sGroups[sid][propName].concat(part);
}
function applyDataSGroupName(sg, name) {
  sg.data.fieldName = name;
}
function applyDataSGroupExpand(sg, expanded) {
  sg.data.expanded = expanded;
}
function applyDataSGroupQuery(sg, query) {
  sg.data.query = query;
}
function applyDataSGroupQueryOp(sg, queryOp) {
  sg.data.queryOp = queryOp;
}
function applyDataSGroupDesc(sGroups, propData) {
  var split = utils.partitionLine(propData, [4, 31, 2, 20, 2, 3], false);
  var id = utils.parseDecimalInt(split[0]) - 1;
  var fieldName = split[1].trim();
  var fieldType = split[2].trim();
  var units = split[3].trim();
  var query = split[4].trim();
  var queryOp = split[5].trim();
  var sGroup = sGroups[id];
  sGroup.data.fieldType = fieldType;
  sGroup.data.fieldName = fieldName;
  sGroup.data.units = units;
  sGroup.data.query = query;
  sGroup.data.queryOp = queryOp;
}
function applyDataSGroupInfo(sg, propData) {
  var split = utils.partitionLine(propData, [10 , 10 , 4 , 1 , 1 , 1 , 3 , 3 , 3 , 3 , 2 , 3 , 2 ], false);
  var x = parseFloat(split[0]);
  var y = parseFloat(split[1]);
  var attached = split[3].trim() === 'A';
  var absolute = split[4].trim() === 'A';
  var showUnits = split[5].trim() === 'U';
  var nCharsToDisplay = split[7].trim();
  nCharsToDisplay = nCharsToDisplay === 'ALL' ? -1 : utils.parseDecimalInt(nCharsToDisplay);
  var tagChar = split[10].trim();
  var daspPos = utils.parseDecimalInt(split[11].trim());
  sg.pp = new Vec2(x, -y);
  sg.data.attached = attached;
  sg.data.absolute = absolute;
  sg.data.showUnits = showUnits;
  sg.data.nCharsToDisplay = nCharsToDisplay;
  sg.data.tagChar = tagChar;
  sg.data.daspPos = daspPos;
}
function applyDataSGroupInfoLine(sGroups, propData) {
  var id = utils.parseDecimalInt(propData.substr(0, 4)) - 1;
  var sg = sGroups[id];
  applyDataSGroupInfo(sg, propData.substr(5));
}
function applyDataSGroupData(sg, data, finalize) {
  sg.data.fieldValue = (sg.data.fieldValue || '') + data;
  if (finalize) {
    sg.data.fieldValue = trimRight(sg.data.fieldValue);
    if (sg.data.fieldValue.startsWith('"') && sg.data.fieldValue.endsWith('"')) {
      sg.data.fieldValue = sg.data.fieldValue.substr(1, sg.data.fieldValue.length - 2);
    }
  }
}
function applyDataSGroupDataLine(sGroups, propData, finalize) {
  var id = utils.parseDecimalInt(propData.substr(0, 5)) - 1;
  var data = propData.substr(5);
  var sg = sGroups[id];
  applyDataSGroupData(sg, data, finalize);
}
function toIntArray(strArray) {
  var ret = [];
  for (var j = 0; j < strArray.length; ++j) {
    ret[j] = utils.parseDecimalInt(strArray[j]);
  }
  return ret;
}
function trimRight(str) {
  return str.replace(/\s+$/, '');
}
function identityMap(array) {
  var map = {};
  for (var i = 0; i < array.length; ++i) map[array[i]] = array[i];
  return map;
}
function parseSGroupSAPLineV2000(ctabString) {
  var _utils$partitionLine = utils.partitionLine(ctabString.slice(0, 7), [1, 3, 3], false),
    _utils$partitionLine2 = _slicedToArray__default["default"](_utils$partitionLine, 3),
    sss = _utils$partitionLine2[1],
    nn6 = _utils$partitionLine2[2];
  var chunksNumberInLine = utils.parseDecimalInt(nn6);
  assert__default["default"](chunksNumberInLine <= 6);
  var sGroupId = utils.parseDecimalInt(sss) - 1;
  var attachmentPointsStr = ctabString.slice(7);
  var attachmentPoints = [];
  for (var i = 0; i < chunksNumberInLine; i++) {
    var CHUNK_SIZE = 11;
    var stringForParse = attachmentPointsStr.slice(i * CHUNK_SIZE);
    var CHUNK_PARTS_LENGTHS = [1, 3, 1, 3, 1, 2];
    var _utils$partitionLine3 = utils.partitionLine(stringForParse, CHUNK_PARTS_LENGTHS, false),
      _utils$partitionLine4 = _slicedToArray__default["default"](_utils$partitionLine3, 6),
      iii = _utils$partitionLine4[1],
      ooo = _utils$partitionLine4[3],
      cc = _utils$partitionLine4[5];
    var atomId = utils.parseDecimalInt(iii) - 1;
    assert__default["default"](atomId >= 0);
    var leaveAtomParsedId = utils.parseDecimalInt(ooo);
    var leaveAtomId = leaveAtomParsedId > 0 ? leaveAtomParsedId - 1 : undefined;
    attachmentPoints.push(new SGroupAttachmentPoint(atomId, leaveAtomId, cc));
  }
  return {
    sGroupId: sGroupId,
    attachmentPoints: attachmentPoints
  };
}
var sGroup = {
  readKeyValuePairs: readKeyValuePairs,
  readKeyMultiValuePairs: readKeyMultiValuePairs,
  loadSGroup: loadSGroup,
  initSGroup: initSGroup,
  applySGroupProp: applySGroupProp,
  applySGroupArrayProp: applySGroupArrayProp,
  applyDataSGroupName: applyDataSGroupName,
  applyDataSGroupQuery: applyDataSGroupQuery,
  applyDataSGroupQueryOp: applyDataSGroupQueryOp,
  applyDataSGroupDesc: applyDataSGroupDesc,
  applyDataSGroupInfo: applyDataSGroupInfo,
  applyDataSGroupData: applyDataSGroupData,
  applyDataSGroupInfoLine: applyDataSGroupInfoLine,
  applyDataSGroupDataLine: applyDataSGroupDataLine,
  applyDataSGroupExpand: applyDataSGroupExpand,
  parseSGroupSAPLineV2000: parseSGroupSAPLineV2000
};

function parseAtomLine(atomLine) {
  var atomSplit = utils.partitionLine(atomLine, utils.fmtInfo.atomLinePartition);
  var params = {
    pp: new Vec2(parseFloat(atomSplit[0]), -parseFloat(atomSplit[1]), parseFloat(atomSplit[2])),
    label: atomSplit[4].trim(),
    explicitValence: utils.fmtInfo.valenceMap[utils.parseDecimalInt(atomSplit[10])],
    massDifference: utils.parseDecimalInt(atomSplit[5]),
    charge: utils.fmtInfo.chargeMap[utils.parseDecimalInt(atomSplit[6])],
    hCount: utils.parseDecimalInt(utils.parseDecimalInt(atomSplit[8])),
    stereoCare: utils.parseDecimalInt(atomSplit[9]) !== 0,
    aam: utils.parseDecimalInt(atomSplit[14]),
    invRet: utils.parseDecimalInt(atomSplit[15]),
    exactChangeFlag: utils.parseDecimalInt(atomSplit[16])
  };
  return new Atom(params);
}
function parseBondLine(bondLine) {
  var bondSplit = utils.partitionLine(bondLine, utils.fmtInfo.bondLinePartition);
  var params = {
    begin: utils.parseDecimalInt(bondSplit[0]) - 1,
    end: utils.parseDecimalInt(bondSplit[1]) - 1,
    type: utils.fmtInfo.bondTypeMap[utils.parseDecimalInt(bondSplit[2])],
    stereo: utils.fmtInfo.bondStereoMap[utils.parseDecimalInt(bondSplit[3])],
    xxx: bondSplit[4],
    topology: utils.fmtInfo.bondTopologyMap[utils.parseDecimalInt(bondSplit[5])],
    reactingCenterStatus: utils.parseDecimalInt(bondSplit[6])
  };
  return new Bond(params);
}
function parseAtomListLine( atomListLine) {
  var split = utils.partitionLine(atomListLine, utils.fmtInfo.atomListHeaderPartition);
  var number = utils.parseDecimalInt(split[0]) - 1;
  var notList = split[2].trim() === 'T';
  var count = utils.parseDecimalInt(split[4].trim());
  var ids = atomListLine.slice(utils.fmtInfo.atomListHeaderLength);
  var list = [];
  var itemLength = utils.fmtInfo.atomListHeaderItemLength;
  for (var i = 0; i < count; ++i) {
    list[i] = utils.parseDecimalInt(ids.slice(i * itemLength, (i + 1) * itemLength - 1));
  }
  return {
    aid: number,
    atomList: new AtomList({
      notList: notList,
      ids: list
    })
  };
}
function parsePropertyLines(ctab, ctabLines, shift, end, sGroups, rLogic) {
  var props = new Pool();
  var _loop = function _loop() {
    var line = ctabLines[shift];
    if (line.charAt(0) === 'A') {
      var propValue = ctabLines[++shift];
      var isPseudo = /'.+'/.test(propValue);
      if (isPseudo && !props.get('pseudo')) {
        props.set('pseudo', new Pool());
      }
      if (!isPseudo && !props.get('alias')) {
        props.set('alias', new Pool());
      }
      props.get(isPseudo ? 'pseudo' : 'alias').set(utils.parseDecimalInt(line.slice(3)) - 1, propValue);
    } else if (line.charAt(0) === 'M') {
      var type = line.slice(3, 6);
      var propertyData = line.slice(6);
      if (type === 'END') {
        return 1;
      } else if (type === 'CHG') {
        if (!props.get('charge')) {
          props.set('charge', sGroup.readKeyValuePairs(propertyData));
        }
      } else if (type === 'RAD') {
        if (!props.get('radical')) {
          props.set('radical', sGroup.readKeyValuePairs(propertyData));
        }
      } else if (type === 'ISO') {
        if (!props.get('isotope')) {
          props.set('isotope', sGroup.readKeyValuePairs(propertyData));
        }
      } else if (type === 'RBC') {
        if (!props.get('ringBondCount')) {
          props.set('ringBondCount', sGroup.readKeyValuePairs(propertyData));
        }
      } else if (type === 'SUB') {
        if (!props.get('substitutionCount')) {
          props.set('substitutionCount', sGroup.readKeyValuePairs(propertyData));
        }
      } else if (type === 'UNS') {
        if (!props.get('unsaturatedAtom')) {
          props.set('unsaturatedAtom', sGroup.readKeyValuePairs(propertyData));
        }
      } else if (type === 'RGP') {
        if (!props.get('rglabel')) props.set('rglabel', new Pool());
        var rglabels = props.get('rglabel');
        var a2rs = sGroup.readKeyMultiValuePairs(propertyData);
        for (var a2ri = 0; a2ri < a2rs.length; a2ri++) {
          var a2r = a2rs[a2ri];
          rglabels.set(a2r[0], (rglabels.get(a2r[0]) || 0) | 1 << a2r[1] - 1);
        }
      } else if (type === 'LOG') {
        propertyData = propertyData.slice(4);
        var rgid = utils.parseDecimalInt(propertyData.slice(0, 3).trim());
        var iii = utils.parseDecimalInt(propertyData.slice(4, 7).trim());
        var hhh = utils.parseDecimalInt(propertyData.slice(8, 11).trim());
        var ooo = propertyData.slice(12).trim();
        var logic = {};
        if (iii > 0) logic.ifthen = iii;
        logic.resth = hhh === 1;
        logic.range = ooo;
        rLogic[rgid] = logic;
      } else if (type === 'APO') {
        if (!props.get('attachmentPoints')) {
          props.set('attachmentPoints', sGroup.readKeyValuePairs(propertyData));
        }
      } else if (type === 'ALS') {
        var pool = parsePropertyLineAtomList(utils.partitionLine(propertyData, [1, 3, 3, 1, 1, 1]), utils.partitionLineFixed(propertyData.slice(10), 4, false));
        if (!props.get('atomList')) props.set('atomList', new Pool());
        if (!props.get('label')) props.set('label', new Pool());
        pool.forEach(function (atomList, aid) {
          props.get('label').set(aid, 'L#');
          props.get('atomList').set(aid, atomList);
        });
      } else if (type === 'STY') {
        sGroup.initSGroup(sGroups, propertyData);
      } else if (type === 'SST') {
        sGroup.applySGroupProp(sGroups, 'subtype', propertyData);
      } else if (type === 'SLB') {
        sGroup.applySGroupProp(sGroups, 'label', propertyData, true);
      } else if (type === 'SPL') {
        sGroup.applySGroupProp(sGroups, 'parent', propertyData, true, true);
      } else if (type === 'SCN') {
        sGroup.applySGroupProp(sGroups, 'connectivity', propertyData);
      } else if (type === 'SAL') {
        sGroup.applySGroupArrayProp(sGroups, 'atoms', propertyData, -1);
      } else if (type === 'SBL') {
        sGroup.applySGroupArrayProp(sGroups, 'bonds', propertyData, -1);
      } else if (type === 'SPA') {
        sGroup.applySGroupArrayProp(sGroups, 'patoms', propertyData, -1);
      } else if (type === 'SMT') {
        var sid = utils.parseDecimalInt(propertyData.slice(0, 4)) - 1;
        sGroups[sid].data.subscript = propertyData.slice(4).trim();
      } else if (type === 'SDT') {
        sGroup.applyDataSGroupDesc(sGroups, propertyData);
      } else if (type === 'SDD') {
        sGroup.applyDataSGroupInfoLine(sGroups, propertyData);
      } else if (type === 'SCD') {
        sGroup.applyDataSGroupDataLine(sGroups, propertyData, false);
      } else if (type === 'SED') {
        sGroup.applyDataSGroupDataLine(sGroups, propertyData, true);
      } else if (type === 'SDS') {
        var expandedSGroups = propertyData.slice(7).trim().split('   ');
        expandedSGroups.forEach(function (eg) {
          var sGroupId = Number(eg) - 1;
          sGroups[sGroupId].data.expanded = true;
        });
      } else if (type === 'SAP') {
        var _sGroup$parseSGroupSA = sGroup.parseSGroupSAPLineV2000(propertyData),
          sGroupId = _sGroup$parseSGroupSA.sGroupId,
          attachmentPoints = _sGroup$parseSGroupSA.attachmentPoints;
        attachmentPoints.forEach(function (attachmentPoint) {
          sGroups[sGroupId].addAttachmentPoint(attachmentPoint);
        });
      }
    }
    ++shift;
  };
  while (shift < end) {
    if (_loop()) break;
  }
  return props;
}
function applyAtomProp(atoms, values, propId) {
  values.forEach(function (propVal, aid) {
    atoms.get(aid)[propId] = propVal;
  });
}
function parseCTabV2000(ctabLines, countsSplit, ignoreChiralFlag) {
  var ctab = new Struct();
  var i;
  var atomCount = utils.parseDecimalInt(countsSplit[0]);
  var bondCount = utils.parseDecimalInt(countsSplit[1]);
  var atomListCount = utils.parseDecimalInt(countsSplit[2]);
  var isAbs = utils.parseDecimalInt(countsSplit[4]) === 1 || ignoreChiralFlag;
  var isAnd = utils.parseDecimalInt(countsSplit[4]) === 0 && !ignoreChiralFlag;
  var stextLinesCount = utils.parseDecimalInt(countsSplit[5]);
  var propertyLinesCount = utils.parseDecimalInt(countsSplit[10]);
  var shift = 0;
  var atomLines = ctabLines.slice(shift, shift + atomCount);
  shift += atomCount;
  var bondLines = ctabLines.slice(shift, shift + bondCount);
  shift += bondCount;
  var atomListLines = ctabLines.slice(shift, shift + atomListCount);
  shift += atomListCount + stextLinesCount;
  var atoms = atomLines.map(parseAtomLine);
  atoms.forEach(function (atom) {
    return ctab.atoms.add(atom);
  });
  var bonds = bondLines.map(parseBondLine);
  bonds.forEach(function (bond) {
    if (bond.stereo && isAbs) {
      ctab.atoms.get(bond.begin).stereoLabel = exports.StereoLabel.Abs;
    }
    if (bond.stereo && isAnd) {
      ctab.atoms.get(bond.begin).stereoLabel = "".concat(exports.StereoLabel.And, "1");
    }
    ctab.bonds.add(bond);
  });
  var atomLists = atomListLines.map(parseAtomListLine);
  atomLists.forEach(function (pair) {
    ctab.atoms.get(pair.aid).atomList = pair.atomList;
    ctab.atoms.get(pair.aid).label = 'L#';
  });
  var sGroups = {};
  var rLogic = {};
  var props = parsePropertyLines(ctab, ctabLines, shift, Math.min(ctabLines.length, shift + propertyLinesCount), sGroups, rLogic);
  props.forEach(function (values, propId) {
    applyAtomProp(ctab.atoms, values, propId);
  });
  var atomMap = {};
  var sid;
  for (sid in sGroups) {
    var sg = sGroups[sid];
    if (sg.type === 'DAT' && sg.atoms.length === 0) {
      var parent = sGroups[sid].parent;
      if (parent >= 0) {
        var psg = sGroups[parent - 1];
        if (psg.type === 'GEN') sg.atoms = [].slice.call(psg.atoms);
      }
    }
  }
  for (sid in sGroups) sGroup.loadSGroup(ctab, sGroups[sid], atomMap);
  var emptyGroups = [];
  for (sid in sGroups) {
    SGroup.filter(ctab, sGroups[sid], atomMap);
    if (sGroups[sid].atoms.length === 0 && !sGroups[sid].allAtoms) {
      emptyGroups.push(+sid);
    }
  }
  for (i = 0; i < emptyGroups.length; ++i) {
    ctab.sGroupForest.remove(emptyGroups[i]);
    ctab.sgroups["delete"](emptyGroups[i]);
  }
  for (var id in rLogic) {
    var rgid = parseInt(id, 10);
    ctab.rgroups.set(rgid, new RGroup(rLogic[rgid]));
  }
  return ctab;
}
function parseRg2000( ctabLines, ignoreChiralFlag) {
  ctabLines = ctabLines.slice(7);
  if (ctabLines[0].trim() !== '$CTAB') throw new Error('RGFile format invalid');
  var i = 1;
  while (ctabLines[i].charAt(0) !== '$') i++;
  if (ctabLines[i].trim() !== '$END CTAB') {
    throw new Error('RGFile format invalid');
  }
  var coreLines = ctabLines.slice(1, i);
  ctabLines = ctabLines.slice(i + 1);
  var fragmentLines = {};
  while (true) {
    if (ctabLines.length === 0) throw new Error('Unexpected end of file');
    var line = ctabLines[0].trim();
    if (line === '$END MOL') {
      ctabLines = ctabLines.slice(1);
      break;
    }
    if (line !== '$RGP') throw new Error('RGFile format invalid');
    var rgid = parseInt(ctabLines[1].trim(), 10);
    fragmentLines[rgid] = [];
    ctabLines = ctabLines.slice(2);
    while (true) {
      if (ctabLines.length === 0) throw new Error('Unexpected end of file');
      line = ctabLines[0].trim();
      if (line === '$END RGP') {
        ctabLines = ctabLines.slice(1);
        break;
      }
      if (line !== '$CTAB') throw new Error('RGFile format invalid');
      i = 1;
      while (ctabLines[i].charAt(0) !== '$') i++;
      if (ctabLines[i].trim() !== '$END CTAB') {
        throw new Error('RGFile format invalid');
      }
      fragmentLines[rgid].push(ctabLines.slice(1, i));
      ctabLines = ctabLines.slice(i + 1);
    }
  }
  var core = parseCTab$1(coreLines, ignoreChiralFlag);
  var frag = {};
  {
    for (var strId in fragmentLines) {
      var id = parseInt(strId, 10);
      frag[id] = [];
      for (var j = 0; j < fragmentLines[id].length; ++j) {
        frag[id].push(parseCTab$1(fragmentLines[id][j], ignoreChiralFlag));
      }
    }
  }
  return utils.rgMerge(core, frag);
}
function parseRxn2000( ctabLines, shouldReactionRelayout, ignoreChiralFlag) {
  ctabLines = ctabLines.slice(4);
  var countsSplit = utils.partitionLine(ctabLines[0], utils.fmtInfo.rxnItemsPartition);
  var nReactants = countsSplit[0] - 0;
  var nProducts = countsSplit[1] - 0;
  var nAgents = countsSplit[2] - 0;
  ctabLines = ctabLines.slice(1);
  var mols = [];
  while (ctabLines.length > 0 && ctabLines[0].substr(0, 4) === '$MOL') {
    ctabLines = ctabLines.slice(1);
    var n = 0;
    while (n < ctabLines.length && ctabLines[n].substr(0, 4) !== '$MOL') n++;
    var lines = ctabLines.slice(0, n);
    var struct;
    if (lines[0].search('\\$MDL') === 0) {
      struct = parseRg2000(lines, ignoreChiralFlag);
    } else {
      struct = parseCTab$1(lines.slice(3), ignoreChiralFlag);
      struct.name = lines[0].trim();
    }
    mols.push(struct);
    ctabLines = ctabLines.slice(n);
  }
  return utils.rxnMerge(mols, nReactants, nProducts, nAgents, shouldReactionRelayout);
}
function parseCTab$1( ctabLines, ignoreChiralFlag) {
  var countsSplit = utils.partitionLine(ctabLines[0], utils.fmtInfo.countsLinePartition);
  ctabLines = ctabLines.slice(1);
  return parseCTabV2000(ctabLines, countsSplit, ignoreChiralFlag);
}
function labelsListToIds$1(labels) {
  var ids = [];
  for (var i = 0; i < labels.length; ++i) {
    var element = Elements.get(labels[i].trim());
    if (element) {
      ids.push(element.number);
    }
  }
  return ids;
}
function parsePropertyLineAtomList(hdr, lst) {
  var aid = utils.parseDecimalInt(hdr[1]) - 1;
  var count = utils.parseDecimalInt(hdr[2]);
  var notList = hdr[4].trim() === 'T';
  var ids = labelsListToIds$1(lst.slice(0, count));
  var ret = new Pool();
  ret.set(aid, new AtomList({
    notList: notList,
    ids: ids
  }));
  return ret;
}
var v2000 = {
  parseCTabV2000: parseCTabV2000,
  parseRg2000: parseRg2000,
  parseRxn2000: parseRxn2000
};

function parseAtomLineV3000(line) {
  var subsplit, key, value, i;
  var split = spacebarsplit(line);
  var params = {
    pp: new Vec2(parseFloat(split[2]), -parseFloat(split[3]), parseFloat(split[4])),
    aam: split[5].trim()
  };
  var label = split[1].trim();
  if (label.charAt(0) === '"' && label.charAt(label.length - 1) === '"') {
    label = label.substr(1, label.length - 2);
  }
  if (label.charAt(label.length - 1) === ']') {
    label = label.substr(0, label.length - 1);
    var atomListParams = {};
    atomListParams.notList = false;
    var matchNotListInfo = label.match(/NOT ?\[/);
    if (matchNotListInfo) {
      atomListParams.notList = true;
      var _matchNotListInfo = _slicedToArray__default["default"](matchNotListInfo, 1),
        matchedSubstr = _matchNotListInfo[0];
      label = label.substr(matchedSubstr.length);
    } else if (label.charAt(0) !== '[') {
      throw new Error("Error: atom list expected, found '" + label + "'");
    } else {
      label = label.substr(1);
    }
    atomListParams.ids = labelsListToIds(label.split(','));
    params.atomList = new AtomList(atomListParams);
    params.label = 'L#';
  } else {
    params.label = label;
  }
  split.splice(0, 6);
  for (i = 0; i < split.length; ++i) {
    subsplit = splitonce(split[i], '=');
    key = subsplit[0];
    value = subsplit[1];
    if (key in utils.fmtInfo.v30atomPropMap) {
      var ival = utils.parseDecimalInt(value);
      if (key === 'VAL') {
        if (ival === 0) continue;
        if (ival === -1) ival = 0;
      }
      params[utils.fmtInfo.v30atomPropMap[key]] = ival;
    } else if (key === 'RGROUPS') {
      value = value.trim().substr(1, value.length - 2);
      var rgrsplit = value.split(' ').slice(1);
      params.rglabel = 0;
      for (var j = 0; j < rgrsplit.length; ++j) {
        params.rglabel |= 1 << rgrsplit[j] - 1;
      }
    } else if (key === 'ATTCHPT') {
      params.attpnt = value.trim() - 0;
    }
  }
  return new Atom(params);
}
function parseBondLineV3000(line) {
  var subsplit, key, value, i;
  var split = spacebarsplit(line);
  var params = {
    begin: utils.parseDecimalInt(split[2]) - 1,
    end: utils.parseDecimalInt(split[3]) - 1,
    type: utils.fmtInfo.bondTypeMap[utils.parseDecimalInt(split[1])]
  };
  split.splice(0, 4);
  for (i = 0; i < split.length; ++i) {
    subsplit = splitonce(split[i], '=');
    key = subsplit[0];
    value = subsplit[1];
    if (key === 'CFG') {
      params.stereo = utils.fmtInfo.v30bondStereoMap[utils.parseDecimalInt(value)];
      if (params.type === Bond.PATTERN.TYPE.DOUBLE && params.stereo === Bond.PATTERN.STEREO.EITHER) {
        params.stereo = Bond.PATTERN.STEREO.CIS_TRANS;
      }
    } else if (key === 'TOPO') {
      params.topology = utils.fmtInfo.bondTopologyMap[utils.parseDecimalInt(value)];
    } else if (key === 'RXCTR') {
      params.reactingCenterStatus = utils.parseDecimalInt(value);
    } else if (key === 'STBOX') {
      params.stereoCare = utils.parseDecimalInt(value);
    }
  }
  return new Bond(params);
}
function v3000parseCollection(ctab, ctabLines, shift) {
  shift++;
  while (ctabLines[shift].trim() !== 'M  V30 END COLLECTION') shift++;
  shift++;
  return shift;
}
function v3000parseSGroup(ctab, ctabLines, sgroups, atomMap, shift) {
  var line = '';
  shift++;
  while (shift < ctabLines.length) {
    line = stripV30(ctabLines[shift++]).trim();
    if (line.trim() === 'END SGROUP') return shift;
    while (line.charAt(line.length - 1) === '-') {
      line = (line.substr(0, line.length - 1) + stripV30(ctabLines[shift++])).trim();
    }
    var split = splitSGroupDef(line);
    var type = split[1];
    var sg = new SGroup(type);
    sg.number = split[0] - 0;
    sg.type = type;
    sg.label = split[2] - 0;
    sgroups[sg.number] = sg;
    var props = {};
    for (var i = 3; i < split.length; ++i) {
      var subsplit = splitonce(split[i], '=');
      if (subsplit.length !== 2) {
        throw new Error("A record of form AAA=BBB or AAA=(...) expected, got '" + split[i] + "'");
      }
      var name = subsplit[0];
      if (!(name in props)) props[name] = [];
      props[name].push(subsplit[1]);
    }
    sg.atoms = parseBracedNumberList(props.ATOMS[0], -1);
    if (props.PATOMS) {
      sg.patoms = parseBracedNumberList(props.PATOMS[0], -1);
    }
    sg.bonds = props.BONDS ? parseBracedNumberList(props.BONDS[0], -1) : [];
    var brkxyzStrs = props.BRKXYZ;
    sg.brkxyz = [];
    if (brkxyzStrs) {
      for (var j = 0; j < brkxyzStrs.length; ++j) {
        sg.brkxyz.push(parseBracedNumberList(brkxyzStrs[j]));
      }
    }
    if (props.MULT) sg.data.subscript = props.MULT[0] - 0;
    if (props.LABEL) sg.data.subscript = props.LABEL[0].trim();
    if (props.CONNECT) {
      sg.data.connectivity = props.CONNECT[0].toLowerCase();
    }
    if (props.FIELDDISP) {
      sGroup.applyDataSGroupInfo(sg, stripQuotes(props.FIELDDISP[0]));
    }
    if (props.FIELDDATA) {
      sGroup.applyDataSGroupData(sg, props.FIELDDATA[0], true);
    }
    if (props.FIELDNAME) {
      sGroup.applyDataSGroupName(sg, props.FIELDNAME[0]);
    }
    if (props.QUERYTYPE) {
      sGroup.applyDataSGroupQuery(sg, props.QUERYTYPE[0]);
    }
    if (props.QUERYOP) sGroup.applyDataSGroupQueryOp(sg, props.QUERYOP[0]);
    sGroup.loadSGroup(ctab, sg, atomMap);
    if (props.ESTATE) sGroup.applyDataSGroupExpand(sg, props.ESTATE[0]);
  }
  throw new Error('S-group declaration incomplete.');
}
function parseCTabV3000(ctabLines, norgroups) {
  var ctab = new Struct();
  var shift = 0;
  if (ctabLines[shift++].trim() !== 'M  V30 BEGIN CTAB') {
    throw Error('CTAB V3000 invalid');
  }
  if (ctabLines[shift].slice(0, 13) !== 'M  V30 COUNTS') {
    throw Error('CTAB V3000 invalid');
  }
  var vals = ctabLines[shift].slice(14).split(' ');
  var isAbs = utils.parseDecimalInt(vals[4]) === 1;
  shift++;
  if (ctabLines[shift].trim() === 'M  V30 BEGIN ATOM') {
    shift++;
    var line;
    while (shift < ctabLines.length) {
      line = stripV30(ctabLines[shift++]).trim();
      if (line === 'END ATOM') break;
      while (line.charAt(line.length - 1) === '-') {
        line = (line.substring(0, line.length - 1) + stripV30(ctabLines[shift++])).trim();
      }
      ctab.atoms.add(parseAtomLineV3000(line));
    }
    if (ctabLines[shift].trim() === 'M  V30 BEGIN BOND') {
      shift++;
      while (shift < ctabLines.length) {
        line = stripV30(ctabLines[shift++]).trim();
        if (line === 'END BOND') break;
        while (line.charAt(line.length - 1) === '-') {
          line = (line.substring(0, line.length - 1) + stripV30(ctabLines[shift++])).trim();
        }
        var bond = parseBondLineV3000(line);
        if (bond.stereo && isAbs) ctab.atoms.get(bond.begin).stereoLabel = 'abs';
        ctab.bonds.add(bond);
      }
    }
    var sgroups = {};
    var atomMap = {};
    while (ctabLines[shift].trim() !== 'M  V30 END CTAB') {
      if (ctabLines[shift].trim() === 'M  V30 BEGIN COLLECTION') {
        shift = v3000parseCollection(ctab, ctabLines, shift);
      } else if (ctabLines[shift].trim() === 'M  V30 BEGIN SGROUP') {
        shift = v3000parseSGroup(ctab, ctabLines, sgroups, atomMap, shift);
      } else throw Error('CTAB V3000 invalid');
    }
  }
  if (ctabLines[shift++].trim() !== 'M  V30 END CTAB') {
    throw Error('CTAB V3000 invalid');
  }
  if (!norgroups) readRGroups3000(ctab, ctabLines.slice(shift));
  return ctab;
}
function readRGroups3000(ctab, ctabLines) {
  var rfrags = {};
  var rLogic = {};
  var shift = 0;
  while (shift < ctabLines.length && ctabLines[shift].search('M  V30 BEGIN RGROUP') === 0) {
    var id = ctabLines[shift++].split(' ').pop();
    rfrags[id] = [];
    rLogic[id] = {};
    while (true) {
      var line = ctabLines[shift].trim();
      if (line.search('M  V30 RLOGIC') === 0) {
        line = line.slice(13);
        var rlsplit = line.trim().split(/\s+/g);
        var iii = utils.parseDecimalInt(rlsplit[0]);
        var hhh = utils.parseDecimalInt(rlsplit[1]);
        var ooo = rlsplit.slice(2).join(' ');
        var logic = {};
        if (iii > 0) logic.ifthen = iii;
        logic.resth = hhh === 1;
        logic.range = ooo;
        rLogic[id] = logic;
        shift++;
        continue;
      }
      if (line !== 'M  V30 BEGIN CTAB') throw Error('CTAB V3000 invalid');
      for (var i = 0; i < ctabLines.length; ++i) {
        if (ctabLines[shift + i].trim() === 'M  V30 END CTAB') break;
      }
      var lines = ctabLines.slice(shift, shift + i + 1);
      var rfrag = parseCTabV3000(lines, true);
      rfrags[id].push(rfrag);
      shift = shift + i + 1;
      if (ctabLines[shift].trim() === 'M  V30 END RGROUP') {
        shift++;
        break;
      }
    }
  }
  Object.keys(rfrags).forEach(function (rgid) {
    rfrags[rgid].forEach(function (rg) {
      rg.rgroups.set(rgid, new RGroup(rLogic[rgid]));
      var frid = rg.frags.add({});
      rg.rgroups.get(rgid).frags.add(frid);
      rg.atoms.forEach(function (atom) {
        atom.fragment = frid;
      });
      rg.mergeInto(ctab);
    });
  });
}
function parseRxn3000( ctabLines, shouldReactionRelayout) {
  ctabLines = ctabLines.slice(4);
  var countsSplit = ctabLines[0].split(/\s+/g).slice(3);
  var nReactants = countsSplit[0] - 0;
  var nProducts = countsSplit[1] - 0;
  var nAgents = countsSplit.length > 2 ? countsSplit[2] - 0 : 0;
  function findCtabEnd(i) {
    for (var _j = i; _j < ctabLines.length; ++_j) {
      if (ctabLines[_j].trim() === 'M  V30 END CTAB') return _j;
    }
    return (void 0);
  }
  function findRGroupEnd(i) {
    for (var _j2 = i; _j2 < ctabLines.length; ++_j2) {
      if (ctabLines[_j2].trim() === 'M  V30 END RGROUP') return _j2;
    }
    return (void 0);
  }
  var molLinesReactants = [];
  var molLinesProducts = [];
  var molLinesAgents = [];
  var current = null;
  var rGroups = [];
  for (var i = 0; i < ctabLines.length; ++i) {
    var line = ctabLines[i].trim();
    var j;
    if (line.startsWith('M  V30 COUNTS')) ; else if (line === 'M  END') {
      break;
    } else if (line === 'M  V30 BEGIN PRODUCT') {
      current = molLinesProducts;
    } else if (line === 'M  V30 END PRODUCT') {
      current = null;
    } else if (line === 'M  V30 BEGIN REACTANT') {
      current = molLinesReactants;
    } else if (line === 'M  V30 END REACTANT') {
      current = null;
    } else if (line === 'M  V30 BEGIN AGENT') {
      current = molLinesAgents;
    } else if (line === 'M  V30 END AGENT') {
      current = null;
    } else if (line.startsWith('M  V30 BEGIN RGROUP')) {
      j = findRGroupEnd(i);
      rGroups.push(ctabLines.slice(i, j + 1));
      i = j;
    } else if (line === 'M  V30 BEGIN CTAB') {
      j = findCtabEnd(i);
      current.push(ctabLines.slice(i, j + 1));
      i = j;
    } else {
      throw new Error('line unrecognized: ' + line);
    }
  }
  var mols = [];
  var molLines = molLinesReactants.concat(molLinesProducts).concat(molLinesAgents);
  for (j = 0; j < molLines.length; ++j) {
    var mol = parseCTabV3000(molLines[j], countsSplit);
    mols.push(mol);
  }
  var ctab = utils.rxnMerge(mols, nReactants, nProducts, nAgents, shouldReactionRelayout);
  readRGroups3000(ctab, function (array) {
    var res = [];
    for (var k = 0; k < array.length; ++k) res = res.concat(array[k]);
    return res;
  }(rGroups));
  return ctab;
}
function spacebarsplit(line) {
  var split = [];
  var bracketEquality = 0;
  var currentIndex = 0;
  var firstSliceIndex = -1;
  var quoted = false;
  for (currentIndex; currentIndex < line.length; currentIndex += 1) {
    var currentSymbol = line[currentIndex];
    if (line.substr(currentIndex, 3) === 'NOT') {
      var closingBracketIndex = line.indexOf(']');
      split.push(line.slice(currentIndex, closingBracketIndex + 1));
      currentIndex = closingBracketIndex + 1;
      firstSliceIndex = currentIndex;
    } else if (currentSymbol === '(') bracketEquality += 1;else if (currentSymbol === ')') bracketEquality -= 1;else if (currentSymbol === '"') quoted = !quoted;else if (!quoted && line[currentIndex] === ' ' && bracketEquality === 0) {
      if (currentIndex > firstSliceIndex + 1) {
        split.push(line.slice(firstSliceIndex + 1, currentIndex));
      }
      firstSliceIndex = currentIndex;
    }
  }
  if (currentIndex > firstSliceIndex + 1) {
    split.push(line.slice(firstSliceIndex + 1, currentIndex));
  }
  return split;
}
function stripQuotes(str) {
  if (str[0] === '"' && str[str.length - 1] === '"') {
    return str.substr(1, str.length - 2);
  }
  return str;
}
function splitonce(line, delim) {
  var p = line.indexOf(delim);
  return [line.slice(0, p), line.slice(p + 1)];
}
function splitSGroupDef(line) {
  var split = [];
  var braceBalance = 0;
  var quoted = false;
  for (var i = 0; i < line.length; ++i) {
    var c = line.charAt(i);
    if (c === '"') {
      quoted = !quoted;
    } else if (!quoted) {
      if (c === '(') {
        braceBalance++;
      } else if (c === ')') {
        braceBalance--;
      } else if (c === ' ' && braceBalance === 0) {
        split.push(line.slice(0, i));
        line = line.slice(i + 1).trim();
        i = 0;
      }
    }
  }
  if (braceBalance !== 0) {
    throw new Error('Brace balance broken. S-group properies invalid!');
  }
  if (line.length > 0) split.push(line.trim());
  return split;
}
function parseBracedNumberList(line, shift) {
  if (!line) return null;
  var list = [];
  line = line.trim();
  line = line.substr(1, line.length - 2);
  var split = line.split(' ');
  shift = shift || 0;
  for (var i = 1; i < split.length; ++i) {
    var value = parseInt(split[i]);
    if (!isNaN(value)) {
      list.push(value + shift);
    }
  }
  return list;
}
function stripV30(line) {
  if (line.slice(0, 7) !== 'M  V30 ') throw new Error('Prefix invalid');
  return line.slice(7);
}
function labelsListToIds(labels) {
  var ids = [];
  for (var i = 0; i < labels.length; ++i) {
    var element = Elements.get(labels[i].trim());
    if (element) {
      ids.push(element.number);
    }
  }
  return ids;
}
var v3000 = {
  parseCTabV3000: parseCTabV3000,
  readRGroups3000: readRGroups3000,
  parseRxn3000: parseRxn3000
};

var loadRGroupFragments = true;
function parseMol( ctabLines, ignoreChiralFlag) {
  if (ctabLines[0].search('\\$MDL') === 0) {
    var _struct = v2000.parseRg2000(ctabLines, ignoreChiralFlag);
    _struct.name = ctabLines[3].trim();
    return _struct;
  }
  var struct = parseCTab(ctabLines.slice(3), ignoreChiralFlag);
  struct.name = ctabLines[0].trim();
  return struct;
}
function parseCTab( ctabLines, ignoreChiralFlag) {
  var countsSplit = partitionLine(ctabLines[0], utils.fmtInfo.countsLinePartition);
  var version = countsSplit[11].trim();
  ctabLines = ctabLines.slice(1);
  if (version === 'V2000') {
    return v2000.parseCTabV2000(ctabLines, countsSplit, ignoreChiralFlag);
  }
  if (version === 'V3000') {
    return v3000.parseCTabV3000(ctabLines, !loadRGroupFragments);
  } else {
    throw new Error('Molfile version unknown: ' + version);
  }
}
function parseRxn( ctabLines, shouldReactionRelayout, ignoreChiralFlag) {
  var split = ctabLines[0].trim().split(' ');
  if (split.length > 1 && split[1] === 'V3000') {
    return v3000.parseRxn3000(ctabLines, shouldReactionRelayout);
  }
  var struct = v2000.parseRxn2000(ctabLines, shouldReactionRelayout, ignoreChiralFlag);
  struct.name = ctabLines[1].trim();
  return struct;
}
var prepareForSaving = {
  MUL: SGroup.prepareMulForSaving,
  SRU: prepareSruForSaving,
  SUP: prepareSupForSaving,
  DAT: prepareDatForSaving,
  GEN: prepareGenForSaving,
  queryComponent: prepareQueryComponentForSaving
};
function prepareSruForSaving(sgroup, mol) {
  var xBonds = [];
  mol.bonds.forEach(function (bond, bid) {
    var a1 = mol.atoms.get(bond.begin);
    var a2 = mol.atoms.get(bond.end);
    if (a1.sgs.has(sgroup.id) && !a2.sgs.has(sgroup.id) || a2.sgs.has(sgroup.id) && !a1.sgs.has(sgroup.id)) {
      xBonds.push(bid);
    }
  }, sgroup);
  if (xBonds.length !== 0 && xBonds.length !== 2) {
    throw {
      id: sgroup.id,
      'error-type': 'cross-bond-number',
      message: 'Unsupported cross-bonds number'
    };
  }
  sgroup.bonds = xBonds;
}
function prepareSupForSaving(sgroup, mol) {
  var xBonds = [];
  mol.bonds.forEach(function (bond, bid) {
    var a1 = mol.atoms.get(bond.begin);
    var a2 = mol.atoms.get(bond.end);
    if (a1.sgs.has(sgroup.id) && !a2.sgs.has(sgroup.id) || a2.sgs.has(sgroup.id) && !a1.sgs.has(sgroup.id)) {
      xBonds.push(bid);
    }
  }, sgroup);
  sgroup.bonds = xBonds;
}
function prepareGenForSaving(_sgroup, _mol) {
}
function prepareQueryComponentForSaving(_sgroup, _mol) {
}
function prepareDatForSaving(sgroup, mol) {
  sgroup.atoms = SGroup.getAtoms(mol, sgroup);
}
var saveToMolfile = {
  MUL: saveMulToMolfile,
  SRU: saveSruToMolfile,
  SUP: saveSupToMolfile,
  DAT: saveDatToMolfile,
  GEN: saveGenToMolfile
};
function saveMulToMolfile(sgroup, mol, sgMap, atomMap, bondMap) {
  var idstr = (sgMap[sgroup.id] + '').padStart(3);
  var lines = [];
  lines = lines.concat(makeAtomBondLines('SAL', idstr, Array.from(sgroup.atomSet.values()), atomMap));
  lines = lines.concat(makeAtomBondLines('SPA', idstr, Array.from(sgroup.parentAtomSet.values()), atomMap));
  lines = lines.concat(makeAtomBondLines('SBL', idstr, sgroup.bonds, bondMap));
  var smtLine = 'M  SMT ' + idstr + ' ' + sgroup.data.mul;
  lines.push(smtLine);
  lines = lines.concat(bracketsToMolfile(mol, sgroup, idstr));
  return lines.join('\n');
}
function saveSruToMolfile(sgroup, mol, sgMap, atomMap, bondMap) {
  var idstr = (sgMap[sgroup.id] + '').padStart(3);
  var lines = [];
  lines = lines.concat(makeAtomBondLines('SAL', idstr, sgroup.atoms, atomMap));
  lines = lines.concat(makeAtomBondLines('SBL', idstr, sgroup.bonds, bondMap));
  lines = lines.concat(bracketsToMolfile(mol, sgroup, idstr));
  return lines.join('\n');
}
function saveSupToMolfile(sgroup, mol, sgMap, atomMap, bondMap) {
  var idstr = (sgMap[sgroup.id] + '').padStart(3);
  var lines = [];
  lines = lines.concat(makeAtomBondLines('SAL', idstr, sgroup.atoms, atomMap));
  lines = lines.concat(makeAtomBondLines('SBL', idstr, sgroup.bonds, bondMap));
  if (sgroup.data.name && sgroup.data.name !== '') {
    lines.push('M  SMT ' + idstr + ' ' + sgroup.data.name);
  }
  return lines.join('\n');
}
function saveDatToMolfile(sgroup, mol, sgMap, atomMap) {
  var idstr = (sgMap[sgroup.id] + '').padStart(3);
  var data = sgroup.data;
  var pp = sgroup.pp;
  if (!data.absolute) pp = pp.sub(SGroup.getMassCentre(mol, sgroup.atoms));
  var lines = [];
  lines = lines.concat(makeAtomBondLines('SAL', idstr, sgroup.atoms, atomMap));
  var sdtLine = 'M  SDT ' + idstr + ' ' + (data.fieldName || '').padEnd(30) + (data.fieldType || '').padStart(2) + (data.units || '').padEnd(20) + (data.query || '').padStart(2);
  if (data.queryOp) {
    sdtLine += data.queryOp.padEnd(80 - 65);
  }
  lines.push(sdtLine);
  var sddLine = 'M  SDD ' + idstr + ' ' + utils.paddedNum(pp.x, 10, 4) + utils.paddedNum(-pp.y, 10, 4) + '    ' + (
  data.attached ? 'A' : 'D') + (
  data.absolute ? 'A' : 'R') + (
  data.showUnits ? 'U' : ' ') +
  '   ' + (
  data.nCharnCharsToDisplay >= 0 ? utils.paddedNum(data.nCharnCharsToDisplay, 3) : 'ALL') +
  '  1   ' + (
  data.tagChar || ' ') +
  '  ' + utils.paddedNum(data.daspPos, 1) +
  '  ';
  lines.push(sddLine);
  var val = normalizeNewlines(data.fieldValue).replace(/\n*$/, '');
  var charsPerLine = 69;
  val.split('\n').forEach(function (chars) {
    while (chars.length > charsPerLine) {
      lines.push('M  SCD ' + idstr + ' ' + chars.slice(0, charsPerLine));
      chars = chars.slice(charsPerLine);
    }
    lines.push('M  SED ' + idstr + ' ' + chars);
  });
  return lines.join('\n');
}
function saveGenToMolfile(sgroup, mol, sgMap, atomMap, bondMap) {
  var idstr = (sgMap[sgroup.id] + '').padStart(3);
  var lines = [];
  lines = lines.concat(makeAtomBondLines('SAL', idstr, sgroup.atoms, atomMap));
  lines = lines.concat(makeAtomBondLines('SBL', idstr, sgroup.bonds, bondMap));
  lines = lines.concat(bracketsToMolfile(mol, sgroup, idstr));
  return lines.join('\n');
}
function makeAtomBondLines(prefix, idstr, ids, map) {
  if (!ids) return [];
  var lines = [];
  for (var i = 0; i < Math.floor((ids.length + 14) / 15); ++i) {
    var rem = Math.min(ids.length - 15 * i, 15);
    var salLine = 'M  ' + prefix + ' ' + idstr + ' ' + utils.paddedNum(rem, 2);
    for (var j = 0; j < rem; ++j) {
      salLine += ' ' + utils.paddedNum(map[ids[i * 15 + j]], 3);
    }
    lines.push(salLine);
  }
  return lines;
}
function bracketsToMolfile(mol, sg, idstr) {
  var atomSet = new Pile(sg.atoms);
  var crossBonds = SGroup.getCrossBonds(mol, atomSet);
  SGroup.bracketPos(sg, mol, crossBonds);
  var bb = sg.bracketBox;
  var d = sg.bracketDirection;
  var n = d.rotateSC(1, 0);
  var brackets = SGroup.getBracketParameters(mol, crossBonds, atomSet, bb, d, n);
  var lines = [];
  for (var i = 0; i < brackets.length; ++i) {
    var bracket = brackets[i];
    var a0 = bracket.c.addScaled(bracket.n, -0.5 * bracket.h).yComplement();
    var a1 = bracket.c.addScaled(bracket.n, 0.5 * bracket.h).yComplement();
    var line = 'M  SDI ' + idstr + utils.paddedNum(4, 3);
    var coord = [a0.x, a0.y, a1.x, a1.y];
    for (var j = 0; j < coord.length; ++j) {
      line += utils.paddedNum(coord[j], 10, 4);
    }
    lines.push(line);
  }
  return lines;
}
var nlRe = /\r\n|[\n\r]/g;
function normalizeNewlines(str) {
  return str.replace(nlRe, '\n');
}
function partitionLine( str, parts, withspace) {
  var res = [];
  for (var i = 0, shift = 0; i < parts.length; ++i) {
    res.push(str.slice(shift, shift + parts[i]));
    if (withspace) shift++;
    shift += parts[i];
  }
  return res;
}
var common = {
  parseCTab: parseCTab,
  parseMol: parseMol,
  parseRxn: parseRxn,
  prepareForSaving: prepareForSaving,
  saveToMolfile: saveToMolfile
};

var END_V2000 = '2D 1   1.00000     0.00000     0';
var Molfile = function () {
  function Molfile() {
    _classCallCheck__default["default"](this, Molfile);
    this.molecule = null;
    this.molfile = null;
    this.reaction = false;
    this.mapping = {};
    this.bondMapping = {};
  }
  _createClass__default["default"](Molfile, [{
    key: "parseCTFile",
    value: function parseCTFile(props) {
      var molfileLines = props.molfileLines,
        shouldReactionRelayout = props.shouldReactionRelayout,
        ignoreChiralFlag = props.ignoreChiralFlag;
      var ret;
      if (molfileLines[0].search('\\$RXN') === 0) {
        ret = common.parseRxn(molfileLines, shouldReactionRelayout, ignoreChiralFlag);
      } else {
        ret = common.parseMol(molfileLines, ignoreChiralFlag);
      }
      ret.initHalfBonds();
      ret.initNeighbors();
      ret.bindSGroupsToFunctionalGroups();
      ret.markFragments();
      return ret;
    }
  }, {
    key: "prepareSGroups",
    value: function prepareSGroups(skipErrors, preserveIndigoDesc) {
      var _this$molecule;
      var mol = this.molecule;
      var toRemove = [];
      var errors = 0;
      (_this$molecule = this.molecule) === null || _this$molecule === void 0 || _this$molecule.sGroupForest.getSGroupsBFS().reverse().forEach(function (id) {
        var sgroup = mol.sgroups.get(id);
        var errorIgnore = false;
        try {
          common.prepareForSaving[sgroup.type](sgroup, mol);
        } catch (e) {
          KetcherLogger.error('molfile.ts::Molfile::prepareSGroups', e);
          if (!skipErrors || typeof e.id !== 'number') {
            throw new Error("Error: ".concat(e.message));
          }
          errorIgnore = true;
        }
        if (errorIgnore || !preserveIndigoDesc && /^INDIGO_.+_DESC$/i.test(sgroup.data.fieldName)) {
          errors += +errorIgnore;
          toRemove.push(sgroup.id);
        }
      }, this);
      if (errors) {
        throw new Error('Warning: ' + errors + ' invalid S-groups were detected. They will be omitted.');
      }
      for (var i = 0; i < toRemove.length; ++i) {
        mol === null || mol === void 0 || mol.sGroupDelete(toRemove[i]);
      }
    }
  }, {
    key: "getCTab",
    value: function getCTab(molecule, rgroups) {
      this.molecule = molecule.clone();
      this.prepareSGroups(false, false);
      this.molfile = '';
      this.writeCTab2000(rgroups);
      return this.molfile;
    }
  }, {
    key: "saveMolecule",
    value: function saveMolecule(molecule, skipSGroupErrors, norgroups, preserveIndigoDesc, ignoreChiralFlag) {
      var _this = this;
      this.reaction = molecule.hasRxnArrow();
      this.molfile = '' + molecule.name;
      if (this.reaction) {
        if (molecule.rgroups.size > 0) {
          throw new Error('Reactions with r-groups are not supported at the moment');
        }
        var components = molecule.getComponents();
        var reactants = components.reactants;
        var products = components.products;
        var all = reactants.concat(products);
        this.molfile = '$RXN\n' + molecule.name + '\n\n\n' + utils.paddedNum(reactants.length, 3) + utils.paddedNum(products.length, 3) + utils.paddedNum(0, 3) + '\n';
        for (var i = 0; i < all.length; ++i) {
          var saver = new Molfile();
          var submol = molecule.clone(all[i], null, true);
          var molfile = saver.saveMolecule(submol, false, true);
          this.molfile += '$MOL\n' + molfile;
        }
        return this.molfile;
      }
      if (molecule.rgroups.size > 0) {
        if (norgroups) {
          molecule = molecule.getScaffold();
        } else {
          var scaffold = new Molfile().getCTab(molecule.getScaffold(), molecule.rgroups);
          this.molfile = '$MDL  REV  1\n$MOL\n$HDR\n' + molecule.name + '\n\n\n$END HDR\n';
          this.molfile += '$CTAB\n' + scaffold + '$END CTAB\n';
          molecule.rgroups.forEach(function (rg, rgid) {
            _this.molfile += '$RGP\n';
            _this.writePaddedNumber(rgid, 3);
            _this.molfile += '\n';
            rg.frags.forEach(function (fid) {
              var group = new Molfile().getCTab(molecule.getFragment(fid));
              _this.molfile += '$CTAB\n' + group + '$END CTAB\n';
            });
            _this.molfile += '$END RGP\n';
          });
          this.molfile += '$END MOL\n';
          return this.molfile;
        }
      }
      this.molecule = molecule.clone();
      this.prepareSGroups(skipSGroupErrors, preserveIndigoDesc);
      this.writeHeader();
      this.writeCTab2000(undefined, ignoreChiralFlag);
      return this.molfile;
    }
  }, {
    key: "writeHeader",
    value: function writeHeader() {
      var date = new Date();
      this.writeCR();
      this.writeWhiteSpace(2);
      this.write('Ketcher');
      this.writeWhiteSpace();
      this.writeCR((date.getMonth() + 1 + '').padStart(2) + (date.getDate() + '').padStart(2) + (date.getFullYear() % 100 + '').padStart(2) + (date.getHours() + '').padStart(2) + (date.getMinutes() + '').padStart(2) + END_V2000);
      this.writeCR();
    }
  }, {
    key: "write",
    value: function write(str) {
      this.molfile += str;
    }
  }, {
    key: "writeCR",
    value: function writeCR(str) {
      if (arguments.length === 0) {
        str = '';
      }
      this.molfile += str + '\n';
    }
  }, {
    key: "writeWhiteSpace",
    value: function writeWhiteSpace() {
      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (arguments.length === 0) {
        length = 1;
      }
      this.write(' '.repeat(Math.max(length, 0)));
    }
  }, {
    key: "writePadded",
    value: function writePadded(str, width) {
      this.write(str);
      this.writeWhiteSpace(width - str.length);
    }
  }, {
    key: "writePaddedNumber",
    value: function writePaddedNumber(number, width) {
      var str = (number - 0).toString();
      this.writeWhiteSpace(width - str.length);
      this.write(str);
    }
  }, {
    key: "writePaddedFloat",
    value: function writePaddedFloat(number, width, precision) {
      this.write(utils.paddedNum(number, width, precision));
    }
  }, {
    key: "writeCTab2000Header",
    value: function writeCTab2000Header(ignoreChiralFlag) {
      this.writePaddedNumber(this.molecule.atoms.size, 3);
      this.writePaddedNumber(this.molecule.bonds.size, 3);
      this.writePaddedNumber(0, 3);
      this.writePaddedNumber(0, 3);
      var isAbsFlag = Array.from(this.molecule.frags.values()).some(function (fr) {
        return fr ? fr.enhancedStereoFlag === exports.StereoFlag.Abs : false;
      });
      this.writePaddedNumber(isAbsFlag || ignoreChiralFlag ? 1 : 0, 3);
      this.writePaddedNumber(0, 3);
      this.writePaddedNumber(0, 3);
      this.writePaddedNumber(0, 3);
      this.writePaddedNumber(0, 3);
      this.writePaddedNumber(0, 3);
      this.writePaddedNumber(999, 3);
      this.writeCR(' V2000');
    }
  }, {
    key: "writeCTab2000",
    value: function writeCTab2000(rgroups, ignoreChiralFlag) {
      var _this2 = this;
      this.writeCTab2000Header(ignoreChiralFlag);
      this.mapping = {};
      var i = 1;
      var atomsIds = [];
      var atomsProps = [];
      this.molecule.atoms.forEach(function (atom, id) {
        var label = atom.label;
        if (atom.atomList != null) {
          label = 'L';
          atomsIds.push(id);
        } else if (atom.pseudo) {
          if (atom.pseudo.length > 3) {
            label = 'A';
            atomsProps.push({
              id: id,
              value: "'".concat(atom.pseudo, "'")
            });
          }
        } else if (atom.alias) {
          atomsProps.push({
            id: id,
            value: atom.alias
          });
        } else if (!Elements.get(atom.label) && ['A', 'Q', 'X', '*', 'R#'].indexOf(atom.label) === -1) {
          label = 'C';
          atomsProps.push({
            id: id,
            value: atom.label
          });
        }
        _this2.writeAtom(atom, label);
        _this2.mapping[id] = i++;
      }, this);
      this.bondMapping = {};
      i = 1;
      this.molecule.bonds.forEach(function (bond, id) {
        _this2.bondMapping[id] = i++;
        _this2.writeBond(bond);
      }, this);
      while (atomsProps.length > 0) {
        this.writeAtomProps(atomsProps[0]);
        atomsProps.splice(0, 1);
      }
      var chargeList = [];
      var isotopeList = [];
      var radicalList = [];
      var rglabelList = [];
      var rglogicList = [];
      var aplabelList = [];
      var rbcountList = [];
      var unsaturatedList = [];
      var substcountList = [];
      this.molecule.atoms.forEach(function (atom, id) {
        if (atom.charge !== 0 && atom.charge !== null) {
          chargeList.push([id, atom.charge]);
        }
        if (atom.isotope !== 0 && atom.isotope !== null) {
          isotopeList.push([id, atom.isotope]);
        }
        if (atom.radical !== 0) {
          radicalList.push([id, atom.radical]);
        }
        if (atom.rglabel != null && atom.label === 'R#') {
          for (var rgi = 0; rgi < 32; rgi++) {
            if (atom.rglabel & 1 << rgi) {
              rglabelList.push([id, rgi + 1]);
            }
          }
        }
        if (atom.attachmentPoints != null) {
          aplabelList.push([id, atom.attachmentPoints]);
        }
        if (atom.ringBondCount !== 0) {
          rbcountList.push([id, atom.ringBondCount]);
        }
        if (atom.substitutionCount !== 0) {
          substcountList.push([id, atom.substitutionCount]);
        }
        if (atom.unsaturatedAtom !== 0) {
          unsaturatedList.push([id, atom.unsaturatedAtom]);
        }
      });
      if (rgroups) {
        rgroups.forEach(function (rg, rgid) {
          if (rg.resth || rg.ifthen > 0 || rg.range.length > 0) {
            var line = '  1 ' + utils.paddedNum(rgid, 3) + ' ' + utils.paddedNum(rg.ifthen, 3) + ' ' + utils.paddedNum(rg.resth ? 1 : 0, 3) + '   ' + rg.range;
            rglogicList.push(line);
          }
        });
      }
      this.writeAtomPropList('M  CHG', chargeList);
      this.writeAtomPropList('M  ISO', isotopeList);
      this.writeAtomPropList('M  RAD', radicalList);
      this.writeAtomPropList('M  RGP', rglabelList);
      for (var j = 0; j < rglogicList.length; ++j) {
        this.write('M  LOG' + rglogicList[j] + '\n');
      }
      this.writeAtomPropList('M  APO', aplabelList);
      this.writeAtomPropList('M  RBC', rbcountList);
      this.writeAtomPropList('M  SUB', substcountList);
      this.writeAtomPropList('M  UNS', unsaturatedList);
      if (atomsIds.length > 0) {
        for (var _j = 0; _j < atomsIds.length; ++_j) {
          var atomId = atomsIds[_j];
          var atomList = this.molecule.atoms.get(atomId).atomList;
          this.write('M  ALS');
          this.writePaddedNumber(atomId + 1, 4);
          this.writePaddedNumber(atomList.ids.length, 3);
          this.writeWhiteSpace();
          this.write(atomList.notList ? 'T' : 'F');
          var labelList = atomList.labelList();
          for (var k = 0; k < labelList.length; ++k) {
            this.writeWhiteSpace();
            this.writePadded(labelList[k], 3);
          }
          this.writeWhiteSpace();
          this.writeCR();
        }
      }
      var sgmap = {};
      var cnt = 1;
      var sgmapback = {};
      var sgorder = this.molecule.sGroupForest.getSGroupsBFS();
      sgorder.forEach(function (id) {
        sgmapback[cnt] = id;
        sgmap[id] = cnt++;
      });
      var _loop = function _loop(sGroupIdInCTab) {
        var id = sgmapback[sGroupIdInCTab];
        var sgroup = _this2.molecule.sgroups.get(id);
        if (SGroup.isQuerySGroup(sgroup)) {
          return 1;
        }
        _this2.write('M  STY');
        _this2.writePaddedNumber(1, 3);
        _this2.writeWhiteSpace(1);
        _this2.writePaddedNumber(sGroupIdInCTab, 3);
        _this2.writeWhiteSpace(1);
        _this2.writePadded(sgroup.type, 3);
        _this2.writeCR();
        _this2.write('M  SLB');
        _this2.writePaddedNumber(1, 3);
        _this2.writeWhiteSpace(1);
        _this2.writePaddedNumber(sGroupIdInCTab, 3);
        _this2.writeWhiteSpace(1);
        _this2.writePaddedNumber(sGroupIdInCTab, 3);
        _this2.writeCR();
        var parentId = _this2.molecule.sGroupForest.parent.get(id);
        if (parentId >= 0) {
          _this2.write('M  SPL');
          _this2.writePaddedNumber(1, 3);
          _this2.writeWhiteSpace(1);
          _this2.writePaddedNumber(sGroupIdInCTab, 3);
          _this2.writeWhiteSpace(1);
          _this2.writePaddedNumber(sgmap[parentId], 3);
          _this2.writeCR();
        }
        if (sgroup.type === 'SRU' && sgroup.data.connectivity) {
          var connectivity = " ".concat(sGroupIdInCTab.toString().padStart(3), " ").concat((sgroup.data.connectivity || '').padEnd(3));
          _this2.write('M  SCN');
          _this2.writePaddedNumber(1, 3);
          _this2.write(connectivity.toUpperCase());
          _this2.writeCR();
        }
        if (sgroup.type === 'SRU') {
          _this2.write('M  SMT ');
          _this2.writePaddedNumber(sGroupIdInCTab, 3);
          _this2.writeWhiteSpace();
          _this2.write(sgroup.data.subscript || 'n');
          _this2.writeCR();
        }
        sgroup.getAttachmentPoints().forEach(function (attachmentPoint) {
          _this2.writeSGroupAttachmentPointLine(sGroupIdInCTab, attachmentPoint);
        });
        _this2.writeCR(common.saveToMolfile[sgroup.type](sgroup, _this2.molecule, sgmap, _this2.mapping, _this2.bondMapping));
      };
      for (var sGroupIdInCTab = 1; sGroupIdInCTab < cnt; ++sGroupIdInCTab) {
        if (_loop(sGroupIdInCTab)) continue;
      }
      var expandedGroups = [];
      this.molecule.sgroups.forEach(function (sg) {
        if (sg.isExpanded() && !SGroup.isQuerySGroup(sg)) expandedGroups.push(sg.id + 1);
      });
      if (expandedGroups.length) {
        var expandedGroupsLine = "M  SDS EXP  ".concat(expandedGroups.length, "   ").concat(expandedGroups.join('   '));
        this.writeCR(expandedGroupsLine);
      }
      this.writeCR('M  END');
    }
  }, {
    key: "writeAtom",
    value: function writeAtom(atom, atomLabel) {
      this.writePaddedFloat(atom.pp.x, 10, 4);
      this.writePaddedFloat(-atom.pp.y, 10, 4);
      this.writePaddedFloat(atom.pp.z, 10, 4);
      this.writeWhiteSpace();
      this.writePadded(atomLabel, 3);
      this.writePaddedNumber(0, 2);
      this.writePaddedNumber(0, 3);
      this.writePaddedNumber(0, 3);
      if (typeof atom.hCount === 'undefined') {
        atom.hCount = 0;
      }
      this.writePaddedNumber(atom.hCount, 3);
      if (typeof atom.stereoCare === 'undefined') {
        atom.stereoCare = 0;
      }
      this.writePaddedNumber(atom.stereoCare, 3);
      var number;
      if (atom.explicitValence < 0) {
        number = 0;
      } else if (atom.explicitValence === 0) {
        number = 15;
      } else {
        number = atom.explicitValence;
      }
      this.writePaddedNumber(number, 3);
      this.writePaddedNumber(0, 3);
      this.writePaddedNumber(0, 3);
      this.writePaddedNumber(0, 3);
      if (typeof atom.aam === 'undefined') {
        atom.aam = 0;
      }
      this.writePaddedNumber(atom.aam, 3);
      if (typeof atom.invRet === 'undefined') {
        atom.invRet = 0;
      }
      this.writePaddedNumber(atom.invRet, 3);
      if (typeof atom.exactChangeFlag === 'undefined') {
        atom.exactChangeFlag = 0;
      }
      this.writePaddedNumber(atom.exactChangeFlag, 3);
      this.writeCR();
    }
  }, {
    key: "writeBond",
    value: function writeBond(bond) {
      this.writePaddedNumber(this.mapping[bond.begin], 3);
      this.writePaddedNumber(this.mapping[bond.end], 3);
      this.writePaddedNumber(bond.type, 3);
      if (typeof bond.stereo === 'undefined') {
        bond.stereo = 0;
      }
      this.writePaddedNumber(bond.stereo, 3);
      this.writePadded(bond.xxx, 3);
      if (typeof bond.topology === 'undefined') {
        bond.topology = 0;
      }
      this.writePaddedNumber(bond.topology, 3);
      if (typeof bond.reactingCenterStatus === 'undefined') {
        bond.reactingCenterStatus = 0;
      }
      this.writePaddedNumber(bond.reactingCenterStatus, 3);
      this.writeCR();
    }
  }, {
    key: "writeAtomProps",
    value: function writeAtomProps(props) {
      this.write('A  ');
      this.writePaddedNumber(props.id + 1, 3);
      this.writeCR();
      this.writeCR(props.value);
    }
  }, {
    key: "writeAtomPropList",
    value: function writeAtomPropList(propId, values) {
      var _this3 = this;
      while (values.length > 0) {
        var part = [];
        while (values.length > 0 && part.length < 8) {
          part.push(values[0]);
          values.splice(0, 1);
        }
        this.write(propId);
        this.writePaddedNumber(part.length, 3);
        part.forEach(function (value) {
          _this3.writeWhiteSpace();
          _this3.writePaddedNumber(_this3.mapping[value[0]], 3);
          _this3.writeWhiteSpace();
          _this3.writePaddedNumber(value[1], 3);
        });
        this.writeCR();
      }
    }
  }, {
    key: "writeSGroupAttachmentPointLine",
    value: function writeSGroupAttachmentPointLine(sgroupId, attachmentPoint) {
      var _this$mapping$attachm;
      this.write("M  SAP");
      this.writeWhiteSpace(1);
      this.writePaddedNumber(sgroupId, 3);
      this.writePaddedNumber(1, 3);
      this.writeWhiteSpace(1);
      var atomId = this.mapping[attachmentPoint.atomId];
      this.writePaddedNumber(atomId, 3);
      this.writeWhiteSpace(1);
      var leaveAtomId = (_this$mapping$attachm = this.mapping[attachmentPoint.leaveAtomId]) !== null && _this$mapping$attachm !== void 0 ? _this$mapping$attachm : 0;
      this.writePaddedNumber(leaveAtomId, 3);
      this.writeWhiteSpace(1);
      var attachmentId = attachmentPoint.attachmentId ? attachmentPoint.attachmentId.slice(0, 2) : '  ';
      this.writePadded(attachmentId, 2);
      this.writeCR();
    }
  }]);
  return Molfile;
}();

function ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var MolSerializer = function () {
  function MolSerializer(options) {
    _classCallCheck__default["default"](this, MolSerializer);
    this.options = _objectSpread$b(_objectSpread$b({}, MolSerializer.DefaultOptions), options);
  }
  _createClass__default["default"](MolSerializer, [{
    key: "deserialize",
    value: function deserialize(content) {
      var molfile = new Molfile();
      var lines = content === null || content === void 0 ? void 0 : content.split(/\r\n|[\n\r]/g);
      var parseCTFileParams = {
        molfileLines: lines,
        shouldReactionRelayout: this.options.reactionRelayout,
        ignoreChiralFlag: this.options.ignoreChiralFlag
      };
      try {
        return molfile.parseCTFile(parseCTFileParams);
      } catch (e) {
        KetcherLogger.error('molSerializer::MolSerializer::deserialize', e);
        if (this.options.badHeaderRecover) {
          try {
            return molfile.parseCTFile(_objectSpread$b(_objectSpread$b({}, parseCTFileParams), {}, {
              molfileLines: lines.slice(1)
            }));
          } catch (e1) {
            KetcherLogger.error('molSerializer::MolSerializer::deserialize', e1);
          }
          try {
            return molfile.parseCTFile(_objectSpread$b(_objectSpread$b({}, parseCTFileParams), {}, {
              molfileLines: [''].concat(lines)
            }));
          } catch (e2) {
            KetcherLogger.error('molSerializer::MolSerializer::deserialize', e2);
          }
        }
        throw e;
      }
    }
  }, {
    key: "serialize",
    value: function serialize(struct) {
      return new Molfile().saveMolecule(struct, this.options.ignoreErrors, this.options.noRgroups, this.options.preserveIndigoDesc, this.options.ignoreChiralFlag);
    }
  }]);
  return MolSerializer;
}();
_defineProperty__default["default"](MolSerializer, "DefaultOptions", {
  badHeaderRecover: false,
  ignoreErrors: false,
  noRgroups: false,
  preserveIndigoDesc: false,
  reactionRelayout: false
});

function CisTrans(mol, neighborsFunc, context) {
  this.molecule = mol;
  this.bonds = new Pool();
  this.getNeighbors = neighborsFunc;
  this.context = context;
}
CisTrans.PARITY = {
  NONE: 0,
  CIS: 1,
  TRANS: 2
};
CisTrans.prototype.each = function (func) {
  this.bonds.forEach(func);
};
CisTrans.prototype.getParity = function (idx) {
  return this.bonds.get(idx).parity;
};
CisTrans.prototype.getSubstituents = function (idx) {
  return this.bonds.get(idx).substituents;
};
CisTrans.prototype.sameside = function (beg, end, neiBeg, neiEnd) {
  var diff = Vec2.diff(beg, end);
  var norm = new Vec2(-diff.y, diff.x);
  if (!norm.normalize()) return 0;
  var normBeg = Vec2.diff(neiBeg, beg);
  var normEnd = Vec2.diff(neiEnd, end);
  if (!normBeg.normalize()) return 0;
  if (!normEnd.normalize()) return 0;
  var prodBeg = Vec2.dot(normBeg, norm);
  var prodEnd = Vec2.dot(normEnd, norm);
  if (Math.abs(prodBeg) < 0.001 || Math.abs(prodEnd) < 0.001) return 0;
  return prodBeg * prodEnd > 0 ? 1 : -1;
};
CisTrans.prototype.samesides = function (iBeg, iEnd, iNeiBeg, iNeiEnd) {
  return this.sameside(this.molecule.atoms.get(iBeg).pp, this.molecule.atoms.get(iEnd).pp, this.molecule.atoms.get(iNeiBeg).pp, this.molecule.atoms.get(iNeiEnd).pp);
};
CisTrans.prototype.sortSubstituents = function (substituents) {
  var h0 = this.molecule.atoms.get(substituents[0]).pureHydrogen();
  var h1 = substituents[1] < 0 || this.molecule.atoms.get(substituents[1]).pureHydrogen();
  var h2 = this.molecule.atoms.get(substituents[2]).pureHydrogen();
  var h3 = substituents[3] < 0 || this.molecule.atoms.get(substituents[3]).pureHydrogen();
  if (h0 && h1) return false;
  if (h2 && h3) return false;
  if (h1) {
    substituents[1] = -1;
  } else if (h0) {
    substituents[0] = substituents[1];
    substituents[1] = -1;
  } else if (substituents[0] > substituents[1]) {
    swap$1(substituents, 0, 1);
  }
  if (h3) {
    substituents[3] = -1;
  } else if (h2) {
    substituents[2] = substituents[3];
    substituents[3] = -1;
  } else if (substituents[2] > substituents[3]) {
    swap$1(substituents, 2, 3);
  }
  return true;
};
CisTrans.prototype.isGeomStereoBond = function (bondIdx, substituents) {
  var bond = this.molecule.bonds.get(bondIdx);
  if (bond.type !== Bond.PATTERN.TYPE.DOUBLE) return false;
  var label1 = this.molecule.atoms.get(bond.begin).label;
  var label2 = this.molecule.atoms.get(bond.end).label;
  if (label1 !== 'C' && label1 !== 'N' && label1 !== 'Si' && label1 !== 'Ge') {
    return false;
  }
  if (label2 !== 'C' && label2 !== 'N' && label2 !== 'Si' && label2 !== 'Ge') {
    return false;
  }
  var neiBegin = this.getNeighbors.call(this.context, bond.begin);
  var neiEnd = this.getNeighbors.call(this.context, bond.end);
  if (neiBegin.length < 2 || neiBegin.length > 3 || neiEnd.length < 2 || neiEnd.length > 3) {
    return false;
  }
  substituents[0] = -1;
  substituents[1] = -1;
  substituents[2] = -1;
  substituents[3] = -1;
  var i;
  var nei;
  for (i = 0; i < neiBegin.length; i++) {
    nei = neiBegin[i];
    if (nei.bid === bondIdx) continue;
    if (this.molecule.bonds.get(nei.bid).type !== Bond.PATTERN.TYPE.SINGLE) {
      return false;
    }
    if (substituents[0] === -1) substituents[0] = nei.aid;
    else substituents[1] = nei.aid;
  }
  for (i = 0; i < neiEnd.length; i++) {
    nei = neiEnd[i];
    if (nei.bid === bondIdx) continue;
    if (this.molecule.bonds.get(nei.bid).type !== Bond.PATTERN.TYPE.SINGLE) {
      return false;
    }
    if (substituents[2] === -1) substituents[2] = nei.aid;
    else substituents[3] = nei.aid;
  }
  if (substituents[1] !== -1 && this.samesides(bond.begin, bond.end, substituents[0], substituents[1]) !== -1) {
    return false;
  }
  if (substituents[3] !== -1 && this.samesides(bond.begin, bond.end, substituents[2], substituents[3]) !== -1) {
    return false;
  }
  return true;
};
CisTrans.prototype.build = function (excludeBonds) {
  var _this = this;
  this.molecule.bonds.forEach(function (bond, bid) {
    var ct = {
      parity: 0,
      substituents: []
    };
    _this.bonds.set(bid, ct);
    if (Array.isArray(excludeBonds) && excludeBonds[bid]) return;
    if (!_this.isGeomStereoBond(bid, ct.substituents)) return;
    if (!_this.sortSubstituents(ct.substituents)) return;
    var sign = _this.samesides(bond.begin, bond.end, ct.substituents[0], ct.substituents[2]);
    if (sign === 1) ct.parity = CisTrans.PARITY.CIS;else if (sign === -1) ct.parity = CisTrans.PARITY.TRANS;
  });
};
function swap$1(arr, i1, i2) {
  var tmp = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = tmp;
}

function Dfs(mol, atomData, components, nReactants) {
  var _this = this;
  this.molecule = mol;
  this.atom_data = atomData;
  this.components = components;
  this.nComponentsInReactants = -1;
  this.nReactants = nReactants;
  this.vertices = new Array(this.molecule.atoms.size);
  this.molecule.atoms.forEach(function (atom, aid) {
    _this.vertices[aid] = new Dfs.VertexDesc();
  }, this);
  this.edges = new Array(this.molecule.bonds.size);
  this.molecule.bonds.forEach(function (bond, bid) {
    _this.edges[bid] = new Dfs.EdgeDesc();
  }, this);
  this.v_seq = [];
}
Dfs.VertexDesc = function () {
  this.dfs_state = 0;
  this.parent_vertex = 0;
  this.parent_edge = 0;
  this.branches = 0;
};
Dfs.EdgeDesc = function () {
  this.opening_cycles = 0;
  this.closing_cycle = 0;
};
Dfs.SeqElem = function (vIdx, parVertex, parEdge) {
  this.idx = vIdx;
  this.parent_vertex = parVertex;
  this.parent_edge = parEdge;
};
Dfs.prototype.walk = function () {
  var _this2 = this;
  var vStack = [];
  var i, j;
  var cid = 0;
  var component = 0;
  var _loop = function _loop() {
    if (vStack.length < 1) {
      var selected = -1;
      while (cid < _this2.components.length && selected === -1) {
        selected = _this2.components[cid].find(function (aid) {
          if (_this2.vertices[aid].dfs_state === 0) {
            selected = aid;
            return true;
          }
          return false;
        });
        if (selected === null) {
          selected = -1;
          cid++;
        }
        if (cid === _this2.nReactants) _this2.nComponentsInReactants = component;
      }
      if (selected < -1) {
        _this2.molecule.atoms.find(function (aid) {
          if (_this2.vertices[aid].dfs_state === 0) {
            selected = aid;
            return true;
          }
          return false;
        });
      }
      if (selected === -1) return 1;
      _this2.vertices[selected].parent_vertex = -1;
      _this2.vertices[selected].parent_edge = -1;
      vStack.push(selected);
      component++;
    }
    var vIdx = vStack.pop();
    var parentVertex = _this2.vertices[vIdx].parent_vertex;
    var seqElem = new Dfs.SeqElem(vIdx, parentVertex, _this2.vertices[vIdx].parent_edge);
    _this2.v_seq.push(seqElem);
    _this2.vertices[vIdx].dfs_state = 2;
    var atomD = _this2.atom_data[vIdx];
    for (i = 0; i < atomD.neighbours.length; i++) {
      var neiIdx = atomD.neighbours[i].aid;
      var edgeIdx = atomD.neighbours[i].bid;
      if (neiIdx === parentVertex) continue;
      if (_this2.vertices[neiIdx].dfs_state === 2) {
        _this2.edges[edgeIdx].closing_cycle = 1;
        j = vIdx;
        while (j !== -1 && _this2.vertices[j].parent_vertex !== neiIdx) {
          j = _this2.vertices[j].parent_vertex;
        }
        if (j === -1) throw new Error('cycle unwind error');
        _this2.edges[_this2.vertices[j].parent_edge].opening_cycles++;
        _this2.vertices[vIdx].branches++;
        seqElem = new Dfs.SeqElem(neiIdx, vIdx, edgeIdx);
        _this2.v_seq.push(seqElem);
      } else {
        if (_this2.vertices[neiIdx].dfs_state === 1) {
          j = vStack.indexOf(neiIdx);
          if (j === -1) {
            throw new Error('internal: removing vertex from stack');
          }
          vStack.splice(j, 1);
          var parent = _this2.vertices[neiIdx].parent_vertex;
          if (parent >= 0) {
            _this2.vertices[parent].branches--;
          }
        }
        _this2.vertices[vIdx].branches++;
        _this2.vertices[neiIdx].parent_vertex = vIdx;
        _this2.vertices[neiIdx].parent_edge = edgeIdx;
        _this2.vertices[neiIdx].dfs_state = 1;
        vStack.push(neiIdx);
      }
    }
  };
  while (true) {
    if (_loop()) break;
  }
};
Dfs.prototype.edgeClosingCycle = function (eIdx) {
  return this.edges[eIdx].closing_cycle !== 0;
};
Dfs.prototype.numBranches = function (vIdx) {
  return this.vertices[vIdx].branches;
};
Dfs.prototype.numOpeningCycles = function (eIdx) {
  return this.edges[eIdx].opening_cycles;
};
Dfs.prototype.toString = function () {
  var str = '';
  this.v_seq.forEach(function (seqElem) {
    str += seqElem.idx + ' -> ';
  });
  str += '*';
  return str;
};

function Stereocenters(mol, neighborsFunc, context) {
  this.molecule = mol;
  this.atoms = new Pool();
  this.getNeighbors = neighborsFunc;
  this.context = context;
}
Stereocenters.prototype.each = function (func, context) {
  this.atoms.forEach(func, context);
};
Stereocenters.prototype.buildFromBonds = function ( ignoreErrors) {
  var _this = this;
  var atoms = this.molecule.atoms;
  var bonds = this.molecule.bonds;
  var alleneMask = new Pile();
  atoms.forEach(function (atom, aid) {
    var neiList = _this.getNeighbors.call(_this.context, aid);
    if (neiList.length !== 2) return false;
    var nei1 = neiList[0];
    var nei2 = neiList[1];
    if ([aid, nei1.aid, nei2.aid].findIndex(function (aid) {
      return ['C', 'Si'].indexOf(atoms.get(aid).label) < 0;
    }, _this) >= 0) {
      return false;
    }
    if ([nei1.bid, nei2.bid].findIndex(function (bid) {
      return bonds.get(bid).type !== Bond.PATTERN.TYPE.DOUBLE;
    }, _this) >= 0) {
      return false;
    }
    var nei1nei = _this.getNeighbors.call(_this.context, nei1.aid).filter(function (nei) {
      return nei.aid !== aid;
    });
    var nei2nei = _this.getNeighbors.call(_this.context, nei2.aid).filter(function (nei) {
      return nei.aid !== aid;
    });
    if (nei1nei.length < 1 || nei1nei.length > 2 || nei2nei.length < 1 || nei2nei.length > 2) {
      return false;
    }
    if (nei1nei.concat(nei2nei).findIndex(function (nei) {
      return bonds.get(nei.bid).type !== Bond.PATTERN.TYPE.SINGLE;
    }, _this) >= 0) {
      return false;
    }
    if (nei1nei.concat(nei2nei).findIndex(function (nei) {
      return bonds.get(nei.bid).stereo === Bond.PATTERN.STEREO.EITHER;
    }, _this) >= 0) {
      return false;
    }
    alleneMask.add(nei1.aid).add(nei2.aid);
    return true;
  });
  if (alleneMask.size > 0) {
    atoms.forEach(function (atom, aid) {
      if (alleneMask.has(aid)) return;
      var neiList = _this.getNeighbors.call(_this.context, aid);
      var stereocenter = false;
      neiList.find(function (nei) {
        var bond = this.molecule.bonds.get(nei.bid);
        if (bond.type === Bond.PATTERN.TYPE.SINGLE && bond.begin === aid) {
          if (bond.stereo === Bond.PATTERN.STEREO.UP || bond.stereo === Bond.PATTERN.STEREO.DOWN) {
            stereocenter = true;
            return true;
          }
        }
        return false;
      }, _this);
      if (!stereocenter) return;
      if (ignoreErrors) {
        _this.buildOneCenter(aid );
      } else {
        _this.buildOneCenter(aid );
      }
    });
  }
};
Stereocenters.allowed_stereocenters = [{
  elem: 'C',
  charge: 0,
  degree: 3,
  n_double_bonds: 0,
  implicit_degree: 4
}, {
  elem: 'C',
  charge: 0,
  degree: 4,
  n_double_bonds: 0,
  implicit_degree: 4
}, {
  elem: 'Si',
  charge: 0,
  degree: 3,
  n_double_bonds: 0,
  implicit_degree: 4
}, {
  elem: 'Si',
  charge: 0,
  degree: 4,
  n_double_bonds: 0,
  implicit_degree: 4
}, {
  elem: 'N',
  charge: 1,
  degree: 3,
  n_double_bonds: 0,
  implicit_degree: 4
}, {
  elem: 'N',
  charge: 1,
  degree: 4,
  n_double_bonds: 0,
  implicit_degree: 4
}, {
  elem: 'N',
  charge: 0,
  degree: 3,
  n_double_bonds: 0,
  implicit_degree: 3
}, {
  elem: 'S',
  charge: 0,
  degree: 4,
  n_double_bonds: 2,
  implicit_degree: 4
}, {
  elem: 'S',
  charge: 1,
  degree: 3,
  n_double_bonds: 0,
  implicit_degree: 3
}, {
  elem: 'S',
  charge: 0,
  degree: 3,
  n_double_bonds: 1,
  implicit_degree: 3
}, {
  elem: 'P',
  charge: 0,
  degree: 3,
  n_double_bonds: 0,
  implicit_degree: 3
}, {
  elem: 'P',
  charge: 1,
  degree: 4,
  n_double_bonds: 0,
  implicit_degree: 4
}, {
  elem: 'P',
  charge: 0,
  degree: 4,
  n_double_bonds: 1,
  implicit_degree: 4
}];
Stereocenters.prototype.buildOneCenter = function (atomIdx ) {
  var _this2 = this;
  var atom = this.molecule.atoms.get(atomIdx);
  var neiList = this.getNeighbors.call(this.context, atomIdx);
  var degree = neiList.length;
  var implicitDegree = -1;
  var stereocenter = {
    group: 0,
    type: 0,
    pyramid: []
  };
  var edgeIds = [];
  var lastAtomDir = 0;
  var nDoubleBonds = 0;
  stereocenter.pyramid[0] = -1;
  stereocenter.pyramid[1] = -1;
  stereocenter.pyramid[2] = -1;
  stereocenter.pyramid[3] = -1;
  var nPureHydrogens = 0;
  if (degree > 4) {
    throw new Error('stereocenter with %d bonds are not supported' + degree);
  }
  neiList.forEach(function (nei, neiIdx) {
    var neiAtom = _this2.molecule.atoms.get(nei.aid);
    var bond = _this2.molecule.bonds.get(nei.bid);
    edgeIds[neiIdx] = {
      edge_idx: nei.bid,
      nei_idx: nei.aid,
      rank: nei.aid,
      vec: Vec2.diff(neiAtom.pp, atom.pp).yComplement()
    };
    if (neiAtom.pureHydrogen()) {
      nPureHydrogens++;
      edgeIds[neiIdx].rank = 10000;
    } else if (neiAtom.label === 'H') {
      edgeIds[neiIdx].rank = 5000;
    }
    if (!edgeIds[neiIdx].vec.normalize()) throw new Error('zero bond length');
    if (bond.type === Bond.PATTERN.TYPE.TRIPLE) {
      throw new Error('non-single bonds not allowed near stereocenter');
    } else if (bond.type === Bond.PATTERN.TYPE.AROMATIC) {
      throw new Error('aromatic bonds not allowed near stereocenter');
    } else if (bond.type === Bond.PATTERN.TYPE.DOUBLE) nDoubleBonds++;
  });
  Stereocenters.allowed_stereocenters.find(function (as) {
    if (as.elem === atom.label && as.charge === atom.charge && as.degree === degree && as.n_double_bonds === nDoubleBonds) {
      implicitDegree = as.implicit_degree;
      return true;
    }
    return false;
  });
  if (implicitDegree === -1) {
    throw new Error('unknown stereocenter configuration: ' + atom.label + ', charge ' + atom.charge + ', ' + degree + ' bonds (' + nDoubleBonds + ' double)');
  }
  if (degree === 4 && nPureHydrogens > 1) {
    throw new Error(nPureHydrogens + ' hydrogens near stereocenter');
  }
  if (degree === 3 && implicitDegree === 4 && nPureHydrogens > 0) {
    throw new Error('have hydrogen(s) besides implicit hydrogen near stereocenter');
  }
  if (degree === 4) {
    if (edgeIds[0].rank > edgeIds[1].rank) swap(edgeIds, 0, 1);
    if (edgeIds[1].rank > edgeIds[2].rank) swap(edgeIds, 1, 2);
    if (edgeIds[2].rank > edgeIds[3].rank) swap(edgeIds, 2, 3);
    if (edgeIds[1].rank > edgeIds[2].rank) swap(edgeIds, 1, 2);
    if (edgeIds[0].rank > edgeIds[1].rank) swap(edgeIds, 0, 1);
    if (edgeIds[1].rank > edgeIds[2].rank) swap(edgeIds, 1, 2);
    var main1 = -1;
    var main2 = -1;
    var side1 = -1;
    var side2 = -1;
    var mainDir = 0;
    for (var neiIdx = 0; neiIdx < 4; neiIdx++) {
      var stereo = this.getBondStereo(atomIdx, edgeIds[neiIdx].edge_idx);
      if (stereo === Bond.PATTERN.STEREO.UP || stereo === Bond.PATTERN.STEREO.DOWN) {
        main1 = neiIdx;
        mainDir = stereo;
        break;
      }
    }
    if (main1 === -1) {
      throw new Error('none of 4 bonds going from stereocenter is stereobond');
    }
    var xyz1, xyz2;
    if (main2 === -1) {
      xyz1 = Stereocenters.xyzzy(edgeIds[main1].vec, edgeIds[(main1 + 1) % 4].vec, edgeIds[(main1 + 2) % 4].vec);
      xyz2 = Stereocenters.xyzzy(edgeIds[main1].vec, edgeIds[(main1 + 1) % 4].vec, edgeIds[(main1 + 3) % 4].vec);
      if (xyz1 + xyz2 === 3 || xyz1 + xyz2 === 12) {
        main2 = (main1 + 1) % 4;
        side1 = (main1 + 2) % 4;
        side2 = (main1 + 3) % 4;
      }
    }
    if (main2 === -1) {
      xyz1 = Stereocenters.xyzzy(edgeIds[main1].vec, edgeIds[(main1 + 2) % 4].vec, edgeIds[(main1 + 1) % 4].vec);
      xyz2 = Stereocenters.xyzzy(edgeIds[main1].vec, edgeIds[(main1 + 2) % 4].vec, edgeIds[(main1 + 3) % 4].vec);
      if (xyz1 + xyz2 === 3 || xyz1 + xyz2 === 12) {
        main2 = (main1 + 2) % 4;
        side1 = (main1 + 1) % 4;
        side2 = (main1 + 3) % 4;
      }
    }
    if (main2 === -1) {
      xyz1 = Stereocenters.xyzzy(edgeIds[main1].vec, edgeIds[(main1 + 3) % 4].vec, edgeIds[(main1 + 1) % 4].vec);
      xyz2 = Stereocenters.xyzzy(edgeIds[main1].vec, edgeIds[(main1 + 3) % 4].vec, edgeIds[(main1 + 2) % 4].vec);
      if (xyz1 + xyz2 === 3 || xyz1 + xyz2 === 12) {
        main2 = (main1 + 3) % 4;
        side1 = (main1 + 2) % 4;
        side2 = (main1 + 1) % 4;
      }
    }
    if (main2 === -1) {
      throw new Error('internal error: can not find opposite bond');
    }
    if (mainDir === Bond.PATTERN.STEREO.UP && this.getBondStereo(atomIdx, edgeIds[main2].edge_idx) === Bond.PATTERN.STEREO.DOWN) {
      throw new Error('stereo types of the opposite bonds mismatch');
    }
    if (mainDir === Bond.PATTERN.STEREO.DOWN && this.getBondStereo(atomIdx, edgeIds[main2].edge_idx) === Bond.PATTERN.STEREO.UP) {
      throw new Error('stereo types of the opposite bonds mismatch');
    }
    if (mainDir === this.getBondStereo(atomIdx, edgeIds[side1].edge_idx)) {
      throw new Error('stereo types of non-opposite bonds match');
    }
    if (mainDir === this.getBondStereo(atomIdx, edgeIds[side2].edge_idx)) {
      throw new Error('stereo types of non-opposite bonds match');
    }
    if (main1 === 3 || main2 === 3) lastAtomDir = mainDir;else {
      lastAtomDir = mainDir === Bond.PATTERN.STEREO.UP ? Bond.PATTERN.STEREO.DOWN : Bond.PATTERN.STEREO.UP;
    }
    var sign = Stereocenters.sign(edgeIds[0].vec, edgeIds[1].vec, edgeIds[2].vec);
    if (lastAtomDir === Bond.PATTERN.STEREO.UP && sign > 0 || lastAtomDir === Bond.PATTERN.STEREO.DOWN && sign < 0) {
      stereocenter.pyramid[0] = edgeIds[0].nei_idx;
      stereocenter.pyramid[1] = edgeIds[1].nei_idx;
      stereocenter.pyramid[2] = edgeIds[2].nei_idx;
    } else {
      stereocenter.pyramid[0] = edgeIds[0].nei_idx;
      stereocenter.pyramid[1] = edgeIds[2].nei_idx;
      stereocenter.pyramid[2] = edgeIds[1].nei_idx;
    }
    stereocenter.pyramid[3] = edgeIds[3].nei_idx;
  } else if (degree === 3) {
    if (edgeIds[0].rank > edgeIds[1].rank) swap(edgeIds, 0, 1);
    if (edgeIds[1].rank > edgeIds[2].rank) swap(edgeIds, 1, 2);
    if (edgeIds[0].rank > edgeIds[1].rank) swap(edgeIds, 0, 1);
    var stereo0 = this.getBondStereo(atomIdx, edgeIds[0].edge_idx);
    var stereo1 = this.getBondStereo(atomIdx, edgeIds[1].edge_idx);
    var stereo2 = this.getBondStereo(atomIdx, edgeIds[2].edge_idx);
    var nUp = 0;
    var nDown = 0;
    nUp += stereo0 === Bond.PATTERN.STEREO.UP ? 1 : 0;
    nUp += stereo1 === Bond.PATTERN.STEREO.UP ? 1 : 0;
    nUp += stereo2 === Bond.PATTERN.STEREO.UP ? 1 : 0;
    nDown += stereo0 === Bond.PATTERN.STEREO.DOWN ? 1 : 0;
    nDown += stereo1 === Bond.PATTERN.STEREO.DOWN ? 1 : 0;
    nDown += stereo2 === Bond.PATTERN.STEREO.DOWN ? 1 : 0;
    if (implicitDegree === 4) {
      if (nUp === 3) throw new Error('all 3 bonds up near stereoatom');
      if (nDown === 3) throw new Error('all 3 bonds down near stereoatom');
      if (nUp === 0 && nDown === 0) {
        throw new Error('no up/down bonds near stereoatom -- indefinite case');
      }
      if (nUp === 1 && nDown === 1) {
        throw new Error('one bond up, one bond down -- indefinite case');
      }
      mainDir = 0;
      if (nUp === 2) {
        lastAtomDir = Bond.PATTERN.STEREO.DOWN;
      } else if (nDown === 2) {
        lastAtomDir = Bond.PATTERN.STEREO.UP;
      } else {
        main1 = -1;
        side1 = -1;
        side2 = -1;
        for (neiIdx = 0; neiIdx < 3; neiIdx++) {
          var dir = this.getBondStereo(atomIdx, edgeIds[neiIdx].edge_idx);
          if (dir === Bond.PATTERN.STEREO.UP || dir === Bond.PATTERN.STEREO.DOWN) {
            main1 = neiIdx;
            mainDir = dir;
            side1 = (neiIdx + 1) % 3;
            side2 = (neiIdx + 2) % 3;
            break;
          }
        }
        if (main1 === -1) {
          throw new Error('internal error: can not find up or down bond');
        }
        var xyz = Stereocenters.xyzzy(edgeIds[side1].vec, edgeIds[side2].vec, edgeIds[main1].vec);
        if (xyz === 3 || xyz === 4) {
          throw new Error('degenerate case for 3 bonds near stereoatom');
        }
        if (xyz === 1) lastAtomDir = mainDir;else {
          lastAtomDir = mainDir === Bond.PATTERN.STEREO.UP ? Bond.PATTERN.STEREO.DOWN : Bond.PATTERN.STEREO.UP;
        }
      }
      var _sign = Stereocenters.sign(edgeIds[0].vec, edgeIds[1].vec, edgeIds[2].vec);
      if (lastAtomDir === Bond.PATTERN.STEREO.UP && _sign > 0 || lastAtomDir === Bond.PATTERN.STEREO.DOWN && _sign < 0) {
        stereocenter.pyramid[0] = edgeIds[0].nei_idx;
        stereocenter.pyramid[1] = edgeIds[1].nei_idx;
        stereocenter.pyramid[2] = edgeIds[2].nei_idx;
      } else {
        stereocenter.pyramid[0] = edgeIds[0].nei_idx;
        stereocenter.pyramid[1] = edgeIds[2].nei_idx;
        stereocenter.pyramid[2] = edgeIds[1].nei_idx;
      }
      stereocenter.pyramid[3] = -1;
    } else {
      var _dir;
      if (nDown > 0 && nUp > 0) {
        throw new Error('one bond up, one bond down -- indefinite case');
      } else if (nDown === 0 && nUp === 0) {
        throw new Error('no up-down bonds attached to stereocenter');
      } else if (nUp > 0) _dir = 1;else _dir = -1;
      if (Stereocenters.xyzzy(edgeIds[0].vec, edgeIds[1].vec, edgeIds[2].vec) === 1 || Stereocenters.xyzzy(edgeIds[0].vec, edgeIds[2].vec, edgeIds[1].vec) === 1 || Stereocenters.xyzzy(edgeIds[2].vec, edgeIds[1].vec, edgeIds[0].vec) === 1) {
        _dir = -_dir;
      }
      var _sign2 = Stereocenters.sign(edgeIds[0].vec, edgeIds[1].vec, edgeIds[2].vec);
      if (_sign2 === _dir) {
        stereocenter.pyramid[0] = edgeIds[0].nei_idx;
        stereocenter.pyramid[1] = edgeIds[2].nei_idx;
        stereocenter.pyramid[2] = edgeIds[1].nei_idx;
      } else {
        stereocenter.pyramid[0] = edgeIds[0].nei_idx;
        stereocenter.pyramid[1] = edgeIds[1].nei_idx;
        stereocenter.pyramid[2] = edgeIds[2].nei_idx;
      }
      stereocenter.pyramid[3] = -1;
    }
  }
  this.atoms.set(atomIdx, stereocenter);
};
Stereocenters.prototype.getBondStereo = function (centerIdx, edgeIdx) {
  var bond = this.molecule.bonds.get(edgeIdx);
  if (centerIdx !== bond.begin) {
    return 0;
  }
  return bond.stereo;
};
Stereocenters.xyzzy = function (v1, v2, u) {
  var eps = 0.001;
  var sine1 = Vec2.cross(v1, v2);
  var cosine1 = Vec2.dot(v1, v2);
  var sine2 = Vec2.cross(v1, u);
  var cosine2 = Vec2.dot(v1, u);
  if (Math.abs(sine1) < eps) {
    if (Math.abs(sine2) < eps) {
      throw new Error('degenerate case -- bonds overlap');
    }
    return sine2 > 0 ? 4 : 8;
  }
  if (sine1 * sine2 < -eps * eps) return 2;
  if (cosine2 < cosine1) return 2;
  return 1;
};
Stereocenters.sign = function (v1, v2, v3) {
  var res = (v1.x - v3.x) * (v2.y - v3.y) - (v1.y - v3.y) * (v2.x - v3.x);
  var eps = 0.001;
  if (res > eps) return 1;
  if (res < -eps) return -1;
  throw new Error('degenerate triangle');
};
Stereocenters.isPyramidMappingRigid = function (mapping) {
  var arr = mapping.slice();
  var rigid = true;
  if (arr[0] > arr[1]) {
    swap(arr, 0, 1);
    rigid = !rigid;
  }
  if (arr[1] > arr[2]) {
    swap(arr, 1, 2);
    rigid = !rigid;
  }
  if (arr[2] > arr[3]) {
    swap(arr, 2, 3);
    rigid = !rigid;
  }
  if (arr[1] > arr[2]) {
    swap(arr, 1, 2);
    rigid = !rigid;
  }
  if (arr[0] > arr[1]) {
    swap(arr, 0, 1);
    rigid = !rigid;
  }
  if (arr[1] > arr[2]) {
    swap(arr, 1, 2);
    rigid = !rigid;
  }
  return rigid;
};
function swap(arr, i1, i2) {
  var tmp = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = tmp;
}

function Smiles() {
  this.smiles = '';
  this.writtenAtoms = [];
  this.writtenComponents = 0;
  this.ignoreErrors = false;
}
Smiles._Atom = function (hCount) {
  this.neighbours = [];
  this.aromatic = false;
  this.lowercase = false;
  this.chirality = 0;
  this.branch_cnt = 0;
  this.paren_written = false;
  this.h_count = hCount;
  this.parent = -1;
};
Smiles.prototype.isBondInRing = function (bid) {
  return this.inLoop[bid];
};
Smiles.prototype.saveMolecule = function (struct, ignoreErrors) {
  var _this = this;
  var i, j, k;
  if (!ignoreErrors) this.ignoreErrors = ignoreErrors;
  struct = struct.clone(undefined, undefined, !struct.hasRxnArrow(),
  undefined, undefined, undefined);
  struct.initHalfBonds();
  struct.initNeighbors();
  struct.sortNeighbors();
  struct.setImplicitHydrogen();
  struct.sgroups.forEach(function (sg) {
    if (sg.type === 'MUL') {
      try {
        SGroup.prepareMulForSaving(sg, struct);
      } catch (error) {
        KetcherLogger.error('smiles.js::Smiles.prototype.saveMolecule', error);
        throw Error('Bad s-group (' + error.message + ')');
      }
    }
  });
  this.atoms = new Array(struct.atoms.size);
  struct.atoms.forEach(function (atom, aid) {
    _this.atoms[aid] = new Smiles._Atom(atom.implicitH);
  });
  var allowedLowercase = ['B', 'C', 'N', 'O', 'P', 'S', 'Se', 'As'];
  struct.bonds.forEach(function (bond, bid) {
    if (bond.type === Bond.PATTERN.TYPE.AROMATIC) {
      _this.atoms[bond.begin].aromatic = true;
      if (allowedLowercase.indexOf(struct.atoms.get(bond.begin).label) !== -1) {
        _this.atoms[bond.begin].lowercase = true;
      }
      _this.atoms[bond.end].aromatic = true;
      if (allowedLowercase.indexOf(struct.atoms.get(bond.end).label) !== -1) {
        _this.atoms[bond.end].lowercase = true;
      }
    }
    _this.atoms[bond.begin].neighbours.push({
      aid: bond.end,
      bid: bid
    });
    _this.atoms[bond.end].neighbours.push({
      aid: bond.begin,
      bid: bid
    });
  });
  this.inLoop = function () {
    struct.prepareLoopStructure();
    var bondsInLoops = new Pile();
    struct.loops.forEach(function (loop) {
      if (loop.hbs.length <= 6) {
        var hbids = loop.hbs.map(function (hbid) {
          return struct.halfBonds.get(hbid).bid;
        });
        bondsInLoops = bondsInLoops.union(new Pile(hbids));
      }
    });
    var inLoop = {};
    bondsInLoops.forEach(function (bid) {
      inLoop[bid] = 1;
    });
    return inLoop;
  }();
  this.touchedCistransbonds = 0;
  this.markCisTrans(struct);
  var components = struct.getComponents();
  var componentsAll = components.reactants.concat(components.products);
  var walk = new Dfs(struct, this.atoms, componentsAll, components.reactants.length);
  walk.walk();
  this.atoms.forEach(function (atom) {
    atom.neighbours = [];
  });
  for (i = 0; i < walk.v_seq.length; i++) {
    var seqEl = walk.v_seq[i];
    var vIdx = seqEl.idx;
    var eIdx = seqEl.parent_edge;
    var vPrevIdx = seqEl.parent_vertex;
    if (eIdx >= 0) {
      var atom = this.atoms[vIdx];
      var openingCycles = walk.numOpeningCycles(eIdx);
      for (j = 0; j < openingCycles; j++) {
        this.atoms[vPrevIdx].neighbours.push({
          aid: -1,
          bid: -1
        });
      }
      if (walk.edgeClosingCycle(eIdx)) {
        for (k = 0; k < atom.neighbours.length; k++) {
          if (atom.neighbours[k].aid === -1) {
            atom.neighbours[k].aid = vPrevIdx;
            atom.neighbours[k].bid = eIdx;
            break;
          }
        }
        if (k === atom.neighbours.length) {
          throw new Error('internal: can not put closing bond to its place');
        }
      } else {
        atom.neighbours.push({
          aid: vPrevIdx,
          bid: eIdx
        });
        atom.parent = vPrevIdx;
      }
      this.atoms[vPrevIdx].neighbours.push({
        aid: vIdx,
        bid: eIdx
      });
    }
  }
  try {
    var stereocenters = new Stereocenters(struct, function (idx) {
      return this.atoms[idx].neighbours;
    }, this);
    stereocenters.buildFromBonds(this.ignoreErrors);
    stereocenters.each(function (sc, atomIdx) {
      var implicitHIdx = -1;
      if (sc.pyramid[3] === -1) implicitHIdx = 3;
      var pyramidMapping = [];
      var counter = 0;
      var atom = _this.atoms[atomIdx];
      if (atom.parent !== -1) {
        for (k = 0; k < 4; k++) {
          if (sc.pyramid[k] === atom.parent) {
            pyramidMapping[counter++] = k;
            break;
          }
        }
      }
      if (implicitHIdx !== -1) pyramidMapping[counter++] = implicitHIdx;
      for (j = 0; j !== atom.neighbours.length; j++) {
        if (atom.neighbours[j].aid === atom.parent) continue;
        for (k = 0; k < 4; k++) {
          if (atom.neighbours[j].aid === sc.pyramid[k]) {
            if (counter >= 4) throw new Error('internal: pyramid overflow');
            pyramidMapping[counter++] = k;
            break;
          }
        }
      }
      if (counter === 4) {
        counter = pyramidMapping[0];
        pyramidMapping[0] = pyramidMapping[1];
        pyramidMapping[1] = pyramidMapping[2];
        pyramidMapping[2] = pyramidMapping[3];
        pyramidMapping[3] = counter;
      } else if (counter !== 3) {
        throw new Error('cannot calculate chirality');
      }
      if (Stereocenters.isPyramidMappingRigid(pyramidMapping)) {
        _this.atoms[atomIdx].chirality = 1;
      } else _this.atoms[atomIdx].chirality = 2;
    });
  } catch (e) {
    KetcherLogger.error('smiles.js::Smiles.prototype.saveMolecule', e);
  }
  var cycleNumbers = [];
  cycleNumbers.push(0);
  var firstComponent = true;
  for (i = 0; i < walk.v_seq.length; i++) {
    seqEl = walk.v_seq[i];
    vIdx = seqEl.idx;
    eIdx = seqEl.parent_edge;
    vPrevIdx = seqEl.parent_vertex;
    var writeAtom = true;
    if (vPrevIdx >= 0) {
      if (walk.numBranches(vPrevIdx) > 1) {
        if (this.atoms[vPrevIdx].branch_cnt > 0 && this.atoms[vPrevIdx].paren_written) {
          this.smiles += ')';
        }
      }
      openingCycles = walk.numOpeningCycles(eIdx);
      for (j = 0; j < openingCycles; j++) {
        for (k = 1; k < cycleNumbers.length; k++) {
          if (cycleNumbers[k] === -1) {
            break;
          }
        }
        if (k === cycleNumbers.length) cycleNumbers.push(vPrevIdx);else cycleNumbers[k] = vPrevIdx;
        this.writeCycleNumber(k);
      }
      if (vPrevIdx >= 0) {
        var branches = walk.numBranches(vPrevIdx);
        if (branches > 1 && this.atoms[vPrevIdx].branch_cnt < branches - 1) {
          if (walk.edgeClosingCycle(eIdx)) {
            this.atoms[vPrevIdx].paren_written = false;
          } else {
            this.smiles += '(';
            this.atoms[vPrevIdx].paren_written = true;
          }
        }
        this.atoms[vPrevIdx].branch_cnt++;
        if (this.atoms[vPrevIdx].branch_cnt > branches) {
          throw new Error('unexpected branch');
        }
      }
      var bond = struct.bonds.get(eIdx);
      var dir = 0;
      if (bond.type === Bond.PATTERN.TYPE.SINGLE) {
        dir = this.calcBondDirection(struct, eIdx, vPrevIdx);
      }
      if (dir === 1 && vIdx === bond.end || dir === 2 && vIdx === bond.begin) {
        this.smiles += '/';
      } else if (dir === 2 && vIdx === bond.end || dir === 1 && vIdx === bond.begin) {
        this.smiles += '\\';
      } else if (bond.type === Bond.PATTERN.TYPE.ANY) {
        this.smiles += '~';
      } else if (bond.type === Bond.PATTERN.TYPE.DOUBLE) {
        this.smiles += '=';
      } else if (bond.type === Bond.PATTERN.TYPE.TRIPLE) {
        this.smiles += '#';
      } else if (bond.type === Bond.PATTERN.TYPE.SINGLE_OR_AROMATIC) {
        this.smiles += '-,:';
      } else if (bond.type === Bond.PATTERN.TYPE.DOUBLE_OR_AROMATIC) {
        this.smiles += '=,:';
      } else if (bond.type === Bond.PATTERN.TYPE.SINGLE_OR_DOUBLE) {
        this.smiles += '-,=';
      } else if (bond.type === Bond.PATTERN.TYPE.AROMATIC && (!this.atoms[bond.begin].lowercase || !this.atoms[bond.end].lowercase || !this.isBondInRing(eIdx))) {
        this.smiles += ':';
      }
      else if (bond.type === Bond.PATTERN.TYPE.SINGLE && this.atoms[bond.begin].aromatic && this.atoms[bond.end].aromatic) {
        this.smiles += '-';
      }
      if (walk.edgeClosingCycle(eIdx)) {
        for (j = 1; j < cycleNumbers.length; j++) {
          if (cycleNumbers[j] === vIdx) break;
        }
        if (j === cycleNumbers.length) throw new Error('cycle number not found');
        this.writeCycleNumber(j);
        cycleNumbers[j] = -1;
        writeAtom = false;
      }
    } else {
      if (!firstComponent) {
        this.smiles += this.writtenComponents === walk.nComponentsInReactants && walk.nReactants !== 0 ? '>>' : '.';
      }
      firstComponent = false;
      this.writtenComponents++;
    }
    if (writeAtom) {
      this.writeAtom(struct, vIdx, this.atoms[vIdx].aromatic, this.atoms[vIdx].lowercase, this.atoms[vIdx].chirality);
      this.writtenAtoms.push(seqEl.idx);
    }
  }
  this.comma = false;
  this.writeRadicals(struct);
  if (this.comma) this.smiles += '|';
  return this.smiles;
};
Smiles.prototype.writeCycleNumber = function (n) {
  if (n > 0 && n < 10) this.smiles += n;else if (n >= 10 && n < 100) this.smiles += '%' + n;else if (n >= 100 && n < 1000) this.smiles += '%%' + n;else throw new Error('bad cycle number: ' + n);
};
Smiles.prototype.writeAtom = function (mol, idx, aromatic, lowercase, chirality) {
  var atom = mol.atoms.get(idx);
  var needBrackets = false;
  var hydro = -1;
  var aam = 0;
  if (atom.label === 'A') {
    this.smiles += '*';
    return;
  }
  if (atom.label === 'R' || atom.label === 'R#') {
    this.smiles += '[*]';
    return;
  }
  aam = atom.aam;
  if (atom.label !== 'C' && atom.label !== 'P' && atom.label !== 'N' && atom.label !== 'S' && atom.label !== 'O' && atom.label !== 'Cl' && atom.label !== 'F' && atom.label !== 'Br' && atom.label !== 'B' && atom.label !== 'I') {
    needBrackets = true;
  }
  if (atom.explicitValence >= 0 || atom.radical !== 0 || chirality > 0 || aromatic && atom.label !== 'C' && atom.label !== 'O' || aromatic && atom.label === 'C' && this.atoms[idx].neighbours.length < 3 && this.atoms[idx].h_count === 0) {
    hydro = this.atoms[idx].h_count;
  }
  var label = atom.label;
  if (atom.atomList && !atom.atomList.notList) {
    label = atom.atomList.label();
    needBrackets = false;
  } else if (atom.isPseudo() || atom.atomList && atom.atomList.notList) {
    label = '*';
    needBrackets = false;
  } else if (chirality || atom.charge !== 0 && atom.charge !== null || atom.isotope > 0 || hydro >= 0 || aam > 0) {
    needBrackets = true;
  }
  if (needBrackets) {
    if (hydro === -1) hydro = this.atoms[idx].h_count;
    this.smiles += '[';
  }
  if (atom.isotope > 0) this.smiles += atom.isotope;
  if (lowercase) this.smiles += label.toLowerCase();else this.smiles += label;
  if (chirality > 0) {
    if (chirality === 1) this.smiles += '@';
    else this.smiles += '@@';
    if (atom.implicitH > 1) {
      throw new Error(atom.implicitH + ' implicit H near stereocenter');
    }
  }
  if (atom.label !== 'H') {
    if (hydro > 1 || hydro === 0 && !needBrackets) this.smiles += 'H' + hydro;else if (hydro === 1) this.smiles += 'H';
  }
  if (atom.charge > 1) this.smiles += '+' + atom.charge;else if (atom.charge < -1) this.smiles += atom.charge;else if (atom.charge === 1) this.smiles += '+';else if (atom.charge === -1) this.smiles += '-';
  if (aam > 0) this.smiles += ':' + aam;
  if (needBrackets) this.smiles += ']';
};
Smiles.prototype.markCisTrans = function (mol) {
  var _this2 = this;
  this.cis_trans = new CisTrans(mol, function (idx) {
    return this.atoms[idx].neighbours;
  }, this);
  this.cis_trans.build();
  this.dbonds = new Array(mol.bonds.size);
  mol.bonds.forEach(function (bond, bid) {
    _this2.dbonds[bid] = {
      ctbond_beg: -1,
      ctbond_end: -1,
      saved: 0
    };
  });
  this.cis_trans.each(function (ct, bid) {
    var bond = mol.bonds.get(bid);
    if (ct.parity !== 0 && !_this2.isBondInRing(bid)) {
      var neiBeg = _this2.atoms[bond.begin].neighbours;
      var neiEnd = _this2.atoms[bond.end].neighbours;
      var aromFailBeg = true;
      var aromFailEnd = true;
      neiBeg.forEach(function (nei) {
        if (nei.bid !== bid && mol.bonds.get(nei.bid).type === Bond.PATTERN.TYPE.SINGLE) {
          aromFailBeg = false;
        }
      });
      neiEnd.forEach(function (nei) {
        if (nei.bid !== bid && mol.bonds.get(nei.bid).type === Bond.PATTERN.TYPE.SINGLE) {
          aromFailEnd = false;
        }
      });
      if (aromFailBeg || aromFailEnd) return;
      neiBeg.forEach(function (nei) {
        if (nei.bid === bid) return;
        if (mol.bonds.get(nei.bid).begin === bond.begin) {
          _this2.dbonds[nei.bid].ctbond_beg = bid;
        } else _this2.dbonds[nei.bid].ctbond_end = bid;
      });
      neiEnd.forEach(function (nei) {
        if (nei.bid === bid) return;
        if (mol.bonds.get(nei.bid).begin === bond.end) {
          _this2.dbonds[nei.bid].ctbond_beg = bid;
        } else _this2.dbonds[nei.bid].ctbond_end = bid;
      });
    }
  });
};
Smiles.prototype.updateSideBonds = function (mol, bondIdx) {
  var bond = mol.bonds.get(bondIdx);
  var subst = this.cis_trans.getSubstituents(bondIdx);
  var parity = this.cis_trans.getParity(bondIdx);
  var sidebonds = [-1, -1, -1, -1];
  sidebonds[0] = mol.findBondId(subst[0], bond.begin);
  if (subst[1] !== -1) sidebonds[1] = mol.findBondId(subst[1], bond.begin);
  sidebonds[2] = mol.findBondId(subst[2], bond.end);
  if (subst[3] !== -1) sidebonds[3] = mol.findBondId(subst[3], bond.end);
  var n1 = 0;
  var n2 = 0;
  var n3 = 0;
  var n4 = 0;
  if (this.dbonds[sidebonds[0]].saved !== 0) {
    if (this.dbonds[sidebonds[0]].saved === 1 && mol.bonds.get(sidebonds[0]).begin === bond.begin || this.dbonds[sidebonds[0]].saved === 2 && mol.bonds.get(sidebonds[0]).end === bond.begin) {
      n1++;
    } else n2++;
  }
  if (sidebonds[1] !== -1 && this.dbonds[sidebonds[1]].saved !== 0) {
    if (this.dbonds[sidebonds[1]].saved === 2 && mol.bonds.get(sidebonds[1]).begin === bond.begin || this.dbonds[sidebonds[1]].saved === 1 && mol.bonds.get(sidebonds[1]).end === bond.begin) {
      n1++;
    } else n2++;
  }
  if (this.dbonds[sidebonds[2]].saved !== 0) {
    if (this.dbonds[sidebonds[2]].saved === 1 && mol.bonds.get(sidebonds[2]).begin === bond.end || this.dbonds[sidebonds[2]].saved === 2 && mol.bonds.get(sidebonds[2]).end === bond.end) {
      n3++;
    } else n4++;
  }
  if (sidebonds[3] !== -1 && this.dbonds[sidebonds[3]].saved !== 0) {
    if (this.dbonds[sidebonds[3]].saved === 2 && mol.bonds.get(sidebonds[3]).begin === bond.end || this.dbonds[sidebonds[3]].saved === 1 && mol.bonds.get(sidebonds[3]).end === bond.end) {
      n3++;
    } else n4++;
  }
  if (parity === CisTrans.PARITY.CIS) {
    n1 += n3;
    n2 += n4;
  } else {
    n1 += n4;
    n2 += n3;
  }
  if (n1 > 0 && n2 > 0) throw new Error('incompatible cis-trans configuration');
  if (n1 === 0 && n2 === 0) return false;
  if (n1 > 0) {
    this.dbonds[sidebonds[0]].saved = mol.bonds.get(sidebonds[0]).begin === bond.begin ? 1 : 2;
    if (sidebonds[1] !== -1) {
      this.dbonds[sidebonds[1]].saved = mol.bonds.get(sidebonds[1]).begin === bond.begin ? 2 : 1;
    }
    this.dbonds[sidebonds[2]].saved = mol.bonds.get(sidebonds[2]).begin === bond.end === (parity === CisTrans.PARITY.CIS) ? 1 : 2;
    if (sidebonds[3] !== -1) {
      this.dbonds[sidebonds[3]].saved = mol.bonds.get(sidebonds[3]).begin === bond.end === (parity === CisTrans.PARITY.CIS) ? 2 : 1;
    }
  }
  if (n2 > 0) {
    this.dbonds[sidebonds[0]].saved = mol.bonds.get(sidebonds[0]).begin === bond.begin ? 2 : 1;
    if (sidebonds[1] !== -1) {
      this.dbonds[sidebonds[1]].saved = mol.bonds.get(sidebonds[1]).begin === bond.begin ? 1 : 2;
    }
    this.dbonds[sidebonds[2]].saved = mol.bonds.get(sidebonds[2]).begin === bond.end === (parity === CisTrans.PARITY.CIS) ? 2 : 1;
    if (sidebonds[3] !== -1) {
      this.dbonds[sidebonds[3]].saved = mol.bonds.get(sidebonds[3]).begin === bond.end === (parity === CisTrans.PARITY.CIS) ? 1 : 2;
    }
  }
  return true;
};
Smiles.prototype.calcBondDirection = function (mol, idx, vprev) {
  var _this3 = this;
  var ntouched;
  if (this.dbonds[idx].ctbond_beg === -1 && this.dbonds[idx].ctbond_end === -1) {
    return 0;
  }
  if (mol.bonds.get(idx).type !== Bond.PATTERN.TYPE.SINGLE) {
    throw new Error('internal: directed bond type ' + mol.bonds.get(idx).type);
  }
  while (true) {
    ntouched = 0;
    this.cis_trans.each(function (ct, bid) {
      if (ct.parity !== 0 && !_this3.isBondInRing(bid)) {
        if (_this3.updateSideBonds(mol, bid)) ntouched++;
      }
    });
    if (ntouched === this.touchedCistransbonds) break;
    this.touchedCistransbonds = ntouched;
  }
  if (this.dbonds[idx].saved === 0) {
    if (vprev === mol.bonds.get(idx).begin) this.dbonds[idx].saved = 1;else this.dbonds[idx].saved = 2;
  }
  return this.dbonds[idx].saved;
};
Smiles.prototype.writeRadicals = function (mol) {
  var marked = new Array(this.writtenAtoms.length);
  var i, j;
  for (i = 0; i < this.writtenAtoms.length; i++) {
    if (marked[i]) continue;
    var radical = mol.atoms.get(this.writtenAtoms[i]).radical;
    if (radical === 0) continue;
    if (this.comma) {
      this.smiles += ',';
    } else {
      this.smiles += ' |';
      this.comma = true;
    }
    if (radical === Atom.PATTERN.RADICAL.SINGLET) this.smiles += '^3:';else if (radical === Atom.PATTERN.RADICAL.DOUPLET) this.smiles += '^1:';
    else this.smiles += '^4:';
    this.smiles += i;
    for (j = i + 1; j < this.writtenAtoms.length; j++) {
      if (mol.atoms.get(this.writtenAtoms[j]).radical === radical) {
        marked[j] = true;
        this.smiles += ',' + j;
      }
    }
  }
};

function ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var SmiSerializer = function () {
  function SmiSerializer(options) {
    _classCallCheck__default["default"](this, SmiSerializer);
    this.options = _objectSpread$a(_objectSpread$a({}, SmiSerializer.DefaultOptions), options);
  }
  _createClass__default["default"](SmiSerializer, [{
    key: "deserialize",
    value: function deserialize(_content) {
      throw new Error('Not implemented yet.');
    }
  }, {
    key: "serialize",
    value: function serialize(struct) {
      return new Smiles().saveMolecule(struct, this.options.ignoreErrors);
    }
  }]);
  return SmiSerializer;
}();
_defineProperty__default["default"](SmiSerializer, "DefaultOptions", {
  ignoreErrors: false
});

var DelimeterRegex = /^[^]+?\$\$\$\$$/gm;
var SdfSerializer = function () {
  function SdfSerializer(options) {
    _classCallCheck__default["default"](this, SdfSerializer);
    this.molSerializerOptions = options;
  }
  _createClass__default["default"](SdfSerializer, [{
    key: "deserialize",
    value: function deserialize(content) {
      var m;
      var result = [];
      var molSerializer = new MolSerializer(this.molSerializerOptions);
      while ((m = DelimeterRegex.exec(content)) !== null) {
        var chunk = m[0].replace(/\r/g, '').trim();
        var end = chunk.indexOf('M  END');
        if (end !== -1) {
          var propChunks = chunk.substr(end + 7).trim().split(/^$\n?/m);
          var struct = molSerializer.deserialize(chunk.substring(0, end + 6));
          var props = propChunks.reduce(function (acc, pc) {
            var m = pc.match(/^> [ \d]*<(\S+)>/);
            if (m) {
              var field = m[1];
              var valueArr = pc.split('\n').slice(1, -1);
              var value = '';
              if (valueArr.length > 1) {
                value = valueArr.join(',');
              } else {
                value = pc.split('\n')[1].trim();
              }
              acc[field] = Number.isFinite(value) ? +value : value.toString();
            }
            return acc;
          }, {});
          result.push({
            struct: struct,
            props: props
          });
        }
      }
      return result;
    }
  }, {
    key: "serialize",
    value: function serialize(sdfItems) {
      var molSerializer = new MolSerializer(this.molSerializerOptions);
      return sdfItems.reduce(function (res, item) {
        res += molSerializer.serialize(item.struct);
        Object.keys(item.props).forEach(function (prop) {
          res += "> <".concat(prop, ">\n");
          res += "".concat(item.props[prop], "\n\n");
        });
        return "".concat(res, "$$$$\n");
      }, '');
    }
  }]);
  return SdfSerializer;
}();

function _classPrivateFieldInitSpec$7(obj, privateMap, value) { _checkPrivateRedeclaration$7(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$7(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _ketSerializer$3 = new WeakMap();
var KetFormatter = function () {
  function KetFormatter(serializer) {
    _classCallCheck__default["default"](this, KetFormatter);
    _classPrivateFieldInitSpec$7(this, _ketSerializer$3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet__default["default"](this, _ketSerializer$3, serializer);
  }
  _createClass__default["default"](KetFormatter, [{
    key: "getStructureFromStructAsync",
    value: function () {
      var _getStructureFromStructAsync = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee(struct, drawingEntitiesManager, selection) {
        var ket;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              ket = _classPrivateFieldGet__default["default"](this, _ketSerializer$3).serialize(struct, drawingEntitiesManager, selection);
              return _context.abrupt("return", ket);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getStructureFromStructAsync(_x, _x2, _x3) {
        return _getStructureFromStructAsync.apply(this, arguments);
      }
      return getStructureFromStructAsync;
    }()
  }, {
    key: "getStructureFromStringAsync",
    value: function () {
      var _getStructureFromStringAsync = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee2(content) {
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", _classPrivateFieldGet__default["default"](this, _ketSerializer$3).deserialize(content));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getStructureFromStringAsync(_x4) {
        return _getStructureFromStringAsync.apply(this, arguments);
      }
      return getStructureFromStringAsync;
    }()
  }, {
    key: "parseMacromoleculeString",
    value: function parseMacromoleculeString(content) {
      _classPrivateFieldGet__default["default"](this, _ketSerializer$3).deserializeMicromolecules(content);
    }
  }]);
  return KetFormatter;
}();

function _classPrivateFieldInitSpec$6(obj, privateMap, value) { _checkPrivateRedeclaration$6(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$6(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _smiSerializer = new WeakMap();
var _structService$4 = new WeakMap();
var _ketSerializer$2 = new WeakMap();
var _format$1 = new WeakMap();
var _options$1 = new WeakMap();
var SmilesFormatter = function () {
  function SmilesFormatter(smiSerializer, structService, ketSerializer, format, options) {
    _classCallCheck__default["default"](this, SmilesFormatter);
    _classPrivateFieldInitSpec$6(this, _smiSerializer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$6(this, _structService$4, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$6(this, _ketSerializer$2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$6(this, _format$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$6(this, _options$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet__default["default"](this, _smiSerializer, smiSerializer);
    _classPrivateFieldSet__default["default"](this, _ketSerializer$2, ketSerializer);
    _classPrivateFieldSet__default["default"](this, _structService$4, structService);
    _classPrivateFieldSet__default["default"](this, _format$1, format);
    _classPrivateFieldSet__default["default"](this, _options$1, options);
  }
  _createClass__default["default"](SmilesFormatter, [{
    key: "getStructureFromStructAsync",
    value: function () {
      var _getStructureFromStructAsync = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee(struct) {
        var stringifiedMolfile;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              stringifiedMolfile = _classPrivateFieldGet__default["default"](this, _smiSerializer).serialize(struct);
              return _context.abrupt("return", stringifiedMolfile);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getStructureFromStructAsync(_x) {
        return _getStructureFromStructAsync.apply(this, arguments);
      }
      return getStructureFromStructAsync;
    }()
  }, {
    key: "getStructureFromStringAsync",
    value: function getStructureFromStringAsync(stringifiedStruct) {
      var serverFormatter = new ServerFormatter(_classPrivateFieldGet__default["default"](this, _structService$4), _classPrivateFieldGet__default["default"](this, _ketSerializer$2), _classPrivateFieldGet__default["default"](this, _format$1), _classPrivateFieldGet__default["default"](this, _options$1));
      return serverFormatter.getStructureFromStringAsync(stringifiedStruct);
    }
  }], [{
    key: "isContainsCoordinates",
    value: function isContainsCoordinates(smiles) {
      return /\([\d.,;-]+\)/.test(smiles);
    }
  }]);
  return SmilesFormatter;
}();

function ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classPrivateFieldInitSpec$5(obj, privateMap, value) { _checkPrivateRedeclaration$5(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$5(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _structService$3 = new WeakMap();
var _ketSerializer$1 = new WeakMap();
var _format = new WeakMap();
var _options = new WeakMap();
var ServerFormatter = function () {
  function ServerFormatter(structService, ketSerializer, format, options) {
    _classCallCheck__default["default"](this, ServerFormatter);
    _classPrivateFieldInitSpec$5(this, _structService$3, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$5(this, _ketSerializer$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$5(this, _format, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$5(this, _options, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet__default["default"](this, _structService$3, structService);
    _classPrivateFieldSet__default["default"](this, _ketSerializer$1, ketSerializer);
    _classPrivateFieldSet__default["default"](this, _format, format);
    _classPrivateFieldSet__default["default"](this, _options, options);
  }
  _createClass__default["default"](ServerFormatter, [{
    key: "getStructureFromStructAsync",
    value: function () {
      var _getStructureFromStructAsync = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee(struct, drawingEntitiesManager) {
        var formatProperties, stringifiedStruct, convertResult, message;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              formatProperties = getPropertiesByFormat(_classPrivateFieldGet__default["default"](this, _format));
              _context.prev = 1;
              stringifiedStruct = _classPrivateFieldGet__default["default"](this, _ketSerializer$1).serialize(struct, drawingEntitiesManager);
              _context.next = 5;
              return _classPrivateFieldGet__default["default"](this, _structService$3).convert({
                struct: stringifiedStruct,
                output_format: formatProperties.mime
              }, _objectSpread$9(_objectSpread$9({}, _classPrivateFieldGet__default["default"](this, _options)), formatProperties.options));
            case 5:
              convertResult = _context.sent;
              return _context.abrupt("return", convertResult.struct);
            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](1);
              if (_context.t0.message === 'Server is not compatible') {
                message = "".concat(formatProperties.name, " is not supported.");
              } else {
                message = "Convert error!\n".concat(_context.t0.message || _context.t0);
              }
              KetcherLogger.error('serverFormatter.ts::getStructureFromStructAsync', _context.t0);
              throw new Error(message);
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 9]]);
      }));
      function getStructureFromStructAsync(_x, _x2) {
        return _getStructureFromStructAsync.apply(this, arguments);
      }
      return getStructureFromStructAsync;
    }()
  }, {
    key: "getCallingMethod",
    value: function getCallingMethod(stringifiedStruct, format) {
      if (_classPrivateFieldGet__default["default"](this, _format) === exports.SupportedFormat.smiles) {
        return {
          method: SmilesFormatter.isContainsCoordinates(stringifiedStruct) ? _classPrivateFieldGet__default["default"](this, _structService$3).convert : _classPrivateFieldGet__default["default"](this, _structService$3).layout,
          struct: stringifiedStruct
        };
      }
      var withCoords = getPropertiesByFormat(format).supportsCoords;
      if (withCoords) {
        return {
          method: _classPrivateFieldGet__default["default"](this, _structService$3).convert,
          struct: stringifiedStruct
        };
      }
      return {
        method: _classPrivateFieldGet__default["default"](this, _structService$3).layout,
        struct: stringifiedStruct.trim()
      };
    }
  }, {
    key: "getStructureFromStringAsync",
    value: function () {
      var _getStructureFromStringAsync = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee2(stringifiedStruct) {
        var data, _this$getCallingMetho, method, struct, result, parsedStruct, formatError;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              data = {
                struct: undefined,
                output_format: getPropertiesByFormat(exports.SupportedFormat.ket).mime
              };
              _this$getCallingMetho = this.getCallingMethod(stringifiedStruct, _classPrivateFieldGet__default["default"](this, _format)), method = _this$getCallingMetho.method, struct = _this$getCallingMetho.struct;
              data.struct = struct;
              _context2.prev = 3;
              _context2.next = 6;
              return method(data, _classPrivateFieldGet__default["default"](this, _options));
            case 6:
              result = _context2.sent;
              parsedStruct = _classPrivateFieldGet__default["default"](this, _ketSerializer$1).deserialize(result.struct);
              if (method === _classPrivateFieldGet__default["default"](this, _structService$3).layout) {
                parsedStruct.rescale();
              }
              return _context2.abrupt("return", parsedStruct);
            case 12:
              _context2.prev = 12;
              _context2.t0 = _context2["catch"](3);
              if (!(_context2.t0.message !== 'Server is not compatible')) {
                _context2.next = 17;
                break;
              }
              KetcherLogger.error('serverFormatter.ts::getStructureFromStringAsync', _context2.t0);
              throw Error("Convert error!\n".concat(_context2.t0.message || _context2.t0));
            case 17:
              formatError = _classPrivateFieldGet__default["default"](this, _format) === 'smiles' ? "".concat(getPropertiesByFormat(exports.SupportedFormat.smilesExt).name, " and opening of ").concat(getPropertiesByFormat(exports.SupportedFormat.smiles).name) : getPropertiesByFormat(_classPrivateFieldGet__default["default"](this, _format)).name;
              throw Error("".concat(formatError, " is not supported in standalone mode."));
            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[3, 12]]);
      }));
      function getStructureFromStringAsync(_x3) {
        return _getStructureFromStringAsync.apply(this, arguments);
      }
      return getStructureFromStringAsync;
    }()
  }]);
  return ServerFormatter;
}();

function _classPrivateFieldInitSpec$4(obj, privateMap, value) { _checkPrivateRedeclaration$4(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$4(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _molSerializer = new WeakMap();
var MolfileV2000Formatter = function () {
  function MolfileV2000Formatter(molSerializer) {
    _classCallCheck__default["default"](this, MolfileV2000Formatter);
    _classPrivateFieldInitSpec$4(this, _molSerializer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet__default["default"](this, _molSerializer, molSerializer);
  }
  _createClass__default["default"](MolfileV2000Formatter, [{
    key: "getStructureFromStructAsync",
    value: function () {
      var _getStructureFromStructAsync = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee(struct) {
        var stringifiedMolfile;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              stringifiedMolfile = _classPrivateFieldGet__default["default"](this, _molSerializer).serialize(struct);
              return _context.abrupt("return", stringifiedMolfile);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getStructureFromStructAsync(_x) {
        return _getStructureFromStructAsync.apply(this, arguments);
      }
      return getStructureFromStructAsync;
    }()
  }, {
    key: "getStructureFromStringAsync",
    value: function () {
      var _getStructureFromStringAsync = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee2(stringifiedStruct) {
        var struct;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              struct = _classPrivateFieldGet__default["default"](this, _molSerializer).deserialize(stringifiedStruct);
              return _context2.abrupt("return", struct);
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getStructureFromStringAsync(_x2) {
        return _getStructureFromStringAsync.apply(this, arguments);
      }
      return getStructureFromStringAsync;
    }()
  }]);
  return MolfileV2000Formatter;
}();

var _excluded$1 = ["reactionRelayout", "badHeaderRecover", "ignoreChiralFlag"];
function _classPrivateFieldInitSpec$3(obj, privateMap, value) { _checkPrivateRedeclaration$3(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$3(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var _structService$2 = new WeakMap();
var FormatterFactory = function () {
  function FormatterFactory(structService) {
    _classCallCheck__default["default"](this, FormatterFactory);
    _classPrivateFieldInitSpec$3(this, _structService$2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet__default["default"](this, _structService$2, structService);
  }
  _createClass__default["default"](FormatterFactory, [{
    key: "separateOptions",
    value: function separateOptions(options) {
      if (!options) {
        return [{}, {}];
      }
      var reactionRelayout = options.reactionRelayout,
        badHeaderRecover = options.badHeaderRecover,
        ignoreChiralFlag = options.ignoreChiralFlag,
        structServiceOptions = _objectWithoutProperties__default["default"](options, _excluded$1);
      var molfileParseOptions = {};
      if (typeof reactionRelayout === 'boolean') {
        molfileParseOptions.reactionRelayout = reactionRelayout;
      }
      if (typeof badHeaderRecover === 'boolean') {
        molfileParseOptions.badHeaderRecover = badHeaderRecover;
      }
      if (typeof ignoreChiralFlag === 'boolean') {
        molfileParseOptions.ignoreChiralFlag = ignoreChiralFlag;
        structServiceOptions['ignore-no-chiral-flag'] = ignoreChiralFlag;
      }
      return [molfileParseOptions, structServiceOptions];
    }
  }, {
    key: "create",
    value: function create(format, options, queryPropertiesAreUsed) {
      var _this$separateOptions = this.separateOptions(options),
        _this$separateOptions2 = _slicedToArray__default["default"](_this$separateOptions, 2),
        molSerializerOptions = _this$separateOptions2[0],
        structServiceOptions = _this$separateOptions2[1];
      var formatter;
      switch (format) {
        case exports.SupportedFormat.ket:
          formatter = new KetFormatter(new KetSerializer());
          break;
        case exports.SupportedFormat.mol:
          if (queryPropertiesAreUsed) {
            formatter = new ServerFormatter(_classPrivateFieldGet__default["default"](this, _structService$2), new KetSerializer(), format, structServiceOptions);
          } else {
            formatter = new MolfileV2000Formatter(new MolSerializer(molSerializerOptions));
          }
          break;
        case exports.SupportedFormat.cml:
        case exports.SupportedFormat.inChIAuxInfo:
        case exports.SupportedFormat.inChI:
        case exports.SupportedFormat.inChIKey:
        case exports.SupportedFormat.molV3000:
        case exports.SupportedFormat.smiles:
        case exports.SupportedFormat.rxnV3000:
        case exports.SupportedFormat.smilesExt:
        case exports.SupportedFormat.smarts:
        case exports.SupportedFormat.cdxml:
        case exports.SupportedFormat.cdx:
        case exports.SupportedFormat.binaryCdx:
        case exports.SupportedFormat.unknown:
        case exports.SupportedFormat.rxn:
        default:
          formatter = new ServerFormatter(_classPrivateFieldGet__default["default"](this, _structService$2), new KetSerializer(), format, structServiceOptions);
      }
      return formatter;
    }
  }]);
  return FormatterFactory;
}();

function identifyStructFormat(stringifiedStruct) {
  var sanitizedString = stringifiedStruct.trim();
  try {
    if (JSON.parse(sanitizedString)) {
      return exports.SupportedFormat.ket;
    }
  } catch (e) {
    KetcherLogger.error('identifyStructFormat.ts::identifyStructFromat', e);
  }
  var isRXN = sanitizedString.includes('$RXN');
  var isSDF = sanitizedString.includes('\n$$$$');
  var isV2000 = sanitizedString.includes('V2000');
  var isV3000 = sanitizedString.includes('V3000');
  if (isRXN) {
    return exports.SupportedFormat.rxn;
  }
  if (isSDF) {
    if (isV2000) {
      return exports.SupportedFormat.sdf;
    } else {
      return exports.SupportedFormat.sdfV3000;
    }
  }
  if (isV2000) {
    return exports.SupportedFormat.mol;
  }
  if (isV3000) {
    return exports.SupportedFormat.molV3000;
  }
  var match = sanitizedString.match(/^(M {2}END|\$END MOL)$/m);
  if (match) {
    var end = (match.index || 0) + match[0].length;
    if (end === sanitizedString.length || sanitizedString.slice(end, end + 20).search(/^\$(MOL|END CTAB)$/m) !== -1) {
      return exports.SupportedFormat.mol;
    }
  }
  if (sanitizedString[0] === '<' && sanitizedString.indexOf('<molecule') !== -1) {
    return exports.SupportedFormat.cml;
  }
  var clearStr = sanitizedString.replace(/\s/g, '').replace(/(\\r)|(\\n)/g, '');
  var isBase64String = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var cdxHeader = 'VjCD0100';
  if (clearStr.length % 4 === 0 && isBase64String.test(clearStr) && window.atob(clearStr).startsWith(cdxHeader)) {
    return exports.SupportedFormat.cdx;
  }
  if (sanitizedString.slice(0, 5) === 'InChI') {
    return exports.SupportedFormat.inChI;
  }
  if (sanitizedString.indexOf('\n') === -1) {
    return exports.SupportedFormat.smiles;
  }
  if (sanitizedString.indexOf('<CDXML') !== -1) {
    return exports.SupportedFormat.cdxml;
  }
  return exports.SupportedFormat.unknown;
}

var KetcherProvider = function () {
  function KetcherProvider() {
    _classCallCheck__default["default"](this, KetcherProvider);
  }
  _createClass__default["default"](KetcherProvider, [{
    key: "setKetcherInstance",
    value: function setKetcherInstance(ketcherInstance) {
      this.ketcherInstance = ketcherInstance;
    }
  }, {
    key: "getKetcher",
    value: function getKetcher() {
      return this.ketcherInstance;
    }
  }]);
  return KetcherProvider;
}();
var ketcherProvider = new KetcherProvider();
function getStructure() {
  var structureFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.SupportedFormat.rxn;
  var formatterFactory = arguments.length > 1 ? arguments[1] : undefined;
  var struct = arguments.length > 2 ? arguments[2] : undefined;
  var drawingEntitiesManager = arguments.length > 3 ? arguments[3] : undefined;
  var formatter = formatterFactory.create(structureFormat);
  return formatter.getStructureFromStructAsync(struct, drawingEntitiesManager);
}
function prepareStructToRender(_x, _x2, _x3) {
  return _prepareStructToRender.apply(this, arguments);
}
function _prepareStructToRender() {
  _prepareStructToRender = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee(structStr, structService, ketcherInstance) {
    var struct;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return parseStruct(structStr, structService, ketcherInstance);
        case 2:
          struct = _context.sent;
          struct.initHalfBonds();
          struct.initNeighbors();
          struct.setImplicitHydrogen();
          struct.markFragments();
          return _context.abrupt("return", struct);
        case 8:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _prepareStructToRender.apply(this, arguments);
}
function parseStruct(structStr, structService, ketcherInstance) {
  var format = identifyStructFormat(structStr);
  var factory = new FormatterFactory(structService);
  var options = ketcherInstance.editor.options();
  var service = factory.create(format, {
    'dearomatize-on-load': options['dearomatize-on-load'],
    'ignore-no-chiral-flag': options.ignoreChiralFlag
  });
  return service.getStructureFromStringAsync(structStr);
}
function deleteAllEntitiesOnCanvas() {
  var editor = CoreEditor.provideEditorInstance();
  var modelChanges = editor.drawingEntitiesManager.deleteAllEntities();
  editor.renderersContainer.update(modelChanges);
}
function parseAndAddMacromoleculesOnCanvas(_x4, _x5) {
  return _parseAndAddMacromoleculesOnCanvas.apply(this, arguments);
}
function _parseAndAddMacromoleculesOnCanvas() {
  _parseAndAddMacromoleculesOnCanvas = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee2(struct, structService) {
    var editor, ketSerializer, format, ketStruct, deserialisedKet, modelChanges;
    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          editor = CoreEditor.provideEditorInstance();
          ketSerializer = new KetSerializer();
          format = identifyStructFormat(struct);
          ketStruct = struct;
          if (!(format !== exports.SupportedFormat.ket)) {
            _context2.next = 8;
            break;
          }
          _context2.next = 7;
          return structService.convert({
            struct: struct,
            output_format: exports.ChemicalMimeType.KET
          });
        case 7:
          ketStruct = _context2.sent.struct;
        case 8:
          deserialisedKet = ketSerializer.deserializeToDrawingEntities(ketStruct);
          assert__default["default"](deserialisedKet);
          modelChanges = deserialisedKet.drawingEntitiesManager.mergeInto(editor.drawingEntitiesManager);
          new EditorHistory(editor).update(modelChanges);
          editor.renderersContainer.update(modelChanges);
        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _parseAndAddMacromoleculesOnCanvas.apply(this, arguments);
}
function getCurrentCenterPointOfCanvas() {
  var editor = CoreEditor.provideEditorInstance();
  var originalCenterPointOfCanvas = new Vec2(editor.canvasOffset.width / 2, editor.canvasOffset.height / 2);
  return Coordinates.viewToCanvas(originalCenterPointOfCanvas);
}

var ChainsCollection = function () {
  function ChainsCollection() {
    _classCallCheck__default["default"](this, ChainsCollection);
    _defineProperty__default["default"](this, "chains", []);
  }
  _createClass__default["default"](ChainsCollection, [{
    key: "rearrange",
    value: function rearrange() {
      this.chains.sort(function (chain1, chain2) {
        var _chain2$firstNode, _chain2$firstNode2, _chain1$firstNode, _chain1$firstNode2;
        if (((_chain2$firstNode = chain2.firstNode) === null || _chain2$firstNode === void 0 ? void 0 : _chain2$firstNode.monomer.position.x) + ((_chain2$firstNode2 = chain2.firstNode) === null || _chain2$firstNode2 === void 0 ? void 0 : _chain2$firstNode2.monomer.position.y) > ((_chain1$firstNode = chain1.firstNode) === null || _chain1$firstNode === void 0 ? void 0 : _chain1$firstNode.monomer.position.x) + ((_chain1$firstNode2 = chain1.firstNode) === null || _chain1$firstNode2 === void 0 ? void 0 : _chain1$firstNode2.monomer.position.y)) {
          return -1;
        } else {
          return 1;
        }
      });
    }
  }, {
    key: "add",
    value: function add(chain) {
      this.chains.push(chain);
    }
  }, {
    key: "firstNode",
    get: function get() {
      var _this$chains$;
      return (_this$chains$ = this.chains[0]) === null || _this$chains$ === void 0 || (_this$chains$ = _this$chains$.subChains[0]) === null || _this$chains$ === void 0 ? void 0 : _this$chains$.nodes[0];
    }
  }], [{
    key: "fromMonomers",
    value: function fromMonomers(monomers) {
      var chainsCollection = new ChainsCollection();
      var _this$getFirstMonomer = this.getFirstMonomersInChains(monomers),
        _this$getFirstMonomer2 = _slicedToArray__default["default"](_this$getFirstMonomer, 2),
        firstMonomersInRegularChains = _this$getFirstMonomer2[0],
        firstMonomersInCycledChains = _this$getFirstMonomer2[1];
      firstMonomersInRegularChains.forEach(function (monomer) {
        chainsCollection.add(new Chain(monomer));
      });
      firstMonomersInCycledChains.forEach(function (monomer) {
        chainsCollection.add(new Chain(monomer, !!exports.IsChainCycled.CYCLED));
      });
      return chainsCollection;
    }
  }, {
    key: "getFirstMonomersInChains",
    value: function getFirstMonomersInChains(monomers) {
      var MonomerTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [Peptide, Chem, Phosphate, Sugar, RNABase];
      var monomersList = monomers.filter(function (monomer) {
        return MonomerTypes.some(function (MonomerType) {
          return monomer instanceof MonomerType;
        });
      });
      var firstMonomersInChains = [];
      var firstMonomersInRegularChains = this.getFirstMonomersInRegularChains(monomersList);
      var firstMonomersInCycledChains = this.getFirstMonomersInCycledChains(monomersList);
      firstMonomersInChains.push(firstMonomersInRegularChains, firstMonomersInCycledChains);
      return firstMonomersInChains;
    }
  }, {
    key: "getFirstMonomersInRegularChains",
    value: function getFirstMonomersInRegularChains(monomersList) {
      var firstMonomersInRegularChains = monomersList.filter(function (monomer) {
        var _R1ConnectedMonomer$a;
        var R1PolymerBond = monomer.attachmentPointsToBonds.R1;
        var isFirstMonomerWithR2R1connection = !R1PolymerBond || R1PolymerBond.isSideChainConnection;
        var R1ConnectedMonomer = R1PolymerBond === null || R1PolymerBond === void 0 ? void 0 : R1PolymerBond.getAnotherMonomer(monomer);
        var isRnaBaseConnectedToSugar = monomer instanceof RNABase && R1ConnectedMonomer instanceof Sugar && getRnaBaseFromSugar(R1ConnectedMonomer) === monomer;
        var isSugarConnectedToR2RnaBase = monomer instanceof Sugar && R1ConnectedMonomer instanceof RNABase && getRnaBaseFromSugar(monomer) && ((_R1ConnectedMonomer$a = R1ConnectedMonomer.attachmentPointsToBonds.R2) === null || _R1ConnectedMonomer$a === void 0 ? void 0 : _R1ConnectedMonomer$a.getAnotherMonomer(R1ConnectedMonomer)) === monomer;
        return (isFirstMonomerWithR2R1connection || isSugarConnectedToR2RnaBase) && !isRnaBaseConnectedToSugar;
      });
      return firstMonomersInRegularChains;
    }
  }, {
    key: "getFirstMonomersInCycledChains",
    value: function getFirstMonomersInCycledChains(monomersList) {
      var _this = this;
      var handledMonomers = new Set();
      var cyclicChains = [];
      monomersList.forEach(function (monomer) {
        if (handledMonomers.has(monomer)) {
          return;
        }
        var monomersInSameChain = new Set();
        monomersInSameChain.add(monomer);
        handledMonomers.add(monomer);
        var nextMonomerInChain = getNextMonomerInChain(monomer);
        while (nextMonomerInChain && !handledMonomers.has(nextMonomerInChain)) {
          monomersInSameChain.add(nextMonomerInChain);
          handledMonomers.add(nextMonomerInChain);
          nextMonomerInChain = getNextMonomerInChain(nextMonomerInChain);
        }
        if (monomer === nextMonomerInChain) {
          cyclicChains.push(Array.from(monomersInSameChain));
        }
      });
      var firstMonomersOfCycledChainsSet = cyclicChains.map(function (cyclicChain) {
        return _this.getMonomerWithLowerCoordsFromMonomerList(cyclicChain);
      });
      return firstMonomersOfCycledChainsSet;
    }
  }, {
    key: "getMonomerWithLowerCoordsFromMonomerList",
    value: function getMonomerWithLowerCoordsFromMonomerList(monomerList) {
      var monomerListShallowCopy = monomerList.slice();
      monomerListShallowCopy.sort(function (monomer1, monomer2) {
        if (monomer2.position.x + monomer2.position.y > monomer1.position.x + monomer1.position.y) {
          return -1;
        } else {
          return 1;
        }
      });
      var monomerWithLowerCoords = monomerListShallowCopy[0];
      return monomerWithLowerCoords;
    }
  }]);
  return ChainsCollection;
}();

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }
function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var HORIZONTAL_DISTANCE_FROM_MONOMER = 25;
var VERTICAL_DISTANCE_FROM_MONOMER = 30;
var DISTANCE_FROM_RIGHT = 55;
var DISTANCE_BETWEEN_MONOMERS = 15;
var MONOMER_START_X_POSITION = 50;
var MONOMER_START_Y_POSITION = 50;
var DrawingEntitiesManager = function () {
  function DrawingEntitiesManager() {
    _classCallCheck__default["default"](this, DrawingEntitiesManager);
    _defineProperty__default["default"](this, "monomers", new Map());
    _defineProperty__default["default"](this, "polymerBonds", new Map());
    _defineProperty__default["default"](this, "micromoleculesHiddenEntities", new Struct());
  }
  _createClass__default["default"](DrawingEntitiesManager, [{
    key: "selectedEntities",
    get: function get() {
      return this.allEntities.filter(function (_ref) {
        var _ref2 = _slicedToArray__default["default"](_ref, 2),
          drawingEntity = _ref2[1];
        return drawingEntity.selected;
      });
    }
  }, {
    key: "allEntities",
    get: function get() {
      return [].concat(_toConsumableArray__default["default"](this.monomers), _toConsumableArray__default["default"](this.polymerBonds));
    }
  }, {
    key: "deleteSelectedEntities",
    value: function deleteSelectedEntities() {
      var _this = this;
      var mergedCommand = new Command();
      this.selectedEntities.forEach(function (_ref3) {
        var _ref4 = _slicedToArray__default["default"](_ref3, 2),
          drawingEntity = _ref4[1];
        var command = _this.deleteDrawingEntity(drawingEntity);
        mergedCommand.merge(command);
      });
      return mergedCommand;
    }
  }, {
    key: "deleteAllEntities",
    value: function deleteAllEntities() {
      var _this2 = this;
      var mergedCommand = new Command();
      this.allEntities.forEach(function (_ref5) {
        var _ref6 = _slicedToArray__default["default"](_ref5, 2),
          drawingEntity = _ref6[1];
        var command = _this2.deleteDrawingEntity(drawingEntity, false);
        mergedCommand.merge(command);
      });
      return mergedCommand;
    }
  }, {
    key: "addMonomerChangeModel",
    value: function addMonomerChangeModel(monomerItem, position, _monomer) {
      if (_monomer) {
        this.monomers.set(_monomer.id, _monomer);
        return _monomer;
      }
      var _monomerFactory = monomerFactory(monomerItem),
        _monomerFactory2 = _slicedToArray__default["default"](_monomerFactory, 1),
        Monomer = _monomerFactory2[0];
      var monomer = new Monomer(monomerItem, position);
      monomer.moveAbsolute(position);
      this.monomers.set(monomer.id, monomer);
      return monomer;
    }
  }, {
    key: "addMonomer",
    value: function addMonomer(monomerItem, position) {
      var command = new Command();
      var operation = new MonomerAddOperation(this.addMonomerChangeModel.bind(this, monomerItem, position), this.deleteMonomerChangeModel.bind(this));
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "deleteDrawingEntity",
    value: function deleteDrawingEntity(drawingEntity) {
      var needToDeleteConnectedEntities = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (drawingEntity instanceof BaseMonomer) {
        return this.deleteMonomer(drawingEntity, needToDeleteConnectedEntities);
      } else if (drawingEntity instanceof PolymerBond$1) {
        return this.deletePolymerBond(drawingEntity);
      } else {
        return new Command();
      }
    }
  }, {
    key: "selectDrawingEntity",
    value: function selectDrawingEntity(drawingEntity) {
      var command = this.unselectAllDrawingEntities();
      drawingEntity.turnOnSelection();
      command.merge(this.createDrawingEntitySelectionCommand(drawingEntity));
      return command;
    }
  }, {
    key: "selectDrawingEntities",
    value: function selectDrawingEntities(drawingEntities) {
      var command = this.unselectAllDrawingEntities();
      drawingEntities.forEach(function (drawingEntity) {
        drawingEntity.turnOnSelection();
        var operation = new DrawingEntitySelectOperation(drawingEntity);
        command.addOperation(operation);
      });
      return command;
    }
  }, {
    key: "createDrawingEntitySelectionCommand",
    value: function createDrawingEntitySelectionCommand(drawingEntity) {
      var command = new Command();
      var selectionCommand = new DrawingEntitySelectOperation(drawingEntity);
      command.addOperation(selectionCommand);
      return command;
    }
  }, {
    key: "unselectAllDrawingEntities",
    value: function unselectAllDrawingEntities() {
      var _this3 = this;
      var command = new Command();
      this.allEntities.forEach(function (_ref7) {
        var _ref8 = _slicedToArray__default["default"](_ref7, 2),
          drawingEntity = _ref8[1];
        if (drawingEntity.selected) {
          command.merge(_this3.unselectDrawingEntity(drawingEntity));
        }
      });
      return command;
    }
  }, {
    key: "unselectDrawingEntity",
    value: function unselectDrawingEntity(drawingEntity) {
      var command = new Command();
      drawingEntity.turnOffSelection();
      command.addOperation(new DrawingEntitySelectOperation(drawingEntity));
      return command;
    }
  }, {
    key: "selectAllDrawingEntities",
    value: function selectAllDrawingEntities() {
      var command = new Command();
      this.allEntities.forEach(function (_ref9) {
        var _ref10 = _slicedToArray__default["default"](_ref9, 2),
          drawingEntity = _ref10[1];
        if (!drawingEntity.selected) {
          drawingEntity.turnOnSelection();
          var operation = new DrawingEntitySelectOperation(drawingEntity);
          command.addOperation(operation);
        }
      });
      return command;
    }
  }, {
    key: "addDrawingEntitiesToSelection",
    value: function addDrawingEntitiesToSelection(drawingEntities) {
      var command = new Command();
      drawingEntities.forEach(function (drawingEntity) {
        if (drawingEntity.selected) {
          drawingEntity.turnOffSelection();
        } else {
          drawingEntity.turnOnSelection();
        }
        command.addOperation(new DrawingEntitySelectOperation(drawingEntity));
      });
      return command;
    }
  }, {
    key: "moveDrawingEntityModelChange",
    value: function moveDrawingEntityModelChange(drawingEntity, offset) {
      if (drawingEntity instanceof PolymerBond$1) {
        drawingEntity.moveToLinkedMonomers();
      } else {
        assert__default["default"](offset);
        drawingEntity.moveRelative(offset);
      }
      return drawingEntity;
    }
  }, {
    key: "moveSelectedDrawingEntities",
    value: function moveSelectedDrawingEntities(partOfMovementOffset, fullMovementOffset) {
      var _this4 = this;
      var command = new Command();
      this.monomers.forEach(function (drawingEntity) {
        if (drawingEntity.selected) {
          command.merge(_this4.createDrawingEntityMovingCommand(drawingEntity, partOfMovementOffset, fullMovementOffset));
        }
      });
      this.polymerBonds.forEach(function (drawingEntity) {
        var _drawingEntity$second;
        if (drawingEntity.selected || drawingEntity.firstMonomer.selected || (_drawingEntity$second = drawingEntity.secondMonomer) !== null && _drawingEntity$second !== void 0 && _drawingEntity$second.selected) {
          command.merge(_this4.createDrawingEntityMovingCommand(drawingEntity, partOfMovementOffset, fullMovementOffset));
        }
      });
      return command;
    }
  }, {
    key: "createDrawingEntityMovingCommand",
    value: function createDrawingEntityMovingCommand(drawingEntity, partOfMovementOffset, fullMovementOffset) {
      var command = new Command();
      var movingCommand = new DrawingEntityMoveOperation(this.moveDrawingEntityModelChange.bind(this, drawingEntity, partOfMovementOffset), this.moveDrawingEntityModelChange.bind(this, drawingEntity, fullMovementOffset ? fullMovementOffset.negated() : partOfMovementOffset.negated()), this.moveDrawingEntityModelChange.bind(this, drawingEntity, fullMovementOffset || partOfMovementOffset), drawingEntity);
      command.addOperation(movingCommand);
      return command;
    }
  }, {
    key: "createDrawingEntityRedrawCommand",
    value: function createDrawingEntityRedrawCommand(drawingEntityRedrawModelChange, invertDrawingEntityRedrawModelChange) {
      var command = new Command();
      var redrawCommand = new DrawingEntityRedrawOperation(drawingEntityRedrawModelChange, invertDrawingEntityRedrawModelChange);
      command.addOperation(redrawCommand);
      return command;
    }
  }, {
    key: "deleteMonomerChangeModel",
    value: function deleteMonomerChangeModel(monomer) {
      this.monomers["delete"](monomer.id);
    }
  }, {
    key: "deleteMonomer",
    value: function deleteMonomer(monomer) {
      var _this5 = this;
      var needToDeleteConnectedBonds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var command = new Command();
      var operation = new MonomerDeleteOperation(monomer, this.addMonomerChangeModel.bind(this, monomer.monomerItem, monomer.position), this.deleteMonomerChangeModel.bind(this));
      command.addOperation(operation);
      if (needToDeleteConnectedBonds && monomer.hasBonds) {
        monomer.forEachBond(function (bond) {
          if (bond.selected) return;
          bond.turnOnSelection();
          command.merge(_this5.deletePolymerBond(bond));
        });
      }
      return command;
    }
  }, {
    key: "selectIfLocatedInRectangle",
    value: function selectIfLocatedInRectangle(rectangleTopLeftPoint, rectangleBottomRightPoint, previousSelectedEntities) {
      var _this6 = this;
      var shiftKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var command = new Command();
      this.allEntities.forEach(function (_ref11) {
        var _ref12 = _slicedToArray__default["default"](_ref11, 2),
          drawingEntity = _ref12[1];
        var isPreviousSelected = previousSelectedEntities.find(function (_ref13) {
          var _ref14 = _slicedToArray__default["default"](_ref13, 2),
            entity = _ref14[1];
          return entity === drawingEntity;
        });
        var isValueChanged = drawingEntity.selectIfLocatedInRectangle(rectangleTopLeftPoint, rectangleBottomRightPoint, !!isPreviousSelected, shiftKey);
        if (isValueChanged) {
          var selectionCommand = _this6.createDrawingEntitySelectionCommand(drawingEntity);
          command.merge(selectionCommand);
        }
      });
      return command;
    }
  }, {
    key: "startPolymerBondCreationChangeModel",
    value: function startPolymerBondCreationChangeModel(firstMonomer, startPosition, endPosition, _polymerBond) {
      if (_polymerBond) {
        this.polymerBonds.set(_polymerBond.id, _polymerBond);
        return _polymerBond;
      }
      var polymerBond = new PolymerBond$1(firstMonomer);
      this.polymerBonds.set(polymerBond.id, polymerBond);
      if (firstMonomer.chosenFirstAttachmentPointForBond) {
        var startBondAttachmentPoint = firstMonomer.startBondAttachmentPoint;
        firstMonomer.setBond(startBondAttachmentPoint, polymerBond);
        firstMonomer.setPotentialBond(startBondAttachmentPoint, polymerBond);
      }
      polymerBond.moveBondStartAbsolute(startPosition.x, startPosition.y);
      polymerBond.moveBondEndAbsolute(endPosition.x, endPosition.y);
      return polymerBond;
    }
  }, {
    key: "startPolymerBondCreation",
    value: function startPolymerBondCreation(firstMonomer, startPosition, endPosition) {
      var command = new Command();
      var operation = new PolymerBondAddOperation(this.startPolymerBondCreationChangeModel.bind(this, firstMonomer, startPosition, endPosition), this.deletePolymerBondChangeModel.bind(this));
      command.addOperation(operation);
      return {
        command: command,
        polymerBond: operation.polymerBond
      };
    }
  }, {
    key: "deletePolymerBondChangeModel",
    value: function deletePolymerBondChangeModel(polymerBond) {
      var _polymerBond$secondMo, _polymerBond$secondMo2, _polymerBond$secondMo3;
      this.polymerBonds["delete"](polymerBond.id);
      var firstMonomerAttachmentPoint = polymerBond.firstMonomer.getAttachmentPointByBond(polymerBond);
      var secondMonomerAttachmentPoint = (_polymerBond$secondMo = polymerBond.secondMonomer) === null || _polymerBond$secondMo === void 0 ? void 0 : _polymerBond$secondMo.getAttachmentPointByBond(polymerBond);
      polymerBond.firstMonomer.removePotentialBonds();
      (_polymerBond$secondMo2 = polymerBond.secondMonomer) === null || _polymerBond$secondMo2 === void 0 || _polymerBond$secondMo2.removePotentialBonds();
      polymerBond.firstMonomer.turnOffSelection();
      (_polymerBond$secondMo3 = polymerBond.secondMonomer) === null || _polymerBond$secondMo3 === void 0 || _polymerBond$secondMo3.turnOffSelection();
      if (firstMonomerAttachmentPoint) {
        polymerBond.firstMonomer.unsetBond(firstMonomerAttachmentPoint);
      }
      if (secondMonomerAttachmentPoint) {
        var _polymerBond$secondMo4;
        (_polymerBond$secondMo4 = polymerBond.secondMonomer) === null || _polymerBond$secondMo4 === void 0 || _polymerBond$secondMo4.unsetBond(secondMonomerAttachmentPoint);
      }
    }
  }, {
    key: "deletePolymerBond",
    value: function deletePolymerBond(polymerBond) {
      var _polymerBond$secondMo5;
      var command = new Command();
      var operation = new PolymerBondDeleteOperation(polymerBond, this.deletePolymerBondChangeModel.bind(this, polymerBond), this.finishPolymerBondCreationModelChange.bind(this, polymerBond.firstMonomer, polymerBond.secondMonomer, polymerBond.firstMonomer.getAttachmentPointByBond(polymerBond), (_polymerBond$secondMo5 = polymerBond.secondMonomer) === null || _polymerBond$secondMo5 === void 0 ? void 0 : _polymerBond$secondMo5.getAttachmentPointByBond(polymerBond)));
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "cancelPolymerBondCreation",
    value: function cancelPolymerBondCreation(polymerBond, secondMonomer) {
      this.polymerBonds["delete"](polymerBond.id);
      var command = new Command();
      polymerBond.firstMonomer.removeBond(polymerBond);
      polymerBond.firstMonomer.removePotentialBonds(true);
      polymerBond.firstMonomer.turnOffSelection();
      polymerBond.firstMonomer.turnOffHover();
      polymerBond.firstMonomer.turnOffAttachmentPointsVisibility();
      secondMonomer === null || secondMonomer === void 0 || secondMonomer.turnOffSelection();
      secondMonomer === null || secondMonomer === void 0 || secondMonomer.turnOffHover();
      secondMonomer === null || secondMonomer === void 0 || secondMonomer.turnOffAttachmentPointsVisibility();
      var operation = new PolymerBondCancelCreationOperation(polymerBond, secondMonomer);
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "movePolymerBond",
    value: function movePolymerBond(polymerBond, position) {
      var command = new Command();
      polymerBond.moveBondEndAbsolute(position.x, position.y);
      var operation = new PolymerBondMoveOperation(polymerBond);
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "finishPolymerBondCreationModelChange",
    value: function finishPolymerBondCreationModelChange(firstMonomer, secondMonomer, firstMonomerAttachmentPoint, secondMonomerAttachmentPoint, _polymerBond) {
      var _polymerBond$secondMo6;
      if (_polymerBond) {
        this.polymerBonds.set(_polymerBond.id, _polymerBond);
        firstMonomer.setBond(firstMonomerAttachmentPoint, _polymerBond);
        secondMonomer.setBond(secondMonomerAttachmentPoint, _polymerBond);
        return _polymerBond;
      }
      var polymerBond = new PolymerBond$1(firstMonomer);
      this.polymerBonds.set(polymerBond.id, polymerBond);
      polymerBond.setSecondMonomer(secondMonomer);
      polymerBond.firstMonomer.setBond(firstMonomerAttachmentPoint, polymerBond);
      assert__default["default"](polymerBond.secondMonomer);
      polymerBond.secondMonomer.setBond(secondMonomerAttachmentPoint, polymerBond);
      polymerBond.firstMonomer.removePotentialBonds(true);
      polymerBond.secondMonomer.removePotentialBonds(true);
      polymerBond.firstMonomer.setChosenFirstAttachmentPoint(null);
      (_polymerBond$secondMo6 = polymerBond.secondMonomer) === null || _polymerBond$secondMo6 === void 0 || _polymerBond$secondMo6.setChosenSecondAttachmentPoint(null);
      polymerBond.moveToLinkedMonomers();
      polymerBond.firstMonomer.turnOffSelection();
      polymerBond.firstMonomer.turnOffHover();
      polymerBond.firstMonomer.turnOffAttachmentPointsVisibility();
      polymerBond.secondMonomer.turnOffSelection();
      polymerBond.secondMonomer.turnOffHover();
      polymerBond.secondMonomer.turnOffAttachmentPointsVisibility();
      polymerBond.turnOffHover();
      return polymerBond;
    }
  }, {
    key: "finishPolymerBondCreation",
    value: function finishPolymerBondCreation(polymerBond, secondMonomer, firstMonomerAttachmentPoint, secondMonomerAttachmentPoint) {
      var command = new Command();
      var firstMonomer = polymerBond.firstMonomer;
      this.polymerBonds["delete"](polymerBond.id);
      var operation = new PolymerBondFinishCreationOperation(this.finishPolymerBondCreationModelChange.bind(this, firstMonomer, secondMonomer, firstMonomerAttachmentPoint, secondMonomerAttachmentPoint), this.deletePolymerBondChangeModel.bind(this));
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "createPolymerBond",
    value: function createPolymerBond(firstMonomer, secondMonomer, firstMonomerAttachmentPoint, secondMonomerAttachmentPoint) {
      var command = new Command();
      var operation = new PolymerBondFinishCreationOperation(this.finishPolymerBondCreationModelChange.bind(this, firstMonomer, secondMonomer, firstMonomerAttachmentPoint, secondMonomerAttachmentPoint), this.deletePolymerBondChangeModel.bind(this));
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "intendToStartBondCreation",
    value: function intendToStartBondCreation(monomer) {
      var command = new Command();
      monomer.turnOnHover();
      monomer.turnOnAttachmentPointsVisibility();
      var operation = new MonomerHoverOperation(monomer, true);
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "intendToStartAttachmenPointBondCreation",
    value: function intendToStartAttachmenPointBondCreation(monomer, attachmentPointName) {
      var command = new Command();
      monomer.turnOnHover();
      monomer.turnOnAttachmentPointsVisibility();
      var operation = new AttachmentPointHoverOperation(monomer, attachmentPointName);
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "intendToFinishBondCreation",
    value: function intendToFinishBondCreation(monomer, bond, shouldCalculateBonds) {
      var command = new Command();
      monomer.turnOnHover();
      monomer.turnOnAttachmentPointsVisibility();
      if (shouldCalculateBonds) {
        bond.firstMonomer.removePotentialBonds();
        monomer.removePotentialBonds();
        var firstMonomerValidSourcePoint = bond.firstMonomer.getValidSourcePoint(monomer);
        var secondMonomerValidTargetPoint = monomer.getValidTargetPoint(bond.firstMonomer);
        bond.firstMonomer.setPotentialBond(firstMonomerValidSourcePoint, bond);
        monomer.setPotentialBond(secondMonomerValidTargetPoint, bond);
      }
      var connectFirstMonomerOperation = new MonomerHoverOperation(bond.firstMonomer, true);
      var connectSecondMonomerOperation = new MonomerHoverOperation(monomer, true);
      command.addOperation(connectFirstMonomerOperation);
      command.addOperation(connectSecondMonomerOperation);
      return command;
    }
  }, {
    key: "intendToFinishAttachmenPointBondCreation",
    value: function intendToFinishAttachmenPointBondCreation(monomer, bond, attachmentPointName, shouldCalculateBonds) {
      var command = new Command();
      monomer.turnOnHover();
      monomer.turnOnAttachmentPointsVisibility();
      if (monomer.isAttachmentPointUsed(attachmentPointName)) {
        var operation = new MonomerHoverOperation(monomer, true);
        command.addOperation(operation);
        return command;
      }
      if (attachmentPointName) {
        monomer.setPotentialSecondAttachmentPoint(attachmentPointName);
        monomer.setPotentialBond(attachmentPointName, bond);
      }
      if (shouldCalculateBonds) {
        bond.firstMonomer.removePotentialBonds();
        monomer.removePotentialBonds();
        var firstMonomerValidSourcePoint = bond.firstMonomer.getValidSourcePoint(monomer);
        var secondMonomerValidTargetPoint = monomer.getValidTargetPoint(bond.firstMonomer);
        bond.firstMonomer.setPotentialBond(firstMonomerValidSourcePoint, bond);
        monomer.setPotentialBond(secondMonomerValidTargetPoint, bond);
      }
      var connectFirstMonomerOperation = new MonomerHoverOperation(bond.firstMonomer, true);
      var connectSecondMonomerOperation = new AttachmentPointHoverOperation(monomer, attachmentPointName);
      command.addOperation(connectFirstMonomerOperation);
      command.addOperation(connectSecondMonomerOperation);
      return command;
    }
  }, {
    key: "cancelIntentionToFinishBondCreation",
    value: function cancelIntentionToFinishBondCreation(monomer, polymerBond) {
      var command = new Command();
      monomer.turnOffHover();
      monomer.turnOffAttachmentPointsVisibility();
      monomer.setPotentialSecondAttachmentPoint(null);
      monomer.removePotentialBonds();
      var operation = new MonomerHoverOperation(monomer, true);
      command.addOperation(operation);
      if (polymerBond && !polymerBond.firstMonomer.chosenFirstAttachmentPointForBond) {
        polymerBond.firstMonomer.removePotentialBonds();
        var _operation = new MonomerHoverOperation(polymerBond.firstMonomer, true);
        command.addOperation(_operation);
      }
      return command;
    }
  }, {
    key: "intendToSelectDrawingEntity",
    value: function intendToSelectDrawingEntity(drawingEntity) {
      var command = new Command();
      drawingEntity.turnOnHover();
      var operation = new DrawingEntityHoverOperation(drawingEntity);
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "cancelIntentionToSelectDrawingEntity",
    value: function cancelIntentionToSelectDrawingEntity(drawingEntity) {
      var command = new Command();
      drawingEntity.turnOffHover();
      var operation = new DrawingEntityHoverOperation(drawingEntity);
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "showPolymerBondInformation",
    value: function showPolymerBondInformation(polymerBond) {
      var command = new Command();
      polymerBond.turnOnHover();
      polymerBond.firstMonomer.turnOnHover();
      polymerBond.firstMonomer.turnOnAttachmentPointsVisibility();
      assert__default["default"](polymerBond.secondMonomer);
      polymerBond.secondMonomer.turnOnHover();
      polymerBond.secondMonomer.turnOnAttachmentPointsVisibility();
      var operation = new PolymerBondShowInfoOperation(polymerBond);
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "hidePolymerBondInformation",
    value: function hidePolymerBondInformation(polymerBond) {
      var command = new Command();
      polymerBond.turnOffHover();
      polymerBond.firstMonomer.turnOffHover();
      polymerBond.firstMonomer.turnOffAttachmentPointsVisibility();
      assert__default["default"](polymerBond.secondMonomer);
      polymerBond.secondMonomer.turnOffHover();
      polymerBond.secondMonomer.turnOffAttachmentPointsVisibility();
      var operation = new PolymerBondShowInfoOperation(polymerBond);
      command.addOperation(operation);
      return command;
    }
  }, {
    key: "addRnaPreset",
    value: function addRnaPreset(_ref15) {
      var _this7 = this;
      var sugar = _ref15.sugar,
        sugarPosition = _ref15.sugarPosition,
        phosphate = _ref15.phosphate,
        phosphatePosition = _ref15.phosphatePosition,
        rnaBase = _ref15.rnaBase,
        rnaBasePosition = _ref15.rnaBasePosition;
      var command = new Command();
      var monomersToAdd = [];
      if (rnaBase && rnaBasePosition) {
        monomersToAdd.push([rnaBase, rnaBasePosition]);
      }
      monomersToAdd.push([sugar, sugarPosition]);
      if (phosphate && phosphatePosition) {
        monomersToAdd.push([phosphate, phosphatePosition]);
      }
      var previousMonomer;
      var monomers = [];
      monomersToAdd.forEach(function (_ref16) {
        var _ref17 = _slicedToArray__default["default"](_ref16, 2),
          monomerItem = _ref17[0],
          monomerPosition = _ref17[1];
        var monomerAddOperation = new MonomerAddOperation(_this7.addMonomerChangeModel.bind(_this7, monomerItem, monomerPosition), _this7.deleteMonomerChangeModel.bind(_this7));
        var monomer = monomerAddOperation.monomer;
        monomers.push(monomer);
        command.addOperation(monomerAddOperation);
        if (previousMonomer) {
          var attPointStart = previousMonomer.getValidSourcePoint(monomer);
          var attPointEnd = monomer.getValidSourcePoint(previousMonomer);
          assert__default["default"](attPointStart);
          assert__default["default"](attPointEnd);
          var operation = new PolymerBondFinishCreationOperation(_this7.finishPolymerBondCreationModelChange.bind(_this7, previousMonomer, monomer, attPointStart, attPointEnd), _this7.deletePolymerBondChangeModel.bind(_this7));
          command.addOperation(operation);
        }
        previousMonomer = monomer;
      });
      return {
        command: command,
        monomers: monomers
      };
    }
  }, {
    key: "findChainByMonomer",
    value: function findChainByMonomer(monomer) {
      var monomerChain = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var monomersInChainSet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
      monomerChain.push(monomer);
      monomersInChainSet.add(monomer.id);
      for (var attachmentPointName in monomer.attachmentPointsToBonds) {
        var polymerBond = monomer.attachmentPointsToBonds[attachmentPointName];
        if (polymerBond) {
          var nextMonomer = monomer === polymerBond.firstMonomer ? polymerBond.secondMonomer : polymerBond.firstMonomer;
          if (!monomersInChainSet.has(nextMonomer.id)) {
            this.findChainByMonomer(nextMonomer, monomerChain, monomersInChainSet);
          }
        }
      }
      return monomerChain;
    }
  }, {
    key: "rearrangeChainModelChange",
    value: function rearrangeChainModelChange(monomer, newPosition) {
      monomer.moveAbsolute(newPosition);
      return monomer;
    }
  }, {
    key: "getNucleotideSize",
    value: function getNucleotideSize(nucleotide) {
      var _nucleotide$sugar$ren, _nucleotide$phosphate, _nucleotide$sugar$ren2, _nucleotide$rnaBase$r;
      var width = (((_nucleotide$sugar$ren = nucleotide.sugar.renderer) === null || _nucleotide$sugar$ren === void 0 || (_nucleotide$sugar$ren = _nucleotide$sugar$ren.monomerSize) === null || _nucleotide$sugar$ren === void 0 ? void 0 : _nucleotide$sugar$ren.width) || 0) + (((_nucleotide$phosphate = nucleotide.phosphate) === null || _nucleotide$phosphate === void 0 || (_nucleotide$phosphate = _nucleotide$phosphate.renderer) === null || _nucleotide$phosphate === void 0 || (_nucleotide$phosphate = _nucleotide$phosphate.monomerSize) === null || _nucleotide$phosphate === void 0 ? void 0 : _nucleotide$phosphate.width) || 0) + (nucleotide.phosphate ? RNA_MONOMER_DISTANCE : 0);
      var height = (((_nucleotide$sugar$ren2 = nucleotide.sugar.renderer) === null || _nucleotide$sugar$ren2 === void 0 || (_nucleotide$sugar$ren2 = _nucleotide$sugar$ren2.monomerSize) === null || _nucleotide$sugar$ren2 === void 0 ? void 0 : _nucleotide$sugar$ren2.height) || 0) + (((_nucleotide$rnaBase$r = nucleotide.rnaBase.renderer) === null || _nucleotide$rnaBase$r === void 0 || (_nucleotide$rnaBase$r = _nucleotide$rnaBase$r.monomerSize) === null || _nucleotide$rnaBase$r === void 0 ? void 0 : _nucleotide$rnaBase$r.height) || 0) + RNA_MONOMER_DISTANCE;
      return {
        width: width,
        height: height
      };
    }
  }, {
    key: "reArrangeChain",
    value: function reArrangeChain(monomer, lastPosition, canvasWidth, rearrangedMonomersSet, monomersWithSideChain, maxVerticalDistance, firstMonomer) {
      var _monomer$renderer$mon, _monomer$renderer, _monomer$renderer$mon2, _monomer$renderer2;
      var command = new Command();
      var monomerWidth = (_monomer$renderer$mon = (_monomer$renderer = monomer.renderer) === null || _monomer$renderer === void 0 || (_monomer$renderer = _monomer$renderer.monomerSize) === null || _monomer$renderer === void 0 ? void 0 : _monomer$renderer.width) !== null && _monomer$renderer$mon !== void 0 ? _monomer$renderer$mon : 0;
      var monomerHeight = (_monomer$renderer$mon2 = (_monomer$renderer2 = monomer.renderer) === null || _monomer$renderer2 === void 0 || (_monomer$renderer2 = _monomer$renderer2.monomerSize) === null || _monomer$renderer2 === void 0 ? void 0 : _monomer$renderer2.height) !== null && _monomer$renderer$mon2 !== void 0 ? _monomer$renderer$mon2 : 0;
      var heightMonomerWithBond = monomerHeight + VERTICAL_DISTANCE_FROM_MONOMER;
      maxVerticalDistance = Math.max(maxVerticalDistance, heightMonomerWithBond);
      monomer.isMonomerInRnaChainRow = maxVerticalDistance > heightMonomerWithBond;
      var oldMonomerPosition = monomer.position;
      var operation = new MonomerMoveOperation(this.rearrangeChainModelChange.bind(this, monomer, Coordinates.canvasToModel(lastPosition)), this.rearrangeChainModelChange.bind(this, monomer, oldMonomerPosition));
      command.addOperation(operation);
      rearrangedMonomersSet.add(monomer.id);
      var nextPositionAndVerticalDistance = this.getNextMonomerPositionForSnakeLayout(monomer, monomerWidth, lastPosition, canvasWidth, rearrangedMonomersSet, monomersWithSideChain, maxVerticalDistance);
      return {
        lastPosition: (nextPositionAndVerticalDistance === null || nextPositionAndVerticalDistance === void 0 ? void 0 : nextPositionAndVerticalDistance.lastPosition) || lastPosition,
        maxVerticalDistance: (nextPositionAndVerticalDistance === null || nextPositionAndVerticalDistance === void 0 ? void 0 : nextPositionAndVerticalDistance.maxVerticalDistance) || maxVerticalDistance,
        nextMonomer: getNextMonomerInChain(monomer, firstMonomer),
        command: command
      };
    }
  }, {
    key: "reArrangeRnaChain",
    value: function reArrangeRnaChain(nucleotide, lastPosition, canvasWidth, rearrangedMonomersSet, monomersWithSideChain, maxVerticalDistance, firstMonomer) {
      var _nucleotide$sugar$ren3, _nucleotide$sugar$ren4, _nucleotide$rnaBase$r2, _nucleotide$rnaBase$r3, _nucleotide$rnaBase, _nucleotide$rnaBase2;
      var command = new Command();
      var nucleotideSize = this.getNucleotideSize(nucleotide);
      var height = nucleotideSize.height,
        width = nucleotideSize.width;
      var heightWithBond = height + VERTICAL_DISTANCE_FROM_MONOMER;
      maxVerticalDistance = Math.max(maxVerticalDistance, heightWithBond);
      nucleotide.sugar.isMonomerInRnaChainRow = true;
      nucleotide.rnaBase.isMonomerInRnaChainRow = true;
      var oldSugarPosition = nucleotide.sugar.position;
      var rnaBasePosition = new Vec2(lastPosition.x, lastPosition.y + ((_nucleotide$sugar$ren3 = (_nucleotide$sugar$ren4 = nucleotide.sugar.renderer) === null || _nucleotide$sugar$ren4 === void 0 || (_nucleotide$sugar$ren4 = _nucleotide$sugar$ren4.monomerSize) === null || _nucleotide$sugar$ren4 === void 0 ? void 0 : _nucleotide$sugar$ren4.height) !== null && _nucleotide$sugar$ren3 !== void 0 ? _nucleotide$sugar$ren3 : 0) / 2 + ((_nucleotide$rnaBase$r2 = (_nucleotide$rnaBase$r3 = nucleotide.rnaBase.renderer) === null || _nucleotide$rnaBase$r3 === void 0 || (_nucleotide$rnaBase$r3 = _nucleotide$rnaBase$r3.monomerSize) === null || _nucleotide$rnaBase$r3 === void 0 ? void 0 : _nucleotide$rnaBase$r3.height) !== null && _nucleotide$rnaBase$r2 !== void 0 ? _nucleotide$rnaBase$r2 : 0) / 2 + RNA_MONOMER_DISTANCE);
      this.addRnaOperations(command, oldSugarPosition, lastPosition, nucleotide.sugar);
      this.addRnaOperations(command, (_nucleotide$rnaBase = nucleotide.rnaBase) === null || _nucleotide$rnaBase === void 0 ? void 0 : _nucleotide$rnaBase.position, rnaBasePosition, nucleotide.rnaBase);
      rearrangedMonomersSet.add(nucleotide.sugar.id);
      rearrangedMonomersSet.add((_nucleotide$rnaBase2 = nucleotide.rnaBase) === null || _nucleotide$rnaBase2 === void 0 ? void 0 : _nucleotide$rnaBase2.id);
      if (nucleotide.phosphate) {
        var _nucleotide$sugar$ren5, _nucleotide$sugar$ren6, _nucleotide$phosphate2, _nucleotide$phosphate3, _nucleotide$phosphate4, _nucleotide$phosphate5;
        nucleotide.phosphate.isMonomerInRnaChainRow = true;
        var phosphatePosition = new Vec2(lastPosition.x + ((_nucleotide$sugar$ren5 = (_nucleotide$sugar$ren6 = nucleotide.sugar.renderer) === null || _nucleotide$sugar$ren6 === void 0 || (_nucleotide$sugar$ren6 = _nucleotide$sugar$ren6.monomerSize) === null || _nucleotide$sugar$ren6 === void 0 ? void 0 : _nucleotide$sugar$ren6.width) !== null && _nucleotide$sugar$ren5 !== void 0 ? _nucleotide$sugar$ren5 : 0) / 2 + ((_nucleotide$phosphate2 = (_nucleotide$phosphate3 = nucleotide.phosphate) === null || _nucleotide$phosphate3 === void 0 || (_nucleotide$phosphate3 = _nucleotide$phosphate3.renderer) === null || _nucleotide$phosphate3 === void 0 || (_nucleotide$phosphate3 = _nucleotide$phosphate3.monomerSize) === null || _nucleotide$phosphate3 === void 0 ? void 0 : _nucleotide$phosphate3.width) !== null && _nucleotide$phosphate2 !== void 0 ? _nucleotide$phosphate2 : 0) / 2 + RNA_MONOMER_DISTANCE, lastPosition.y);
        this.addRnaOperations(command, (_nucleotide$phosphate4 = nucleotide.phosphate) === null || _nucleotide$phosphate4 === void 0 ? void 0 : _nucleotide$phosphate4.position, phosphatePosition, nucleotide.phosphate);
        rearrangedMonomersSet.add((_nucleotide$phosphate5 = nucleotide.phosphate) === null || _nucleotide$phosphate5 === void 0 ? void 0 : _nucleotide$phosphate5.id);
      }
      var lastMonomerInNucleotide = nucleotide.baseMonomer === nucleotide.sugar && nucleotide.phosphate ? nucleotide.phosphate : nucleotide.sugar;
      var nextMonomerPositionAndVerticalDistance = this.getNextMonomerPositionForSnakeLayout(lastMonomerInNucleotide, width, lastPosition, canvasWidth, rearrangedMonomersSet, monomersWithSideChain, maxVerticalDistance);
      this.setRnaBaseSideChainMonomers(nucleotide.rnaBase, rearrangedMonomersSet, monomersWithSideChain);
      var nextMonomer = getNextMonomerInChain(lastMonomerInNucleotide, firstMonomer);
      return {
        command: command,
        lastPosition: (nextMonomerPositionAndVerticalDistance === null || nextMonomerPositionAndVerticalDistance === void 0 ? void 0 : nextMonomerPositionAndVerticalDistance.lastPosition) || lastPosition,
        maxVerticalDistance: (nextMonomerPositionAndVerticalDistance === null || nextMonomerPositionAndVerticalDistance === void 0 ? void 0 : nextMonomerPositionAndVerticalDistance.maxVerticalDistance) || maxVerticalDistance,
        nextMonomer: nextMonomer
      };
    }
  }, {
    key: "getNextMonomerPositionForSnakeLayout",
    value: function getNextMonomerPositionForSnakeLayout(monomer, width, lastPosition, canvasWidth, rearrangedMonomersSet, monomersWithSideChain, maxVerticalDistance) {
      var nextPositionAndDistance;
      for (var attachmentPointName in monomer.attachmentPointsToBonds) {
        var polymerBond = monomer.attachmentPointsToBonds[attachmentPointName];
        var nextMonomer = polymerBond === null || polymerBond === void 0 ? void 0 : polymerBond.getAnotherMonomer(monomer);
        if (!polymerBond || rearrangedMonomersSet.has(nextMonomer.id)) {
          continue;
        }
        if (attachmentPointName === 'R2' && nextMonomer.getAttachmentPointByBond(polymerBond) === 'R1' || attachmentPointName === 'R1' && nextMonomer.getAttachmentPointByBond(polymerBond) === 'R2') {
          nextPositionAndDistance = this.getNextPositionAndDistance(lastPosition, width, maxVerticalDistance, canvasWidth);
        } else {
          monomersWithSideChain.push(nextMonomer);
        }
      }
      return nextPositionAndDistance;
    }
  }, {
    key: "setRnaBaseSideChainMonomers",
    value: function setRnaBaseSideChainMonomers(rnaBase, rearrangedMonomersSet, monomersWithSideChain) {
      var _iterator = _createForOfIteratorHelper$1(Object.keys(rnaBase.attachmentPointsToBonds).reverse()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var attachmentPointName = _step.value;
          var polymerBond = rnaBase.attachmentPointsToBonds[attachmentPointName];
          var nextMonomer = polymerBond === null || polymerBond === void 0 ? void 0 : polymerBond.getAnotherMonomer(rnaBase);
          if (!polymerBond || !nextMonomer || rearrangedMonomersSet.has(nextMonomer.id)) {
            continue;
          }
          monomersWithSideChain.push(nextMonomer);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "addRnaOperations",
    value: function addRnaOperations(command, oldMonomerPosition, newPosition, monomer) {
      if (!monomer || !oldMonomerPosition || !newPosition) {
        return;
      }
      var operation = new MonomerMoveOperation(this.rearrangeChainModelChange.bind(this, monomer, Coordinates.canvasToModel(newPosition)), this.rearrangeChainModelChange.bind(this, monomer, oldMonomerPosition));
      command.addOperation(operation);
    }
  }, {
    key: "reArrangeChains",
    value: function reArrangeChains(canvasWidth, isSnakeMode) {
      var needRedrawBonds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var command = new Command();
      if (isSnakeMode) {
        var rearrangedMonomersSet = new Set();
        var lastPosition = new Vec2({
          x: MONOMER_START_X_POSITION,
          y: MONOMER_START_Y_POSITION
        });
        var firstMonomers = this.getFirstMonomersInChains([Peptide, Chem, Sugar, Phosphate], _toConsumableArray__default["default"](this.monomers.values()));
        var result = this.reArrangeMonomers(canvasWidth, firstMonomers, rearrangedMonomersSet, lastPosition);
        command.merge(result.command);
      }
      if (needRedrawBonds) {
        command.merge(this.redrawBonds());
      }
      return command;
    }
  }, {
    key: "redrawBondsModelChange",
    value: function redrawBondsModelChange(polymerBond, startPosition, endPosition) {
      if (startPosition && endPosition) {
        polymerBond.moveBondStartAbsolute(startPosition.x, startPosition.y);
        polymerBond.moveBondEndAbsolute(endPosition.x, endPosition.y);
      } else {
        polymerBond.moveToLinkedMonomers();
      }
      return polymerBond;
    }
  }, {
    key: "redrawBonds",
    value: function redrawBonds() {
      var _this8 = this;
      var command = new Command();
      this.polymerBonds.forEach(function (polymerBond) {
        command.merge(_this8.createDrawingEntityRedrawCommand(_this8.redrawBondsModelChange.bind(_this8, polymerBond), _this8.redrawBondsModelChange.bind(_this8, polymerBond, polymerBond.startPosition, polymerBond.endPosition)));
      });
      return command;
    }
  }, {
    key: "getFirstMonomersInChains",
    value: function getFirstMonomersInChains(MonomerTypes, currentMonomers) {
      var monomersList = currentMonomers.filter(function (monomer) {
        return MonomerTypes.some(function (MonomerType) {
          return monomer instanceof MonomerType;
        });
      });
      var firstMonomersInChains = monomersList.filter(function (monomer) {
        var polymerBond = monomer.getBondByAttachmentPoint(exports.AttachmentPointName.R2);
        var isFirstMonomerWithR2R1connection = (!monomer.attachmentPointsToBonds.R1 || monomer.attachmentPointsToBonds.R1.isSideChainConnection) && (polymerBond === null || polymerBond === void 0 ? void 0 : polymerBond.isBackBoneChainConnection);
        var isSingleMonomerOrNucleoside = !monomer.attachmentPointsToBonds.R1 && !monomer.attachmentPointsToBonds.R2;
        return isFirstMonomerWithR2R1connection || isSingleMonomerOrNucleoside;
      });
      var _ChainsCollection$get = ChainsCollection.getFirstMonomersInChains(monomersList),
        _ChainsCollection$get2 = _slicedToArray__default["default"](_ChainsCollection$get, 2);
        _ChainsCollection$get2[0];
        var cycledChains = _ChainsCollection$get2[1];
      firstMonomersInChains.push.apply(firstMonomersInChains, _toConsumableArray__default["default"](cycledChains));
      firstMonomersInChains.sort(function (monomer1, monomer2) {
        if (monomer2.position.x + monomer2.position.y > monomer1.position.x + monomer1.position.y) {
          return -1;
        } else {
          return 1;
        }
      });
      return firstMonomersInChains;
    }
  }, {
    key: "reArrangeChainInRecursive",
    value: function reArrangeChainInRecursive(_monomer, _lastPosition, canvasWidth, rearrangedMonomersSet, monomersWithSideChain, _maxVerticalDistance) {
      var firstMonomer = _monomer;
      var command = new Command();
      var stack = [{
        monomer: _monomer,
        lastPosition: _lastPosition,
        maxVerticalDistance: _maxVerticalDistance
      }];
      var lastRearrangeResult = {
        lastPosition: _lastPosition,
        maxVerticalDistance: _maxVerticalDistance
      };
      while (stack.length > 0) {
        var stackItem = stack.pop();
        assert__default["default"](stackItem);
        var lastPosition = stackItem.lastPosition,
          maxVerticalDistance = stackItem.maxVerticalDistance,
          monomer = stackItem.monomer;
        var rearrangeMethod = void 0;
        var entityToRearrange = void 0;
        if (monomer instanceof Sugar || monomer instanceof Phosphate) {
          var nucleotideOrNucleoside = getNucleotideOrNucleoSideFromFirstMonomer(monomer);
          if (nucleotideOrNucleoside) {
            rearrangeMethod = this.reArrangeRnaChain;
            entityToRearrange = nucleotideOrNucleoside;
          } else {
            rearrangeMethod = this.reArrangeChain;
            entityToRearrange = monomer;
          }
        } else {
          rearrangeMethod = this.reArrangeChain;
          entityToRearrange = monomer;
        }
        var rearrangeResult = rearrangeMethod.call(this, entityToRearrange, lastPosition, canvasWidth, rearrangedMonomersSet, monomersWithSideChain, maxVerticalDistance, firstMonomer);
        command.merge(rearrangeResult.command);
        if (rearrangeResult !== null && rearrangeResult !== void 0 && rearrangeResult.lastPosition) {
          lastRearrangeResult = rearrangeResult;
        }
        if (rearrangeResult !== null && rearrangeResult !== void 0 && rearrangeResult.nextMonomer) {
          stack.push({
            monomer: rearrangeResult.nextMonomer,
            lastPosition: rearrangeResult.lastPosition,
            maxVerticalDistance: rearrangeResult.maxVerticalDistance
          });
        }
      }
      return {
        command: command,
        lastPosition: lastRearrangeResult.lastPosition,
        maxVerticalDistance: lastRearrangeResult.maxVerticalDistance
      };
    }
  }, {
    key: "getNextPositionAndDistance",
    value: function getNextPositionAndDistance(lastPosition, width, height, canvasWidth) {
      var isMonomerFitCanvas = lastPosition.x + width + DISTANCE_BETWEEN_MONOMERS + HORIZONTAL_DISTANCE_FROM_MONOMER + DISTANCE_FROM_RIGHT < canvasWidth;
      if (!isMonomerFitCanvas) {
        return {
          maxVerticalDistance: 0,
          lastPosition: getFirstPosition(height, lastPosition)
        };
      }
      return {
        maxVerticalDistance: height,
        lastPosition: new Vec2({
          x: lastPosition.x + width + HORIZONTAL_DISTANCE_FROM_MONOMER,
          y: lastPosition.y
        })
      };
    }
  }, {
    key: "isPartOfR2R1Chain",
    value: function isPartOfR2R1Chain(monomer) {
      var _R1Bond$getAnotherMon, _R2Bond$getAnotherMon;
      var R1Bond = monomer.attachmentPointsToBonds.R1;
      var R2Bond = monomer.attachmentPointsToBonds.R2;
      return (R1Bond === null || R1Bond === void 0 || (_R1Bond$getAnotherMon = R1Bond.getAnotherMonomer(monomer)) === null || _R1Bond$getAnotherMon === void 0 ? void 0 : _R1Bond$getAnotherMon.getAttachmentPointByBond(R1Bond)) === 'R2' || (R2Bond === null || R2Bond === void 0 || (_R2Bond$getAnotherMon = R2Bond.getAnotherMonomer(monomer)) === null || _R2Bond$getAnotherMon === void 0 ? void 0 : _R2Bond$getAnotherMon.getAttachmentPointByBond(R2Bond)) === 'R1';
    }
  }, {
    key: "getFirstMonomerInR2R1Chain",
    value: function getFirstMonomerInR2R1Chain(monomer) {
      var _R1Bond$getAnotherMon2;
      var R1Bond = monomer.attachmentPointsToBonds.R1;
      return R1Bond && ((_R1Bond$getAnotherMon2 = R1Bond.getAnotherMonomer(monomer)) === null || _R1Bond$getAnotherMon2 === void 0 ? void 0 : _R1Bond$getAnotherMon2.getAttachmentPointByBond(R1Bond)) === 'R2' ? this.getFirstMonomerInR2R1Chain(R1Bond.getAnotherMonomer(monomer)) : monomer;
    }
  }, {
    key: "reArrangeMonomers",
    value: function reArrangeMonomers(canvasWidth, firstMonomers, rearrangedMonomersSet, lastPosition) {
      var _this9 = this;
      var command = new Command();
      firstMonomers.forEach(function (monomer) {
        if (rearrangedMonomersSet.has(monomer.id)) {
          return;
        }
        var monomersWithSideChain = [];
        var rearrangeResult = _this9.reArrangeChainInRecursive(monomer, lastPosition, canvasWidth, rearrangedMonomersSet, monomersWithSideChain, 0);
        command.merge(rearrangeResult.command);
        lastPosition = rearrangeResult.lastPosition;
        lastPosition = getFirstPosition(rearrangeResult.maxVerticalDistance, lastPosition);
        if (monomersWithSideChain.length > 0) {
          monomersWithSideChain.reverse().forEach(function (monomerWithSideChain) {
            var currentMonomerChain = _this9.findChainByMonomer(monomerWithSideChain, undefined, new Set(_toConsumableArray__default["default"](rearrangedMonomersSet)));
            var firstMonomers = _this9.getFirstMonomersInChains([Peptide, Chem, Sugar, Phosphate], currentMonomerChain);
            if (rearrangedMonomersSet.has(monomerWithSideChain.id)) {
              return;
            }
            if (!firstMonomers.length) {
              firstMonomers = [monomerWithSideChain];
            } else if (_this9.isPartOfR2R1Chain(monomerWithSideChain)) {
              var firstMonomerInR2R1Chain = _this9.getFirstMonomerInR2R1Chain(monomerWithSideChain);
              firstMonomers = [firstMonomerInR2R1Chain];
            } else {
              var _monomerWithSideChain, _monomerWithSideChain2;
              var oldMonomerPosition = monomerWithSideChain.position;
              var operation = new MonomerMoveOperation(_this9.rearrangeChainModelChange.bind(_this9, monomerWithSideChain, Coordinates.canvasToModel(lastPosition)), _this9.rearrangeChainModelChange.bind(_this9, monomerWithSideChain, oldMonomerPosition));
              rearrangedMonomersSet.add(monomerWithSideChain.id);
              command.addOperation(operation);
              var height = ((_monomerWithSideChain = (_monomerWithSideChain2 = monomerWithSideChain.renderer) === null || _monomerWithSideChain2 === void 0 || (_monomerWithSideChain2 = _monomerWithSideChain2.monomerSize) === null || _monomerWithSideChain2 === void 0 ? void 0 : _monomerWithSideChain2.height) !== null && _monomerWithSideChain !== void 0 ? _monomerWithSideChain : 0) + VERTICAL_DISTANCE_FROM_MONOMER;
              lastPosition = getFirstPosition(height, lastPosition);
            }
            var rearrangeResult = _this9.reArrangeMonomers(canvasWidth, firstMonomers, rearrangedMonomersSet, lastPosition);
            command.merge(rearrangeResult.command);
            lastPosition = rearrangeResult.lastPosition;
          });
        }
      });
      return {
        command: command,
        lastPosition: lastPosition
      };
    }
  }, {
    key: "setMicromoleculesHiddenEntities",
    value: function setMicromoleculesHiddenEntities(struct) {
      struct.mergeInto(this.micromoleculesHiddenEntities);
      this.micromoleculesHiddenEntities.atoms = new Pool();
      this.micromoleculesHiddenEntities.bonds = new Pool();
      this.micromoleculesHiddenEntities.halfBonds = new Pool();
      this.micromoleculesHiddenEntities.sgroups = new Pool();
      this.micromoleculesHiddenEntities.functionalGroups = new Pool();
      this.micromoleculesHiddenEntities.sGroupForest = new SGroupForest();
      this.micromoleculesHiddenEntities.frags = new Pool();
    }
  }, {
    key: "clearMicromoleculesHiddenEntities",
    value: function clearMicromoleculesHiddenEntities() {
      this.micromoleculesHiddenEntities = new Struct();
    }
  }, {
    key: "mergeInto",
    value: function mergeInto(targetDrawingEntitiesManager) {
      var command = new Command();
      var monomerToNewMonomer = new Map();
      this.monomers.forEach(function (monomer) {
        var monomerAddCommand = targetDrawingEntitiesManager.addMonomer(monomer.monomerItem, monomer.position);
        monomerToNewMonomer.set(monomer, monomerAddCommand.operations[0].monomer);
        command.merge(monomerAddCommand);
      });
      this.polymerBonds.forEach(function (polymerBond) {
        assert__default["default"](polymerBond.secondMonomer);
        var polymerBondCreateCommand = targetDrawingEntitiesManager.createPolymerBond(monomerToNewMonomer.get(polymerBond.firstMonomer), monomerToNewMonomer.get(polymerBond.secondMonomer), polymerBond.firstMonomer.getAttachmentPointByBond(polymerBond), polymerBond.secondMonomer.getAttachmentPointByBond(polymerBond));
        command.merge(polymerBondCreateCommand);
      });
      this.micromoleculesHiddenEntities.mergeInto(targetDrawingEntitiesManager.micromoleculesHiddenEntities);
      return command;
    }
  }, {
    key: "centerMacroStructure",
    value: function centerMacroStructure() {
      var centerPointOfModel = Coordinates.canvasToModel(getCurrentCenterPointOfCanvas());
      var structCenter = this.getMacroStructureCenter();
      var offset = Vec2.diff(centerPointOfModel, structCenter);
      this.monomers.forEach(function (monomer) {
        monomer.moveAbsolute(new Vec2(monomer.position).add(offset));
      });
      this.polymerBonds.forEach(function (bond) {
        var _Vec2$add = new Vec2(bond.position).add(offset),
          startX = _Vec2$add.x,
          startY = _Vec2$add.y;
        bond.moveBondStartAbsolute(startX, startY);
        var _Vec2$add2 = new Vec2(bond.endPosition).add(offset),
          endX = _Vec2$add2.x,
          endY = _Vec2$add2.y;
        bond.moveBondEndAbsolute(endX, endY);
      });
    }
  }, {
    key: "getMacroStructureCenter",
    value: function getMacroStructureCenter() {
      var xmin = 1e50;
      var ymin = xmin;
      var xmax = -xmin;
      var ymax = -ymin;
      this.monomers.forEach(function (monomer) {
        xmin = Math.min(xmin, monomer.position.x);
        ymin = Math.min(ymin, monomer.position.y);
        xmax = Math.max(xmax, monomer.position.x);
        ymax = Math.max(ymax, monomer.position.y);
      });
      this.polymerBonds.forEach(function (bond) {
        xmin = Math.min(xmin, bond.position.x);
        ymin = Math.min(ymin, bond.position.y);
        xmax = Math.max(xmax, bond.position.x);
        ymax = Math.max(ymax, bond.position.y);
      });
      return new Vec2((xmin + xmax) / 2, (ymin + ymax) / 2);
    }
  }, {
    key: "applyMonomersSequenceLayout",
    value: function applyMonomersSequenceLayout() {
      var chainsCollection = ChainsCollection.fromMonomers(_toConsumableArray__default["default"](this.monomers.values()));
      chainsCollection.rearrange();
      SequenceRenderer.show(chainsCollection);
      return chainsCollection;
    }
  }, {
    key: "clearCanvas",
    value: function clearCanvas() {
      var editor = CoreEditor.provideEditorInstance();
      this.monomers.forEach(function (monomer) {
        editor.renderersContainer.deleteMonomer(monomer);
      });
      this.polymerBonds.forEach(function (polymerBond) {
        editor.renderersContainer.deletePolymerBond(polymerBond);
      });
      SequenceRenderer.removeEmptyNodes();
    }
  }, {
    key: "applyFlexLayoutMode",
    value: function applyFlexLayoutMode() {
      var needRedrawBonds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var editor = CoreEditor.provideEditorInstance();
      var command = new Command();
      if (needRedrawBonds) {
        command.merge(this.redrawBonds());
      }
      this.monomers.forEach(function (monomer) {
        editor.renderersContainer.deleteMonomer(monomer);
        editor.renderersContainer.addMonomer(monomer);
      });
      this.polymerBonds.forEach(function (polymerBond) {
        editor.renderersContainer.deletePolymerBond(polymerBond);
        editor.renderersContainer.addPolymerBond(polymerBond);
      });
      SequenceRenderer.removeEmptyNodes();
      return command;
    }
  }, {
    key: "getAllSelectedEntities",
    value: function getAllSelectedEntities(drawingEntity) {
      var needToSelectConnectedBonds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var editor = CoreEditor.provideEditorInstance();
      if (!(editor.mode instanceof SequenceMode) || drawingEntity instanceof PolymerBond$1) {
        return [drawingEntity];
      }
      var drawingEntities = [drawingEntity];
      if (drawingEntity.isPartOfRna && drawingEntity instanceof Sugar) {
        var sugar = drawingEntity;
        if (isValidNucleoside(sugar)) {
          var nucleoside = Nucleoside.fromSugar(sugar);
          drawingEntities.push(nucleoside.rnaBase);
          if (needToSelectConnectedBonds && nucleoside.rnaBase.hasBonds) {
            nucleoside.rnaBase.forEachBond(function (polymerBond) {
              drawingEntities.push(polymerBond);
            });
          }
        } else if (isValidNucleotide(sugar)) {
          var nucleotide = Nucleotide.fromSugar(sugar);
          drawingEntities.push(nucleotide.rnaBase);
          drawingEntities.push(nucleotide.phosphate);
          if (needToSelectConnectedBonds && nucleotide.rnaBase.hasBonds) {
            nucleotide.rnaBase.forEachBond(function (polymerBond) {
              drawingEntities.push(polymerBond);
            });
          }
          if (needToSelectConnectedBonds && nucleotide.phosphate.hasBonds) {
            nucleotide.phosphate.forEachBond(function (polymerBond) {
              drawingEntities.push(polymerBond);
            });
          }
        }
      }
      var monomer = drawingEntity;
      if (needToSelectConnectedBonds && monomer.hasBonds) {
        monomer.forEachBond(function (polymerBond) {
          if (!drawingEntities.includes(polymerBond)) {
            drawingEntities.push(polymerBond);
          }
        });
      }
      return drawingEntities;
    }
  }, {
    key: "validateIfApplicableForFasta",
    value: function validateIfApplicableForFasta() {
      var monomerTypes = new Set();
      var isValid = true;
      this.monomers.forEach(function (monomer) {
        var monomerType = monomer.monomerItem.props.MonomerType;
        monomerTypes.add(monomerType);
        if (monomerType === MONOMER_CONST.CHEM || monomerTypes.size > 1) {
          isValid = false;
        }
      });
      return isValid;
    }
  }, {
    key: "moveMonomer",
    value: function moveMonomer(monomer, position) {
      var oldMonomerPosition = monomer.position;
      var command = new Command();
      var operation = new MonomerMoveOperation(this.rearrangeChainModelChange.bind(this, monomer, position), this.rearrangeChainModelChange.bind(this, monomer, oldMonomerPosition));
      command.addOperation(operation);
      return command;
    }
  }]);
  return DrawingEntitiesManager;
}();
function getFirstPosition(height, lastPosition) {
  return new Vec2(MONOMER_START_X_POSITION, lastPosition.y + height);
}
function getNucleotideOrNucleoSideFromFirstMonomer(monomer) {
  if (monomer instanceof Sugar) {
    var nextMonomer = getNextMonomerInChain(monomer);
    var rnaBaseMonomer = getRnaBaseFromSugar(monomer);
    var isNucleoside = !(nextMonomer instanceof Phosphate) && rnaBaseMonomer instanceof RNABase;
    var isNucleotide = nextMonomer && nextMonomer instanceof Phosphate && rnaBaseMonomer instanceof RNABase;
    if (isNucleotide) {
      return {
        sugar: monomer,
        phosphate: nextMonomer,
        rnaBase: rnaBaseMonomer,
        baseMonomer: monomer
      };
    }
    if (isNucleoside) {
      return {
        sugar: monomer,
        rnaBase: rnaBaseMonomer,
        baseMonomer: monomer
      };
    }
  }
  if (monomer instanceof Phosphate) {
    var r1PolymerBond = monomer.attachmentPointsToBonds.R1;
    var _nextMonomer = r1PolymerBond === null || r1PolymerBond === void 0 ? void 0 : r1PolymerBond.getAnotherMonomer(monomer);
    var _rnaBaseMonomer = getRnaBaseFromSugar(_nextMonomer);
    var _isNucleotide = _nextMonomer && _nextMonomer instanceof Sugar && _rnaBaseMonomer instanceof RNABase;
    if (_isNucleotide) {
      return {
        sugar: _nextMonomer,
        phosphate: monomer,
        rnaBase: _rnaBaseMonomer,
        baseMonomer: monomer
      };
    }
  }
  return undefined;
}

var HISTORY_SIZE = 32;
var EditorHistory = function () {
  function EditorHistory(editor) {
    _classCallCheck__default["default"](this, EditorHistory);
    _defineProperty__default["default"](this, "historyStack", []);
    _defineProperty__default["default"](this, "historyPointer", 0);
    if (EditorHistory._instance) {
      return EditorHistory._instance;
    }
    this.editor = editor;
    this.historyPointer = 0;
    EditorHistory._instance = this;
    return this;
  }
  _createClass__default["default"](EditorHistory, [{
    key: "update",
    value: function update(command, megreWithLatestHistoryCommand) {
      var latestCommand = this.historyStack[this.historyStack.length - 1];
      if (megreWithLatestHistoryCommand && latestCommand) {
        latestCommand.merge(command);
      } else {
        this.historyStack.splice(this.historyPointer, HISTORY_SIZE + 1, command);
        if (this.historyStack.length > HISTORY_SIZE) {
          this.historyStack.shift();
        }
        this.historyPointer = this.historyStack.length;
      }
    }
  }, {
    key: "undo",
    value: function undo() {
      var _this$editor, _this$editor2;
      if (this.historyPointer === 0) {
        return;
      }
      assert__default["default"](this.editor);
      this.historyPointer--;
      var lastCommand = this.historyStack[this.historyPointer];
      lastCommand.invert(this.editor.renderersContainer);
      var turnOffSelectionCommand = (_this$editor = this.editor) === null || _this$editor === void 0 ? void 0 : _this$editor.drawingEntitiesManager.unselectAllDrawingEntities();
      (_this$editor2 = this.editor) === null || _this$editor2 === void 0 || _this$editor2.renderersContainer.update(turnOffSelectionCommand);
    }
  }, {
    key: "redo",
    value: function redo() {
      if (this.historyPointer === this.historyStack.length) {
        return;
      }
      assert__default["default"](this.editor);
      var lastCommand = this.historyStack[this.historyPointer];
      lastCommand.execute(this.editor.renderersContainer);
      this.historyPointer++;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      EditorHistory._instance = null;
    }
  }]);
  return EditorHistory;
}();

function ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function isMouseMainButtonPressed(event) {
  return event.button === 0;
}
var editor;
var CoreEditor = function () {
  function CoreEditor(_ref) {
    var theme = _ref.theme,
      canvas = _ref.canvas;
    _classCallCheck__default["default"](this, CoreEditor);
    _defineProperty__default["default"](this, "lastCursorPosition", new Vec2(0, 0));
    _defineProperty__default["default"](this, "lastCursorPositionOfCanvas", new Vec2(0, 0));
    _defineProperty__default["default"](this, "_monomersLibrary", []);
    _defineProperty__default["default"](this, "mode", new FlexMode());
    _defineProperty__default["default"](this, "sequenceTypeEnterMode", exports.SequenceType.RNA);
    _defineProperty__default["default"](this, "hotKeyEventHandler", function () {});
    this.theme = theme;
    this.canvas = canvas;
    resetEditorEvents();
    this.events = exports.editorEvents;
    this.subscribeEvents();
    this.renderersContainer = new RenderersManager({
      theme: theme
    });
    this.drawingEntitiesManager = new DrawingEntitiesManager();
    this.domEventSetup();
    this.setupContextMenuEvents();
    this.setupKeyboardEvents();
    this.canvasOffset = this.canvas.getBoundingClientRect();
    this.zoomTool = ZoomTool.initInstance(this.drawingEntitiesManager);
    editor = this;
    var ketcher = ketcherProvider.getKetcher();
    this.micromoleculesEditor = ketcher === null || ketcher === void 0 ? void 0 : ketcher.editor;
    this.switchToMacromolecules();
  }
  _createClass__default["default"](CoreEditor, [{
    key: "selectedTool",
    get:
    function get() {
      return this.tool;
    }
  }, {
    key: "setMonomersLibrary",
    value: function setMonomersLibrary(monomersLibrary) {
      this._monomersLibrary = monomersLibrary;
    }
  }, {
    key: "monomersLibrary",
    get: function get() {
      return _.groupBy(this._monomersLibrary.map(function (libraryItem) {
        return _objectSpread$8(_objectSpread$8({}, libraryItem), {}, {
          label: libraryItem.props.MonomerName
        });
      }), function (libraryItem) {
        return libraryItem.props.MonomerType;
      });
    }
  }, {
    key: "handleHotKeyEvents",
    value: function handleHotKeyEvents(event) {
      var _keySettings$shortcut;
      var keySettings = hotkeysConfiguration;
      var hotKeys = initHotKeys(keySettings);
      var shortcutKey = keyNorm.lookup(hotKeys, event);
      var isInput = event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA';
      if ((_keySettings$shortcut = keySettings[shortcutKey]) !== null && _keySettings$shortcut !== void 0 && _keySettings$shortcut.handler && !isInput) {
        keySettings[shortcutKey].handler(this);
        event.preventDefault();
      }
    }
  }, {
    key: "setupKeyboardEvents",
    value: function setupKeyboardEvents() {
      var _this = this;
      this.setupHotKeysEvents();
      document.addEventListener('keydown', function () {
        var _ref2 = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee(event) {
          return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.mode.onKeyDown(event);
              case 2:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "setupHotKeysEvents",
    value: function setupHotKeysEvents() {
      var _this2 = this;
      this.hotKeyEventHandler = function (event) {
        return _this2.handleHotKeyEvents(event);
      };
      document.addEventListener('keydown', this.hotKeyEventHandler);
    }
  }, {
    key: "setupContextMenuEvents",
    value: function setupContextMenuEvents() {
      var _this3 = this;
      document.addEventListener('contextmenu', function (event) {
        var _event$target;
        event.preventDefault();
        if (!(_this3.mode instanceof SequenceMode) || _this3.mode.isEditMode) {
          return false;
        }
        if (((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.__data__) instanceof BaseSequenceItemRenderer) {
          _this3.events.rightClickSequence.dispatch(event);
        } else {
          _this3.events.rightClickCanvas.dispatch(event);
        }
        return false;
      });
    }
  }, {
    key: "subscribeEvents",
    value: function subscribeEvents() {
      var _this4 = this;
      this.events.selectMonomer.add(function (monomer) {
        return _this4.onSelectMonomer(monomer);
      });
      this.events.selectPreset.add(function (preset) {
        return _this4.onSelectRNAPreset(preset);
      });
      this.events.selectTool.add(function (tool) {
        return _this4.onSelectTool(tool);
      });
      this.events.createBondViaModal.add(function (payload) {
        return _this4.onCreateBond(payload);
      });
      this.events.cancelBondCreationViaModal.add(function (secondMonomer) {
        return _this4.onCancelBondCreation(secondMonomer);
      });
      this.events.selectMode.add(function (isSnakeMode) {
        return _this4.onSelectMode(isSnakeMode);
      });
      this.events.selectHistory.add(function (name) {
        return _this4.onSelectHistory(name);
      });
      renderersEvents.forEach(function (eventName) {
        _this4.events[eventName].add(function (event) {
          return _this4.useToolIfNeeded(eventName, event);
        });
      });
      this.events.editSequence.add(function (sequenceItemRenderer) {
        return _this4.onEditSequence(sequenceItemRenderer);
      });
      this.events.startNewSequence.add(function () {
        return _this4.onStartNewSequence();
      });
      this.events.changeSequenceTypeEnterMode.add(function (mode) {
        return _this4.onChangeSequenceTypeEnterMode(mode);
      });
    }
  }, {
    key: "onEditSequence",
    value: function onEditSequence(sequenceItemRenderer) {
      if (!(this.mode instanceof SequenceMode)) {
        return;
      }
      this.mode.turnOnEditMode(sequenceItemRenderer);
    }
  }, {
    key: "onStartNewSequence",
    value: function onStartNewSequence() {
      if (!(this.mode instanceof SequenceMode)) {
        return;
      }
      this.mode.startNewSequence();
    }
  }, {
    key: "onChangeSequenceTypeEnterMode",
    value: function onChangeSequenceTypeEnterMode(mode) {
      this.sequenceTypeEnterMode = mode;
    }
  }, {
    key: "onSelectMonomer",
    value: function onSelectMonomer(monomer) {
      this.selectTool('monomer', monomer);
    }
  }, {
    key: "onSelectRNAPreset",
    value: function onSelectRNAPreset(preset) {
      if (preset) {
        this.selectTool('preset', preset);
      } else {
        this.tool = undefined;
      }
    }
  }, {
    key: "onSelectTool",
    value: function onSelectTool(tool) {
      this.selectTool(tool);
    }
  }, {
    key: "onCreateBond",
    value: function onCreateBond(payload) {
      if (this.tool instanceof PolymerBond) {
        this.tool.handleBondCreation(payload);
      }
    }
  }, {
    key: "onCancelBondCreation",
    value: function onCancelBondCreation(secondMonomer) {
      if (this.tool instanceof PolymerBond) {
        this.tool.handleBondCreationCancellation(secondMonomer);
      }
    }
  }, {
    key: "onSelectMode",
    value: function onSelectMode(data) {
      var mode = _typeof__default["default"](data) === 'object' ? data.mode : data;
      var ModeConstructor = modesMap[mode];
      assert__default["default"](ModeConstructor);
      var history = new EditorHistory(this);
      this.mode.destroy();
      this.mode = new ModeConstructor(this.mode.modeName);
      var command = this.mode.initialize();
      history.update(command, _typeof__default["default"](data) === 'object' ? data === null || data === void 0 ? void 0 : data.mergeWithLatestHistoryCommand : false);
    }
  }, {
    key: "setMode",
    value: function setMode(mode) {
      this.mode = mode;
    }
  }, {
    key: "isSequenceEditMode",
    get: function get() {
      return this.mode instanceof SequenceMode && this.mode.isEditMode;
    }
  }, {
    key: "onSelectHistory",
    value: function onSelectHistory(name) {
      var history = new EditorHistory(this);
      if (name === 'undo') {
        history.undo();
      } else if (name === 'redo') {
        history.redo();
      }
    }
  }, {
    key: "selectTool",
    value: function selectTool(name, options) {
      var ToolConstructor = toolsMap[name];
      var oldTool = this.tool;
      this.tool = new ToolConstructor(this, options);
      if (isBaseTool(oldTool)) {
        oldTool === null || oldTool === void 0 || oldTool.destroy();
      }
    }
  }, {
    key: "unsubscribeEvents",
    value: function unsubscribeEvents() {
      for (var eventName in this.events) {
        this.events[eventName].handlers = [];
      }
      document.removeEventListener('keydown', this.hotKeyEventHandler);
    }
  }, {
    key: "trackedDomEvents",
    get: function get() {
      var trackedDomEvents = [{
        target: this.canvas,
        eventName: 'click',
        toolEventHandler: 'click'
      }, {
        target: this.canvas,
        eventName: 'dblclick',
        toolEventHandler: 'dblclick'
      }, {
        target: this.canvas,
        eventName: 'mousedown',
        toolEventHandler: 'mousedown'
      }, {
        target: document,
        eventName: 'mousemove',
        toolEventHandler: 'mousemove'
      }, {
        target: document,
        eventName: 'mouseup',
        toolEventHandler: 'mouseup'
      }, {
        target: document,
        eventName: 'mouseleave',
        toolEventHandler: 'mouseleave'
      }, {
        target: this.canvas,
        eventName: 'mouseleave',
        toolEventHandler: 'mouseLeaveClientArea'
      }, {
        target: this.canvas,
        eventName: 'mouseover',
        toolEventHandler: 'mouseover'
      }];
      return trackedDomEvents;
    }
  }, {
    key: "domEventSetup",
    value: function domEventSetup() {
      var _this5 = this;
      this.trackedDomEvents.forEach(function (_ref3) {
        var target = _ref3.target,
          eventName = _ref3.eventName,
          toolEventHandler = _ref3.toolEventHandler;
        _this5.events[eventName] = new DOMSubscription_1();
        var subs = _this5.events[eventName];
        target.addEventListener(eventName, subs.dispatch.bind(subs));
        subs.add(function (event) {
          _this5.updateLastCursorPosition(event);
          if (['mouseup', 'mousedown', 'click', 'dbclick'].includes(event.type) && !isMouseMainButtonPressed(event)) {
            return true;
          }
          _this5.useModeIfNeeded(toolEventHandler, event);
          var isToolUsed = _this5.useToolIfNeeded(toolEventHandler, event);
          if (isToolUsed) {
            return true;
          }
          return true;
        }, -1);
      });
    }
  }, {
    key: "updateLastCursorPosition",
    value: function updateLastCursorPosition(event) {
      var events = ['mousemove', 'click', 'mousedown', 'mouseup', 'mouseover'];
      if (events.includes(event.type)) {
        var clientAreaBoundingBox = this.canvasOffset;
        this.lastCursorPosition = new Vec2({
          x: event.pageX - clientAreaBoundingBox.x,
          y: event.pageY - clientAreaBoundingBox.y
        });
        this.lastCursorPositionOfCanvas = Coordinates.viewToCanvas(this.lastCursorPosition);
      }
    }
  }, {
    key: "useToolIfNeeded",
    value: function useToolIfNeeded(eventHandlerName, event) {
      var _editorTool$isSelecti;
      var editorTool = this.tool;
      if (!editorTool) {
        return false;
      }
      var conditions = [eventHandlerName in editorTool, this.canvas.contains(event === null || event === void 0 ? void 0 : event.target) || ((_editorTool$isSelecti = editorTool.isSelectionRunning) === null || _editorTool$isSelecti === void 0 ? void 0 : _editorTool$isSelecti.call(editorTool))
      ];
      if (conditions.every(function (condition) {
        return condition;
      })) {
        var _editorTool$eventHand;
        (_editorTool$eventHand = editorTool[eventHandlerName]) === null || _editorTool$eventHand === void 0 || _editorTool$eventHand.call(editorTool, event);
        return true;
      }
      return false;
    }
  }, {
    key: "useModeIfNeeded",
    value: function useModeIfNeeded(eventHandlerName, event) {
      var _this$mode, _this$mode$eventHandl;
      (_this$mode = this.mode) === null || _this$mode === void 0 || (_this$mode$eventHandl = _this$mode[eventHandlerName]) === null || _this$mode$eventHandl === void 0 || _this$mode$eventHandl.call(_this$mode, event);
    }
  }, {
    key: "switchToMicromolecules",
    value: function switchToMicromolecules() {
      this.unsubscribeEvents();
      var history = new EditorHistory(this);
      history.destroy();
      var struct = this.micromoleculesEditor.struct();
      var reStruct = this.micromoleculesEditor.render.ctab;
      var _MacromoleculesConver = MacromoleculesConverter.convertDrawingEntitiesToStruct(this.drawingEntitiesManager, struct, reStruct),
        conversionErrorMessage = _MacromoleculesConver.conversionErrorMessage;
      reStruct.render.setMolecule(struct);
      if (conversionErrorMessage) {
        var ketcher = ketcherProvider.getKetcher();
        ketcher.editor.setMacromoleculeConvertionError(conversionErrorMessage);
      }
    }
  }, {
    key: "switchToMacromolecules",
    value: function switchToMacromolecules() {
      var _this$micromoleculesE;
      var struct = ((_this$micromoleculesE = this.micromoleculesEditor) === null || _this$micromoleculesE === void 0 ? void 0 : _this$micromoleculesE.struct()) || new Struct();
      var ketcher = ketcherProvider.getKetcher();
      var _MacromoleculesConver2 = MacromoleculesConverter.convertStructToDrawingEntities(struct, this.drawingEntitiesManager),
        modelChanges = _MacromoleculesConver2.modelChanges;
      this.renderersContainer.update(modelChanges);
      ketcher === null || ketcher === void 0 || ketcher.editor.clear();
    }
  }], [{
    key: "provideEditorInstance",
    value: function provideEditorInstance() {
      return editor;
    }
  }]);
  return CoreEditor;
}();

var Nucleoside = function () {
  function Nucleoside(sugar, rnaBase) {
    _classCallCheck__default["default"](this, Nucleoside);
    this.sugar = sugar;
    this.rnaBase = rnaBase;
  }
  _createClass__default["default"](Nucleoside, [{
    key: "isMonomerTypeDifferentForChaining",
    value: function isMonomerTypeDifferentForChaining(monomerToChain) {
      return this.sugar.isMonomerTypeDifferentForChaining(monomerToChain);
    }
  }, {
    key: "SubChainConstructor",
    get: function get() {
      return this.sugar.SubChainConstructor;
    }
  }, {
    key: "monomer",
    get: function get() {
      return this.sugar;
    }
  }, {
    key: "monomers",
    get: function get() {
      return [this.sugar, this.rnaBase];
    }
  }, {
    key: "firstMonomerInNode",
    get: function get() {
      return this.sugar;
    }
  }, {
    key: "lastMonomerInNode",
    get: function get() {
      return this.sugar;
    }
  }, {
    key: "renderer",
    get: function get() {
      return this.monomer.renderer;
    }
  }, {
    key: "modified",
    get: function get() {
      return this.sugar.label !== RNA_DNA_NON_MODIFIED_PART.SUGAR_RNA;
    }
  }], [{
    key: "fromSugar",
    value: function fromSugar(sugar) {
      var needValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (needValidation) {
        assert__default["default"](isValidNucleoside(sugar), 'Created nucleoside is not valid. Please check nucleotide parts connections.');
        var isNucleotide = isValidNucleotide(sugar);
        assert__default["default"](!isNucleotide, 'Created nucleoside is nucleotide.');
      }
      return new Nucleoside(sugar, getRnaBaseFromSugar(sugar));
    }
  }, {
    key: "createOnCanvas",
    value: function createOnCanvas(rnaBaseName, position) {
      var editor = CoreEditor.provideEditorInstance();
      var rnaBaseLibraryItem = getRnaPartLibraryItem(editor, rnaBaseName);
      var sugarName = getSugarBySequenceType(editor.sequenceTypeEnterMode);
      assert__default["default"](sugarName);
      var sugarLibraryItem = getRnaPartLibraryItem(editor, sugarName);
      assert__default["default"](sugarLibraryItem);
      assert__default["default"](rnaBaseLibraryItem);
      var modelChanges = new Command();
      modelChanges.merge(editor.drawingEntitiesManager.addMonomer(sugarLibraryItem, position));
      modelChanges.merge(editor.drawingEntitiesManager.addMonomer(rnaBaseLibraryItem, position));
      var sugar = modelChanges.operations[0].monomer;
      var rnaBase = modelChanges.operations[1].monomer;
      modelChanges.merge(editor.drawingEntitiesManager.createPolymerBond(sugar, rnaBase, exports.AttachmentPointName.R3, exports.AttachmentPointName.R1));
      return {
        modelChanges: modelChanges,
        node: Nucleoside.fromSugar(sugar, false)
      };
    }
  }]);
  return Nucleoside;
}();

exports.SequenceType = void 0;
(function (SequenceType) {
  SequenceType["RNA"] = "RNA";
  SequenceType["DNA"] = "DNA";
  SequenceType["PEPTIDE"] = "PEPTIDE";
})(exports.SequenceType || (exports.SequenceType = {}));
exports.IsChainCycled = void 0;
(function (IsChainCycled) {
  IsChainCycled[IsChainCycled["NOT_CYCLED"] = 0] = "NOT_CYCLED";
  IsChainCycled[IsChainCycled["CYCLED"] = 1] = "CYCLED";
})(exports.IsChainCycled || (exports.IsChainCycled = {}));

var BaseOperation = function () {
  function BaseOperation(type) {
    var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck__default["default"](this, BaseOperation);
    this.type = type;
    this.priority = priority;
  }
  _createClass__default["default"](BaseOperation, [{
    key: "execute",
    value: function execute(_restruct) {
      throw new Error('Operation.execute() is not implemented');
    }
  }, {
    key: "perform",
    value: function perform(restruct) {
      this.execute(restruct);
      if (!this._inverted) {
        this._inverted = this.invert();
        this._inverted._inverted = this;
      }
      return this._inverted;
    }
  }, {
    key: "invert",
    value: function invert() {
      throw new Error('Operation.invert() is not implemented');
    }
  }, {
    key: "isDummy",
    value: function isDummy(_restruct) {
      return false;
    }
  }], [{
    key: "invalidateAtom",
    value: function invalidateAtom(restruct, atomId, level) {
      var atom = restruct.atoms.get(atomId);
      if (!atom) {
        return;
      }
      restruct.markAtom(atomId, level ? 1 : 0);
      var halfBonds = restruct.molecule.halfBonds;
      atom.a.neighbors.forEach(function (halfBondId) {
        if (!halfBonds.has(halfBondId)) {
          return;
        }
        var halfBond = halfBonds.get(halfBondId);
        if (!halfBond) {
          return;
        }
        restruct.markBond(halfBond.bid, 1);
        restruct.markAtom(halfBond.end, 0);
        if (level) {
          BaseOperation.invalidateLoop(restruct, halfBond.bid);
        }
      });
      var fragment = atom.a.fragment;
      var stereoLabelStyle = restruct.render.options.stereoLabelStyle;
      restruct.atoms.forEach(function (atom, atomId) {
        if (stereoLabelStyle === exports.StereLabelStyleType.IUPAC || stereoLabelStyle === exports.StereLabelStyleType.Classic) {
          if (atom.a.fragment === fragment) restruct.markAtom(atomId, 0);
        }
      });
    }
  }, {
    key: "invalidateLoop",
    value: function invalidateLoop(restruct, bondId) {
      var bond = restruct.bonds.get(bondId);
      if (!bond || !bond.b.hb1 || !bond.b.hb2) {
        return;
      }
      var halfBond1 = restruct.molecule.halfBonds.get(bond.b.hb1);
      var halfBond2 = restruct.molecule.halfBonds.get(bond.b.hb2);
      if (halfBond1 && halfBond1.loop >= 0) {
        restruct.loopRemove(halfBond1.loop);
      }
      if (halfBond2 && halfBond2.loop >= 0) {
        restruct.loopRemove(halfBond2.loop);
      }
    }
  }, {
    key: "invalidateBond",
    value: function invalidateBond(restruct, bondId) {
      BaseOperation.invalidateLoop(restruct, bondId);
      var bond = restruct.bonds.get(bondId);
      if (!bond) {
        return;
      }
      BaseOperation.invalidateAtom(restruct, bond.b.begin, 0);
      BaseOperation.invalidateAtom(restruct, bond.b.end, 0);
    }
  }, {
    key: "invalidateItem",
    value: function invalidateItem(restruct, map, id, level) {
      if (map === 'atoms') {
        BaseOperation.invalidateAtom(restruct, id, level);
        return;
      }
      if (map === 'bonds') {
        BaseOperation.invalidateBond(restruct, id);
        if (level > 0) {
          BaseOperation.invalidateLoop(restruct, id);
        }
        return;
      }
      restruct.markItem(map, id, level);
    }
  }, {
    key: "invalidateEnhancedFlag",
    value: function invalidateEnhancedFlag(restruct, fragmentId) {
      BaseOperation.invalidateItem(restruct, 'enhancedFlags', fragmentId, 1);
    }
  }]);
  return BaseOperation;
}();

var OperationType = Object.freeze({
  ATOM_ADD: 'Add atom',
  ATOM_DELETE: 'Delete atom',
  ATOM_ATTR: 'Set atom attribute',
  ATOM_MOVE: 'Move atom',
  CALC_IMPLICIT_H: 'Calculate implicit hydrogen',
  BOND_ADD: 'Add bond',
  BOND_DELETE: 'Delete bond',
  BOND_ATTR: 'Set bond attribute',
  BOND_MOVE: 'Move bond',
  LOOP_MOVE: 'Move loop',
  S_GROUP_ATTACHMENT_POINT_ADD: 'Add attachment point to s-group',
  S_GROUP_ATTACHMENT_POINT_REMOVE: 'Remove attachment point from s-group',
  S_GROUP_ATOM_ADD: 'Add atom to s-group',
  S_GROUP_ATOM_REMOVE: 'Remove atom from s-group',
  S_GROUP_ATTR: 'Set s-group attribute',
  S_GROUP_CREATE: 'Create s-group',
  S_GROUP_DELETE: 'Delete s-group',
  S_GROUP_ADD_TO_HIERACHY: 'Add s-group to hierarchy',
  S_GROUP_REMOVE_FROM_HIERACHY: 'Delete s-group from hierarchy',
  R_GROUP_ATTR: 'Set r-group attribute',
  R_GROUP_FRAGMENT: 'R-group fragment',
  R_GROUP_ATTACHMENT_POINT_ADD: 'Add R-group attachment point',
  R_GROUP_ATTACHMENT_POINT_REMOVE: 'Remove R-group attachment point',
  UPDATE_IF_THEN: 'Update',
  RESTORE_IF_THEN: 'Restore',
  RXN_ARROW_ADD: 'Add rxn arrow',
  RXN_ARROW_DELETE: 'Delete rxn arrow',
  RXN_ARROW_MOVE: 'Move rxn arrow',
  RXN_ARROW_ROTATE: 'Rotate rxn arrow',
  RXN_ARROW_RESIZE: 'Resize rxn arrow',
  RXN_PLUS_ADD: 'Add rxn plus',
  RXN_PLUS_DELETE: 'Delete rxn plus',
  RXN_PLUS_MOVE: 'Move rxn plus',
  S_GROUP_DATA_MOVE: 'Move s-group data',
  CANVAS_LOAD: 'Load canvas',
  ALIGN_DESCRIPTORS: 'Align descriptors',
  SIMPLE_OBJECT_ADD: 'Add simple object',
  SIMPLE_OBJECT_DELETE: 'Delete simple object',
  SIMPLE_OBJECT_MOVE: 'Move simple object',
  SIMPLE_OBJECT_RESIZE: 'Resize simple object',
  RESTORE_DESCRIPTORS_POSITION: 'Restore descriptors position',
  FRAGMENT_ADD: 'Add fragment',
  FRAGMENT_DELETE: 'Delete fragment',
  FRAGMENT_SET_PROPERTIES: 'Set fragment properties',
  FRAGMENT_STEREO_FLAG: 'Add fragment stereo flag',
  FRAGMENT_ADD_STEREO_ATOM: 'Add stereo atom to fragment',
  FRAGMENT_DELETE_STEREO_ATOM: 'Delete stereo atom from fragment',
  ENHANCED_FLAG_MOVE: 'Move enhanced flag',
  TEXT_CREATE: 'Add text',
  TEXT_UPDATE: 'Edit text',
  TEXT_DELETE: 'Delete text',
  TEXT_MOVE: 'Move text',
  ADD_HIGHLIGHT: 'Highlight',
  UPDATE_HIGHLIGHT: 'Update highlight',
  REMOVE_HIGHLIGHT: 'Remove highlight',
  POLYMER_BOND_ADD: 'Add polymer bond',
  POLYMER_BOND_DELETE: 'Remove polymer bond',
  POLYMER_BOND_MOVE: 'Move polymer bond',
  POLYMER_BOND_FINISH_CREATION: 'Finish polymer bond creation',
  POLYMER_BOND_CANCEL_CREATION: 'Cancel polymer bond creation',
  PEPTIDE_ADD: 'Add peptide',
  PEPTIDE_REMOVE: 'Remove peptide',
  PEPTIDE_MOVE: 'Move peptide',
  PEPTIDE_HOVER: 'Hover peptide',
  DRAWING_ENTITY_SELECT: 'Select drawing entity',
  DRAWING_ENTITY_HOVER: 'Hover drawing entity',
  SHOW_POLYMER_BOND_INFORMATION: 'Show polymer bond information'
});
exports.OperationPriority = void 0;
(function (OperationPriority) {
  OperationPriority[OperationPriority["ATOM_ATTR"] = 1] = "ATOM_ATTR";
  OperationPriority[OperationPriority["BOND_ADD"] = 1] = "BOND_ADD";
  OperationPriority[OperationPriority["R_GROUP_ATTACHMENT_POINT_REMOVE"] = 1] = "R_GROUP_ATTACHMENT_POINT_REMOVE";
  OperationPriority[OperationPriority["ATOM_MOVE"] = 2] = "ATOM_MOVE";
  OperationPriority[OperationPriority["BOND_ATTR"] = 2] = "BOND_ATTR";
  OperationPriority[OperationPriority["BOND_MOVE"] = 2] = "BOND_MOVE";
  OperationPriority[OperationPriority["BOND_DELETE"] = 3] = "BOND_DELETE";
  OperationPriority[OperationPriority["S_GROUP_ATOM_ADD"] = 3] = "S_GROUP_ATOM_ADD";
  OperationPriority[OperationPriority["S_GROUP_ATTACHMENT_POINT_ADD"] = 3] = "S_GROUP_ATTACHMENT_POINT_ADD";
  OperationPriority[OperationPriority["R_GROUP_ATTACHMENT_POINT_ADD"] = 3] = "R_GROUP_ATTACHMENT_POINT_ADD";
  OperationPriority[OperationPriority["S_GROUP_ATTR"] = 4] = "S_GROUP_ATTR";
  OperationPriority[OperationPriority["ATOM_DELETE"] = 5] = "ATOM_DELETE";
  OperationPriority[OperationPriority["FRAGMENT_STEREO_FLAG"] = 6] = "FRAGMENT_STEREO_FLAG";
  OperationPriority[OperationPriority["CALC_IMPLICIT_H"] = 10] = "CALC_IMPLICIT_H";
  OperationPriority[OperationPriority["FRAGMENT_DELETE_STEREO_ATOM"] = 90] = "FRAGMENT_DELETE_STEREO_ATOM";
  OperationPriority[OperationPriority["S_GROUP_DELETE"] = 95] = "S_GROUP_DELETE";
  OperationPriority[OperationPriority["S_GROUP_ADD_TO_HIERACHY"] = 100] = "S_GROUP_ADD_TO_HIERACHY";
  OperationPriority[OperationPriority["FRAGMENT_ADD_STEREO_ATOM"] = 100] = "FRAGMENT_ADD_STEREO_ATOM";
})(exports.OperationPriority || (exports.OperationPriority = {}));

function _callSuper$z(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$z() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$z() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$z = function _isNativeReflectConstruct() { return !!t; })(); }
var AtomAttr = function (_BaseOperation) {
  _inherits__default["default"](AtomAttr, _BaseOperation);
  function AtomAttr(atomId, attribute, value) {
    var _this;
    _classCallCheck__default["default"](this, AtomAttr);
    _this = _callSuper$z(this, AtomAttr, [OperationType.ATOM_ATTR, exports.OperationPriority.ATOM_ATTR]);
    _this.data = {
      aid: atomId,
      attribute: attribute,
      value: value
    };
    _this.data2 = null;
    return _this;
  }
  _createClass__default["default"](AtomAttr, [{
    key: "execute",
    value: function execute(restruct) {
      if (this.data) {
        var _this$data = this.data,
          aid = _this$data.aid,
          attribute = _this$data.attribute,
          value = _this$data.value;
        var atom = restruct.molecule.atoms.get(aid);
        if (!this.data2) {
          this.data2 = {
            aid: aid,
            attribute: attribute,
            value: atom[attribute]
          };
        }
        atom[attribute] = value;
        BaseOperation.invalidateAtom(restruct, aid);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new AtomAttr();
      inverted.data = this.data2;
      inverted.data2 = this.data;
      return inverted;
    }
  }, {
    key: "isDummy",
    value: function isDummy(restruct) {
      var _this$data2, _this$data3, _this$data4;
      return restruct.molecule.atoms.get((_this$data2 = this.data) === null || _this$data2 === void 0 ? void 0 : _this$data2.aid)[(_this$data3 = this.data) === null || _this$data3 === void 0 ? void 0 : _this$data3.attribute] === ((_this$data4 = this.data) === null || _this$data4 === void 0 ? void 0 : _this$data4.value);
    }
  }]);
  return AtomAttr;
}(BaseOperation);

function _callSuper$y(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$y() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$y() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$y = function _isNativeReflectConstruct() { return !!t; })(); }
var AtomMove = function (_BaseOperation) {
  _inherits__default["default"](AtomMove, _BaseOperation);
  function AtomMove(atomId, d, noinvalidate) {
    var _this;
    _classCallCheck__default["default"](this, AtomMove);
    _this = _callSuper$y(this, AtomMove, [OperationType.ATOM_MOVE, exports.OperationPriority.ATOM_MOVE]);
    _this.data = {
      aid: atomId,
      d: d,
      noinvalidate: noinvalidate
    };
    return _this;
  }
  _createClass__default["default"](AtomMove, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var _this$data = this.data,
        aid = _this$data.aid,
        d = _this$data.d;
      var atom = struct.atoms.get(aid);
      if (!atom) return;
      atom.pp.add_(d);
      var reatom = restruct.atoms.get(aid);
      if (reatom) {
        var scaled = Scale.modelToCanvas(d, restruct.render.options);
        reatom.visel.translate(scaled);
      }
      this.data.d = d.negated();
      if (!this.data.noinvalidate) {
        BaseOperation.invalidateAtom(restruct, aid, 1);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new AtomMove();
      inverted.data = this.data;
      return inverted;
    }
  }, {
    key: "isDummy",
    value: function isDummy() {
      var d = this.data.d;
      return d.x === 0 && d.y === 0;
    }
  }]);
  return AtomMove;
}(BaseOperation);

function _callSuper$x(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$x() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$x() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$x = function _isNativeReflectConstruct() { return !!t; })(); }
var AtomAdd = function (_BaseOperation) {
  _inherits__default["default"](AtomAdd, _BaseOperation);
  function AtomAdd(atom, pos) {
    var _this;
    _classCallCheck__default["default"](this, AtomAdd);
    _this = _callSuper$x(this, AtomAdd, [OperationType.ATOM_ADD]);
    _this.data = {
      atom: atom,
      pos: pos,
      aid: null
    };
    return _this;
  }
  _createClass__default["default"](AtomAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        atom = _this$data.atom,
        pos = _this$data.pos;
      var struct = restruct.molecule;
      var pp = {
        label: ''
      };
      if (atom) {
        Object.keys(atom).forEach(function (p) {
          pp[p] = atom[p];
        });
      }
      pp.label = pp.label || 'C';
      if (typeof this.data.aid !== 'number') {
        this.data.aid = struct.atoms.add(new Atom(pp));
      } else {
        struct.atoms.set(this.data.aid, new Atom(pp));
      }
      var aid = this.data.aid;
      var atomData = new ReAtom(struct.atoms.get(aid));
      atomData.component = restruct.connectedComponents.add(new Pile([aid]));
      restruct.atoms.set(aid, atomData);
      restruct.markAtom(aid, 1);
      struct.atomSetPos(aid, new Vec2(pos));
      var arrow = struct.rxnArrows.get(0);
      if (arrow) {
        var _atom = struct.atoms.get(aid);
        _atom.rxnFragmentType = struct.defineRxnFragmentTypeForAtomset(new Pile([aid]), arrow.pos[0].x);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new AtomDelete();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return AtomAdd;
}(BaseOperation);
var AtomDelete = function (_BaseOperation2) {
  _inherits__default["default"](AtomDelete, _BaseOperation2);
  function AtomDelete(atomId) {
    var _this2;
    _classCallCheck__default["default"](this, AtomDelete);
    _this2 = _callSuper$x(this, AtomDelete, [OperationType.ATOM_DELETE, exports.OperationPriority.ATOM_DELETE]);
    _this2.data = {
      aid: atomId,
      atom: null,
      pos: null
    };
    return _this2;
  }
  _createClass__default["default"](AtomDelete, [{
    key: "execute",
    value: function execute(restruct) {
      var aid = this.data.aid;
      var struct = restruct.molecule;
      if (!this.data.atom) {
        this.data.atom = struct.atoms.get(aid);
        this.data.pos = this.data.atom.pp;
      }
      var restructedAtom = restruct.atoms.get(aid);
      if (!restructedAtom) {
        return;
      }
      var set = restruct.connectedComponents.get(restructedAtom.component);
      set["delete"](aid);
      if (set.size === 0) {
        restruct.connectedComponents["delete"](restructedAtom.component);
      }
      restruct.clearVisel(restructedAtom.visel);
      restruct.atoms["delete"](aid);
      restruct.markItemRemoved();
      struct.atoms["delete"](aid);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new AtomAdd();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return AtomDelete;
}(BaseOperation);

function _callSuper$w(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$w() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$w() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$w = function _isNativeReflectConstruct() { return !!t; })(); }
var BondAttr = function (_BaseOperation) {
  _inherits__default["default"](BondAttr, _BaseOperation);
  function BondAttr(bondId, attribute, value) {
    var _this;
    var needInvalidateBond = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    _classCallCheck__default["default"](this, BondAttr);
    _this = _callSuper$w(this, BondAttr, [OperationType.BOND_ATTR, exports.OperationPriority.BOND_ATTR]);
    _this.data = {
      bid: bondId,
      attribute: attribute,
      value: value,
      needInvalidateBond: needInvalidateBond
    };
    _this.data2 = null;
    return _this;
  }
  _createClass__default["default"](BondAttr, [{
    key: "execute",
    value: function execute(restruct) {
      if (this.data) {
        var _this$data = this.data,
          attribute = _this$data.attribute,
          bid = _this$data.bid,
          value = _this$data.value;
        var bond = restruct.molecule.bonds.get(bid);
        if (!this.data2) {
          this.data2 = {
            bid: bid,
            attribute: attribute,
            value: bond[attribute]
          };
        }
        bond[attribute] = value;
        if (this.data.needInvalidateBond) {
          BaseOperation.invalidateBond(restruct, bid);
        }
        if (attribute === 'type') {
          BaseOperation.invalidateLoop(restruct, bid);
        }
      }
    }
  }, {
    key: "isDummy",
    value: function isDummy(restruct) {
      if (this.data) {
        var _this$data2 = this.data,
          attribute = _this$data2.attribute,
          bid = _this$data2.bid,
          value = _this$data2.value;
        var bond = restruct.molecule.bonds.get(bid);
        return bond[attribute] === value;
      }
      return false;
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new BondAttr();
      inverted.data = this.data2;
      inverted.data2 = this.data;
      return inverted;
    }
  }]);
  return BondAttr;
}(BaseOperation);

function _callSuper$v(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$v() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$v() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$v = function _isNativeReflectConstruct() { return !!t; })(); }
var BondMove = function (_BaseOperation) {
  _inherits__default["default"](BondMove, _BaseOperation);
  function BondMove(bondId, d) {
    var _this;
    _classCallCheck__default["default"](this, BondMove);
    _this = _callSuper$v(this, BondMove, [OperationType.BOND_MOVE, exports.OperationPriority.BOND_MOVE]);
    _this.data = {
      bid: bondId,
      d: d
    };
    return _this;
  }
  _createClass__default["default"](BondMove, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        bid = _this$data.bid,
        d = _this$data.d;
      var bond = restruct.bonds.get(bid);
      if (!bond) return;
      var scaled = Scale.modelToCanvas(d, restruct.render.options);
      bond.visel.translate(scaled);
      this.data.d = d.negated();
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new BondMove();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return BondMove;
}(BaseOperation);

function _callSuper$u(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$u() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$u() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$u = function _isNativeReflectConstruct() { return !!t; })(); }
var BondAdd = function (_BaseOperation) {
  _inherits__default["default"](BondAdd, _BaseOperation);
  function BondAdd(begin, end, bond) {
    var _this;
    var needInvalidateAtoms = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    _classCallCheck__default["default"](this, BondAdd);
    _this = _callSuper$u(this, BondAdd, [OperationType.BOND_ADD, exports.OperationPriority.BOND_ADD]);
    _this.data = {
      bond: bond,
      begin: begin,
      end: end,
      bid: null,
      needInvalidateAtoms: needInvalidateAtoms
    };
    return _this;
  }
  _createClass__default["default"](BondAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        begin = _this$data.begin,
        bond = _this$data.bond,
        end = _this$data.end;
      var struct = restruct.molecule;
      if (begin === end) {
        throw new Error('Distinct atoms expected');
      }
      if (this.data.needInvalidateAtoms) {
        BaseOperation.invalidateAtom(restruct, begin, 1);
        BaseOperation.invalidateAtom(restruct, end, 1);
      }
      var pp = {
        type: 0,
        begin: 0,
        end: 0
      };
      if (bond) {
        Object.keys(bond).forEach(function (p) {
          pp[p] = bond[p];
        });
      }
      pp.type = pp.type || Bond.PATTERN.TYPE.SINGLE;
      pp.begin = begin;
      pp.end = end;
      var newBond = new Bond(pp);
      if (typeof this.data.bid === 'number') {
        struct.bonds.set(this.data.bid, newBond);
      } else {
        this.data.bid = struct.bonds.add(newBond);
      }
      var bid = this.data.bid;
      var structBond = struct.bonds.get(bid);
      struct.bondInitHalfBonds(bid);
      struct.atomAddNeighbor(structBond.hb1);
      struct.atomAddNeighbor(structBond.hb2);
      restruct.bonds.set(bid, new ReBond(structBond));
      restruct.markBond(bid, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new BondDelete();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return BondAdd;
}(BaseOperation);
var BondDelete = function (_BaseOperation2) {
  _inherits__default["default"](BondDelete, _BaseOperation2);
  function BondDelete(bondId) {
    var _this2;
    _classCallCheck__default["default"](this, BondDelete);
    _this2 = _callSuper$u(this, BondDelete, [OperationType.BOND_DELETE, exports.OperationPriority.BOND_DELETE]);
    _this2.data = {
      bid: bondId,
      bond: null,
      begin: null,
      end: null
    };
    return _this2;
  }
  _createClass__default["default"](BondDelete, [{
    key: "execute",
    value: function execute(restruct) {
      var bid = this.data.bid;
      var struct = restruct.molecule;
      if (!this.data.bond) {
        this.data.bond = struct.bonds.get(bid);
        this.data.begin = this.data.bond.begin;
        this.data.end = this.data.bond.end;
      }
      BaseOperation.invalidateBond(restruct, bid);
      var rebond = restruct.bonds.get(bid);
      if (!rebond) return;
      [rebond.b.hb1, rebond.b.hb2].forEach(function (hbid) {
        if (hbid === undefined) return;
        var halfBond = restruct.molecule.halfBonds.get(hbid);
        if (halfBond && halfBond.loop >= 0) {
          restruct.loopRemove(halfBond.loop);
        }
      }, restruct);
      restruct.clearVisel(rebond.visel);
      restruct.bonds["delete"](bid);
      restruct.markItemRemoved();
      var structBond = struct.bonds.get(bid);
      [structBond.hb1, structBond.hb2].forEach(function (hbid) {
        var halfBond = struct.halfBonds.get(hbid);
        if (!halfBond) {
          return;
        }
        var atom = struct.atoms.get(halfBond.begin);
        var pos = atom.neighbors.indexOf(hbid);
        var prev = (pos + atom.neighbors.length - 1) % atom.neighbors.length;
        var next = (pos + 1) % atom.neighbors.length;
        struct.setHbNext(atom.neighbors[prev], atom.neighbors[next]);
        atom.neighbors.splice(pos, 1);
      });
      struct.halfBonds["delete"](structBond.hb1);
      struct.halfBonds["delete"](structBond.hb2);
      struct.bonds["delete"](bid);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new BondAdd();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return BondDelete;
}(BaseOperation);

function _callSuper$t(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$t() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$t() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$t = function _isNativeReflectConstruct() { return !!t; })(); }
var CanvasLoad = function (_BaseOperation) {
  _inherits__default["default"](CanvasLoad, _BaseOperation);
  function CanvasLoad(struct) {
    var _this;
    _classCallCheck__default["default"](this, CanvasLoad);
    _this = _callSuper$t(this, CanvasLoad, [OperationType.CANVAS_LOAD]);
    _this.data = {
      struct: struct
    };
    return _this;
  }
  _createClass__default["default"](CanvasLoad, [{
    key: "execute",
    value: function execute(restruct) {
      var oldStruct = restruct.molecule;
      restruct.clearVisels();
      if (this.data.struct) {
        restruct.render.setMolecule(this.data.struct, true);
      }
      this.data.struct = oldStruct;
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new CanvasLoad();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return CanvasLoad;
}(BaseOperation);

function _callSuper$s(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$s() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$s() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$s = function _isNativeReflectConstruct() { return !!t; })(); }
var AlignDescriptors = function (_BaseOperation) {
  _inherits__default["default"](AlignDescriptors, _BaseOperation);
  function AlignDescriptors() {
    var _this;
    _classCallCheck__default["default"](this, AlignDescriptors);
    _this = _callSuper$s(this, AlignDescriptors, [OperationType.ALIGN_DESCRIPTORS]);
    _this.history = {};
    return _this;
  }
  _createClass__default["default"](AlignDescriptors, [{
    key: "execute",
    value: function execute(restruct) {
      var _this2 = this;
      var struct = restruct.molecule;
      var sgroups = Array.from(struct.sgroups.values()).reverse();
      var structBox = struct.getCoordBoundingBoxObj();
      var alignPoint = new Vec2(structBox.max.x, structBox.min.y).add(new Vec2(2.0, -1.0));
      sgroups.forEach(function (sgroup) {
        _this2.history[sgroup.id] = new Vec2(sgroup.pp);
        alignPoint = alignPoint.add(new Vec2(0.0, 0.5));
        sgroup.pp = alignPoint;
        struct.sgroups.set(sgroup.id, sgroup);
        BaseOperation.invalidateItem(restruct, 'sgroupData', sgroup.id, 1);
      });
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RestoreDescriptorsPosition(this.history);
    }
  }]);
  return AlignDescriptors;
}(BaseOperation);
var RestoreDescriptorsPosition = function (_BaseOperation2) {
  _inherits__default["default"](RestoreDescriptorsPosition, _BaseOperation2);
  function RestoreDescriptorsPosition(history) {
    var _this3;
    _classCallCheck__default["default"](this, RestoreDescriptorsPosition);
    _this3 = _callSuper$s(this, RestoreDescriptorsPosition, [OperationType.RESTORE_DESCRIPTORS_POSITION]);
    _this3.history = history;
    return _this3;
  }
  _createClass__default["default"](RestoreDescriptorsPosition, [{
    key: "execute",
    value: function execute(restruct) {
      var _this4 = this;
      var struct = restruct.molecule;
      var sgroups = Array.from(struct.sgroups.values());
      sgroups.forEach(function (sgroup) {
        sgroup.pp = _this4.history[sgroup.id];
        struct.sgroups.set(sgroup.id, sgroup);
        BaseOperation.invalidateItem(restruct, 'sgroupData', sgroup.id, 1);
      });
    }
  }, {
    key: "invert",
    value: function invert() {
      return new AlignDescriptors();
    }
  }]);
  return RestoreDescriptorsPosition;
}(BaseOperation);

function _callSuper$r(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$r() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$r() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$r = function _isNativeReflectConstruct() { return !!t; })(); }
var EnhancedFlagMove = function (_BaseOperation) {
  _inherits__default["default"](EnhancedFlagMove, _BaseOperation);
  function EnhancedFlagMove(fragmentId, p) {
    var _this;
    _classCallCheck__default["default"](this, EnhancedFlagMove);
    _this = _callSuper$r(this, EnhancedFlagMove, [OperationType.ENHANCED_FLAG_MOVE]);
    _this.data = {
      frid: fragmentId,
      p: p
    };
    return _this;
  }
  _createClass__default["default"](EnhancedFlagMove, [{
    key: "execute",
    value: function execute(restruct) {
      var frid = this.data.frid;
      var p = this.data.p;
      var fragment = restruct.molecule.frags.get(frid);
      if (!fragment) return;
      var currentPosition = fragment.stereoFlagPosition ? new Vec2(fragment.stereoFlagPosition.x, fragment.stereoFlagPosition.y) : Fragment.getDefaultStereoFlagPosition(restruct.molecule, frid);
      var newPosition = Vec2.sum(currentPosition, p);
      fragment.stereoFlagPosition = newPosition;
      this.data.p = p.negated();
      BaseOperation.invalidateItem(restruct, 'enhancedFlags', frid, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new EnhancedFlagMove();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return EnhancedFlagMove;
}(BaseOperation);

function _callSuper$q(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$q() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$q() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$q = function _isNativeReflectConstruct() { return !!t; })(); }
var UpdateIfThen = function (_BaseOperation) {
  _inherits__default["default"](UpdateIfThen, _BaseOperation);
  function UpdateIfThen(rgNew, rgOld) {
    var _this;
    var skipRgids = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    _classCallCheck__default["default"](this, UpdateIfThen);
    _this = _callSuper$q(this, UpdateIfThen, [OperationType.UPDATE_IF_THEN]);
    _this.rgid_new = rgNew;
    _this.rgid_old = rgOld;
    _this.ifThenHistory = new Map();
    _this.skipRgids = skipRgids || [];
    return _this;
  }
  _createClass__default["default"](UpdateIfThen, [{
    key: "execute",
    value: function execute(restruct) {
      var _this2 = this;
      var struct = restruct.molecule;
      struct.rgroups.forEach(function (rg, rgid) {
        if (rg.ifthen === _this2.rgid_old && !_this2.skipRgids.includes(rgid)) {
          rg.ifthen = _this2.rgid_new;
          _this2.ifThenHistory.set(rgid, _this2.rgid_old);
          struct.rgroups.set(rgid, rg);
        }
      });
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RestoreIfThen(this.rgid_new, this.rgid_old, this.ifThenHistory);
    }
  }]);
  return UpdateIfThen;
}(BaseOperation);
var RestoreIfThen = function (_BaseOperation2) {
  _inherits__default["default"](RestoreIfThen, _BaseOperation2);
  function RestoreIfThen(rgNew, rgOld, history) {
    var _this3;
    _classCallCheck__default["default"](this, RestoreIfThen);
    _this3 = _callSuper$q(this, RestoreIfThen, [OperationType.RESTORE_IF_THEN]);
    _this3.rgid_new = rgNew;
    _this3.rgid_old = rgOld;
    _this3.ifThenHistory = history || new Map();
    return _this3;
  }
  _createClass__default["default"](RestoreIfThen, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      this.ifThenHistory.forEach(function (rg, rgid) {
        var rgValue = struct.rgroups.get(rgid);
        rgValue.ifthen = rg;
        struct.rgroups.set(rgid, rgValue);
      });
    }
  }, {
    key: "invert",
    value: function invert() {
      return new UpdateIfThen(this.rgid_old, this.rgid_new);
    }
  }]);
  return RestoreIfThen;
}(BaseOperation);

function _callSuper$p(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$p() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$p() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$p = function _isNativeReflectConstruct() { return !!t; })(); }
var FragmentAdd = function (_BaseOperation) {
  _inherits__default["default"](FragmentAdd, _BaseOperation);
  function FragmentAdd(fragmentId, properties) {
    var _this;
    _classCallCheck__default["default"](this, FragmentAdd);
    _this = _callSuper$p(this, FragmentAdd, [OperationType.FRAGMENT_ADD]);
    _this.frid = typeof fragmentId === 'undefined' ? null : fragmentId;
    if (properties) {
      _this.properties = properties;
    }
    return _this;
  }
  _createClass__default["default"](FragmentAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var frag = new Fragment([], null, this.properties);
      if (this.frid === null) {
        this.frid = struct.frags.add(frag);
      } else {
        struct.frags.set(this.frid, frag);
      }
      restruct.frags.set(this.frid, new ReFrag(frag));
      restruct.enhancedFlags.set(this.frid, new ReEnhancedFlag());
    }
  }, {
    key: "invert",
    value: function invert() {
      return new FragmentDelete(this.frid);
    }
  }]);
  return FragmentAdd;
}(BaseOperation);
var FragmentSetProperties = function (_BaseOperation2) {
  _inherits__default["default"](FragmentSetProperties, _BaseOperation2);
  function FragmentSetProperties(fragmentId, properties) {
    var _this2;
    _classCallCheck__default["default"](this, FragmentSetProperties);
    _this2 = _callSuper$p(this, FragmentSetProperties, [OperationType.FRAGMENT_SET_PROPERTIES]);
    _this2.frid = fragmentId;
    _this2.properties = properties;
    return _this2;
  }
  _createClass__default["default"](FragmentSetProperties, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var frag = struct.frags.get(this.frid);
      if (frag) {
        if (this.properties) {
          frag.properties = this.properties;
        } else {
          frag === null || frag === void 0 || delete frag.properties;
        }
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      return new FragmentSetProperties(this.frid, undefined);
    }
  }]);
  return FragmentSetProperties;
}(BaseOperation);
var FragmentDelete = function (_BaseOperation3) {
  _inherits__default["default"](FragmentDelete, _BaseOperation3);
  function FragmentDelete(fragmentId) {
    var _this3;
    _classCallCheck__default["default"](this, FragmentDelete);
    _this3 = _callSuper$p(this, FragmentDelete, [OperationType.FRAGMENT_DELETE, 100]);
    _this3.frid = fragmentId;
    return _this3;
  }
  _createClass__default["default"](FragmentDelete, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      if (!struct.frags.get(this.frid)) {
        return;
      }
      BaseOperation.invalidateItem(restruct, 'frags', this.frid, 1);
      restruct.frags["delete"](this.frid);
      struct.frags["delete"](this.frid);
      var enhancedFalg = restruct.enhancedFlags.get(this.frid);
      if (!enhancedFalg) return;
      restruct.clearVisel(enhancedFalg.visel);
      restruct.enhancedFlags["delete"](this.frid);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new FragmentAdd(this.frid);
    }
  }]);
  return FragmentDelete;
}(BaseOperation);

function _callSuper$o(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$o() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$o() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$o = function _isNativeReflectConstruct() { return !!t; })(); }
var FragmentAddStereoAtom = function (_BaseOperation) {
  _inherits__default["default"](FragmentAddStereoAtom, _BaseOperation);
  function FragmentAddStereoAtom(fragmentId, atomId) {
    var _this;
    _classCallCheck__default["default"](this, FragmentAddStereoAtom);
    _this = _callSuper$o(this, FragmentAddStereoAtom, [OperationType.FRAGMENT_ADD_STEREO_ATOM, exports.OperationPriority.FRAGMENT_ADD_STEREO_ATOM]);
    _this.data = {
      frid: fragmentId,
      aid: atomId
    };
    return _this;
  }
  _createClass__default["default"](FragmentAddStereoAtom, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        aid = _this$data.aid,
        frid = _this$data.frid;
      var frag = restruct.molecule.frags.get(frid);
      if (frag) {
        frag.updateStereoAtom(restruct.molecule, aid, frid, true);
        BaseOperation.invalidateEnhancedFlag(restruct, frid);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      return new FragmentDeleteStereoAtom(this.data.frid, this.data.aid);
    }
  }]);
  return FragmentAddStereoAtom;
}(BaseOperation);
var FragmentDeleteStereoAtom = function (_BaseOperation2) {
  _inherits__default["default"](FragmentDeleteStereoAtom, _BaseOperation2);
  function FragmentDeleteStereoAtom(fragmentId, atomId) {
    var _this2;
    _classCallCheck__default["default"](this, FragmentDeleteStereoAtom);
    _this2 = _callSuper$o(this, FragmentDeleteStereoAtom, [OperationType.FRAGMENT_DELETE_STEREO_ATOM, exports.OperationPriority.FRAGMENT_DELETE_STEREO_ATOM]);
    _this2.data = {
      frid: fragmentId,
      aid: atomId
    };
    return _this2;
  }
  _createClass__default["default"](FragmentDeleteStereoAtom, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data2 = this.data,
        aid = _this$data2.aid,
        frid = _this$data2.frid;
      var frag = restruct.molecule.frags.get(frid);
      if (frag) {
        frag.updateStereoAtom(restruct.molecule, aid, frid, false);
        BaseOperation.invalidateEnhancedFlag(restruct, frid);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var _this$data3 = this.data,
        aid = _this$data3.aid,
        frid = _this$data3.frid;
      return new FragmentAddStereoAtom(frid, aid);
    }
  }]);
  return FragmentDeleteStereoAtom;
}(BaseOperation);

function _callSuper$n(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$n() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$n() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$n = function _isNativeReflectConstruct() { return !!t; })(); }
var FragmentStereoFlag = function (_BaseOperation) {
  _inherits__default["default"](FragmentStereoFlag, _BaseOperation);
  function FragmentStereoFlag(fragmentId) {
    var _this;
    _classCallCheck__default["default"](this, FragmentStereoFlag);
    _this = _callSuper$n(this, FragmentStereoFlag, [OperationType.FRAGMENT_STEREO_FLAG, exports.OperationPriority.FRAGMENT_STEREO_FLAG]);
    _this.frid = fragmentId;
    return _this;
  }
  _createClass__default["default"](FragmentStereoFlag, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var fragment = struct.frags.get(this.frid);
      fragment.updateStereoFlag(struct);
      BaseOperation.invalidateEnhancedFlag(restruct, this.frid);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new FragmentStereoFlag(this.frid);
      return inverted;
    }
  }]);
  return FragmentStereoFlag;
}(BaseOperation);

function _callSuper$m(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$m() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$m() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$m = function _isNativeReflectConstruct() { return !!t; })(); }
var CalcImplicitH = function (_BaseOperation) {
  _inherits__default["default"](CalcImplicitH, _BaseOperation);
  function CalcImplicitH(aids) {
    var _this;
    _classCallCheck__default["default"](this, CalcImplicitH);
    _this = _callSuper$m(this, CalcImplicitH, [OperationType.CALC_IMPLICIT_H, exports.OperationPriority.CALC_IMPLICIT_H]);
    _this.atomIds = aids;
    return _this;
  }
  _createClass__default["default"](CalcImplicitH, [{
    key: "execute",
    value: function execute(restruct) {
      var aIds = this.atomIds;
      restruct.molecule.setImplicitHydrogen(aIds);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new CalcImplicitH(this.atomIds);
    }
  }]);
  return CalcImplicitH;
}(BaseOperation);

function _callSuper$l(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$l() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$l() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$l = function _isNativeReflectConstruct() { return !!t; })(); }
var LoopMove = function (_BaseOperation) {
  _inherits__default["default"](LoopMove, _BaseOperation);
  function LoopMove(id, d) {
    var _this;
    _classCallCheck__default["default"](this, LoopMove);
    _this = _callSuper$l(this, LoopMove, [OperationType.LOOP_MOVE]);
    _this.data = {
      id: id,
      d: d
    };
    return _this;
  }
  _createClass__default["default"](LoopMove, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        id = _this$data.id,
        d = _this$data.d;
      var reloop = restruct.reloops.get(id);
      if (reloop && reloop.visel) {
        var scaled = Scale.modelToCanvas(d, restruct.render.options);
        reloop.visel.translate(scaled);
      }
      this.data.d = d.negated();
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new LoopMove();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return LoopMove;
}(BaseOperation);

function _callSuper$k(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$k() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$k() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$k = function _isNativeReflectConstruct() { return !!t; })(); }
var RGroupAttr = function (_BaseOperation) {
  _inherits__default["default"](RGroupAttr, _BaseOperation);
  function RGroupAttr(rgroupId, attribute, value) {
    var _this;
    _classCallCheck__default["default"](this, RGroupAttr);
    _this = _callSuper$k(this, RGroupAttr, [OperationType.R_GROUP_ATTR]);
    _this.data = {
      rgid: rgroupId,
      attribute: attribute,
      value: value
    };
    _this.data2 = null;
    return _this;
  }
  _createClass__default["default"](RGroupAttr, [{
    key: "execute",
    value: function execute(restruct) {
      if (this.data) {
        var _this$data = this.data,
          rgid = _this$data.rgid,
          attribute = _this$data.attribute,
          value = _this$data.value;
        var rgp = restruct.molecule.rgroups.get(rgid);
        if (!rgp) {
          return;
        }
        if (!this.data2) {
          this.data2 = {
            rgid: rgid,
            attribute: attribute,
            value: rgp[attribute]
          };
        }
        rgp[attribute] = value;
        BaseOperation.invalidateItem(restruct, 'rgroups', rgid);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new RGroupAttr();
      inverted.data = this.data2;
      inverted.data2 = this.data;
      return inverted;
    }
  }, {
    key: "isDummy",
    value: function isDummy(restruct) {
      if (this.data) {
        var _this$data2 = this.data,
          rgid = _this$data2.rgid,
          attribute = _this$data2.attribute,
          value = _this$data2.value;
        var rgroup = restruct.molecule.rgroups.get(rgid);
        return rgroup[attribute] === value;
      }
      return false;
    }
  }]);
  return RGroupAttr;
}(BaseOperation);

function _callSuper$j(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$j() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$j() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$j = function _isNativeReflectConstruct() { return !!t; })(); }
var RGroupFragment = function (_BaseOperation) {
  _inherits__default["default"](RGroupFragment, _BaseOperation);
  function RGroupFragment(rgroupId, fragmentId, rg) {
    var _this;
    _classCallCheck__default["default"](this, RGroupFragment);
    _this = _callSuper$j(this, RGroupFragment, [OperationType.R_GROUP_FRAGMENT]);
    _this.rgid_new = rgroupId;
    _this.rg_new = rg;
    _this.rgid_old = null;
    _this.rg_old = null;
    _this.frid = fragmentId;
    return _this;
  }
  _createClass__default["default"](RGroupFragment, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      this.rgid_old = this.rgid_old || RGroup.findRGroupByFragment(struct.rgroups, this.frid);
      this.rg_old = this.rgid_old ? struct.rgroups.get(this.rgid_old) : null;
      this.removeOld(struct, restruct);
      this.setNew(struct, restruct);
    }
  }, {
    key: "removeOld",
    value: function removeOld(struct, restruct) {
      if (!this.rg_old) {
        return;
      }
      this.rg_old.frags["delete"](this.frid);
      restruct.clearVisel(restruct.rgroups.get(this.rgid_old).visel);
      if (this.rg_old.frags.size === 0) {
        restruct.rgroups["delete"](this.rgid_old);
        struct.rgroups["delete"](this.rgid_old);
        restruct.markItemRemoved();
      } else {
        restruct.markItem('rgroups', this.rgid_old, 1);
      }
    }
  }, {
    key: "setNew",
    value: function setNew(struct, restruct) {
      if (!this.rgid_new) {
        return;
      }
      var rgNew = struct.rgroups.get(this.rgid_new);
      if (!rgNew) {
        rgNew = this.rg_new || new RGroup();
        struct.rgroups.set(this.rgid_new, rgNew);
        restruct.rgroups.set(this.rgid_new, new ReRGroup(rgNew));
      } else {
        restruct.markItem('rgroups', this.rgid_new, 1);
      }
      rgNew.frags.add(this.frid);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RGroupFragment(this.rgid_old, this.frid, this.rg_old);
    }
  }]);
  return RGroupFragment;
}(BaseOperation);

function _callSuper$i(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$i() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$i() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$i = function _isNativeReflectConstruct() { return !!t; })(); }
var RGroupAttachmentPointAdd = function (_BaseOperation) {
  _inherits__default["default"](RGroupAttachmentPointAdd, _BaseOperation);
  function RGroupAttachmentPointAdd(data) {
    var _this;
    _classCallCheck__default["default"](this, RGroupAttachmentPointAdd);
    _this = _callSuper$i(this, RGroupAttachmentPointAdd, [OperationType.R_GROUP_ATTACHMENT_POINT_ADD, exports.OperationPriority.R_GROUP_ATTACHMENT_POINT_ADD]);
    _this.data = data;
    return _this;
  }
  _createClass__default["default"](RGroupAttachmentPointAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        atomId = _this$data.atomId,
        attachmentPointType = _this$data.attachmentPointType;
      var newAttachmentPoint = new RGroupAttachmentPoint(atomId, attachmentPointType);
      var struct = restruct.molecule;
      var revertedId = this.data.attachmentPointId;
      var attachmentPointId = 0;
      if (revertedId === undefined) {
        var newId = struct.rgroupAttachmentPoints.add(newAttachmentPoint);
        attachmentPointId = newId;
      } else {
        struct.rgroupAttachmentPoints.set(revertedId, newAttachmentPoint);
        attachmentPointId = revertedId;
      }
      this.data.attachmentPointId = attachmentPointId;
      var reAtom = restruct.atoms.get(atomId);
      assert__default["default"](reAtom != null);
      restruct.rgroupAttachmentPoints.set(attachmentPointId, new ReRGroupAttachmentPoint(newAttachmentPoint, reAtom));
    }
  }, {
    key: "invert",
    value: function invert() {
      if (this.data.attachmentPointId === undefined) {
        throw Error("Inverted attachmentPointId doesn't exist");
      }
      return new RGroupAttachmentPointRemove(this.data.attachmentPointId);
    }
  }]);
  return RGroupAttachmentPointAdd;
}(BaseOperation);

function ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _callSuper$h(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$h() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$h() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$h = function _isNativeReflectConstruct() { return !!t; })(); }
var INITIAL_DATA = {
  atomId: 0,
  attachmentPointType: 1,
  attachmentPointId: 0
};
var RGroupAttachmentPointRemove = function (_BaseOperation) {
  _inherits__default["default"](RGroupAttachmentPointRemove, _BaseOperation);
  function RGroupAttachmentPointRemove(attachmentPointId) {
    var _this;
    _classCallCheck__default["default"](this, RGroupAttachmentPointRemove);
    _this = _callSuper$h(this, RGroupAttachmentPointRemove, [OperationType.R_GROUP_ATTACHMENT_POINT_REMOVE, exports.OperationPriority.R_GROUP_ATTACHMENT_POINT_REMOVE]);
    _this.data = _objectSpread$7(_objectSpread$7({}, INITIAL_DATA), {}, {
      attachmentPointId: attachmentPointId
    });
    return _this;
  }
  _createClass__default["default"](RGroupAttachmentPointRemove, [{
    key: "execute",
    value: function execute(restruct) {
      var attachmentPointId = this.data.attachmentPointId;
      var struct = restruct.molecule;
      var item = struct.rgroupAttachmentPoints.get(attachmentPointId);
      var reItem = restruct.rgroupAttachmentPoints.get(attachmentPointId);
      assert__default["default"](item != null && reItem != null);
      this.data.atomId = item.atomId;
      this.data.attachmentPointType = item.type;
      restruct.markItemRemoved();
      restruct.clearVisel(reItem.visel);
      restruct.rgroupAttachmentPoints["delete"](attachmentPointId);
      struct.rgroupAttachmentPoints["delete"](attachmentPointId);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RGroupAttachmentPointAdd(this.data);
    }
  }]);
  return RGroupAttachmentPointRemove;
}(BaseOperation);

function _callSuper$g(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$g() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$g() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$g = function _isNativeReflectConstruct() { return !!t; })(); }
var RxnArrowMove = function (_Base) {
  _inherits__default["default"](RxnArrowMove, _Base);
  function RxnArrowMove(id, d, noinvalidate) {
    var _this;
    _classCallCheck__default["default"](this, RxnArrowMove);
    _this = _callSuper$g(this, RxnArrowMove, [OperationType.RXN_ARROW_MOVE]);
    _this.data = {
      id: id,
      d: d,
      noinvalidate: noinvalidate
    };
    return _this;
  }
  _createClass__default["default"](RxnArrowMove, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var id = this.data.id;
      var d = this.data.d;
      var item = struct.rxnArrows.get(id);
      item.pos.forEach(function (p) {
        return p.add_(d);
      });
      restruct.rxnArrows.get(id).visel.translate(Scale.modelToCanvas(d, restruct.render.options));
      this.data.d = d.negated();
      if (!this.data.noinvalidate) {
        BaseOperation.invalidateItem(restruct, 'rxnArrows', id, 1);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var move = new RxnArrowMove(this.data.id, this.data.d, this.data.noinvalidate);
      move.data = this.data;
      return move;
    }
  }]);
  return RxnArrowMove;
}(BaseOperation);

function _callSuper$f(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$f() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$f() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$f = function _isNativeReflectConstruct() { return !!t; })(); }
var RxnArrowRotate = function (_Base) {
  _inherits__default["default"](RxnArrowRotate, _Base);
  function RxnArrowRotate(id, angle, center, noinvalidate) {
    var _this;
    _classCallCheck__default["default"](this, RxnArrowRotate);
    _this = _callSuper$f(this, RxnArrowRotate, [OperationType.RXN_ARROW_ROTATE]);
    _this.data = {
      id: id,
      angle: angle,
      center: center,
      noinvalidate: noinvalidate
    };
    return _this;
  }
  _createClass__default["default"](RxnArrowRotate, [{
    key: "execute",
    value: function execute(reStruct) {
      var _this2 = this,
        _reStruct$rxnArrows$g;
      var degree = utils$1.degrees(this.data.angle);
      var arrowId = this.data.id;
      var arrow = reStruct.molecule.rxnArrows.get(arrowId);
      if (arrow) {
        arrow.pos = arrow.pos.map(function (p) {
          return p.rotateAroundOrigin(degree, _this2.data.center);
        });
      }
      var options = reStruct.render.options;
      var drawingCenter = this.data.center.scaled(options.microModeScale).add(options.offset);
      (_reStruct$rxnArrows$g = reStruct.rxnArrows.get(arrowId)) === null || _reStruct$rxnArrows$g === void 0 || _reStruct$rxnArrows$g.visel.rotate(degree, drawingCenter);
      if (!this.data.noinvalidate) {
        BaseOperation.invalidateItem(reStruct, 'rxnArrows', arrowId, 1);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var move = new RxnArrowRotate(this.data.id, -this.data.angle, this.data.center, this.data.noinvalidate);
      return move;
    }
  }]);
  return RxnArrowRotate;
}(BaseOperation);

function _callSuper$e(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$e() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$e() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$e = function _isNativeReflectConstruct() { return !!t; })(); }
var ARROW_MAX_SNAPPING_ANGLE = Math.PI / 12;
var RxnArrowResize = function (_Base) {
  _inherits__default["default"](RxnArrowResize, _Base);
  function RxnArrowResize(id, d, current, anchor, noinvalidate, isSnappingEnabled) {
    var _this;
    _classCallCheck__default["default"](this, RxnArrowResize);
    _this = _callSuper$e(this, RxnArrowResize, [OperationType.RXN_ARROW_RESIZE]);
    _this.data = {
      id: id,
      d: d,
      current: current,
      anchor: anchor,
      noinvalidate: noinvalidate
    };
    _this.isSnappingEnabled = isSnappingEnabled;
    return _this;
  }
  _createClass__default["default"](RxnArrowResize, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var id = this.data.id;
      var d = this.data.d;
      var current = this.data.current;
      var item = struct.rxnArrows.get(id);
      var reItem = restruct.rxnArrows.get(id);
      assert__default["default"](item != null && reItem != null);
      var anchor = this.data.anchor;
      if (anchor) {
        var _middlePoint, _middlePoint2;
        var previousPos0 = item.pos[0].get_xy0();
        var previousPos1 = item.pos[1].get_xy0();
        var middlePoint;
        if (RxnArrow.isElliptical(item)) {
          var _reItem$getReferenceP = reItem.getReferencePoints();
          var _reItem$getReferenceP2 = _slicedToArray__default["default"](_reItem$getReferenceP, 3);
          middlePoint = _reItem$getReferenceP2[2];
        }
        if (
        tfx(anchor.x) === tfx(item.pos[1].x) && tfx(anchor.y) === tfx(item.pos[1].y)) {
          if (this.isSnappingEnabled) {
            var currentArrowVector = current.sub(item.pos[0]);
            var snappedArrowVector = getSnappedArrowVector(currentArrowVector);
            var snappedCurrent = item.pos[0].add(snappedArrowVector);
            current.x = snappedCurrent.x;
            current.y = snappedCurrent.y;
          }
          item.pos[1].x = anchor.x = current.x;
          current.x = previousPos1.x;
          item.pos[1].y = anchor.y = current.y;
          current.y = previousPos1.y;
        }
        if (
        tfx(anchor.x) === tfx(item.pos[0].x) && tfx(anchor.y) === tfx(item.pos[0].y)) {
          if (this.isSnappingEnabled) {
            var _currentArrowVector = current.sub(item.pos[1]);
            var _snappedArrowVector = getSnappedArrowVector(_currentArrowVector);
            var _snappedCurrent = item.pos[1].add(_snappedArrowVector);
            current.x = _snappedCurrent.x;
            current.y = _snappedCurrent.y;
          }
          item.pos[0].x = anchor.x = current.x;
          current.x = previousPos0.x;
          item.pos[0].y = anchor.y = current.y;
          current.y = previousPos0.y;
        }
        if (tfx(anchor.x) === tfx((_middlePoint = middlePoint) === null || _middlePoint === void 0 ? void 0 : _middlePoint.x) && tfx(anchor.y) === tfx((_middlePoint2 = middlePoint) === null || _middlePoint2 === void 0 ? void 0 : _middlePoint2.y)) {
          var _reItem$getArrowParam = reItem.getArrowParams(item.pos[0].x, item.pos[0].y, item.pos[1].x, item.pos[1].y),
            angle = _reItem$getArrowParam.angle;
          var angleInRadians = angle * Math.PI / 180;
          var cosAngle = Math.cos(angleInRadians);
          var sinAngle = Math.sin(angleInRadians);
          var diffX = current.x - anchor.x;
          var diffY = current.y - anchor.y;
          var diff = diffY * cosAngle - diffX * sinAngle;
          if (item.height !== undefined) {
            item.height -= diff;
          }
          var _reItem$getReferenceP3 = reItem.getReferencePoints(),
            _reItem$getReferenceP4 = _slicedToArray__default["default"](_reItem$getReferenceP3, 3),
            newMiddlePoint = _reItem$getReferenceP4[2];
          anchor.y = newMiddlePoint.y;
          anchor.x = newMiddlePoint.x;
        }
      } else {
        if (this.isSnappingEnabled) {
          d = getSnappedArrowVector(d);
        }
        item.pos[1].add_(d);
      }
      reItem.visel.translate(Scale.modelToCanvas(d, restruct.render.options));
      this.data.d = d.negated();
      if (!this.data.noinvalidate) {
        BaseOperation.invalidateItem(restruct, 'rxnArrows', id, 1);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RxnArrowResize(this.data.id, this.data.d, this.data.current, this.data.anchor, this.data.noinvalidate, this.isSnappingEnabled);
    }
  }]);
  return RxnArrowResize;
}(BaseOperation);
function getSnappedArrowVector(arrow) {
  var AXIS = {
    POSITIVE_X: 0,
    POSITIVE_Y: Math.PI / 2,
    NEGATIVE_X: [Math.PI, -Math.PI],
    NEGATIVE_Y: -Math.PI / 2
  };
  var oxAngle = arrow.oxAngle();
  var arrowLength = arrow.length();
  var isSnappingToPositiveXAxis = Math.abs(oxAngle - AXIS.POSITIVE_X) <= ARROW_MAX_SNAPPING_ANGLE;
  if (isSnappingToPositiveXAxis) {
    return new Vec2(arrowLength, 0);
  }
  var isSnappingToPositiveYAxis = Math.abs(oxAngle - AXIS.POSITIVE_Y) <= ARROW_MAX_SNAPPING_ANGLE;
  if (isSnappingToPositiveYAxis) {
    return new Vec2(0, arrowLength);
  }
  var isSnappingToNegativeXAxis = Math.abs(oxAngle - AXIS.NEGATIVE_X[0]) <= ARROW_MAX_SNAPPING_ANGLE || Math.abs(oxAngle - AXIS.NEGATIVE_X[1]) <= ARROW_MAX_SNAPPING_ANGLE;
  if (isSnappingToNegativeXAxis) {
    return new Vec2(-arrowLength, 0);
  }
  var isSnappingToNegativeYAxis = Math.abs(oxAngle - AXIS.NEGATIVE_Y) <= ARROW_MAX_SNAPPING_ANGLE;
  if (isSnappingToNegativeYAxis) {
    return new Vec2(0, -arrowLength);
  }
  return arrow;
}

function _callSuper$d(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$d() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$d() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$d = function _isNativeReflectConstruct() { return !!t; })(); }
var RxnPlusMove = function (_BaseOperation) {
  _inherits__default["default"](RxnPlusMove, _BaseOperation);
  function RxnPlusMove(id, d, noinvalidate) {
    var _this;
    _classCallCheck__default["default"](this, RxnPlusMove);
    _this = _callSuper$d(this, RxnPlusMove, [OperationType.RXN_PLUS_MOVE]);
    _this.data = {
      id: id,
      d: d,
      noinvalidate: noinvalidate
    };
    return _this;
  }
  _createClass__default["default"](RxnPlusMove, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        id = _this$data.id,
        d = _this$data.d,
        noinvalidate = _this$data.noinvalidate;
      var struct = restruct.molecule;
      struct.rxnPluses.get(id).pp.add_(d);
      var rxn = restruct.rxnPluses.get(id);
      var scaled = Scale.modelToCanvas(d, restruct.render.options);
      rxn.visel.translate(scaled);
      this.data.d = d.negated();
      if (!noinvalidate) {
        BaseOperation.invalidateItem(restruct, 'rxnPluses', id, 1);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new RxnPlusMove();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return RxnPlusMove;
}(BaseOperation);

function _callSuper$c(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$c() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$c() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$c = function _isNativeReflectConstruct() { return !!t; })(); }
var RxnPlusAdd = function (_BaseOperation) {
  _inherits__default["default"](RxnPlusAdd, _BaseOperation);
  function RxnPlusAdd(pos) {
    var _this;
    _classCallCheck__default["default"](this, RxnPlusAdd);
    _this = _callSuper$c(this, RxnPlusAdd, [OperationType.RXN_PLUS_ADD]);
    _this.data = {
      plid: null,
      pos: pos
    };
    return _this;
  }
  _createClass__default["default"](RxnPlusAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var newRxn = new RxnPlus();
      if (typeof this.data.plid === 'number') {
        struct.rxnPluses.set(this.data.plid, newRxn);
      } else {
        this.data.plid = struct.rxnPluses.add(newRxn);
      }
      var _this$data = this.data,
        pos = _this$data.pos,
        plid = _this$data.plid;
      var structRxn = struct.rxnPluses.get(plid);
      restruct.rxnPluses.set(plid, new ReRxnPlus(structRxn));
      struct.rxnPlusSetPos(plid, new Vec2(pos));
      BaseOperation.invalidateItem(restruct, 'rxnPluses', plid, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new RxnPlusDelete();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return RxnPlusAdd;
}(BaseOperation);
var RxnPlusDelete = function (_BaseOperation2) {
  _inherits__default["default"](RxnPlusDelete, _BaseOperation2);
  function RxnPlusDelete(plid) {
    var _this2;
    _classCallCheck__default["default"](this, RxnPlusDelete);
    _this2 = _callSuper$c(this, RxnPlusDelete, [OperationType.RXN_PLUS_DELETE]);
    _this2.data = {
      plid: plid,
      pos: null
    };
    return _this2;
  }
  _createClass__default["default"](RxnPlusDelete, [{
    key: "execute",
    value: function execute(restruct) {
      var plid = this.data.plid;
      var struct = restruct.molecule;
      if (!this.data.pos) {
        this.data.pos = struct.rxnPluses.get(plid).pp;
      }
      restruct.markItemRemoved();
      var rxn = restruct.rxnPluses.get(plid);
      if (!rxn) return;
      restruct.clearVisel(rxn.visel);
      restruct.rxnPluses["delete"](plid);
      struct.rxnPluses["delete"](plid);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new RxnPlusAdd();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return RxnPlusDelete;
}(BaseOperation);

function _callSuper$b(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$b() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$b() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$b = function _isNativeReflectConstruct() { return !!t; })(); }
var RxnArrowAdd = function (_Base) {
  _inherits__default["default"](RxnArrowAdd, _Base);
  function RxnArrowAdd() {
    var _this;
    var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.RxnArrowMode.OpenAngle;
    var id = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck__default["default"](this, RxnArrowAdd);
    _this = _callSuper$b(this, RxnArrowAdd, [OperationType.RXN_ARROW_ADD]);
    _this.data = {
      pos: pos,
      mode: mode,
      id: id
    };
    return _this;
  }
  _createClass__default["default"](RxnArrowAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var item = new RxnArrow({
        mode: this.data.mode
      });
      if (this.data.id == null) {
        var index = struct.rxnArrows.add(item);
        this.data.id = index;
      } else {
        struct.rxnArrows.set(this.data.id, item);
      }
      var itemId = this.data.id;
      restruct.rxnArrows.set(itemId, new ReRxnArrow(item));
      var positions = _toConsumableArray__default["default"](this.data.pos);
      struct.rxnArrowSetPos(itemId, positions.map(function (p) {
        return new Vec2(p);
      }));
      BaseOperation.invalidateItem(restruct, 'rxnArrows', itemId, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RxnArrowDelete(this.data.id);
    }
  }]);
  return RxnArrowAdd;
}(BaseOperation);
var RxnArrowDelete = function (_Base2) {
  _inherits__default["default"](RxnArrowDelete, _Base2);
  function RxnArrowDelete(id) {
    var _this2;
    _classCallCheck__default["default"](this, RxnArrowDelete);
    _this2 = _callSuper$b(this, RxnArrowDelete, [OperationType.RXN_ARROW_DELETE]);
    _this2.data = {
      id: id,
      pos: [],
      mode: exports.RxnArrowMode.OpenAngle
    };
    _this2.performed = false;
    return _this2;
  }
  _createClass__default["default"](RxnArrowDelete, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var item = struct.rxnArrows.get(this.data.id);
      this.data.pos = item.pos;
      this.data.mode = item.mode;
      this.performed = true;
      restruct.markItemRemoved();
      restruct.clearVisel(restruct.rxnArrows.get(this.data.id).visel);
      restruct.rxnArrows["delete"](this.data.id);
      struct.rxnArrows["delete"](this.data.id);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RxnArrowAdd(this.data.pos, this.data.mode, this.data.id);
    }
  }]);
  return RxnArrowDelete;
}(BaseOperation);

function _callSuper$a(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$a() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$a() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$a = function _isNativeReflectConstruct() { return !!t; })(); }
var SimpleObjectAdd = function (_Base) {
  _inherits__default["default"](SimpleObjectAdd, _Base);
  function SimpleObjectAdd() {
    var _this;
    var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.SimpleObjectMode.line;
    var toCircle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var id = arguments.length > 3 ? arguments[3] : undefined;
    _classCallCheck__default["default"](this, SimpleObjectAdd);
    _this = _callSuper$a(this, SimpleObjectAdd, [OperationType.SIMPLE_OBJECT_ADD]);
    _this.data = {
      pos: pos,
      mode: mode,
      toCircle: toCircle,
      id: id
    };
    return _this;
  }
  _createClass__default["default"](SimpleObjectAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var item = new SimpleObject({
        mode: this.data.mode
      });
      if (this.data.id == null) {
        var index = struct.simpleObjects.add(item);
        this.data.id = index;
      } else {
        struct.simpleObjects.set(this.data.id, item);
      }
      var itemId = this.data.id;
      restruct.simpleObjects.set(itemId, new ReSimpleObject(item));
      var positions = _toConsumableArray__default["default"](this.data.pos);
      if (this.data.toCircle) {
        positions[1] = makeCircleFromEllipse(positions[0], positions[1]);
      }
      struct.simpleObjectSetPos(itemId, positions.map(function (p) {
        return new Vec2(p);
      }));
      BaseOperation.invalidateItem(restruct, 'simpleObjects', itemId, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new SimpleObjectDelete(this.data.id);
    }
  }]);
  return SimpleObjectAdd;
}(BaseOperation);
var SimpleObjectDelete = function (_Base2) {
  _inherits__default["default"](SimpleObjectDelete, _Base2);
  function SimpleObjectDelete(id) {
    var _this2;
    _classCallCheck__default["default"](this, SimpleObjectDelete);
    _this2 = _callSuper$a(this, SimpleObjectDelete, [OperationType.SIMPLE_OBJECT_DELETE]);
    _this2.data = {
      id: id,
      pos: [],
      mode: exports.SimpleObjectMode.line,
      toCircle: false
    };
    _this2.performed = false;
    return _this2;
  }
  _createClass__default["default"](SimpleObjectDelete, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var item = struct.simpleObjects.get(this.data.id);
      this.data.pos = item.pos;
      this.data.mode = item.mode;
      this.data.toCircle = item.toCircle;
      this.performed = true;
      restruct.markItemRemoved();
      restruct.clearVisel(restruct.simpleObjects.get(this.data.id).visel);
      restruct.simpleObjects["delete"](this.data.id);
      struct.simpleObjects["delete"](this.data.id);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new SimpleObjectAdd(this.data.pos, this.data.mode, this.data.toCircle, this.data.id);
    }
  }]);
  return SimpleObjectDelete;
}(BaseOperation);
var SimpleObjectMove = function (_Base3) {
  _inherits__default["default"](SimpleObjectMove, _Base3);
  function SimpleObjectMove(id, d, noinvalidate) {
    var _this3;
    _classCallCheck__default["default"](this, SimpleObjectMove);
    _this3 = _callSuper$a(this, SimpleObjectMove, [OperationType.SIMPLE_OBJECT_MOVE]);
    _this3.data = {
      id: id,
      d: d,
      noinvalidate: noinvalidate
    };
    return _this3;
  }
  _createClass__default["default"](SimpleObjectMove, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var id = this.data.id;
      var d = this.data.d;
      var item = struct.simpleObjects.get(id);
      item.pos.forEach(function (p) {
        return p.add_(d);
      });
      restruct.simpleObjects.get(id).visel.translate(Scale.modelToCanvas(d, restruct.render.options));
      this.data.d = d.negated();
      if (!this.data.noinvalidate) {
        BaseOperation.invalidateItem(restruct, 'simpleObjects', id, 1);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var move = new SimpleObjectMove(this.data.id, this.data.d, this.data.noinvalidate);
      move.data = this.data;
      return move;
    }
  }]);
  return SimpleObjectMove;
}(BaseOperation);
function handleRectangleChangeWithAnchor(item, anchor, current) {
  var previousPos0 = item.pos[0].get_xy0();
  var previousPos1 = item.pos[1].get_xy0();
  if (tfx(anchor.x) === tfx(item.pos[1].x)) {
    item.pos[1].x = anchor.x = current.x;
    current.x = previousPos1.x;
  }
  if (tfx(anchor.y) === tfx(item.pos[1].y)) {
    item.pos[1].y = anchor.y = current.y;
    current.y = previousPos1.y;
  }
  if (tfx(anchor.x) === tfx(item.pos[0].x)) {
    item.pos[0].x = anchor.x = current.x;
    current.x = previousPos0.x;
  }
  if (tfx(anchor.y) === tfx(item.pos[0].y)) {
    item.pos[0].y = anchor.y = current.y;
    current.y = previousPos0.y;
  }
}
var SimpleObjectResize = function (_Base4) {
  _inherits__default["default"](SimpleObjectResize, _Base4);
  function SimpleObjectResize(id, d, current, anchor, noinvalidate, toCircle) {
    var _this4;
    _classCallCheck__default["default"](this, SimpleObjectResize);
    _this4 = _callSuper$a(this, SimpleObjectResize, [OperationType.SIMPLE_OBJECT_RESIZE]);
    _this4.data = {
      id: id,
      d: d,
      current: current,
      anchor: anchor,
      noinvalidate: noinvalidate,
      toCircle: toCircle
    };
    return _this4;
  }
  _createClass__default["default"](SimpleObjectResize, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var id = this.data.id;
      var d = this.data.d;
      var current = this.data.current;
      var item = struct.simpleObjects.get(id);
      var anchor = this.data.anchor;
      if (item.mode === exports.SimpleObjectMode.ellipse) {
        if (anchor) {
          handleRectangleChangeWithAnchor(item, anchor, current);
        } else if (this.data.toCircle) {
          var previousPos1 = item.pos[1].get_xy0();
          var circlePoint = makeCircleFromEllipse(item.pos[0], current);
          item.pos[1].x = circlePoint.x;
          item.pos[1].y = circlePoint.y;
          this.data.current = previousPos1;
        } else {
          var _previousPos = item.pos[1].get_xy0();
          item.pos[1].x = current.x;
          item.pos[1].y = current.y;
          this.data.current = _previousPos;
        }
      } else if (item.mode === exports.SimpleObjectMode.line && anchor) {
        var previousPos0 = item.pos[0].get_xy0();
        var _previousPos2 = item.pos[1].get_xy0();
        if (tfx(anchor.x) === tfx(item.pos[1].x) && tfx(anchor.y) === tfx(item.pos[1].y)) {
          item.pos[1].x = anchor.x = current.x;
          current.x = _previousPos2.x;
          item.pos[1].y = anchor.y = current.y;
          current.y = _previousPos2.y;
        }
        if (tfx(anchor.x) === tfx(item.pos[0].x) && tfx(anchor.y) === tfx(item.pos[0].y)) {
          item.pos[0].x = anchor.x = current.x;
          current.x = previousPos0.x;
          item.pos[0].y = anchor.y = current.y;
          current.y = previousPos0.y;
        }
      } else if (item.mode === exports.SimpleObjectMode.rectangle && anchor) {
        handleRectangleChangeWithAnchor(item, anchor, current);
      } else item.pos[1].add_(d);
      restruct.simpleObjects.get(id).visel.translate(Scale.modelToCanvas(d, restruct.render.options));
      this.data.d = d.negated();
      if (!this.data.noinvalidate) {
        BaseOperation.invalidateItem(restruct, 'simpleObjects', id, 1);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      return new SimpleObjectResize(this.data.id, this.data.d, this.data.current, this.data.anchor, this.data.noinvalidate, this.data.toCircle);
    }
  }]);
  return SimpleObjectResize;
}(BaseOperation);
function makeCircleFromEllipse(position0, position1) {
  var diff = Vec2.diff(position1, position0);
  var min = Math.abs(diff.x) < Math.abs(diff.y) ? diff.x : diff.y;
  return new Vec2(position0.x + (diff.x > 0 ? 1 : -1) * Math.abs(min), position0.y + (diff.y > 0 ? 1 : -1) * Math.abs(min), 0);
}

function _callSuper$9(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$9() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$9() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$9 = function _isNativeReflectConstruct() { return !!t; })(); }
var SGroupAtomAdd = function (_BaseOperation) {
  _inherits__default["default"](SGroupAtomAdd, _BaseOperation);
  function SGroupAtomAdd(sgroupId, aid) {
    var _this;
    _classCallCheck__default["default"](this, SGroupAtomAdd);
    _this = _callSuper$9(this, SGroupAtomAdd, [OperationType.S_GROUP_ATOM_ADD, exports.OperationPriority.S_GROUP_ATOM_ADD]);
    _this.data = {
      sgid: sgroupId,
      aid: aid
    };
    return _this;
  }
  _createClass__default["default"](SGroupAtomAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        aid = _this$data.aid,
        sgid = _this$data.sgid;
      var struct = restruct.molecule;
      var atom = struct.atoms.get(aid);
      var sgroup = struct.sgroups.get(sgid);
      if (sgroup.atoms.indexOf(aid) >= 0) {
        throw new Error('The same atom cannot be added to an S-group more than once');
      }
      if (!atom) {
        throw new Error('OpSGroupAtomAdd: Atom ' + aid + ' not found');
      }
      struct.atomAddToSGroup(sgid, aid);
      BaseOperation.invalidateAtom(restruct, aid);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new SGroupAtomRemove();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return SGroupAtomAdd;
}(BaseOperation);
var SGroupAtomRemove = function (_BaseOperation2) {
  _inherits__default["default"](SGroupAtomRemove, _BaseOperation2);
  function SGroupAtomRemove(sgroupId, aid) {
    var _this2;
    _classCallCheck__default["default"](this, SGroupAtomRemove);
    _this2 = _callSuper$9(this, SGroupAtomRemove, [OperationType.S_GROUP_ATOM_REMOVE, 4]);
    _this2.data = {
      sgid: sgroupId,
      aid: aid
    };
    return _this2;
  }
  _createClass__default["default"](SGroupAtomRemove, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data2 = this.data,
        aid = _this$data2.aid,
        sgid = _this$data2.sgid;
      var struct = restruct.molecule;
      var atom = struct.atoms.get(aid);
      var sgroup = struct.sgroups.get(sgid);
      if (!atom || !sgroup) {
        return;
      }
      SGroup.removeAtom(sgroup, aid);
      atom.sgs["delete"](sgid);
      BaseOperation.invalidateAtom(restruct, aid);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new SGroupAtomAdd();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return SGroupAtomRemove;
}(BaseOperation);

function _callSuper$8(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$8() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$8() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct() { return !!t; })(); }
var SGroupAttr = function (_BaseOperation) {
  _inherits__default["default"](SGroupAttr, _BaseOperation);
  function SGroupAttr(sgroupId, attribute, value) {
    var _this;
    _classCallCheck__default["default"](this, SGroupAttr);
    _this = _callSuper$8(this, SGroupAttr, [OperationType.S_GROUP_ATTR, exports.OperationPriority.S_GROUP_ATTR]);
    _this.data = {
      sgid: sgroupId,
      attr: attribute,
      value: value
    };
    return _this;
  }
  _createClass__default["default"](SGroupAttr, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var sgroupId = this.data.sgid;
      var sgroup = struct.sgroups.get(sgroupId);
      if (!sgroup) {
        return;
      }
      var sgroupData = restruct.sgroupData.get(sgroupId);
      if (sgroup.type === 'DAT' && sgroupData) {
        restruct.clearVisel(sgroupData.visel);
        restruct.sgroupData["delete"](sgroupId);
      }
      this.data.value = sgroup.setAttr(this.data.attr, this.data.value);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new SGroupAttr();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return SGroupAttr;
}(BaseOperation);

function _callSuper$7(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$7() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$7() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct() { return !!t; })(); }
var SGroupDataMove = function (_BaseOperation) {
  _inherits__default["default"](SGroupDataMove, _BaseOperation);
  function SGroupDataMove(id, d) {
    var _this;
    _classCallCheck__default["default"](this, SGroupDataMove);
    _this = _callSuper$7(this, SGroupDataMove, [OperationType.S_GROUP_DATA_MOVE]);
    _this.data = {
      id: id,
      d: d
    };
    return _this;
  }
  _createClass__default["default"](SGroupDataMove, [{
    key: "execute",
    value: function execute(restruct) {
      var _sgroups$get$pp;
      var _this$data = this.data,
        d = _this$data.d,
        id = _this$data.id;
      var sgroups = restruct.molecule.sgroups;
      (_sgroups$get$pp = sgroups.get(id).pp) === null || _sgroups$get$pp === void 0 || _sgroups$get$pp.add_(d);
      this.data.d = d.negated();
      BaseOperation.invalidateItem(restruct, 'sgroupData', id, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new SGroupDataMove();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return SGroupDataMove;
}(BaseOperation);

function _callSuper$6(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$6() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$6() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct() { return !!t; })(); }
var SGroupAddToHierarchy = function (_BaseOperation) {
  _inherits__default["default"](SGroupAddToHierarchy, _BaseOperation);
  function SGroupAddToHierarchy(sgroupId, parent, children) {
    var _this;
    _classCallCheck__default["default"](this, SGroupAddToHierarchy);
    _this = _callSuper$6(this, SGroupAddToHierarchy, [OperationType.S_GROUP_ADD_TO_HIERACHY, exports.OperationPriority.S_GROUP_ADD_TO_HIERACHY]);
    _this.data = {
      sgid: sgroupId,
      parent: parent,
      children: children
    };
    return _this;
  }
  _createClass__default["default"](SGroupAddToHierarchy, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        sgid = _this$data.sgid,
        parent = _this$data.parent,
        children = _this$data.children;
      var struct = restruct.molecule;
      var sgroup = struct.sgroups.get(sgid);
      var relations = struct.sGroupForest.insert(sgroup, parent, children);
      this.data.parent = relations.parent;
      this.data.children = relations.children;
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new SGroupRemoveFromHierarchy();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return SGroupAddToHierarchy;
}(BaseOperation);
var SGroupRemoveFromHierarchy = function (_BaseOperation2) {
  _inherits__default["default"](SGroupRemoveFromHierarchy, _BaseOperation2);
  function SGroupRemoveFromHierarchy(sgroupId) {
    var _this2;
    _classCallCheck__default["default"](this, SGroupRemoveFromHierarchy);
    _this2 = _callSuper$6(this, SGroupRemoveFromHierarchy, [OperationType.S_GROUP_REMOVE_FROM_HIERACHY, 110]);
    _this2.data = {
      sgid: sgroupId
    };
    return _this2;
  }
  _createClass__default["default"](SGroupRemoveFromHierarchy, [{
    key: "execute",
    value: function execute(restruct) {
      var sgid = this.data.sgid;
      var struct = restruct.molecule;
      this.data.parent = struct.sGroupForest.parent.get(sgid);
      this.data.children = struct.sGroupForest.children.get(sgid);
      struct.sGroupForest.remove(sgid);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new SGroupAddToHierarchy();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return SGroupRemoveFromHierarchy;
}(BaseOperation);

function _callSuper$5(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$5() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$5() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct() { return !!t; })(); }
var SGroupCreate = function (_BaseOperation) {
  _inherits__default["default"](SGroupCreate, _BaseOperation);
  function SGroupCreate(sgroupId, type, pp, expanded, name, oldSgroup) {
    var _this;
    _classCallCheck__default["default"](this, SGroupCreate);
    _this = _callSuper$5(this, SGroupCreate, [OperationType.S_GROUP_CREATE]);
    _this.data = {
      sgid: sgroupId,
      type: type,
      pp: pp,
      expanded: expanded,
      name: name,
      oldSgroup: oldSgroup
    };
    return _this;
  }
  _createClass__default["default"](SGroupCreate, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var _this$data = this.data,
        sgid = _this$data.sgid,
        pp = _this$data.pp,
        expanded = _this$data.expanded,
        name = _this$data.name,
        oldSgroup = _this$data.oldSgroup;
      var sgroup = oldSgroup instanceof MonomerMicromolecule ? new MonomerMicromolecule(SGroup.TYPES.SUP, oldSgroup.monomer) : new SGroup(this.data.type);
      sgroup.id = sgid;
      struct.sgroups.set(sgid, sgroup);
      if (pp) {
        sgroup.pp = new Vec2(pp);
      }
      if (expanded) {
        sgroup.data.expanded = expanded;
      }
      if (name) {
        sgroup.data.name = name;
      }
      var existingSGroup = struct.sgroups.get(sgid);
      if (existingSGroup) {
        restruct.sgroups.set(sgid, new ReSGroup(existingSGroup));
        if (FunctionalGroup.isFunctionalGroup(sgroup) || SGroup.isSuperAtom(sgroup)) {
          restruct.molecule.functionalGroups.add(new FunctionalGroup(sgroup));
        }
      }
      this.data.sgid = sgid;
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new SGroupDelete();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return SGroupCreate;
}(BaseOperation);
var SGroupDelete = function (_BaseOperation2) {
  _inherits__default["default"](SGroupDelete, _BaseOperation2);
  function SGroupDelete(sgroupId) {
    var _this2;
    _classCallCheck__default["default"](this, SGroupDelete);
    _this2 = _callSuper$5(this, SGroupDelete, [OperationType.S_GROUP_DELETE, exports.OperationPriority.S_GROUP_DELETE]);
    _this2.data = {
      sgid: sgroupId
    };
    return _this2;
  }
  _createClass__default["default"](SGroupDelete, [{
    key: "execute",
    value: function execute(restruct) {
      var _sgroup$item, _sgroup$item2, _sgroup$item3, _sgroup$item4;
      var struct = restruct.molecule;
      var sgid = this.data.sgid;
      var sgroup = restruct.sgroups.get(sgid);
      var sgroupData = restruct.sgroupData.get(sgid);
      if (!sgroup) return;
      this.data.type = sgroup === null || sgroup === void 0 || (_sgroup$item = sgroup.item) === null || _sgroup$item === void 0 ? void 0 : _sgroup$item.type;
      this.data.pp = sgroup === null || sgroup === void 0 || (_sgroup$item2 = sgroup.item) === null || _sgroup$item2 === void 0 ? void 0 : _sgroup$item2.pp;
      if ((sgroup === null || sgroup === void 0 || (_sgroup$item3 = sgroup.item) === null || _sgroup$item3 === void 0 ? void 0 : _sgroup$item3.type) === 'DAT' && sgroupData) {
        restruct.clearVisel(sgroupData.visel);
        restruct.sgroupData["delete"](sgid);
      }
      restruct.clearVisel(sgroup.visel);
      if ((sgroup === null || sgroup === void 0 || (_sgroup$item4 = sgroup.item) === null || _sgroup$item4 === void 0 || (_sgroup$item4 = _sgroup$item4.atoms) === null || _sgroup$item4 === void 0 ? void 0 : _sgroup$item4.length) !== 0) {
        throw new Error('S-Group not empty!');
      }
      if (FunctionalGroup.isFunctionalGroup(sgroup.item) || SGroup.isSuperAtom(sgroup.item)) {
        var relatedFGroupId;
        this.data.name = sgroup.item.data.name;
        this.data.expanded = sgroup.item.isExpanded();
        restruct.molecule.functionalGroups.forEach(function (fg, fgid) {
          if (fg.relatedSGroupId === sgid) {
            relatedFGroupId = fgid;
          }
        });
        restruct.molecule.functionalGroups["delete"](relatedFGroupId);
      }
      restruct.sgroups["delete"](sgid);
      struct.sgroups["delete"](sgid);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new SGroupCreate();
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return SGroupDelete;
}(BaseOperation);

function _callSuper$4(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$4() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$4() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct() { return !!t; })(); }
var TextCreate = function (_BaseOperation) {
  _inherits__default["default"](TextCreate, _BaseOperation);
  function TextCreate(content, position, pos, id) {
    var _this;
    _classCallCheck__default["default"](this, TextCreate);
    _this = _callSuper$4(this, TextCreate, [OperationType.TEXT_CREATE]);
    _this.data = {
      content: content,
      position: position,
      pos: pos,
      id: id
    };
    return _this;
  }
  _createClass__default["default"](TextCreate, [{
    key: "execute",
    value: function execute(restruct) {
      var item = new Text(this.data);
      if (this.data.id == null) {
        var index = restruct.molecule.texts.add(item);
        this.data.id = index;
      } else {
        restruct.molecule.texts.set(this.data.id, item);
      }
      var itemId = this.data.id;
      restruct.texts.set(itemId, new ReText(item));
      restruct.molecule.textSetPosition(itemId, new Vec2(this.data.position));
      BaseOperation.invalidateItem(restruct, 'texts', itemId, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new TextDelete(this.data.id);
    }
  }]);
  return TextCreate;
}(BaseOperation);
var TextDelete = function (_BaseOperation2) {
  _inherits__default["default"](TextDelete, _BaseOperation2);
  function TextDelete(id) {
    var _this2;
    _classCallCheck__default["default"](this, TextDelete);
    _this2 = _callSuper$4(this, TextDelete, [OperationType.TEXT_DELETE]);
    _this2.data = {
      id: id
    };
    return _this2;
  }
  _createClass__default["default"](TextDelete, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var item = struct.texts.get(this.data.id);
      if (!item) return;
      this.data.content = item.content;
      this.data.position = item.position;
      restruct.markItemRemoved();
      restruct.clearVisel(restruct.texts.get(this.data.id).visel);
      restruct.texts["delete"](this.data.id);
      struct.texts["delete"](this.data.id);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new TextCreate(this.data.content, this.data.position, this.data.pos, this.data.id);
    }
  }]);
  return TextDelete;
}(BaseOperation);

function _callSuper$3(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$3() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$3() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct() { return !!t; })(); }
var TextUpdate = function (_BaseOperation) {
  _inherits__default["default"](TextUpdate, _BaseOperation);
  function TextUpdate(id, content) {
    var _this;
    _classCallCheck__default["default"](this, TextUpdate);
    _this = _callSuper$3(this, TextUpdate, [OperationType.TEXT_UPDATE]);
    _this.data = {
      id: id,
      content: content
    };
    return _this;
  }
  _createClass__default["default"](TextUpdate, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        id = _this$data.id,
        content = _this$data.content;
      var text = restruct.molecule.texts.get(id);
      if (text) {
        this.data.previousContent = text.content;
        text.content = content;
      }
      BaseOperation.invalidateItem(restruct, 'texts', id, 1);
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverted = new TextUpdate(this.data.id, this.data.previousContent);
      inverted.data.previousContent = this.data.content;
      return inverted;
    }
  }]);
  return TextUpdate;
}(BaseOperation);

function _callSuper$2(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }
var TextMove = function (_BaseOperation) {
  _inherits__default["default"](TextMove, _BaseOperation);
  function TextMove(id, d, noinvalidate) {
    var _this;
    _classCallCheck__default["default"](this, TextMove);
    _this = _callSuper$2(this, TextMove, [OperationType.TEXT_MOVE]);
    _this.data = {
      id: id,
      d: d,
      noinvalidate: noinvalidate
    };
    return _this;
  }
  _createClass__default["default"](TextMove, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var id = this.data.id;
      var difference = this.data.d;
      var item = struct.texts.get(id);
      var renderItem = restruct.texts.get(id);
      if (!item || !renderItem) {
        return;
      }
      item.position.add_(difference);
      item.setPos(renderItem.getReferencePoints());
      renderItem.visel.translate(Scale.modelToCanvas(difference, restruct.render.options));
      this.data.d = difference.negated();
      if (!this.data.noinvalidate) {
        BaseOperation.invalidateItem(restruct, 'texts', id, 1);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var move = new TextMove(this.data.id, this.data.d, this.data.noinvalidate);
      move.data = this.data;
      return move;
    }
  }]);
  return TextMove;
}(BaseOperation);

var Action = function () {
  function Action() {
    var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    _classCallCheck__default["default"](this, Action);
    this.operations = operations;
  }
  _createClass__default["default"](Action, [{
    key: "addOp",
    value: function addOp(operation, restruct) {
      if (!restruct || !operation.isDummy(restruct)) {
        this.operations.push(operation);
      }
      return operation;
    }
  }, {
    key: "mergeWith",
    value: function mergeWith(action) {
      this.operations = this.operations.concat(action.operations);
      return this;
    }
  }, {
    key: "perform",
    value: function perform(restruct) {
      var action = new Action();
      var sortedOperations = _toConsumableArray__default["default"](this.operations).sort(function (a, b) {
        return a.priority - b.priority;
      });
      sortedOperations.forEach(function (operation) {
        var invertedOperation = operation.perform(restruct);
        action.addOp(invertedOperation);
      });
      return action;
    }
  }, {
    key: "isDummy",
    value: function isDummy(restruct) {
      return this.operations.find(
      function (operation) {
        return restruct ? !operation.isDummy(restruct) : true;
      }) === undefined;
    }
  }]);
  return Action;
}();

function fromAromaticTemplateOnBond(restruct, template, bid, _events, simpleFusing) {
  var action = simpleFusing(restruct, template, bid);
  return Promise.resolve(action);
}

var _excluded = ["id", "dist"];
function ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var SELECTION_DISTANCE_COEFFICIENT = 0.4;
var SELECTION_WITHIN_TEXT = 0;
var findMaps = {
  atoms: findClosestAtom,
  bonds: findClosestBond,
  enhancedFlags: findClosestEnhancedFlag,
  sgroupData: findClosestDataSGroupData,
  sgroups: findClosestSGroup,
  rxnArrows: findClosestRxnArrow,
  rxnPluses: findClosestRxnPlus,
  frags: findClosestFrag,
  rgroups: findClosestRGroup,
  simpleObjects: findClosestSimpleObject,
  texts: findClosestText
};
function findClosestText(restruct, cursorPosition) {
  var minDist = null;
  var ret = null;
  restruct.texts.forEach(function (text, id) {
    var referencePoints = text.getReferencePoints(restruct);
    var topX = referencePoints[0].x;
    var topY = referencePoints[0].y;
    var bottomX = referencePoints[2].x;
    var bottomY = referencePoints[2].y;
    var distances = [];
    if (cursorPosition.x >= topX && cursorPosition.x <= bottomX) {
      if (cursorPosition.y < topY) {
        distances.push(topY - cursorPosition.y);
      } else if (cursorPosition.y > bottomY) {
        distances.push(cursorPosition.y - bottomY);
      } else {
        distances.push(cursorPosition.y - topY, bottomY - cursorPosition.y);
      }
    }
    if (cursorPosition.x < topX && cursorPosition.y < topY) {
      distances.push(Vec2.dist(new Vec2(topX, topY), cursorPosition));
    }
    if (cursorPosition.x > bottomX && cursorPosition.y > bottomY) {
      distances.push(Vec2.dist(new Vec2(bottomX, bottomY), cursorPosition));
    }
    if (cursorPosition.x < topX && cursorPosition.y > bottomY) {
      distances.push(Vec2.dist(new Vec2(topX, bottomY), cursorPosition));
    }
    if (cursorPosition.x > bottomX && cursorPosition.y < topY) {
      distances.push(Vec2.dist(new Vec2(bottomX, topY), cursorPosition));
    }
    if (cursorPosition.y >= topY && cursorPosition.y <= bottomY) {
      if (cursorPosition.x < topX) {
        distances.push(topX - cursorPosition.x);
      } else if (cursorPosition.x > bottomX) {
        distances.push(cursorPosition.x - bottomX);
      } else {
        distances.push(SELECTION_WITHIN_TEXT);
      }
    }
    var dist = Math.min.apply(Math, distances);
    if (dist < SELECTION_DISTANCE_COEFFICIENT && (!ret || dist < minDist)) {
      minDist = dist;
      ret = {
        id: id,
        dist: minDist
      };
    }
  });
  return ret;
}
function findClosestSimpleObject(restruct, pos) {
  var minDist = null;
  var refPoint = null;
  var ret = null;
  restruct.simpleObjects.forEach(function (simpleObject, id) {
    var dist = simpleObject.calcDistance(pos, restruct.render.options.microModeScale);
    if (dist.minDist < 0.3 && (!ret || dist.minDist < minDist)) {
      minDist = dist.minDist;
      refPoint = dist.refPoint;
      ret = {
        id: id,
        dist: minDist,
        ref: refPoint
      };
    }
  });
  return ret;
}
function findClosestAtom(restruct, pos, skip, minDist) {
  var closestAtom = null;
  var maxMinDist = SELECTION_DISTANCE_COEFFICIENT;
  var skipId = skip && skip.map === 'atoms' ? skip.id : null;
  minDist = minDist || maxMinDist;
  minDist = Math.min(minDist, maxMinDist);
  restruct.atoms.forEach(function (atom, aid) {
    if (aid === skipId) return;
    var dist = Vec2.dist(pos, atom.a.pp);
    if (dist < minDist) {
      closestAtom = aid;
      minDist = dist;
    }
  });
  if (closestAtom !== null) {
    return {
      id: closestAtom,
      dist: minDist
    };
  }
  return null;
}
function findClosestBond(restruct, pos, skip, minDist, scale) {
  var closestBond = null;
  var closestBondCenter = null;
  var maxMinDist = 0.8 * SELECTION_DISTANCE_COEFFICIENT;
  var skipId = skip && skip.map === 'bonds' ? skip.id : null;
  minDist = minDist || maxMinDist;
  minDist = Math.min(minDist, maxMinDist);
  var minCDist = minDist;
  restruct.bonds.forEach(function (bond, bid) {
    if (bid === skipId) return;
    var p1 = restruct.atoms.get(bond.b.begin).a.pp;
    var p2 = restruct.atoms.get(bond.b.end).a.pp;
    var mid = Vec2.lc2(p1, 0.5, p2, 0.5);
    var cdist = Vec2.dist(pos, mid);
    if (cdist < minCDist) {
      minCDist = cdist;
      closestBondCenter = bid;
    }
  });
  restruct.bonds.forEach(function (bond, bid) {
    if (bid === skipId) return;
    var hb = restruct.molecule.halfBonds.get(bond.b.hb1);
    var dir = hb.dir;
    var norm = hb.norm;
    var p1 = restruct.atoms.get(bond.b.begin).a.pp;
    var p2 = restruct.atoms.get(bond.b.end).a.pp;
    var inStripe = Vec2.dot(pos.sub(p1), dir) * Vec2.dot(pos.sub(p2), dir) < 0;
    if (inStripe) {
      var dist = Math.abs(Vec2.dot(pos.sub(p1), norm));
      if (dist < minDist) {
        closestBond = bid;
        minDist = dist;
      }
    }
  });
  if (closestBondCenter !== null) {
    return {
      id: closestBondCenter,
      dist: minCDist
    };
  }
  if (closestBond !== null && minDist > SELECTION_DISTANCE_COEFFICIENT * scale) {
    return {
      id: closestBond,
      dist: minDist
    };
  }
  return null;
}
function findClosestEnhancedFlag(restruct, pos, skip, _minDist, options) {
  var minDist;
  var ret = null;
  restruct.enhancedFlags.forEach(function (item, id) {
    var fragment = restruct.molecule.frags.get(id);
    if (!fragment || !fragment.enhancedStereoFlag || !options.showStereoFlags) return;
    var p = fragment.stereoFlagPosition ? new Vec2(fragment.stereoFlagPosition.x, fragment.stereoFlagPosition.y) : Fragment.getDefaultStereoFlagPosition(restruct.molecule, id);
    if (!p || Math.abs(pos.x - p.x) >= 1.0) return;
    var dist = Math.abs(pos.y - p.y);
    if (dist < 0.3 && (!ret || dist < minDist)) {
      minDist = dist;
      ret = {
        id: id,
        dist: minDist
      };
    }
  });
  return ret;
}
function findClosestDataSGroupData(restruct, pos) {
  var minDist = null;
  var ret = null;
  restruct.sgroupData.forEach(function (item, id) {
    if (item.sgroup.type !== 'DAT') throw new Error('Data group expected');
    if (item.sgroup.data.fieldName !== 'MRV_IMPLICIT_H') {
      var box = item.sgroup.dataArea;
      var inBox = box.p0.y < pos.y && box.p1.y > pos.y && box.p0.x < pos.x && box.p1.x > pos.x;
      var xDist = Math.min(Math.abs(box.p0.x - pos.x), Math.abs(box.p1.x - pos.x));
      if (inBox && (ret === null || xDist < minDist)) {
        ret = {
          id: id,
          dist: xDist
        };
        minDist = xDist;
      }
    }
  });
  return ret;
}
function findClosestFrag(restruct, pos, skip, minDist, scale) {
  minDist = Math.min(minDist || SELECTION_DISTANCE_COEFFICIENT, SELECTION_DISTANCE_COEFFICIENT);
  var struct = restruct.molecule;
  var closestAtom = findClosestAtom(restruct, pos, skip, minDist);
  if (closestAtom) {
    return {
      id: struct.atoms.get(closestAtom.id).fragment,
      dist: closestAtom.dist
    };
  }
  var closestBond = findClosestBond(restruct, pos, skip, minDist, scale);
  if (closestBond) {
    var atomId = struct.bonds.get(closestBond.id).begin;
    return {
      id: struct.atoms.get(atomId).fragment,
      dist: closestBond.dist
    };
  }
  return null;
}
function findClosestRGroup(restruct, pos, skip, minDist) {
  minDist = Math.min(minDist || SELECTION_DISTANCE_COEFFICIENT, SELECTION_DISTANCE_COEFFICIENT);
  var ret = null;
  restruct.rgroups.forEach(function (rgroup, rgid) {
    if (rgid !== skip && rgroup.labelBox && rgroup.labelBox.contains(pos, 0.5)) {
      var dist = Vec2.dist(rgroup.labelBox.centre(), pos);
      if (!ret || dist < minDist) {
        minDist = dist;
        ret = {
          id: rgid,
          dist: minDist
        };
      }
    }
  });
  return ret;
}
function findClosestRxnArrow(restruct, pos) {
  var minDist = null;
  var refPoint = null;
  var ret = null;
  restruct.rxnArrows.forEach(function (rxnArrow, id) {
    var dist = rxnArrow.calcDistance(pos, restruct.render.options.microModeScale);
    if (dist.minDist < 0.3 && (!ret || dist.minDist < minDist)) {
      minDist = dist.minDist;
      refPoint = dist.refPoint;
      ret = {
        id: id,
        dist: minDist,
        ref: refPoint
      };
    }
  });
  return ret;
}
function findClosestRxnPlus(restruct, pos) {
  var minDist = null;
  var ret = null;
  restruct.rxnPluses.forEach(function (plus, id) {
    var p = plus.item.pp;
    var dist = Math.max(Math.abs(pos.x - p.x), Math.abs(pos.y - p.y));
    if (dist < 0.3 && (!ret || dist < minDist)) {
      minDist = dist;
      ret = {
        id: id,
        dist: minDist
      };
    }
  });
  return ret;
}
function findClosestSGroup(restruct, pos) {
  var ret = null;
  var minDist = SELECTION_DISTANCE_COEFFICIENT;
  restruct.molecule.sgroups.forEach(function (sg, sgid) {
    if (sg.isContracted()) {
      var _sg$getContractedPosi = sg.getContractedPosition(restruct.molecule),
        position = _sg$getContractedPosi.position;
      var d = sg.bracketDirection;
      var n = d.rotateSC(1, 0);
      var pg = new Vec2(Vec2.dot(pos, d), Vec2.dot(pos, n));
      var shift = new Vec2(0.625, 0.625);
      var box = {
        p0: Vec2.diff(position, shift),
        p1: Vec2.sum(position, shift)
      };
      var inBox = box.p0.y < pg.y && box.p1.y > pg.y && box.p0.x < pg.x && box.p1.x > pg.x;
      var xDist = Math.min(Math.abs(box.p0.x - pg.x), Math.abs(box.p1.x - pg.x));
      if (inBox && (ret === null || xDist < minDist)) {
        ret = sgid;
        minDist = xDist;
      }
    } else {
      var _d = sg.bracketDirection;
      var _n = _d.rotateSC(1, 0);
      var _pg = new Vec2(Vec2.dot(pos, _d), Vec2.dot(pos, _n));
      sg.areas.forEach(function (box) {
        var inBox = box.p0.y < _pg.y && box.p1.y > _pg.y && box.p0.x < _pg.x && box.p1.x > _pg.x;
        var xDist = Math.min(Math.abs(box.p0.x - _pg.x), Math.abs(box.p1.x - _pg.x));
        if (inBox && (ret === null || xDist < minDist)) {
          ret = sgid;
          minDist = xDist;
        }
      });
    }
  });
  if (ret !== null) {
    return {
      id: ret,
      dist: minDist
    };
  }
  return null;
}
function findClosestItem(restruct, pos, maps, skip, scale) {
  maps = maps || Object.keys(findMaps);
  return maps.reduce(function (res, mp) {
    var minDist = res ? res.dist : null;
    var item = findMaps[mp](restruct, pos, skip, minDist, scale);
    if (item !== null && (res === null || item.dist < res.dist)) {
      var id = item.id,
        dist = item.dist,
        other = _objectWithoutProperties__default["default"](item, _excluded);
      return _objectSpread$6({
        map: mp,
        id: id,
        dist: dist
      }, other);
    }
    return res;
  }, null);
}
function findCloseMerge(restruct, selected) {
  var maps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['atoms', 'bonds'];
  var scale = arguments.length > 3 ? arguments[3] : undefined;
  var pos = {
    atoms: new Map(),
    bonds: new Map()
  };
  var struct = restruct.molecule;
  selected.atoms.forEach(function (aid) {
    pos.atoms.set(aid, struct.atoms.get(aid).pp);
  });
  selected.bonds.forEach(function (bid) {
    var bond = struct.bonds.get(bid);
    pos.bonds.set(bid, Vec2.lc2(struct.atoms.get(bond.begin).pp, 0.5, struct.atoms.get(bond.end).pp, 0.5));
  });
  var result = {};
  maps.forEach(function (mp) {
    result[mp] = Array.from(pos[mp].keys()).reduce(function (res, srcId) {
      var skip = {
        map: mp,
        id: srcId
      };
      var item = findMaps[mp](restruct, pos[mp].get(srcId), skip, null, scale);
      if (item && !selected[mp].includes(item.id)) res.set(srcId, item.id);
      return res;
    }, new Map());
  });
  return result;
}
var closest = {
  atom: findClosestAtom,
  item: findClosestItem,
  merge: findCloseMerge
};

function atomGetAttr(restruct, aid, name) {
  var atom = restruct.molecule.atoms.get(aid);
  if (!atom) return null;
  return atom[name];
}
function atomGetDegree(restruct, aid) {
  return restruct.atoms.get(aid).a.neighbors.length;
}
function atomGetSGroups(restruct, atomId) {
  return Array.from(restruct.atoms.get(atomId).a.sgs);
}
function atomGetPos(restruct, id) {
  return restruct.molecule.atoms.get(id).pp;
}
function findStereoAtoms(struct, atomIds) {
  if (!atomIds) {
    return [];
  }
  return atomIds.filter(function (atomId) {
    var atom = struct.atoms.get(atomId);
    if ((atom === null || atom === void 0 ? void 0 : atom.stereoLabel) !== null) {
      return true;
    }
    var connectedBonds = Atom.getConnectedBondIds(struct, atomId);
    var connectedWithStereoBond = connectedBonds.some(function (bondId) {
      var bond = struct.bonds.get(bondId);
      return (bond === null || bond === void 0 ? void 0 : bond.begin) === atomId && (bond === null || bond === void 0 ? void 0 : bond.stereo);
    });
    return connectedWithStereoBond;
  });
}
function structSelection(struct) {
  return selectionKeys.reduce(function (res, key) {
    res[key] = Array.from(struct[key].keys());
    return res;
  }, {});
}
function formatSelection(selection) {
  return selectionKeys.reduce(function (res, key) {
    res[key] = selection[key] || [];
    return res;
  }, {});
}
function atomForNewBond(restruct, id, bond) {
  var _atomNeighbours$;
  var neighbours = [];
  var pos = atomGetPos(restruct, id);
  var atomNeighbours = restruct.molecule.atomGetNeighbors(id);
  var prevBondId = restruct.molecule.findBondId(id, atomNeighbours.length ? (_atomNeighbours$ = atomNeighbours[0]) === null || _atomNeighbours$ === void 0 ? void 0 : _atomNeighbours$.aid : undefined);
  var prevBond = restruct.molecule.bonds.get(prevBondId);
  var prevBondType = prevBond ? prevBond.type : bond ? bond.type : 1;
  restruct.molecule.atomGetNeighbors(id).forEach(function (nei) {
    var neiPos = atomGetPos(restruct, nei.aid);
    if (Vec2.dist(pos, neiPos) < 0.1) return;
    neighbours.push({
      id: nei.aid,
      v: Vec2.diff(neiPos, pos)
    });
  });
  neighbours.sort(function (nei1, nei2) {
    return Math.atan2(nei1.v.y, nei1.v.x) - Math.atan2(nei2.v.y, nei2.v.x);
  });
  var i;
  var maxI = 0;
  var angle;
  var maxAngle = 0;
  for (i = 0; i < neighbours.length; i++) {
    angle = Vec2.angle(neighbours[i].v, neighbours[(i + 1) % neighbours.length].v);
    if (angle < 0) angle += 2 * Math.PI;
    if (angle > maxAngle) {
      maxI = i;
      maxAngle = angle;
    }
  }
  var v = new Vec2(1, 0);
  if (neighbours.length > 0) {
    if (neighbours.length === 1) {
      maxAngle = -(4 * Math.PI / 3);
      var nei = restruct.molecule.atomGetNeighbors(id)[0];
      if (atomGetDegree(restruct, nei.aid) > 1) {
        var neiNeighbours = [];
        var neiPos = atomGetPos(restruct, nei.aid);
        var neiV = Vec2.diff(pos, neiPos);
        var neiAngle = Math.atan2(neiV.y, neiV.x);
        restruct.molecule.atomGetNeighbors(nei.aid).forEach(function (neiNei) {
          var neiNeiPos = atomGetPos(restruct, neiNei.aid);
          if (neiNei.bid === nei.bid || Vec2.dist(neiPos, neiNeiPos) < 0.1) {
            return;
          }
          var vDiff = Vec2.diff(neiNeiPos, neiPos);
          var ang = Math.atan2(vDiff.y, vDiff.x) - neiAngle;
          if (ang < 0) ang += 2 * Math.PI;
          neiNeighbours.push(ang);
        });
        neiNeighbours.sort(function (nei1, nei2) {
          return nei1 - nei2;
        });
        if (neiNeighbours[0] <= Math.PI * 1.01 && neiNeighbours[neiNeighbours.length - 1] <= 1.01 * Math.PI) {
          maxAngle *= -1;
        }
      }
    }
    var shallBe180DegToPrevBond = neighbours.length === 1 && prevBondType === (bond === null || bond === void 0 ? void 0 : bond.type) && ((bond === null || bond === void 0 ? void 0 : bond.type) === Bond.PATTERN.TYPE.DOUBLE || (bond === null || bond === void 0 ? void 0 : bond.type) === Bond.PATTERN.TYPE.TRIPLE) || prevBondType === Bond.PATTERN.TYPE.SINGLE && (bond === null || bond === void 0 ? void 0 : bond.type) === Bond.PATTERN.TYPE.TRIPLE || prevBondType === Bond.PATTERN.TYPE.TRIPLE && (bond === null || bond === void 0 ? void 0 : bond.type) === Bond.PATTERN.TYPE.SINGLE;
    if (shallBe180DegToPrevBond) {
      var prevBondAngle = restruct.molecule.bonds.get(prevBondId).angle;
      if (prevBondAngle > -90 && prevBondAngle < 90 && neighbours[0].v.x > 0) {
        angle = prevBondAngle * Math.PI / 180 + Math.PI;
      } else {
        angle = prevBondAngle * Math.PI / 180;
      }
    } else {
      angle = maxAngle / 2 + Math.atan2(neighbours[maxI].v.y, neighbours[maxI].v.x);
    }
    v = v.rotate(angle);
  }
  v.add_(pos);
  var a = closest.atom(restruct, v, null, 0.1);
  a = a === null ? {
    label: 'C'
  } : a.id;
  return {
    atom: a,
    pos: v
  };
}
function getRelSGroupsBySelection(struct, selectedAtoms) {
  return struct.sgroups.filter(function (_sgid, sg) {
    return !sg.data.attached && !sg.data.absolute && _.difference(sg.atoms, selectedAtoms).length === 0;
  });
}
function isAttachmentBond(_ref, selection) {
  var begin = _ref.begin,
    end = _ref.end;
  if (!selection.atoms) {
    return false;
  }
  var isBondStartsInSelectionAndEndsOutside = selection.atoms.includes(begin) && !selection.atoms.includes(end);
  var isBondEndsInSelectionAndStartsOutside = selection.atoms.includes(end) && !selection.atoms.includes(begin);
  return isBondStartsInSelectionAndEndsOutside || isBondEndsInSelectionAndStartsOutside;
}

function fromRGroupAttrs(restruct, id, attrs) {
  var action = new Action();
  Object.keys(attrs).forEach(function (key) {
    action.addOp(new RGroupAttr(id, key, attrs[key]));
  });
  return action.perform(restruct);
}
function fromRGroupFragment(restruct, rgidNew, frid) {
  var action = new Action();
  action.addOp(new RGroupFragment(rgidNew, frid));
  return action.perform(restruct);
}
function fromUpdateIfThen(restruct, rgidNew, rgidOld) {
  var skipRgids = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var action = new Action();
  if (!restruct.molecule.rgroups.get(rgidOld)) {
    action.addOp(new UpdateIfThen(rgidNew, rgidOld, skipRgids));
  }
  return action.perform(restruct);
}

function _callSuper$1(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }
var SGroupAttachmentPointAdd = function (_BaseOperation) {
  _inherits__default["default"](SGroupAttachmentPointAdd, _BaseOperation);
  function SGroupAttachmentPointAdd(sGroupId, attachmentPoint) {
    var _this;
    _classCallCheck__default["default"](this, SGroupAttachmentPointAdd);
    _this = _callSuper$1(this, SGroupAttachmentPointAdd, [OperationType.S_GROUP_ATTACHMENT_POINT_ADD, exports.OperationPriority.S_GROUP_ATTACHMENT_POINT_ADD]);
    _this.data = {
      sGroupId: sGroupId,
      attachmentPoint: attachmentPoint
    };
    return _this;
  }
  _createClass__default["default"](SGroupAttachmentPointAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var struct = restruct.molecule;
      var sgroup = struct.sgroups.get(this.data.sGroupId);
      assert__default["default"](sgroup != null);
      var attachmentPoint = this.data.attachmentPoint;
      var apAtom = struct.atoms.get(attachmentPoint.atomId);
      if (!apAtom) {
        throw new Error("attachmentPoint for Atom with id \"".concat(attachmentPoint.atomId, "\" is not found"));
      }
      sgroup.addAttachmentPoint(attachmentPoint);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new SGroupAttachmentPointRemove(this.data.sGroupId, this.data.attachmentPoint);
    }
  }]);
  return SGroupAttachmentPointAdd;
}(BaseOperation);
var SGroupAttachmentPointRemove = function (_BaseOperation2) {
  _inherits__default["default"](SGroupAttachmentPointRemove, _BaseOperation2);
  function SGroupAttachmentPointRemove(sGroupId, attachmentPoint) {
    var _this2;
    _classCallCheck__default["default"](this, SGroupAttachmentPointRemove);
    _this2 = _callSuper$1(this, SGroupAttachmentPointRemove, [OperationType.S_GROUP_ATTACHMENT_POINT_REMOVE, 4]);
    _this2.data = {
      sGroupId: sGroupId,
      attachmentPoint: attachmentPoint
    };
    return _this2;
  }
  _createClass__default["default"](SGroupAttachmentPointRemove, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        sGroupId = _this$data.sGroupId,
        attachmentPoint = _this$data.attachmentPoint;
      var struct = restruct.molecule;
      var sgroup = struct.sgroups.get(sGroupId);
      sgroup === null || sgroup === void 0 || sgroup.removeAttachmentPoint(attachmentPoint.atomId);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new SGroupAttachmentPointAdd(this.data.sGroupId, this.data.attachmentPoint);
    }
  }]);
  return SGroupAttachmentPointRemove;
}(BaseOperation);

function fromSeveralSgroupAddition(restruct, type, atoms, attrs) {
  var descriptors = attrs.fieldValue;
  if (typeof descriptors === 'string' || type !== 'DAT') {
    return fromSgroupAddition(restruct, type, atoms, attrs, restruct.molecule.sgroups.newId(), []);
  }
  return descriptors.reduce(function (acc, fValue) {
    var localAttrs = Object.assign({}, attrs);
    localAttrs.fieldValue = fValue;
    return acc.mergeWith(fromSgroupAddition(restruct, type, atoms, localAttrs, restruct.molecule.sgroups.newId(), []));
  }, new Action());
}
function fromSgroupAttrs(restruct, id, attrs) {
  var action = new Action();
  Object.keys(attrs).forEach(function (key) {
    action.addOp(new SGroupAttr(id, key, attrs[key]));
  });
  return action.perform(restruct);
}
function setExpandSGroup(restruct, sgid, attrs) {
  var action = new Action();
  Object.keys(attrs).forEach(function (key) {
    action.addOp(new SGroupAttr(sgid, key, attrs[key]));
  });
  var sgroup = restruct.molecule.sgroups.get(sgid);
  assert__default["default"](sgroup != null);
  var atoms = SGroup.getAtoms(restruct, sgroup);
  atoms.forEach(function (aid) {
    var _restruct$atoms$get;
    action.mergeWith(fromAtomsAttrs(restruct, aid, (_restruct$atoms$get = restruct.atoms.get(aid)) === null || _restruct$atoms$get === void 0 ? void 0 : _restruct$atoms$get.a, false));
  });
  return action.perform(restruct);
}
function expandSGroupWithMultipleAttachmentPoint(restruct) {
  var action = new Action();
  var struct = restruct.molecule;
  struct.sgroups.forEach(function (sgroup) {
    if (sgroup.isNotContractible(struct) && !(sgroup instanceof MonomerMicromolecule)) {
      action.mergeWith(setExpandSGroup(restruct, sgroup.id, {
        expanded: true
      }));
    }
  });
  return action;
}
function sGroupAttributeAction(id, attrs) {
  var action = new Action();
  Object.keys(attrs).forEach(function (key) {
    action.addOp(new SGroupAttr(id, key, attrs[key]));
  });
  return action;
}
function fromSgroupDeletion(restruct, id) {
  var action = new Action();
  var struct = restruct.molecule;
  var sG = restruct.sgroups.get(id).item;
  if (sG.type === 'SRU') {
    struct.sGroupsRecalcCrossBonds();
    sG.neiAtoms.forEach(function (aid) {
      if (atomGetAttr(restruct, aid, 'label') === '*') {
        action.addOp(new AtomAttr(aid, 'label', 'C'));
      }
    });
  }
  var sg = struct.sgroups.get(id);
  var atoms = SGroup.getAtoms(struct, sg);
  var attrs = sg.getAttrs();
  action.addOp(new SGroupRemoveFromHierarchy(id));
  atoms.forEach(function (atom) {
    action.addOp(new SGroupAtomRemove(id, atom));
  });
  sg.getAttachmentPoints().forEach(function (attachmentPoint) {
    action.addOp(new SGroupAttachmentPointRemove(id, attachmentPoint));
  });
  action.addOp(new SGroupDelete(id));
  action = action.perform(restruct);
  action.mergeWith(sGroupAttributeAction(id, attrs));
  return action;
}
function fromSgroupAddition(restruct, type, atoms, attrs, sgid, attachmentPoints, pp, expanded, name, oldSgroup) {
  var action = new Action();
  sgid = sgid - 0 === sgid ? sgid : restruct.molecule.sgroups.newId();
  if (type === 'SUP') {
    action.addOp(new SGroupCreate(sgid, type, pp, expanded, name, oldSgroup));
  } else {
    action.addOp(new SGroupCreate(sgid, type, pp));
  }
  atoms.forEach(function (atom) {
    action.addOp(new SGroupAtomAdd(sgid, atom));
  });
  if (type === 'SUP') {
    attachmentPoints.forEach(function (attachmentPoint) {
      action.addOp(new SGroupAttachmentPointAdd(sgid, attachmentPoint));
    });
  }
  action.addOp(type !== 'DAT' ? new SGroupAddToHierarchy(sgid) : new SGroupAddToHierarchy(sgid, -1, []));
  action = action.perform(restruct);
  if (type === 'SRU') {
    restruct.molecule.sGroupsRecalcCrossBonds();
    var asteriskAction = new Action();
    restruct.sgroups.get(sgid).item.neiAtoms.forEach(function (aid) {
      var plainCarbon = restruct.atoms.get(aid).a.isPlainCarbon();
      if (atomGetDegree(restruct, aid) === 1 && plainCarbon) {
        asteriskAction.addOp(new AtomAttr(aid, 'label', '*'));
      }
    });
    asteriskAction = asteriskAction.perform(restruct);
    asteriskAction.mergeWith(action);
    action = asteriskAction;
  }
  return fromSgroupAttrs(restruct, sgid, attrs).mergeWith(action);
}
function fromSgroupAction(context, restruct, newSg, sourceAtoms, selection) {
  if (context === SgContexts.Bond) {
    return fromBondAction(restruct, newSg, sourceAtoms, selection);
  }
  var atomsFromBonds = getAtomsFromBonds(restruct.molecule, selection.bonds);
  var newSourceAtoms = fp.uniq(sourceAtoms.concat(atomsFromBonds));
  if (context === SgContexts.Fragment) {
    return fromGroupAction(restruct, newSg, newSourceAtoms, Array.from(restruct.atoms.keys()));
  }
  if (context === SgContexts.Multifragment) {
    return fromMultiFragmentAction(restruct, newSg, newSourceAtoms);
  }
  if (context === SgContexts.Group) {
    return fromGroupAction(restruct, newSg, newSourceAtoms, newSourceAtoms);
  }
  if (context === SgContexts.Atom) {
    return fromAtomAction(restruct, newSg, newSourceAtoms);
  }
  if (SGroup.isQuerySGroup(newSg)) {
    return fromQueryComponentSGroupAction(restruct, newSg, newSourceAtoms, Array.from(restruct.atoms.keys()));
  }
  return {
    action: fromSeveralSgroupAddition(restruct, newSg.type, newSourceAtoms, newSg.attrs)
  };
}
function fromAtomAction(restruct, newSg, sourceAtoms) {
  return sourceAtoms.reduce(function (acc, atom) {
    acc.action = acc.action.mergeWith(fromSeveralSgroupAddition(restruct, newSg.type, [atom], newSg.attrs));
    return acc;
  }, {
    action: new Action(),
    selection: {
      atoms: sourceAtoms,
      bonds: []
    }
  });
}
function fromQueryComponentSGroupAction(restruct, newSg, sourceAtoms, targetAtoms) {
  var selection = {
    atoms: [],
    bonds: []
  };
  var allFragments = new Pile(sourceAtoms.map(function (aid) {
    var _restruct$atoms$get2;
    return (_restruct$atoms$get2 = restruct.atoms.get(aid)) === null || _restruct$atoms$get2 === void 0 ? void 0 : _restruct$atoms$get2.a.fragment;
  }));
  Array.from(allFragments).forEach(function (fragId) {
    var atoms = targetAtoms.reduce(function (res, aid) {
      var _restruct$atoms$get3;
      var atom = (_restruct$atoms$get3 = restruct.atoms.get(aid)) === null || _restruct$atoms$get3 === void 0 ? void 0 : _restruct$atoms$get3.a;
      if (fragId === (atom === null || atom === void 0 ? void 0 : atom.fragment)) res.push(aid);
      return res;
    }, []);
    var bonds = getAtomsBondIds(restruct.molecule, atoms);
    selection.atoms = selection.atoms.concat(atoms);
    selection.bonds = selection.bonds.concat(bonds);
  });
  return {
    action: fromSeveralSgroupAddition(restruct, newSg.type, selection.atoms, newSg.attrs),
    selection: selection
  };
}
function fromGroupAction(restruct, newSg, sourceAtoms, targetAtoms) {
  var allFragments = new Pile(sourceAtoms.map(function (aid) {
    return restruct.atoms.get(aid).a.fragment;
  }));
  return Array.from(allFragments).reduce(function (acc, fragId) {
    var atoms = targetAtoms.reduce(function (res, aid) {
      var atom = restruct.atoms.get(aid).a;
      if (fragId === atom.fragment) res.push(aid);
      return res;
    }, []);
    var bonds = getAtomsBondIds(restruct.molecule, atoms);
    acc.action = acc.action.mergeWith(fromSeveralSgroupAddition(restruct, newSg.type, atoms, newSg.attrs));
    acc.selection.atoms = acc.selection.atoms.concat(atoms);
    acc.selection.bonds = acc.selection.bonds.concat(bonds);
    return acc;
  }, {
    action: new Action(),
    selection: {
      atoms: [],
      bonds: []
    }
  });
}
function fromBondAction(restruct, newSg, sourceAtoms, currSelection) {
  var struct = restruct.molecule;
  var bonds = getAtomsBondIds(struct, sourceAtoms);
  if (currSelection.bonds) bonds = fp.uniq(bonds.concat(currSelection.bonds));
  return bonds.reduce(function (acc, bondid) {
    var bond = struct.bonds.get(bondid);
    acc.action = acc.action.mergeWith(fromSeveralSgroupAddition(restruct, newSg.type, [bond.begin, bond.end], newSg.attrs));
    acc.selection.bonds.push(bondid);
    return acc;
  }, {
    action: new Action(),
    selection: {
      atoms: sourceAtoms,
      bonds: []
    }
  });
}
function fromMultiFragmentAction(restruct, newSg, atoms) {
  var bonds = getAtomsBondIds(restruct.molecule, atoms);
  return {
    action: fromSeveralSgroupAddition(restruct, newSg.type, atoms, newSg.attrs),
    selection: {
      atoms: atoms,
      bonds: bonds
    }
  };
}
function removeAtomFromSgroupIfNeeded(action, restruct, id) {
  var sgroups = atomGetSGroups(restruct, id);
  if (sgroups.length > 0) {
    sgroups.forEach(function (sid) {
      action.addOp(new SGroupAtomRemove(sid, id));
    });
    return true;
  }
  return false;
}
function removeSgroupIfNeeded(action, restruct, atoms) {
  var struct = restruct.molecule;
  var sgCounts = new Map();
  atoms.forEach(function (id) {
    var sgroups = atomGetSGroups(restruct, id);
    sgroups.forEach(function (sid) {
      sgCounts.set(sid, sgCounts.has(sid) ? sgCounts.get(sid) + 1 : 1);
    });
  });
  sgCounts.forEach(function (count, sid) {
    var sG = restruct.sgroups.get(sid).item;
    var sgAtoms = SGroup.getAtoms(restruct.molecule, sG);
    if (sgAtoms.length === count) {
      var sgroup = struct.sgroups.get(sid);
      action.mergeWith(sGroupAttributeAction(sid, sgroup.getAttrs()));
      action.addOp(new SGroupRemoveFromHierarchy(sid));
      sgroup.getAttachmentPoints().forEach(function (attachmentPoint) {
        action.addOp(new SGroupAttachmentPointRemove(sid, attachmentPoint));
      });
      action.addOp(new SGroupDelete(sid));
    }
  });
}
function getAtomsBondIds(struct, atoms) {
  var atomSet = new Pile(atoms);
  return Array.from(struct.bonds.keys()).filter(function (bid) {
    var bond = struct.bonds.get(bid);
    return atomSet.has(bond.begin) && atomSet.has(bond.end);
  });
}
function getAtomsFromBonds(struct, bonds) {
  bonds = bonds || [];
  return bonds.reduce(function (acc, bondid) {
    var bond = struct.bonds.get(bondid);
    acc = acc.concat([bond.begin, bond.end]);
    return acc;
  }, []);
}

function ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function fromBondAddition(reStruct, bond, begin, end, beginAtomPos, endAtomPos) {
  var _struct$frags$get;
  var action = new Action();
  var struct = reStruct.molecule;
  var mouseDownNothingAndUpNothing = function mouseDownNothingAndUpNothing(beginAtomAttr, endAtomAttr) {
    var newFragmentId = action.addOp(new FragmentAdd().perform(reStruct)).frid;
    var newBeginAtomId = action.addOp(new AtomAdd(_objectSpread$5(_objectSpread$5({}, beginAtomAttr), {}, {
      fragment: newFragmentId
    }), beginAtomPos).perform(reStruct)).data.aid;
    var newEndAtomId = action.addOp(new AtomAdd(_objectSpread$5(_objectSpread$5({}, endAtomAttr), {}, {
      fragment: newFragmentId
    }), endAtomPos).perform(reStruct)).data.aid;
    return [newBeginAtomId, newEndAtomId];
  };
  var mouseDownNothingAndUpAtom = function mouseDownNothingAndUpAtom(beginAtomAttr, endAtomId) {
    var fragmentId = atomGetAttr(reStruct, endAtomId, 'fragment');
    var newBeginAtomId = action.addOp(new AtomAdd(_objectSpread$5(_objectSpread$5({}, beginAtomAttr), {}, {
      fragment: fragmentId
    }), beginAtomPos).perform(reStruct)).data.aid;
    var endAtom = struct.atoms.get(endAtomId);
    if (endAtom && !FunctionalGroup.isAtomInContractedFunctionalGroup(endAtom, struct.sgroups, struct.functionalGroups, false)) {
      mergeSgroups(action, reStruct, [newBeginAtomId], endAtomId);
    }
    return [newBeginAtomId, endAtomId];
  };
  var mouseDownAtomAndUpNothing = function mouseDownAtomAndUpNothing(beginAtomId, endAtomAttr) {
    var fragmentId = atomGetAttr(reStruct, beginAtomId, 'fragment');
    var newEndAtomId = action.addOp(new AtomAdd(_objectSpread$5(_objectSpread$5({}, endAtomAttr), {}, {
      fragment: fragmentId
    }), endAtomPos !== null && endAtomPos !== void 0 ? endAtomPos : atomForNewBond(reStruct, begin, bond).pos).perform(reStruct)).data.aid;
    var beginAtom = struct.atoms.get(beginAtomId);
    if (beginAtom && !FunctionalGroup.isAtomInContractedFunctionalGroup(beginAtom, struct.sgroups, struct.functionalGroups, false)) {
      mergeSgroups(action, reStruct, [newEndAtomId], beginAtomId);
    }
    return [beginAtomId, newEndAtomId];
  };
  var beginAtomId, endAtomId;
  var startsOnAtom = typeof begin === 'number';
  var endsOnAtom = typeof end === 'number';
  if (!startsOnAtom && !endsOnAtom) {
    var _mouseDownNothingAndU = mouseDownNothingAndUpNothing(begin, end);
    var _mouseDownNothingAndU2 = _slicedToArray__default["default"](_mouseDownNothingAndU, 2);
    beginAtomId = _mouseDownNothingAndU2[0];
    endAtomId = _mouseDownNothingAndU2[1];
  } else if (!startsOnAtom && endsOnAtom) {
    var _mouseDownNothingAndU3 = mouseDownNothingAndUpAtom(begin, end);
    var _mouseDownNothingAndU4 = _slicedToArray__default["default"](_mouseDownNothingAndU3, 2);
    beginAtomId = _mouseDownNothingAndU4[0];
    endAtomId = _mouseDownNothingAndU4[1];
  } else if (startsOnAtom && !endsOnAtom) {
    var _mouseDownAtomAndUpNo = mouseDownAtomAndUpNothing(begin, end);
    var _mouseDownAtomAndUpNo2 = _slicedToArray__default["default"](_mouseDownAtomAndUpNo, 2);
    beginAtomId = _mouseDownAtomAndUpNo2[0];
    endAtomId = _mouseDownAtomAndUpNo2[1];
  } else {
    beginAtomId = begin;
    endAtomId = end;
  }
  if (atomGetAttr(reStruct, beginAtomId, 'label') === '*') {
    action.addOp(new AtomAttr(beginAtomId, 'label', 'C').perform(reStruct));
  }
  if (atomGetAttr(reStruct, endAtomId, 'label') === '*') {
    action.addOp(new AtomAttr(endAtomId, 'label', 'C').perform(reStruct));
  }
  var newBondId = action.addOp(new BondAdd(beginAtomId, endAtomId, bond).perform(reStruct)).data.bid;
  var newBond = struct.bonds.get(newBondId);
  if (newBond) {
    action.addOp(new CalcImplicitH([newBond.begin, newBond.end]).perform(reStruct));
    action.mergeWith(fromBondStereoUpdate(reStruct, newBond));
  }
  action.operations.reverse();
  var mergedFragmentId = mergeFragmentsIfNeeded(action, reStruct, beginAtomId, endAtomId);
  if ((_struct$frags$get = struct.frags.get(mergedFragmentId || 0)) !== null && _struct$frags$get !== void 0 && _struct$frags$get.stereoAtoms && !bond.stereo) {
    action.addOp(new FragmentStereoFlag(mergedFragmentId || 0).perform(reStruct));
  }
  return [action, beginAtomId, endAtomId, newBondId];
}
function fromBondsAttrs(restruct, ids, attrs, reset) {
  var struct = restruct.molecule;
  var action = new Action();
  var bids = Array.isArray(ids) ? ids : [ids];
  bids.forEach(function (bid) {
    Object.keys(Bond.attrlist).forEach(function (key) {
      if (!(key in attrs) && !reset) return;
      var value = key in attrs ? attrs[key] : Bond.attrGetDefault(key);
      action.addOp(new BondAttr(bid, key, value).perform(restruct));
      if (key === 'stereo' && key in attrs) {
        var bond = struct.bonds.get(bid);
        if (bond) {
          action.addOp(new CalcImplicitH([bond.begin, bond.end]).perform(restruct));
          action.mergeWith(fromBondStereoUpdate(restruct, bond));
        }
      }
    });
  });
  return action;
}
function fromBondsMerge(restruct, mergeMap) {
  var struct = restruct.molecule;
  var atomPairs = new Map();
  var action = new Action();
  mergeMap.forEach(function (dstId, srcId) {
    var bond = struct.bonds.get(srcId);
    var bondCI = struct.bonds.get(dstId);
    if (!bond || !bondCI) return;
    var params = utils$1.mergeBondsParams(struct, bond, struct, bondCI);
    if (!params.merged) return;
    atomPairs.set(bond.begin, !params.cross ? bondCI.begin : bondCI.end);
    atomPairs.set(bond.end, !params.cross ? bondCI.end : bondCI.begin);
  });
  atomPairs.forEach(function (dst, src) {
    action = fromAtomMerge(restruct, src, dst).mergeWith(action);
  });
  return action;
}
function fromBondFlipping(restruct, id) {
  var bond = restruct.molecule.bonds.get(id);
  var action = new Action();
  action.addOp(new BondDelete(id).perform(restruct));
  if (Number.isInteger(bond === null || bond === void 0 ? void 0 : bond.end) && Number.isInteger(bond === null || bond === void 0 ? void 0 : bond.begin)) {
    action.addOp(new BondAdd(bond === null || bond === void 0 ? void 0 : bond.end, bond === null || bond === void 0 ? void 0 : bond.begin, bond).perform(restruct));
  }
  return action;
}
function fromBondStereoUpdate(restruct, bond, withReverse) {
  var _struct$atoms$get, _struct$atoms$get2;
  var action = new Action();
  var struct = restruct.molecule;
  var beginFrId = (_struct$atoms$get = struct.atoms.get(bond === null || bond === void 0 ? void 0 : bond.begin)) === null || _struct$atoms$get === void 0 ? void 0 : _struct$atoms$get.fragment;
  var endFrId = (_struct$atoms$get2 = struct.atoms.get(bond === null || bond === void 0 ? void 0 : bond.end)) === null || _struct$atoms$get2 === void 0 ? void 0 : _struct$atoms$get2.fragment;
  var fragmentStereoBonds = [];
  struct.bonds.forEach(function (bond) {
    var _struct$atoms$get3, _struct$atoms$get4;
    if (((_struct$atoms$get3 = struct.atoms.get(bond.begin)) === null || _struct$atoms$get3 === void 0 ? void 0 : _struct$atoms$get3.fragment) === beginFrId) {
      fragmentStereoBonds.push(bond);
    }
    if (beginFrId !== endFrId && ((_struct$atoms$get4 = struct.atoms.get(bond.begin)) === null || _struct$atoms$get4 === void 0 ? void 0 : _struct$atoms$get4.fragment) === endFrId) {
      fragmentStereoBonds.push(bond);
    }
  });
  var stereoAtomsMap = getStereoAtomsMap(struct, fragmentStereoBonds, bond);
  stereoAtomsMap.forEach(function (stereoProp, aId) {
    var _struct$atoms$get5;
    if (((_struct$atoms$get5 = struct.atoms.get(aId)) === null || _struct$atoms$get5 === void 0 ? void 0 : _struct$atoms$get5.stereoLabel) !== stereoProp.stereoLabel) {
      action.mergeWith(fromStereoAtomAttrs(restruct, aId, stereoProp, withReverse));
    }
  });
  return action;
}
function getStereoAtomsMap(struct, bonds, bond) {
  var stereoAtomsMap = new Map();
  var correctAtomIds = [];
  bonds.forEach(function (bond) {
    if (bond) {
      var beginNeighs = struct.atomGetNeighbors(bond.begin);
      var endNeighs = struct.atomGetNeighbors(bond.end);
      if (StereoValidator.isCorrectStereoCenter(bond, beginNeighs, endNeighs, struct)) {
        var _struct$atoms$get6, _stereoAtomsMap$get;
        var stereoLabel = (_struct$atoms$get6 = struct.atoms.get(bond.begin)) === null || _struct$atoms$get6 === void 0 ? void 0 : _struct$atoms$get6.stereoLabel;
        if (stereoLabel == null || ((_stereoAtomsMap$get = stereoAtomsMap.get(bond.begin)) === null || _stereoAtomsMap$get === void 0 ? void 0 : _stereoAtomsMap$get.stereoLabel) == null) {
          stereoAtomsMap.set(bond.begin, {
            stereoParity: getStereoParity(bond.stereo),
            stereoLabel: stereoLabel || "".concat(exports.StereoLabel.Abs)
          });
        }
        correctAtomIds.push(bond.begin);
      } else {
        if (!correctAtomIds.includes(bond.begin)) {
          stereoAtomsMap.set(bond.begin, {
            stereoParity: Atom.PATTERN.STEREO_PARITY.NONE,
            stereoLabel: null
          });
        }
        if (!correctAtomIds.includes(bond.end)) {
          stereoAtomsMap.set(bond.end, {
            stereoParity: Atom.PATTERN.STEREO_PARITY.NONE,
            stereoLabel: null
          });
        }
      }
    }
  });
  if (bond) {
    if (!correctAtomIds.includes(bond.begin)) {
      stereoAtomsMap.set(bond.begin, {
        stereoParity: Atom.PATTERN.STEREO_PARITY.NONE,
        stereoLabel: null
      });
    }
    if (!correctAtomIds.includes(bond.end)) {
      stereoAtomsMap.set(bond.end, {
        stereoParity: Atom.PATTERN.STEREO_PARITY.NONE,
        stereoLabel: null
      });
    }
  }
  return stereoAtomsMap;
}
function getStereoParity(stereo) {
  var newAtomParity = null;
  switch (stereo) {
    case Bond.PATTERN.STEREO.UP:
      newAtomParity = Atom.PATTERN.STEREO_PARITY.ODD;
      break;
    case Bond.PATTERN.STEREO.EITHER:
      newAtomParity = Atom.PATTERN.STEREO_PARITY.EITHER;
      break;
    case Bond.PATTERN.STEREO.DOWN:
      newAtomParity = Atom.PATTERN.STEREO_PARITY.EVEN;
      break;
  }
  return newAtomParity;
}
var plainBondTypes = [Bond.PATTERN.TYPE.SINGLE, Bond.PATTERN.TYPE.DOUBLE, Bond.PATTERN.TYPE.TRIPLE];
function bondChangingAction(restruct, itemID, bond, bondProps) {
  var action = new Action();
  var newItemId = itemID;
  if ((bondProps.stereo !== Bond.PATTERN.STEREO.NONE &&
  bondProps.type === Bond.PATTERN.TYPE.SINGLE || bond.type === Bond.PATTERN.TYPE.DATIVE) && bond.type === bondProps.type && bond.stereo === bondProps.stereo) {
    action.mergeWith(fromBondFlipping(restruct, itemID));
    newItemId = action.operations[1].data.bid;
  }
  var loop = plainBondTypes.includes(bondProps.type) ? plainBondTypes : null;
  if (bondProps.stereo === Bond.PATTERN.STEREO.NONE && bondProps.type === Bond.PATTERN.TYPE.SINGLE && bond.stereo === Bond.PATTERN.STEREO.NONE && loop) {
    bondProps.type = loop[(loop.indexOf(bond.type) + 1) % loop.length];
  }
  return fromBondsAttrs(restruct, newItemId, bondProps).mergeWith(action);
}

function fromAtomAddition(restruct, pos, atom) {
  atom = Object.assign({}, atom);
  var action = new Action();
  atom.fragment = action.addOp(new FragmentAdd().perform(restruct)).frid;
  var aid = action.addOp(new AtomAdd(atom, pos).perform(restruct)).data.aid;
  action.addOp(new CalcImplicitH([aid]).perform(restruct));
  return action;
}
function fromAtomsAttrs(restruct, ids, attrs, reset) {
  var action = new Action();
  var aids = Array.isArray(ids) ? ids : [ids];
  aids.forEach(function (atomId) {
    var _atomNeighbors$;
    Object.keys(Atom.attrlist).forEach(function (key) {
      if (key === 'attachmentPoints' && !(key in attrs)) return;
      if (!(key in attrs) && !reset) return;
      var value = key in attrs ? attrs[key] : Atom.attrGetDefault(key);
      switch (key) {
        case 'stereoLabel':
          if (key in attrs && value) {
            action.addOp(new AtomAttr(atomId, key, value).perform(restruct));
          }
          break;
        case 'stereoParity':
          if (key in attrs && value) {
            action.addOp(new AtomAttr(atomId, key, value).perform(restruct));
          }
          break;
        default:
          action.addOp(new AtomAttr(atomId, key, value).perform(restruct));
          break;
      }
    });
    if (!reset && 'label' in attrs && attrs.label !== null && attrs.label !== 'L#' && !('atomList' in attrs)) {
      action.addOp(new AtomAttr(atomId, 'atomList', null).perform(restruct));
    }
    action.addOp(new CalcImplicitH([atomId]).perform(restruct));
    var atomNeighbors = restruct.molecule.atomGetNeighbors(atomId);
    var bond = restruct.molecule.bonds.get(atomNeighbors === null || atomNeighbors === void 0 || (_atomNeighbors$ = atomNeighbors[0]) === null || _atomNeighbors$ === void 0 ? void 0 : _atomNeighbors$.bid);
    if (bond) {
      action.mergeWith(fromBondStereoUpdate(restruct, bond));
    }
    var atom = restruct.molecule.atoms.get(atomId);
    assert__default["default"](atom != null);
    if (Atom.isInAromatizedRing(restruct.molecule, atomId)) {
      action.addOp(new AtomAttr(atomId, 'implicitHCount', atom.implicitH).perform(restruct));
    }
  });
  return action;
}
function fromStereoAtomAttrs(restruct, aid, attrs, withReverse) {
  var action = new Action();
  var atom = restruct.molecule.atoms.get(aid);
  if (atom) {
    var frid = atom.fragment;
    if ('stereoParity' in attrs) {
      action.addOp(new AtomAttr(aid, 'stereoParity', attrs.stereoParity).perform(restruct));
    }
    if ('stereoLabel' in attrs) {
      action.addOp(new AtomAttr(aid, 'stereoLabel', attrs.stereoLabel).perform(restruct));
      if (attrs.stereoLabel === null) {
        action.addOp(new FragmentDeleteStereoAtom(frid, aid).perform(restruct));
      } else {
        action.addOp(new FragmentAddStereoAtom(frid, aid).perform(restruct));
      }
    }
    if (withReverse) action.operations.reverse();
  }
  return action;
}
function fromAtomsFragmentAttr(restruct, aids, newfrid) {
  var action = new Action();
  aids.forEach(function (aid) {
    var atom = restruct.molecule.atoms.get(aid);
    var oldfrid = atom.fragment;
    action.addOp(new AtomAttr(aid, 'fragment', newfrid));
    if (atom.stereoLabel !== null) {
      action.addOp(new FragmentAddStereoAtom(newfrid, aid));
      action.addOp(new FragmentDeleteStereoAtom(oldfrid, aid));
    }
  });
  return action.perform(restruct);
}
function fromAtomMerge(restruct, srcId, dstId) {
  var _dstAtomNeighbors$, _atomNeighbors$2;
  if (srcId === dstId) return new Action();
  var fragAction = new Action();
  mergeFragmentsIfNeeded(fragAction, restruct, srcId, dstId);
  var action = new Action();
  var atomNeighbors = restruct.molecule.atomGetNeighbors(srcId);
  atomNeighbors.forEach(function (nei) {
    var bond = restruct.molecule.bonds.get(nei.bid);
    if (dstId === bond.begin || dstId === bond.end) {
      action.addOp(new BondDelete(nei.bid));
      return;
    }
    var begin = bond.begin === nei.aid ? nei.aid : dstId;
    var end = bond.begin === nei.aid ? dstId : nei.aid;
    var mergeBondId = restruct.molecule.findBondId(begin, end);
    if (mergeBondId === null) {
      action.addOp(new BondAdd(begin, end, bond));
    } else {
      var _attrs = Bond.getAttrHash(bond);
      Object.keys(_attrs).forEach(function (key) {
        action.addOp(new BondAttr(mergeBondId, key, _attrs[key]));
      });
    }
    action.addOp(new BondDelete(nei.bid));
  });
  var attrs = Atom.getAttrHash(restruct.molecule.atoms.get(srcId));
  if (atomGetDegree(restruct, srcId) === 1 && attrs.label === '*') {
    attrs.label = 'C';
  }
  Object.keys(attrs).forEach(function (key) {
    if (key !== 'stereoLabel' && key !== 'stereoParity') {
      action.addOp(new AtomAttr(dstId, key, attrs[key]));
    }
  });
  var sgChanged = removeAtomFromSgroupIfNeeded(action, restruct, srcId);
  if (sgChanged) removeSgroupIfNeeded(action, restruct, [srcId]);
  var sgroups = atomGetSGroups(restruct, srcId);
  sgroups.forEach(function (sgroupId) {
    var sgroup = restruct.sgroups.get(sgroupId).item;
    for (var i = 0; i < sgroup.attachmentPoints.length; ++i) {
      if (sgroup.attachmentPoints[i].atomId === srcId) {
        action.addOp(new SGroupAttachmentPointRemove(sgroupId, new SGroupAttachmentPoint(srcId, undefined, undefined)));
        return;
      }
    }
  });
  action.addOp(new AtomDelete(srcId));
  var dstAtomNeighbors = restruct.molecule.atomGetNeighbors(dstId);
  var bond = restruct.molecule.bonds.get(((_dstAtomNeighbors$ = dstAtomNeighbors[0]) === null || _dstAtomNeighbors$ === void 0 ? void 0 : _dstAtomNeighbors$.bid) || ((_atomNeighbors$2 = atomNeighbors[0]) === null || _atomNeighbors$2 === void 0 ? void 0 : _atomNeighbors$2.bid));
  return action.perform(restruct).mergeWith(fragAction).mergeWith(fromBondStereoUpdate(restruct, bond));
}
function mergeFragmentsIfNeeded(action, restruct, srcId, dstId) {
  var frid = atomGetAttr(restruct, srcId, 'fragment');
  var frid2 = atomGetAttr(restruct, dstId, 'fragment');
  if (frid2 === frid || typeof frid !== 'number' || typeof frid2 !== 'number') {
    return frid;
  }
  var struct = restruct.molecule;
  var rgid = RGroup.findRGroupByFragment(struct.rgroups, frid2);
  if (!(typeof rgid === 'undefined')) {
    action.mergeWith(fromRGroupFragment(restruct, null, frid2)).mergeWith(fromUpdateIfThen(restruct, 0, rgid));
  }
  var fridAtoms = struct.getFragmentIds(frid);
  var atomsToNewFrag = [];
  struct.atoms.forEach(function (atom, aid) {
    if (atom.fragment === frid2) atomsToNewFrag.push(aid);
  });
  var moveAtomsAction = fromAtomsFragmentAttr(restruct, atomsToNewFrag, frid);
  mergeSgroups(action, restruct, fridAtoms, dstId);
  action.addOp(new FragmentDelete(frid2).perform(restruct));
  action.mergeWith(moveAtomsAction);
  return frid;
}
function mergeSgroups(action, restruct, srcAtoms, dstAtom) {
  var sgroups = atomGetSGroups(restruct, dstAtom);
  sgroups.forEach(function (sid) {
    var sgroup = restruct.molecule.sgroups.get(sid);
    var notExpandedContexts = ['Atom', 'Bond', 'Group'];
    if (sgroup.type === 'DAT' && notExpandedContexts.includes(sgroup.data.context)) {
      return;
    }
    var atomsToSgroup = fp.without(sgroup.atoms, srcAtoms);
    atomsToSgroup.forEach(function (aid) {
      return action.addOp(new SGroupAtomAdd(sid, aid).perform(restruct));
    });
  });
}
function checkAtomValence(restruct, atomId) {
  var action = new Action();
  if (!restruct.atoms.has(atomId)) return action;
  action.addOp(new CalcImplicitH([atomId]));
  return action.perform(restruct);
}

function fromNewCanvas(restruct, struct) {
  var action = new Action();
  action.addOp(new CanvasLoad(struct));
  return action.perform(restruct);
}
function fromDescriptorsAlign(restruct) {
  var action = new Action();
  action.addOp(new AlignDescriptors());
  return action.perform(restruct);
}

function fromChain(restruct, p0, v, nSect, atomId) {
  var dx = Math.cos(Math.PI / 6);
  var dy = Math.sin(Math.PI / 6);
  var action = new Action();
  var frid = atomId !== null ? atomGetAttr(restruct, atomId, 'fragment') : action.addOp(new FragmentAdd().perform(restruct)).frid;
  var chainItems = {
    atoms: [],
    bonds: []
  };
  var id0 = atomId !== null ? atomId : action.addOp(new AtomAdd({
    label: 'C',
    fragment: frid
  }, p0).perform(restruct)).data.aid;
  chainItems.atoms.push(id0);
  action.operations.reverse();
  for (var i = 0; i < nSect; i++) {
    var pos = new Vec2(dx * (i + 1), i & 1 ? 0 : dy).rotate(v).add(p0);
    var ret = fromBondAddition(restruct, {}, id0, {
      label: 'C'
    }, undefined, pos);
    action = ret[0].mergeWith(action);
    id0 = ret[2];
    chainItems.bonds.push(ret[3]);
    chainItems.atoms.push(id0);
  }
  return [action, chainItems];
}

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function fromItemsFuse(restruct, items) {
  var action = new Action();
  if (!items) return action;
  var usedAtoms = new Set();
  var connectedAtomIds = getAllConnectedAtomsIds(restruct, mergeMapOfItemsToSet(items.atoms), mergeMapOfItemsToSet(items.bonds));
  items.atoms.forEach(function (dst, src) {
    if (usedAtoms.has(dst) || usedAtoms.has(src)) return;
    action = fromAtomMerge(restruct, src, dst).mergeWith(action);
    usedAtoms.add(dst).add(src);
  });
  action = fromBondsMerge(restruct, items.bonds).mergeWith(action);
  action = valenceCheck(restruct, connectedAtomIds).mergeWith(action);
  return action;
}
function getItemsToFuse(editor, items) {
  var struct = editor.render.ctab.molecule;
  var mergeItems = items || {
    atoms: Array.from(struct.atoms.keys()),
    bonds: Array.from(struct.bonds.keys())
  };
  return closestToMerge(struct, editor.findMerge(mergeItems, ['atoms', 'bonds']));
}
function getHoverToFuse(items) {
  if (!items) return null;
  var hoverItems = _objectSpread$4(_objectSpread$4({
    atoms: Array.from(items.atoms.values()),
    bonds: Array.from(items.bonds.values())
  }, items.functionalGroups && {
    functionalGroups: Array.from(items.functionalGroups.values())
  }), items.atomToFunctionalGroup && {
    sgroups: Array.from(items.atomToFunctionalGroup.values())
  });
  return {
    map: 'merge',
    id: +Date.now(),
    items: hoverItems
  };
}
function mergeMapOfItemsToSet(items) {
  var itemsSet = new Set();
  items.forEach(function (value, key) {
    itemsSet.add(value).add(key);
  });
  return itemsSet;
}
function closestToMerge(struct, closestMap) {
  var mergeMap = {
    atoms: new Map(closestMap.atoms),
    bonds: new Map(closestMap.bonds),
    atomToFunctionalGroup: new Map(closestMap.atomToFunctionalGroup)
  };
  closestMap.bonds.forEach(function (dstId, srcId) {
    var bond = struct.bonds.get(srcId);
    var bondCI = struct.bonds.get(dstId);
    if (utils$1.mergeBondsParams(struct, bond, struct, bondCI).merged) {
      mergeMap.atoms["delete"](bond.begin);
      mergeMap.atoms["delete"](bond.end);
    } else {
      mergeMap.bonds["delete"](srcId);
    }
  });
  if (mergeMap.atoms.size === 0 && mergeMap.bonds.size === 0 && mergeMap.atomToFunctionalGroup.size === 0) {
    return null;
  }
  return mergeMap;
}
function getAllConnectedAtomsIds(restruct, atomsIds, bondsIds) {
  var initialAtoms = new Set(atomsIds);
  var connectedAtoms = new Set();
  var _iterator = _createForOfIteratorHelper(bondsIds),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var bondId = _step.value;
      var bond = restruct.bonds.get(bondId);
      if (bond) {
        var _bond$b = bond.b,
          begin = _bond$b.begin,
          end = _bond$b.end;
        initialAtoms.add(begin).add(end);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var _iterator2 = _createForOfIteratorHelper(initialAtoms),
    _step2;
  try {
    var _loop = function _loop() {
      var initialAtom = _step2.value;
      if (connectedAtoms.has(initialAtom)) return 1;
      var relevantConnectedComponent = _toConsumableArray__default["default"](restruct.connectedComponents.values()).find(function (component) {
        return component.has(initialAtom);
      });
      if (relevantConnectedComponent) relevantConnectedComponent.forEach(function (id) {
        return connectedAtoms.add(id);
      });
    };
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      if (_loop()) continue;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return connectedAtoms;
}
function valenceCheck(restruct, atomIds) {
  var action = new Action();
  if (!atomIds) return action;
  var usedAtoms = new Set();
  atomIds.forEach(function (atomId) {
    if (usedAtoms.has(atomId)) return;
    action = checkAtomValence(restruct, atomId).mergeWith(action);
    usedAtoms.add(atomId);
  });
  return action;
}

function fromMultipleMove(restruct, lists, d) {
  d = new Vec2(d);
  var action = new Action();
  var struct = restruct.molecule;
  var loops = new Pile();
  var atomsToInvalidate = new Pile();
  if (lists.atoms) {
    var atomSet = new Pile(lists.atoms);
    var bondlist = [];
    restruct.bonds.forEach(function (bond, bid) {
      if (atomSet.has(bond.b.begin) && atomSet.has(bond.b.end)) {
        bondlist.push(bid);
        ['hb1', 'hb2'].forEach(function (hb) {
          var loop = struct.halfBonds.get(bond.b[hb]).loop;
          if (loop >= 0) loops.add(loop);
        });
        return;
      }
      if (atomSet.has(bond.b.begin)) {
        atomsToInvalidate.add(bond.b.begin);
        return;
      }
      if (atomSet.has(bond.b.end)) atomsToInvalidate.add(bond.b.end);
    });
    bondlist.forEach(function (bond) {
      action.addOp(new BondMove(bond, d));
    });
    loops.forEach(function (loopId) {
      if (restruct.reloops.get(loopId) && restruct.reloops.get(loopId).visel) {
        action.addOp(new LoopMove(loopId, d));
      }
    });
    lists.atoms.forEach(function (aid) {
      action.addOp(new AtomMove(aid, d, !atomsToInvalidate.has(aid)));
    });
    if (lists.sgroupData && lists.sgroupData.length === 0) {
      var sgroups = getRelSGroupsBySelection(struct, lists.atoms);
      sgroups.forEach(function (sg) {
        action.addOp(new SGroupDataMove(sg.id, d));
      });
    }
  }
  if (lists.rxnArrows) {
    lists.rxnArrows.forEach(function (rxnArrow) {
      action.addOp(new RxnArrowMove(rxnArrow, d, true));
    });
  }
  if (lists.rxnPluses) {
    lists.rxnPluses.forEach(function (rxnPulse) {
      action.addOp(new RxnPlusMove(rxnPulse, d, true));
    });
  }
  if (lists.simpleObjects) {
    lists.simpleObjects.forEach(function (simpleObject) {
      action.addOp(new SimpleObjectMove(simpleObject, d, true));
    });
  }
  if (lists.sgroupData) {
    lists.sgroupData.forEach(function (sgData) {
      action.addOp(new SGroupDataMove(sgData, d));
    });
  }
  if (lists.enhancedFlags) {
    lists.enhancedFlags.forEach(function (fid) {
      action.addOp(new EnhancedFlagMove(fid, d));
    });
  }
  if (lists.texts) {
    lists.texts.forEach(function (text) {
      action.addOp(new TextMove(text, d, true));
    });
  }
  return action.perform(restruct);
}
function fromStereoFlagUpdate(restruct, frid) {
  var flag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var action = new Action();
  if (!flag) {
    var struct = restruct.molecule;
    var frag = restruct.molecule.frags.get(frid);
    frag.stereoAtoms.forEach(function (aid) {
      if (struct.atoms.get(aid).stereoLabel === null) {
        action.addOp(new FragmentDeleteStereoAtom(frid, aid));
      }
    });
  }
  action.addOp(new FragmentStereoFlag(frid));
  return action.perform(restruct);
}
function processAtom(restruct, aid, frid, newfrid) {
  var queue = [aid];
  var usedIds = new Pile(queue);
  while (queue.length > 0) {
    var id = queue.shift();
    restruct.molecule.atomGetNeighbors(id).forEach(function (nei) {
      if (restruct.molecule.atoms.get(nei.aid).fragment === frid && !usedIds.has(nei.aid)) {
        usedIds.add(nei.aid);
        queue.push(nei.aid);
      }
    });
  }
  return fromAtomsFragmentAttr(restruct, usedIds, newfrid);
}
function fromFragmentSplit(restruct, frid) {
  var rgForRemove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var action = new Action();
  var rgid = RGroup.findRGroupByFragment(restruct.molecule.rgroups, frid);
  restruct.molecule.atoms.forEach(function (atom, aid) {
    if (atom.fragment === frid) {
      var newfrid = action.addOp(new FragmentAdd().perform(restruct)).frid;
      action.mergeWith(processAtom(restruct, aid, frid, newfrid));
      if (rgid) action.mergeWith(fromRGroupFragment(restruct, rgid, newfrid));
    }
  });
  if (frid !== -1) {
    action.mergeWith(fromRGroupFragment(restruct, 0, frid));
    action.addOp(new FragmentDelete(frid).perform(restruct));
    action.mergeWith(fromUpdateIfThen(restruct, 0, rgid, rgForRemove));
  }
  action.operations.reverse();
  return action;
}

function fromRGroupAttachmentPointUpdate(restruct, atomId, attachmentPoints) {
  var action = new Action();
  action.mergeWith(fromRGroupAttachmentPointsDeletionByAtom(restruct, atomId));
  action.mergeWith(fromRGroupAttachmentPointAddition(restruct, attachmentPoints, atomId));
  return action;
}
function fromRGroupAttachmentPointAddition(restruct, attachmentPoints, atomId) {
  var action = new Action();
  switch (attachmentPoints) {
    case exports.AttachmentPoints.FirstSideOnly:
      action.addOp(new RGroupAttachmentPointAdd({
        atomId: atomId,
        attachmentPointType: 'primary'
      }));
      break;
    case exports.AttachmentPoints.SecondSideOnly:
      action.addOp(new RGroupAttachmentPointAdd({
        atomId: atomId,
        attachmentPointType: 'secondary'
      }));
      break;
    case exports.AttachmentPoints.BothSides:
      action.addOp(new RGroupAttachmentPointAdd({
        atomId: atomId,
        attachmentPointType: 'primary'
      }));
      action.addOp(new RGroupAttachmentPointAdd({
        atomId: atomId,
        attachmentPointType: 'secondary'
      }));
      break;
  }
  return action.perform(restruct);
}
function fromRGroupAttachmentPointsDeletionByAtom(restruct, atomId) {
  var action = new Action();
  var attachmentPointsToDelete = restruct.molecule.getRGroupAttachmentPointsByAtomId(atomId);
  attachmentPointsToDelete.forEach(function (rgroupAttachmentPointId) {
    action.addOp(new RGroupAttachmentPointRemove(rgroupAttachmentPointId));
  });
  return action.perform(restruct);
}
function fromRGroupAttachmentPointDeletion(restruct, id) {
  var _getNewAtomAttachment = getNewAtomAttachmentPoints(restruct.molecule, id),
    atomId = _getNewAtomAttachment.atomId,
    newAttachmentPoints = _getNewAtomAttachment.newAttachmentPoints;
  var actionToUpdateAtomsAttrs = fromAtomsAttrs(restruct, atomId, {
    attachmentPoints: newAttachmentPoints
  }, null);
  var actionToDeletePoint = new Action();
  actionToDeletePoint.addOp(new RGroupAttachmentPointRemove(id));
  return actionToDeletePoint.perform(restruct).mergeWith(actionToUpdateAtomsAttrs);
}
function getNewAtomAttachmentPoints(struct, rgroupAttachmentPointToDelete) {
  var pointToDelete = struct.rgroupAttachmentPoints.get(rgroupAttachmentPointToDelete);
  assert__default["default"](pointToDelete != null);
  var attachedAtomId = pointToDelete.atomId;
  var attachedAtom = struct.atoms.get(attachedAtomId);
  var currentAttachmentPoints = attachedAtom === null || attachedAtom === void 0 ? void 0 : attachedAtom.attachmentPoints;
  var newAttachmentPoints = exports.AttachmentPoints.None;
  if (currentAttachmentPoints === exports.AttachmentPoints.BothSides) {
    var pointToDeleteType = pointToDelete.type;
    if (pointToDeleteType === 'primary') {
      newAttachmentPoints = exports.AttachmentPoints.SecondSideOnly;
    } else if (pointToDeleteType === 'secondary') {
      newAttachmentPoints = exports.AttachmentPoints.FirstSideOnly;
    }
  }
  return {
    atomId: attachedAtomId,
    newAttachmentPoints: newAttachmentPoints
  };
}

function fromOneAtomDeletion(restruct, atomId) {
  return fromFragmentDeletion(restruct, {
    atoms: [atomId]
  });
}
function fromBondDeletion(restruct, bid) {
  var skipAtoms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var action = new Action();
  var bond = restruct.molecule.bonds.get(bid);
  var atomsToRemove = [];
  action.addOp(new BondDelete(bid));
  if (!skipAtoms.includes(bond.begin) && atomGetDegree(restruct, bond.begin) === 0) {
    if (removeAtomFromSgroupIfNeeded(action, restruct, bond.begin)) {
      atomsToRemove.push(bond.begin);
    }
    action.addOp(new AtomDelete(bond.begin));
  }
  if (!skipAtoms.includes(bond.end) && atomGetDegree(restruct, bond.end) === 0) {
    if (removeAtomFromSgroupIfNeeded(action, restruct, bond.end)) {
      atomsToRemove.push(bond.end);
    }
    action.addOp(new AtomDelete(bond.end));
  }
  removeSgroupIfNeeded(action, restruct, atomsToRemove);
  action = action.perform(restruct);
  action.addOp(new CalcImplicitH([bond.begin, bond.end]).perform(restruct));
  action.mergeWith(fromBondStereoUpdate(restruct, bond, false));
  action.operations.reverse();
  return action;
}
function fromOneBondDeletion(restruct, id) {
  var frid = restruct.molecule.getBondFragment(id);
  var action = fromBondDeletion(restruct, id);
  action = fromFragmentSplit(restruct, frid).mergeWith(action);
  return action;
}
function fromFragmentDeletion(restruct, rawSelection) {
  assert__default["default"](!!rawSelection != null);
  var action = new Action();
  var atomsToRemove = [];
  var frids = [];
  var selection = formatSelection(rawSelection);
  selection.sgroups.forEach(function (sgroupId) {
    var sgroup = restruct.sgroups.get(sgroupId);
    var sgroupAtoms = sgroup.item.atoms;
    selection.atoms = selection.atoms.concat(sgroupAtoms);
    restruct.molecule.bonds.forEach(function (bond, bondId) {
      if (sgroupAtoms.indexOf(bond.begin) >= 0 && sgroupAtoms.indexOf(bond.end) >= 0) {
        selection.bonds.push(bondId);
      }
    });
  });
  selection.atoms = Array.from(new Set(selection.atoms));
  selection.bonds = Array.from(new Set(selection.bonds));
  selection.atoms.forEach(function (aid) {
    restruct.molecule.atomGetNeighbors(aid).forEach(function (nei) {
      if (selection.bonds.indexOf(nei.bid) === -1) {
        selection.bonds = selection.bonds.concat([nei.bid]);
      }
    });
  });
  var actionRemoveBonds = new Action();
  selection.bonds.forEach(function (bid) {
    var frid = restruct.molecule.getBondFragment(bid);
    if (frids.indexOf(frid) < 0) frids.push(frid);
    actionRemoveBonds.mergeWith(fromBondDeletion(restruct, bid, selection.atoms));
  });
  var removedRGroupAttachmentPoints = [];
  selection.atoms.forEach(function (aid) {
    var frid3 = restruct.molecule.atoms.get(aid).fragment;
    if (frids.indexOf(frid3) < 0) frids.push(frid3);
    if (removeAtomFromSgroupIfNeeded(action, restruct, aid)) {
      atomsToRemove.push(aid);
    }
    action.addOp(new AtomDelete(aid));
    var attachmentPointsToDelete = restruct.molecule.getRGroupAttachmentPointsByAtomId(aid);
    attachmentPointsToDelete.forEach(function (id) {
      action.addOp(new RGroupAttachmentPointRemove(id));
      removedRGroupAttachmentPoints.push(id);
    });
  });
  removeSgroupIfNeeded(action, restruct, atomsToRemove);
  selection.rxnArrows.forEach(function (id) {
    action.addOp(new RxnArrowDelete(id));
  });
  selection.rxnPluses.forEach(function (id) {
    action.addOp(new RxnPlusDelete(id));
  });
  selection.simpleObjects.forEach(function (id) {
    action.addOp(new SimpleObjectDelete(id));
  });
  selection.texts.forEach(function (id) {
    action.addOp(new TextDelete(id));
  });
  var actionToDeleteRGroupAttachmentPoints = new Action();
  selection.rgroupAttachmentPoints.forEach(function (id) {
    if (!removedRGroupAttachmentPoints.includes(id)) {
      actionToDeleteRGroupAttachmentPoints.mergeWith(fromRGroupAttachmentPointDeletion(restruct, id));
    }
  });
  action = action.perform(restruct);
  action.mergeWith(actionRemoveBonds).mergeWith(actionToDeleteRGroupAttachmentPoints);
  var rgForRemove = frids.map(function (frid) {
    return RGroup.findRGroupByFragment(restruct.molecule.rgroups, frid);
  });
  while (frids.length > 0) {
    action = fromFragmentSplit(restruct, frids.pop(), rgForRemove).mergeWith(action);
  }
  return action;
}

function fromPaste(restruct, pstruct, point) {
  var angle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var isPreview = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var xy0 = getStructCenter(pstruct);
  var offset = Vec2.diff(point, xy0);
  var action = new Action();
  var aidMap = new Map();
  var fridMap = new Map();
  var pasteItems = {
    atoms: [],
    bonds: []
  };
  pstruct.atoms.forEach(function (atom, aid) {
    if (!fridMap.has(atom.fragment) && !pstruct.isAtomFromMacromolecule(aid)) {
      fridMap.set(atom.fragment, action.addOp(new FragmentAdd(null, atom.fragment.properties).perform(restruct)).frid);
    }
    var tmpAtom = Object.assign(atom.clone(), {
      fragment: fridMap.get(atom.fragment)
    });
    var operation = new AtomAdd(tmpAtom, Vec2.diff(atom.pp, xy0).rotate(angle).add(point)).perform(restruct);
    action.addOp(operation);
    aidMap.set(aid, operation.data.aid);
    pasteItems.atoms.push(operation.data.aid);
    action.mergeWith(fromRGroupAttachmentPointAddition(restruct, tmpAtom.attachmentPoints, operation.data.aid));
  });
  pstruct.frags.forEach(function (frag, frid) {
    if (!frag) return;
    if (frag.properties) {
      action.addOp(new FragmentSetProperties(fridMap.get(frid), frag.properties).perform(restruct));
    }
    frag.stereoAtoms.forEach(function (aid) {
      return action.addOp(new FragmentAddStereoAtom(fridMap.get(frid), aidMap.get(aid)).perform(restruct));
    });
  });
  pstruct.bonds.forEach(function (bond) {
    var operation = new BondAdd(aidMap.get(bond.begin), aidMap.get(bond.end), bond, false).perform(restruct);
    action.addOp(operation);
    pasteItems.bonds.push(operation.data.bid);
    new BondAttr(operation.data.bid, 'isPreview', isPreview, false).perform(restruct);
  });
  pasteItems.atoms.forEach(function (aid) {
    action.addOp(new CalcImplicitH([aid]).perform(restruct));
    new AtomAttr(aid, 'isPreview', isPreview).perform(restruct);
  });
  pstruct.sgroups.forEach(function (sg) {
    var newsgid = restruct.molecule.sgroups.newId();
    var sgAtoms = sg.atoms.map(function (aid) {
      return aidMap.get(aid);
    });
    var attachmentPoints = sg.cloneAttachmentPoints(aidMap);
    if (sg.isNotContractible(pstruct) && !(sg instanceof MonomerMicromolecule)) {
      sg.setAttr('expanded', true);
    }
    var sgAction = fromSgroupAddition(restruct, sg.type, sgAtoms, sg.data, newsgid, attachmentPoints, sg.pp ? sg.pp.add(offset) : null, sg.type === 'SUP' ? sg.isExpanded() : null, sg.data.name, sg);
    sgAction.operations.reverse().forEach(function (oper) {
      action.addOp(oper);
    });
  });
  pstruct.rxnArrows.forEach(function (rxnArrow) {
    action.addOp(new RxnArrowAdd(rxnArrow.pos.map(function (p) {
      return p.add(offset);
    }), rxnArrow.mode).perform(restruct));
  });
  pstruct.rxnPluses.forEach(function (plus) {
    action.addOp(new RxnPlusAdd(plus.pp.add(offset)).perform(restruct));
  });
  pstruct.simpleObjects.forEach(function (simpleObject) {
    action.addOp(new SimpleObjectAdd(simpleObject.pos.map(function (p) {
      return p.add(offset);
    }), simpleObject.mode).perform(restruct));
  });
  pstruct.texts.forEach(function (text) {
    action.addOp(new TextCreate(text.content, text.position.add(offset), text.pos.map(function (p) {
      return p.add(offset);
    })).perform(restruct));
  });
  pstruct.rgroups.forEach(function (rg, rgid) {
    rg.frags.forEach(function (__frag, frid) {
      action.addOp(new RGroupFragment(rgid, fridMap.get(frid)).perform(restruct));
    });
    var ifThen = pstruct.rgroups.get(rgid).ifthen;
    var newRgId = pstruct.rgroups.get(ifThen) ? ifThen : 0;
    action.mergeWith(fromRGroupAttrs(restruct, rgid, rg.getAttrs())).mergeWith(fromUpdateIfThen(restruct, newRgId, rg.ifthen));
  });
  action.operations.reverse();
  return [action, pasteItems];
}
function getStructCenter(struct) {
  var isOnlyOneSGroup = struct.sgroups.size === 1;
  if (isOnlyOneSGroup) {
    var onlyOneStructsSgroupId = struct.sgroups.keys().next().value;
    var sgroup = struct.sgroups.get(onlyOneStructsSgroupId);
    if (sgroup.isContracted()) {
      return sgroup.getContractedPosition(struct).position;
    }
  }
  if (struct.atoms.size > 0) {
    var xmin = 1e50;
    var ymin = xmin;
    var xmax = -xmin;
    var ymax = -ymin;
    struct.atoms.forEach(function (atom) {
      xmin = Math.min(xmin, atom.pp.x);
      ymin = Math.min(ymin, atom.pp.y);
      xmax = Math.max(xmax, atom.pp.x);
      ymax = Math.max(ymax, atom.pp.y);
    });
    return new Vec2((xmin + xmax) / 2, (ymin + ymax) / 2);
  }
  if (struct.rxnArrows.size > 0) return struct.rxnArrows.get(0).center();
  if (struct.rxnPluses.size > 0) return struct.rxnPluses.get(0).pp;
  if (struct.simpleObjects.size > 0)
    return struct.simpleObjects.get(0).center();
  if (struct.texts.size > 0) return struct.texts.get(0).position;
  return new Vec2(0, 0);
}

function fromArrowAddition(restruct, pos, mode) {
  var action = new Action();
  action.addOp(new RxnArrowAdd(pos, mode));
  return action.perform(restruct);
}
function fromArrowResizing(restruct, id, d, current, anchor, isSnappingEnabled) {
  var action = new Action();
  action.addOp(new RxnArrowResize(id, d, current, anchor, false, isSnappingEnabled));
  return action.perform(restruct);
}
function fromArrowDeletion(restruct, id) {
  var action = new Action();
  action.addOp(new RxnArrowDelete(id));
  return action.perform(restruct);
}
function fromPlusAddition(restruct, pos) {
  var action = new Action();
  action.addOp(new RxnPlusAdd(pos).perform(restruct));
  return action;
}
function fromPlusDeletion(restruct, id) {
  var action = new Action();
  action.addOp(new RxnPlusDelete(id));
  return action.perform(restruct);
}

function fromFlip(reStruct, selection, flipDirection, center) {
  var action = new Action();
  var structToFlip = selection || structSelection(reStruct.molecule);
  action.mergeWith(fromStructureFlip(reStruct, structToFlip, flipDirection, center));
  if (structToFlip.rxnArrows) {
    action.mergeWith(fromRxnArrowFlip(reStruct, structToFlip.rxnArrows, flipDirection, center));
  }
  if (structToFlip.rxnPluses) {
    action.mergeWith(fromRxnPlusFlip(reStruct, structToFlip.rxnPluses, flipDirection, center));
  }
  if (structToFlip.texts) {
    action.mergeWith(fromTextFlip(reStruct, structToFlip.texts, flipDirection, center));
  }
  return action;
}
function fromRxnArrowFlip(reStruct, rxnArrowIds, flipDirection, center) {
  var action = new Action();
  rxnArrowIds.forEach(function (arrowId) {
    var rxnArrow = reStruct.molecule.rxnArrows.get(arrowId);
    if (!rxnArrow) {
      return;
    }
    var _rxnArrow$pos = _slicedToArray__default["default"](rxnArrow.pos, 2),
      start = _rxnArrow$pos[0],
      end = _rxnArrow$pos[1];
    var oxAngle = end.sub(start).oxAngle();
    var oyAngle = oxAngle - Math.PI / 2;
    var rotateAngle = flipDirection === 'vertical' ? -2 * oxAngle : -2 * oyAngle;
    action.addOp(new RxnArrowRotate(arrowId, rotateAngle, rxnArrow.center()));
    var difference = flipPointByCenter(rxnArrow.center(), center, flipDirection);
    action.addOp(new RxnArrowMove(arrowId, difference));
  });
  return action.perform(reStruct);
}
function fromRxnPlusFlip(reStruct, rxnPlusIds, flipDirection, center) {
  var action = new Action();
  rxnPlusIds.forEach(function (plusId) {
    var rxnPlus = reStruct.molecule.rxnPluses.get(plusId);
    if (!rxnPlus) {
      return;
    }
    var difference = flipPointByCenter(rxnPlus.pp, center, flipDirection);
    action.addOp(new RxnPlusMove(plusId, difference));
  });
  return action.perform(reStruct);
}
function fromTextFlip(reStruct, textIds, flipDirection, center) {
  var action = new Action();
  textIds.forEach(function (textId) {
    var text = reStruct.molecule.texts.get(textId);
    if (!text) {
      return;
    }
    var textMiddleLeft = text.pos[0];
    var textMiddleRight = text.pos[2];
    var textCenter = Vec2.centre(textMiddleLeft, textMiddleRight);
    var difference = flipPointByCenter(textCenter, center, flipDirection);
    action.addOp(new TextMove(textId, difference));
  });
  return action.perform(reStruct);
}
function fromStructureFlip(reStruct, selection, flipDirection, center) {
  var _selection$atoms;
  var struct = reStruct.molecule;
  var action = new Action();
  selection === null || selection === void 0 || (_selection$atoms = selection.atoms) === null || _selection$atoms === void 0 || _selection$atoms.forEach(function (atomId) {
    var atom = struct.atoms.get(atomId);
    if (!atom) {
      return;
    }
    var difference = flipPointByCenter(atom.pp, center, flipDirection);
    action.addOp(new AtomMove(atomId, difference));
  });
  var sGroups = getRelSGroupsBySelection(struct, (selection === null || selection === void 0 ? void 0 : selection.atoms) || []);
  sGroups.forEach(function (sGroup) {
    if (!sGroup.pp) {
      return;
    }
    var difference = flipPointByCenter(sGroup.pp, center, flipDirection);
    action.addOp(new SGroupDataMove(sGroup.id, difference));
  });
  if (selection !== null && selection !== void 0 && selection.bonds) {
    flipBonds(selection.bonds, struct, action);
  }
  return action.perform(reStruct);
}
function flipBonds(bondIds, struct, action) {
  bondIds.forEach(function (bondId) {
    var bond = struct.bonds.get(bondId);
    if (!bond) {
      return;
    }
    if (bond.type !== Bond.PATTERN.TYPE.SINGLE) {
      return;
    }
    if (bond.stereo === Bond.PATTERN.STEREO.UP) {
      action.addOp(new BondAttr(bondId, 'stereo', Bond.PATTERN.STEREO.DOWN));
      return;
    }
    if (bond.stereo === Bond.PATTERN.STEREO.DOWN) {
      action.addOp(new BondAttr(bondId, 'stereo', Bond.PATTERN.STEREO.UP));
    }
  });
}
function flipPointByCenter(pointToFlip, center, flipDirection) {
  var d = new Vec2();
  if (flipDirection === 'horizontal') {
    d.x = center.x > pointToFlip.x ? 2 * (center.x - pointToFlip.x) : -2 * (pointToFlip.x - center.x);
  } else {
    d.y = center.y > pointToFlip.y ? 2 * (center.y - pointToFlip.y) : -2 * (pointToFlip.y - center.y);
  }
  return d;
}
function fromRotate(restruct, selection, center, angle) {
  var struct = restruct.molecule;
  var action = new Action();
  if (!selection) {
    selection = structSelection(struct);
  }
  if (selection.atoms) {
    selection.atoms.forEach(function (aid) {
      var atom = struct.atoms.get(aid);
      action.addOp(new AtomMove(aid, rotateDelta(atom.pp, center, angle)));
    });
    if (!selection.sgroupData) {
      var sgroups = getRelSGroupsBySelection(struct, selection.atoms);
      sgroups.forEach(function (sg) {
        action.addOp(new SGroupDataMove(sg.id, rotateDelta(sg.pp, center, angle)));
      });
    }
  }
  if (selection.rxnArrows) {
    selection.rxnArrows.forEach(function (arrowId) {
      action.addOp(new RxnArrowRotate(arrowId, angle, center));
    });
  }
  if (selection.rxnPluses) {
    selection.rxnPluses.forEach(function (pid) {
      var plus = struct.rxnPluses.get(pid);
      action.addOp(new RxnPlusMove(pid, rotateDelta(plus.pp, center, angle)));
    });
  }
  if (selection.texts) {
    selection.texts.forEach(function (textId) {
      var text = struct.texts.get(textId);
      action.addOp(new TextMove(textId, rotateDelta(text.position, center, angle)));
    });
  }
  if (selection.sgroupData) {
    selection.sgroupData.forEach(function (did) {
      var data = struct.sgroups.get(did);
      action.addOp(new SGroupDataMove(did, rotateDelta(data.pp, center, angle)));
    });
  }
  if (selection.enhancedFlags) {
    selection.enhancedFlags.forEach(function (flagId) {
      var frId = flagId;
      var frag = restruct.molecule.frags.get(frId);
      action.addOp(new EnhancedFlagMove(flagId, rotateDelta(frag.stereoFlagPosition || Fragment.getDefaultStereoFlagPosition(restruct.molecule, frId), center, angle)));
    });
  }
  return action.perform(restruct);
}
function rotateDelta(v, center, angle) {
  var v1 = v.sub(center);
  v1 = v1.rotate(angle);
  v1.add_(center);
  return v1.sub(v);
}

function fromSimpleObjectDeletion(restruct, id) {
  var action = new Action();
  action.addOp(new SimpleObjectDelete(id));
  return action.perform(restruct);
}
function fromSimpleObjectAddition(restruct, pos, mode, toCircle) {
  var action = new Action();
  action.addOp(new SimpleObjectAdd(pos, mode, toCircle));
  return action.perform(restruct);
}
function fromSimpleObjectResizing(restruct, id, d, current, anchor, toCircle) {
  var action = new Action();
  action.addOp(new SimpleObjectResize(id, d, current, anchor, false, toCircle));
  return action.perform(restruct);
}

function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
var benzeneMoleculeName = 'Benzene';
var cyclopentadieneMoleculeName = 'Cyclopentadiene';
var benzeneDoubleBondIndexes = [2, 4];
function fromTemplateOnCanvas(restruct, template, pos) {
  var angle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var isPreview = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var _fromPaste = fromPaste(restruct, template.molecule, pos, angle, isPreview),
    _fromPaste2 = _slicedToArray__default["default"](_fromPaste, 2),
    action = _fromPaste2[0],
    pasteItems = _fromPaste2[1];
  action.addOp(new CalcImplicitH(pasteItems.atoms).perform(restruct));
  return [action, pasteItems];
}
function extraBondAction(restruct, aid, angle) {
  var action = new Action();
  var frid = atomGetAttr(restruct, aid, 'fragment');
  var additionalAtom = null;
  if (angle === null) {
    var middleAtom = atomForNewBond(restruct, aid);
    var actionRes = fromBondAddition(restruct, {
      type: 1
    }, aid, middleAtom.atom, undefined, middleAtom.pos.get_xy0());
    action = actionRes[0];
    action.operations.reverse();
    additionalAtom = actionRes[2];
  } else {
    var operation = new AtomAdd({
      label: 'C',
      fragment: frid
    }, new Vec2(1, 0).rotate(angle).add(restruct.molecule.atoms.get(aid).pp).get_xy0()).perform(restruct);
    action.addOp(operation);
    action.addOp(new BondAdd(aid, operation.data.aid, {
      type: 1
    }).perform(restruct));
    additionalAtom = operation.data.aid;
  }
  return {
    action: action,
    aid1: additionalAtom
  };
}
function fromTemplateOnAtom(restruct, template, aid, angle, extraBond) {
  var isPreview = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var action = new Action();
  var tmpl = template.molecule;
  var struct = restruct.molecule;
  var isTmplSingleGroup = template.molecule.isSingleGroup();
  var atom = struct.atoms.get(aid);
  var aid1 = aid;
  var delta = null;
  if (extraBond) {
    var extraRes = extraBondAction(restruct, aid, angle);
    action = extraRes.action;
    aid1 = extraRes.aid1;
    atom = struct.atoms.get(aid1);
    delta = utils$1.calcAngle(struct.atoms.get(aid).pp, atom.pp) - template.angle0;
  } else {
    if (angle === null) {
      angle = utils$1.calcAngle(atom.pp, atomForNewBond(restruct, aid).pos);
    }
    delta = angle - template.angle0;
  }
  var map = new Map();
  var xy0 = tmpl.atoms.get(template.aid).pp;
  var frid = atomGetAttr(restruct, aid, 'fragment');
  var pasteItems = {
    atoms: [],
    bonds: []
  };
  tmpl.atoms.forEach(function (a, id) {
    var attrs = Atom.getAttrHash(a);
    attrs.fragment = frid;
    if (id === template.aid) {
      action.mergeWith(fromAtomsAttrs(restruct, aid1, attrs, true));
      map.set(id, aid1);
      pasteItems.atoms.push(aid1);
    } else {
      var v = Vec2.diff(a.pp, xy0).rotate(delta).add(atom.pp);
      var operation = new AtomAdd(attrs, v.get_xy0()).perform(restruct);
      action.addOp(operation);
      map.set(id, operation.data.aid);
      pasteItems.atoms.push(operation.data.aid);
    }
  });
  if (!isTmplSingleGroup) mergeSgroups(action, restruct, pasteItems.atoms, aid);
  tmpl.bonds.forEach(function (bond) {
    var operation = new BondAdd(map.get(bond.begin), map.get(bond.end), bond).perform(restruct);
    action.addOp(operation);
    new BondAttr(operation.data.bid, 'isPreview', isPreview).perform(restruct);
    pasteItems.bonds.push(operation.data.bid);
  });
  tmpl.sgroups.forEach(function (sg) {
    var newsgid = restruct.molecule.sgroups.newId();
    var sgAtoms = sg.atoms.map(function (aid) {
      return map.get(aid);
    });
    var attachmentPoints = sg.cloneAttachmentPoints(map);
    var sgAction = fromSgroupAddition(restruct, sg.type, sgAtoms, _objectSpread$3(_objectSpread$3({}, sg.data), {}, {
      expanded: isPreview ? true : sg.data.expanded
    }), newsgid, attachmentPoints, atom.pp, sg.type === 'SUP' ? sg.isExpanded() : null, sg.data.name);
    sgAction.operations.reverse().forEach(function (oper) {
      action.addOp(oper);
    });
  });
  action.operations.reverse();
  action.addOp(new CalcImplicitH([].concat(_toConsumableArray__default["default"](pasteItems.atoms), [aid])).perform(restruct));
  action.mergeWith(fromBondStereoUpdate(restruct, restruct.molecule.bonds.get(pasteItems.bonds[0])));
  return [action, pasteItems];
}
function fromTemplateOnBondAction(restruct, template, bid, events, flip, force) {
  var isPreview = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  if (!force) return fromTemplateOnBond(restruct, template, bid, flip);
  var simpleFusing = function simpleFusing(restruct, template, bid) {
    return fromTemplateOnBond(restruct, template, bid, flip, isPreview);
  };
  return fromAromaticTemplateOnBond(restruct, template, bid, events, simpleFusing);
}
function getConnectingBond(template, struct, bondId, bond) {
  var isBenzeneTemplate = template.name === benzeneMoleculeName;
  var isCyclopentadieneTemplate = template.name === cyclopentadieneMoleculeName;
  if (template.bonds.size && (isBenzeneTemplate || isCyclopentadieneTemplate)) {
    var _Bond$getBondNeighbou = Bond.getBondNeighbourIds(struct, bondId),
      beginBondIds = _Bond$getBondNeighbou.beginBondIds,
      endBondIds = _Bond$getBondNeighbou.endBondIds;
    var isOnlyTwoConnectingBonds = beginBondIds.length === 1 && endBondIds.length === 1;
    if (!isOnlyTwoConnectingBonds) {
      return null;
    }
    var beginBond = struct.bonds.get(beginBondIds[0]);
    var endBond = struct.bonds.get(endBondIds[0]);
    if (!beginBond || !endBond) {
      throw new Error('Incorrect bond id was provided');
    }
    if (isBenzeneTemplate) {
      return Bond.getBenzeneConnectingBondType(bond, beginBond, endBond);
    }
    if (isCyclopentadieneTemplate) {
      return Bond.getCyclopentadieneFusingBondType(bond, beginBond, endBond);
    }
  }
  return null;
}
function fromTemplateOnBond(restruct, template, bid, flip) {
  var isPreview = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var action = new Action();
  var tmpl = template.molecule;
  var struct = restruct.molecule;
  var bond = struct.bonds.get(bid);
  var tmplBond = tmpl.bonds.get(template.bid);
  var tmplBegin = tmpl.atoms.get(flip ? tmplBond.end : tmplBond.begin);
  var atomsMap = new Map([[tmplBond.begin, flip ? bond.end : bond.begin], [tmplBond.end, flip ? bond.begin : bond.end]]);
  var bondAtoms = {
    begin: flip ? tmplBond.end : tmplBond.begin,
    end: flip ? tmplBond.begin : tmplBond.end
  };
  var _utils$mergeBondsPara = utils$1.mergeBondsParams(struct, bond, tmpl, bondAtoms),
    angle = _utils$mergeBondsPara.angle,
    scale = _utils$mergeBondsPara.scale;
  var frid = struct.getBondFragment(bid);
  var pasteItems = {
    atoms: [],
    bonds: []
  };
  tmpl.atoms.forEach(function (atom, id) {
    var attrs = Atom.getAttrHash(atom);
    attrs.fragment = frid;
    if (id === tmplBond.begin || id === tmplBond.end) {
      action.mergeWith(fromAtomsAttrs(restruct, atomsMap.get(id), attrs, true));
      return;
    }
    var v = Vec2.diff(atom.pp, tmplBegin.pp).rotate(angle).scaled(scale).add(struct.atoms.get(bond.begin).pp);
    var mergeA = closest.atom(restruct, v, null, 0.1);
    if (mergeA === null) {
      var operation = new AtomAdd(attrs, v).perform(restruct);
      action.addOp(operation);
      atomsMap.set(id, operation.data.aid);
      pasteItems.atoms.push(operation.data.aid);
    } else {
      atomsMap.set(id, mergeA.id);
      action.mergeWith(fromAtomsAttrs(restruct, atomsMap.get(id), attrs, true));
    }
  });
  mergeSgroups(action, restruct, pasteItems.atoms, bond.begin);
  var fusingBondType = getConnectingBond(tmpl, struct, bid, bond);
  var isFusingBenzeneBySpecialRules = fusingBondType !== null;
  tmpl.bonds.forEach(function (tBond, tBondIndex) {
    var existId = struct.findBondId(atomsMap.get(tBond.begin), atomsMap.get(tBond.end));
    var previewBondId = null;
    if (existId === null) {
      var operation = new BondAdd(atomsMap.get(tBond.begin), atomsMap.get(tBond.end), tBond).perform(restruct);
      action.addOp(operation);
      var newBondId = operation.data.bid;
      previewBondId = newBondId;
      if (isFusingBenzeneBySpecialRules) {
        var isBenzeneTemplate = tmpl.name === benzeneMoleculeName;
        var isCyclopentadieneTemplate = tmpl.name === cyclopentadieneMoleculeName;
        if (isBenzeneTemplate) {
          var newBondType = benzeneDoubleBondIndexes.includes(tBondIndex) ? Bond.PATTERN.TYPE.DOUBLE : Bond.PATTERN.TYPE.SINGLE;
          action.addOp(new BondAttr(newBondId, 'type', newBondType).perform(restruct));
        }
        if (isCyclopentadieneTemplate) {
          var _Bond$getBondNeighbou2 = Bond.getBondNeighbourIds(struct, bid),
            beginBondIds = _Bond$getBondNeighbou2.beginBondIds,
            endBondIds = _Bond$getBondNeighbou2.endBondIds;
          var bondBegin = struct.bonds.get(beginBondIds[0]);
          var bondEnd = struct.bonds.get(endBondIds[0]);
          var _newBondType = Bond.getCyclopentadieneDoubleBondIndexes(bond, bondBegin, bondEnd).includes(tBondIndex) ? Bond.PATTERN.TYPE.DOUBLE : Bond.PATTERN.TYPE.SINGLE;
          action.addOp(new BondAttr(newBondId, 'type', _newBondType).perform(restruct));
        }
      }
      pasteItems.bonds.push(newBondId);
    } else {
      var commonBond = bond.type > tmplBond.type ? bond : tmplBond;
      action.mergeWith(fromBondsAttrs(restruct, existId, commonBond, true));
      if (isFusingBenzeneBySpecialRules && fusingBondType) {
        action.addOp(new BondAttr(bid, 'type', fusingBondType).perform(restruct));
      }
      previewBondId = bid;
    }
    action.addOp(new BondAttr(previewBondId, 'isPreview', isPreview).perform(restruct));
  });
  if (pasteItems.atoms.length) {
    action.addOp(new CalcImplicitH([bond.begin, bond.end].concat(_toConsumableArray__default["default"](pasteItems.atoms))).perform(restruct));
  }
  if (pasteItems.bonds.length) {
    action.mergeWith(fromBondStereoUpdate(restruct, restruct.molecule.bonds.get(pasteItems.bonds[0])));
  }
  action.operations.reverse();
  return [action, pasteItems];
}

function fromTextCreation(restruct, content, position, pos) {
  var action = new Action();
  action.addOp(new TextCreate(content, position, pos));
  return action.perform(restruct);
}
function fromTextUpdating(restruct, id, content) {
  var action = new Action();
  action.addOp(new TextUpdate(id, content));
  return action.perform(restruct);
}
function fromTextDeletion(restruct, id) {
  var action = new Action();
  action.addOp(new TextDelete(id));
  return action.perform(restruct);
}

function _callSuper(t, o, e) { return o = _getPrototypeOf__default["default"](o), _possibleConstructorReturn__default["default"](t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf__default["default"](t).constructor) : o.apply(t, e)); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
var HighlightAdd = function (_BaseOperation) {
  _inherits__default["default"](HighlightAdd, _BaseOperation);
  function HighlightAdd(atoms, bonds, color, highlightId) {
    var _this;
    _classCallCheck__default["default"](this, HighlightAdd);
    _this = _callSuper(this, HighlightAdd, [OperationType.ADD_HIGHLIGHT]);
    _this.data = {
      atoms: atoms,
      bonds: bonds,
      color: color,
      highlightId: highlightId
    };
    return _this;
  }
  _createClass__default["default"](HighlightAdd, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$data = this.data,
        atoms = _this$data.atoms,
        bonds = _this$data.bonds,
        color = _this$data.color;
      if (!color) {
        return;
      }
      var struct = restruct.molecule;
      var highlight = new Highlight({
        atoms: atoms,
        bonds: bonds,
        color: color
      });
      if (typeof this.data.highlightId !== 'number') {
        this.data.highlightId = struct.highlights.add(highlight);
      } else {
        struct.highlights.set(this.data.highlightId, highlight);
      }
      notifyChanged(restruct, atoms, bonds);
    }
  }, {
    key: "invert",
    value: function invert() {
      var _this$data2 = this.data,
        atoms = _this$data2.atoms,
        bonds = _this$data2.bonds,
        color = _this$data2.color,
        highlightId = _this$data2.highlightId;
      var inverted = new HighlightDelete(highlightId, atoms, bonds, color);
      return inverted;
    }
  }]);
  return HighlightAdd;
}(BaseOperation);
var HighlightDelete = function (_BaseOperation2) {
  _inherits__default["default"](HighlightDelete, _BaseOperation2);
  function HighlightDelete(highlightId, atoms, bonds, color) {
    var _this2;
    _classCallCheck__default["default"](this, HighlightDelete);
    _this2 = _callSuper(this, HighlightDelete, [OperationType.REMOVE_HIGHLIGHT, 5]);
    _this2.data = {
      highlightId: highlightId,
      atoms: atoms || [],
      bonds: bonds || [],
      color: color || 'white'
    };
    return _this2;
  }
  _createClass__default["default"](HighlightDelete, [{
    key: "execute",
    value: function execute(restruct) {
      if (typeof this.data.highlightId === 'number') {
        var struct = restruct.molecule;
        var highlightToRemove = struct.highlights.get(this.data.highlightId);
        if (typeof highlightToRemove === 'undefined') {
          return;
        }
        var atoms = highlightToRemove.atoms,
          bonds = highlightToRemove.bonds,
          color = highlightToRemove.color;
        this.data.atoms = atoms;
        this.data.bonds = bonds;
        this.data.color = color;
        struct.highlights["delete"](this.data.highlightId);
        notifyChanged(restruct, atoms, bonds);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var _this$data3 = this.data,
        atoms = _this$data3.atoms,
        bonds = _this$data3.bonds,
        color = _this$data3.color,
        highlightId = _this$data3.highlightId;
      var inverted = new HighlightAdd(atoms, bonds, color, highlightId);
      inverted.data = this.data;
      return inverted;
    }
  }]);
  return HighlightDelete;
}(BaseOperation);
(function (_BaseOperation3) {
  _inherits__default["default"](HighlightUpdate, _BaseOperation3);
  function HighlightUpdate(highlightId, atoms, bonds, color) {
    var _this3;
    _classCallCheck__default["default"](this, HighlightUpdate);
    _this3 = _callSuper(this, HighlightUpdate, [OperationType.UPDATE_HIGHLIGHT]);
    _this3.newData = {
      atoms: atoms,
      bonds: bonds,
      color: color,
      highlightId: highlightId
    };
    _this3.oldData = {
      atoms: atoms,
      bonds: bonds,
      color: color,
      highlightId: highlightId
    };
    return _this3;
  }
  _createClass__default["default"](HighlightUpdate, [{
    key: "execute",
    value: function execute(restruct) {
      var _this$newData = this.newData,
        atoms = _this$newData.atoms,
        bonds = _this$newData.bonds,
        color = _this$newData.color;
      if (!color) {
        return;
      }
      var highlightId = this.newData.highlightId;
      var struct = restruct.molecule;
      var highlightToUpdate = struct.highlights.get(highlightId);
      if (highlightToUpdate) {
        var oldAtoms = highlightToUpdate.atoms,
          oldBonds = highlightToUpdate.bonds,
          oldColor = highlightToUpdate.color;
        this.oldData = {
          atoms: oldAtoms,
          bonds: oldBonds,
          color: oldColor,
          highlightId: highlightId
        };
        var updatedHighlight = new Highlight({
          atoms: atoms,
          bonds: bonds,
          color: color
        });
        struct.highlights.set(this.newData.highlightId, updatedHighlight);
        notifyChanged(restruct, [].concat(_toConsumableArray__default["default"](atoms), _toConsumableArray__default["default"](oldAtoms)), [].concat(_toConsumableArray__default["default"](bonds), _toConsumableArray__default["default"](oldBonds)));
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var _this$oldData = this.oldData,
        atoms = _this$oldData.atoms,
        bonds = _this$oldData.bonds,
        color = _this$oldData.color;
      var inverted = new HighlightUpdate(this.newData.highlightId, atoms, bonds, color);
      return inverted;
    }
  }]);
  return HighlightUpdate;
})(BaseOperation);
function notifyChanged(restruct, atoms, bonds) {
  var reAtoms = restruct.atoms;
  var reBonds = restruct.bonds;
  if (atoms) {
    atoms.forEach(function (atomId) {
      if (typeof reAtoms.get(atomId) !== 'undefined') {
        restruct.markAtom(atomId, 1);
      }
    });
  }
  if (bonds) {
    bonds.forEach(function (bondId) {
      if (typeof reBonds.get(bondId) !== 'undefined') {
        restruct.markBond(bondId, 1);
      }
    });
  }
}

function fromHighlightCreate(restruct, highlights) {
  var action = new Action();
  highlights.forEach(function (highlight) {
    var atoms = highlight.atoms,
      bonds = highlight.bonds,
      color = highlight.color;
    action.addOp(new HighlightAdd(atoms, bonds, color));
  });
  return action.perform(restruct);
}
function fromHighlightClear(restruct) {
  var action = new Action();
  var highlights = restruct.molecule.highlights;
  highlights.forEach(function (_, key) {
    action.addOp(new HighlightDelete(key));
  });
  return action.perform(restruct);
}

var vectorUtils = {
  fracAngle: utils$1.fracAngle,
  calcAngle: utils$1.calcAngle,
  degrees: utils$1.degrees,
  calcNewAtomPos: utils$1.calcNewAtomPos
};

var IndigoShowHydrogenLabelsMode;
(function (IndigoShowHydrogenLabelsMode) {
  IndigoShowHydrogenLabelsMode["OFF"] = "none";
  IndigoShowHydrogenLabelsMode["HETERO"] = "hetero";
  IndigoShowHydrogenLabelsMode["TERMINAL_HETERO"] = "terminal-hetero";
  IndigoShowHydrogenLabelsMode["ALL"] = "all";
})(IndigoShowHydrogenLabelsMode || (IndigoShowHydrogenLabelsMode = {}));
function getLabelRenderModeForIndigo() {
  var renderModeMapping = _defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"](_defineProperty__default["default"]({}, exports.ShowHydrogenLabels.Off, IndigoShowHydrogenLabelsMode.HETERO), exports.ShowHydrogenLabels.Hetero, IndigoShowHydrogenLabelsMode.HETERO), exports.ShowHydrogenLabels.Terminal, IndigoShowHydrogenLabelsMode.TERMINAL_HETERO), exports.ShowHydrogenLabels.TerminalAndHetero, IndigoShowHydrogenLabelsMode.TERMINAL_HETERO), exports.ShowHydrogenLabels.On, IndigoShowHydrogenLabelsMode.ALL);
  return renderModeMapping[ketcherProvider.getKetcher().editor.options().showHydrogenLabels] || IndigoShowHydrogenLabelsMode.OFF;
}

function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function pollDeferred(process, complete, timeGap, startTimeGap) {
  return new Promise(function (resolve, reject) {
    function iterate() {
      process().then(function (val) {
        try {
          if (complete(val)) resolve(val);else setTimeout(iterate, timeGap);
        } catch (error) {
          KetcherLogger.error('remoteStructService.ts::pollDeferred', error);
          reject(error);
        }
      }, function (err) {
        return reject(err);
      });
    }
    setTimeout(iterate, startTimeGap || 0);
  });
}
function parametrizeUrl(url, params) {
  return url.replace(/:(\w+)/g, function (_, val) {
    return params[val];
  });
}
function request(method, url, data, headers, responseHandler) {
  var requestUrl = url;
  if (data && method === 'GET') requestUrl = parametrizeUrl(url, data);
  var response = fetch(requestUrl, {
    method: method,
    headers: Object.assign({
      Accept: 'application/json'
    }, headers),
    body: method !== 'GET' ? data : undefined,
    credentials: 'same-origin'
  });
  if (responseHandler) {
    response = responseHandler(response);
  } else {
    response = response.then(function (response) {
      return response.json().then(function (res) {
        return response.ok ? res : Promise.reject(res.error);
      });
    });
  }
  return response;
}
function indigoCall(method, url, baseUrl, defaultOptions, customHeaders) {
  return function (data, options, responseHandler) {
    var body = Object.assign({}, data);
    body.options = Object.assign(body.options || {}, defaultOptions, options);
    return request(method, baseUrl + url, JSON.stringify(body), _objectSpread$2({
      'Content-Type': 'application/json'
    }, customHeaders), responseHandler);
  };
}
var RemoteStructService = function () {
  function RemoteStructService(apiPath, defaultOptions, customHeaders) {
    _classCallCheck__default["default"](this, RemoteStructService);
    this.apiPath = apiPath;
    this.defaultOptions = defaultOptions;
    this.customHeaders = customHeaders;
  }
  _createClass__default["default"](RemoteStructService, [{
    key: "getInChIKey",
    value: function getInChIKey(struct) {
      return indigoCall('POST', 'indigo/convert', this.apiPath, this.defaultOptions, this.customHeaders)({
        struct: struct,
        output_format: 'chemical/x-inchi'
      }, {});
    }
  }, {
    key: "info",
    value: function () {
      var _info = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee() {
        var indigoVersion, imagoVersions, isAvailable, response;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              isAvailable = false;
              _context.prev = 1;
              _context.next = 4;
              return request('GET', this.apiPath + 'info');
            case 4:
              response = _context.sent;
              indigoVersion = response.indigo_version;
              imagoVersions = response.imago_versions;
              isAvailable = true;
              _context.next = 16;
              break;
            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](1);
              KetcherLogger.error('remoteStructService.ts::RemoteStructService::info', _context.t0);
              indigoVersion = '';
              imagoVersions = [];
              isAvailable = false;
            case 16:
              return _context.abrupt("return", {
                indigoVersion: indigoVersion,
                imagoVersions: imagoVersions,
                isAvailable: isAvailable
              });
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[1, 10]]);
      }));
      function info() {
        return _info.apply(this, arguments);
      }
      return info;
    }()
  }, {
    key: "convert",
    value: function convert(data, options) {
      return indigoCall('POST', 'indigo/convert', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }, {
    key: "layout",
    value: function layout(data, options) {
      return indigoCall('POST', 'indigo/layout', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }, {
    key: "clean",
    value: function clean(data, options) {
      return indigoCall('POST', 'indigo/clean', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }, {
    key: "aromatize",
    value: function aromatize(data, options) {
      return indigoCall('POST', 'indigo/aromatize', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }, {
    key: "dearomatize",
    value: function dearomatize(data, options) {
      return indigoCall('POST', 'indigo/dearomatize', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }, {
    key: "calculateCip",
    value: function calculateCip(data, options) {
      return indigoCall('POST', 'indigo/calculate_cip', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }, {
    key: "automap",
    value: function automap(data, options) {
      return indigoCall('POST', 'indigo/automap', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }, {
    key: "check",
    value: function check(data, options) {
      return indigoCall('POST', 'indigo/check', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }, {
    key: "calculate",
    value: function calculate(data, options) {
      return indigoCall('POST', 'indigo/calculate', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }, {
    key: "recognize",
    value: function recognize(blob, version) {
      var parVersion = version ? "?version=".concat(version) : '';
      var req = request('POST', this.apiPath + "imago/uploads".concat(parVersion), blob, {
        'Content-Type': blob.type || 'application/octet-stream'
      });
      var status = request.bind(null, 'GET', this.apiPath + 'imago/uploads/:id');
      return req.then(function (data) {
        return pollDeferred(status.bind(null, {
          id: data.upload_id
        }), function (response) {
          if (response.state === 'FAILURE') throw response;
          return response.state === 'SUCCESS';
        }, 500, 300);
      }).then(function (response) {
        return {
          struct: response.metadata.mol_str
        };
      });
    }
  }, {
    key: "generateImageAsBase64",
    value: function generateImageAsBase64(data, options) {
      var outputFormat = (options === null || options === void 0 ? void 0 : options.outputFormat) || 'png';
      var bondThickness = (options === null || options === void 0 ? void 0 : options.bondThickness) || defaultBondThickness;
      return indigoCall('POST', 'indigo/render', this.apiPath, this.defaultOptions, this.customHeaders)({
        struct: data
      }, {
        'render-output-format': outputFormat,
        'render-bond-line-width': bondThickness,
        'render-label-mode': getLabelRenderModeForIndigo()
      }, function (response) {
        return response.then(function (resp) {
          return resp.text();
        });
      });
    }
  }, {
    key: "toggleExplicitHydrogens",
    value: function toggleExplicitHydrogens(data, options) {
      return indigoCall('POST', 'indigo/convert_explicit_hydrogens', this.apiPath, this.defaultOptions, this.customHeaders)(data, options);
    }
  }]);
  return RemoteStructService;
}();

var RemoteStructServiceProvider = function () {
  function RemoteStructServiceProvider(apiPath, customHeaders) {
    _classCallCheck__default["default"](this, RemoteStructServiceProvider);
    _defineProperty__default["default"](this, "mode", 'remote');
    var currentApiPath = apiPath;
    this.customHeaders = customHeaders;
    var params = new URLSearchParams(document.location.search);
    if (params.has('api_path')) {
      currentApiPath = params.get('api_path');
    }
    this.apiPath = !currentApiPath || /\/$/.test(currentApiPath) ? currentApiPath : currentApiPath + '/';
  }
  _createClass__default["default"](RemoteStructServiceProvider, [{
    key: "createStructService",
    value: function createStructService(options) {
      return new RemoteStructService(this.apiPath, options, this.customHeaders);
    }
  }]);
  return RemoteStructServiceProvider;
}();

function _classPrivateFieldInitSpec$2(obj, privateMap, value) { _checkPrivateRedeclaration$2(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$2(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var defaultTypes = ['radicals', 'pseudoatoms', 'stereo', 'query', 'overlapping_atoms', 'overlapping_bonds', 'rgroups', 'chiral', '3d'];
var defaultCalcProps = ['molecular-weight', 'most-abundant-mass', 'monoisotopic-mass', 'gross', 'mass-composition'];
function convertStructToString(struct, serializer) {
  if (typeof struct !== 'string') {
    var aidMap = new Map();
    var result = struct.clone(null, null, false, aidMap);
    return serializer.serialize(result);
  }
  return struct;
}
var _structService$1 = new WeakMap();
var _ketSerializer = new WeakMap();
var Indigo = function () {
  function Indigo(structService) {
    _classCallCheck__default["default"](this, Indigo);
    _classPrivateFieldInitSpec$2(this, _structService$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$2(this, _ketSerializer, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet__default["default"](this, _structService$1, structService);
    _classPrivateFieldSet__default["default"](this, _ketSerializer, new KetSerializer());
  }
  _createClass__default["default"](Indigo, [{
    key: "info",
    value: function info() {
      return _classPrivateFieldGet__default["default"](this, _structService$1).info();
    }
  }, {
    key: "convert",
    value: function convert(struct, options) {
      var outputFormat = (options === null || options === void 0 ? void 0 : options.outputFormat) || exports.ChemicalMimeType.KET;
      return _classPrivateFieldGet__default["default"](this, _structService$1).convert({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        output_format: outputFormat
      });
    }
  }, {
    key: "layout",
    value: function layout(struct) {
      var _this = this;
      return _classPrivateFieldGet__default["default"](this, _structService$1).layout({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        output_format: exports.ChemicalMimeType.KET
      }).then(function (data) {
        return _classPrivateFieldGet__default["default"](_this, _ketSerializer).deserialize(data.struct);
      });
    }
  }, {
    key: "clean",
    value: function clean(struct) {
      var _this2 = this;
      return _classPrivateFieldGet__default["default"](this, _structService$1).clean({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        output_format: exports.ChemicalMimeType.KET
      }).then(function (data) {
        return _classPrivateFieldGet__default["default"](_this2, _ketSerializer).deserialize(data.struct);
      });
    }
  }, {
    key: "aromatize",
    value: function aromatize(struct) {
      var _this3 = this;
      return _classPrivateFieldGet__default["default"](this, _structService$1).aromatize({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        output_format: exports.ChemicalMimeType.KET
      }).then(function (data) {
        return _classPrivateFieldGet__default["default"](_this3, _ketSerializer).deserialize(data.struct);
      });
    }
  }, {
    key: "dearomatize",
    value: function dearomatize(struct) {
      var _this4 = this;
      return _classPrivateFieldGet__default["default"](this, _structService$1).dearomatize({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        output_format: exports.ChemicalMimeType.KET
      }).then(function (data) {
        return _classPrivateFieldGet__default["default"](_this4, _ketSerializer).deserialize(data.struct);
      });
    }
  }, {
    key: "calculateCip",
    value: function calculateCip(struct) {
      var _this5 = this;
      return _classPrivateFieldGet__default["default"](this, _structService$1).calculateCip({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        output_format: exports.ChemicalMimeType.KET
      }).then(function (data) {
        return _classPrivateFieldGet__default["default"](_this5, _ketSerializer).deserialize(data.struct);
      });
    }
  }, {
    key: "automap",
    value: function automap(struct, options) {
      var _this6 = this;
      var mode = (options === null || options === void 0 ? void 0 : options.mode) || 'discard';
      return _classPrivateFieldGet__default["default"](this, _structService$1).automap({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        output_format: exports.ChemicalMimeType.KET,
        mode: mode
      }).then(function (data) {
        return _classPrivateFieldGet__default["default"](_this6, _ketSerializer).deserialize(data.struct);
      });
    }
  }, {
    key: "check",
    value: function check(struct, options) {
      var types = (options === null || options === void 0 ? void 0 : options.types) || defaultTypes;
      return _classPrivateFieldGet__default["default"](this, _structService$1).check({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        types: types
      });
    }
  }, {
    key: "calculate",
    value: function calculate(struct, options) {
      var properties = (options === null || options === void 0 ? void 0 : options.properties) || defaultCalcProps;
      return _classPrivateFieldGet__default["default"](this, _structService$1).calculate({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        properties: properties
      });
    }
  }, {
    key: "recognize",
    value: function recognize(image, options) {
      var _this7 = this;
      var version = (options === null || options === void 0 ? void 0 : options.version) || '';
      return _classPrivateFieldGet__default["default"](this, _structService$1).recognize(image, version).then(function (data) {
        return _classPrivateFieldGet__default["default"](_this7, _ketSerializer).deserialize(data.struct);
      });
    }
  }, {
    key: "generateImageAsBase64",
    value: function generateImageAsBase64(struct, options) {
      var outputFormat = (options === null || options === void 0 ? void 0 : options.outputFormat) || 'png';
      var backgroundColor = (options === null || options === void 0 ? void 0 : options.backgroundColor) || '';
      var bondThickness = (options === null || options === void 0 ? void 0 : options.bondThickness) || defaultBondThickness;
      return _classPrivateFieldGet__default["default"](this, _structService$1).generateImageAsBase64(convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)), {
        outputFormat: outputFormat,
        backgroundColor: backgroundColor,
        bondThickness: bondThickness
      });
    }
  }, {
    key: "toggleExplicitHydrogens",
    value: function toggleExplicitHydrogens(struct) {
      var _this8 = this;
      return _classPrivateFieldGet__default["default"](this, _structService$1).toggleExplicitHydrogens({
        struct: convertStructToString(struct, _classPrivateFieldGet__default["default"](this, _ketSerializer)),
        output_format: exports.ChemicalMimeType.KET
      }).then(function (data) {
        return _classPrivateFieldGet__default["default"](_this8, _ketSerializer).deserialize(data.struct);
      });
    }
  }]);
  return Indigo;
}();

// Copyright Joyent, Inc. and other Node contributors.

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };

var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}
var events = EventEmitter;
var once_1 = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
events.once = once_1;

function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classPrivateFieldInitSpec$1(obj, privateMap, value) { _checkPrivateRedeclaration$1(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$1(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var allowedApiSettings = {
  'general.dearomatize-on-load': 'dearomatize-on-load',
  ignoreChiralFlag: 'ignoreChiralFlag',
  disableQueryElements: 'disableQueryElements',
  bondThickness: 'bondThickness'
};
var _structService = new WeakMap();
var _formatterFactory = new WeakMap();
var _editor = new WeakMap();
var _indigo = new WeakMap();
var _eventBus = new WeakMap();
var Ketcher = function () {
  function Ketcher(editor, structService, formatterFactory) {
    _classCallCheck__default["default"](this, Ketcher);
    _classPrivateFieldInitSpec$1(this, _structService, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$1(this, _formatterFactory, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$1(this, _editor, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$1(this, _indigo, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$1(this, _eventBus, {
      writable: true,
      value: void 0
    });
    assert__default["default"](editor != null);
    assert__default["default"](structService != null);
    assert__default["default"](formatterFactory != null);
    _classPrivateFieldSet__default["default"](this, _editor, editor);
    _classPrivateFieldSet__default["default"](this, _structService, structService);
    _classPrivateFieldSet__default["default"](this, _formatterFactory, formatterFactory);
    _classPrivateFieldSet__default["default"](this, _indigo, new Indigo(_classPrivateFieldGet__default["default"](this, _structService)));
    _classPrivateFieldSet__default["default"](this, _eventBus, new events.EventEmitter());
    this.logging = {
      enabled: false,
      level: exports.LogLevel.ERROR,
      showTrace: false
    };
  }
  _createClass__default["default"](Ketcher, [{
    key: "editor",
    get: function get() {
      return _classPrivateFieldGet__default["default"](this, _editor);
    }
  }, {
    key: "eventBus",
    get: function get() {
      return _classPrivateFieldGet__default["default"](this, _eventBus);
    }
  }, {
    key: "formatterFactory",
    get: function get() {
      return _classPrivateFieldGet__default["default"](this, _formatterFactory);
    }
  }, {
    key: "indigo",
    get: function get() {
      return _classPrivateFieldGet__default["default"](this, _indigo);
    }
  }, {
    key: "settings",
    get: function get() {
      var options = _classPrivateFieldGet__default["default"](this, _editor).options();
      var result = Object.entries(allowedApiSettings).reduce(function (acc, _ref) {
        var _ref2 = _slicedToArray__default["default"](_ref, 2),
          apiSetting = _ref2[0],
          clientSetting = _ref2[1];
        if (clientSetting in options) {
          return _objectSpread$1(_objectSpread$1({}, acc), {}, _defineProperty__default["default"]({}, apiSetting, clientSetting));
        }
        return acc;
      }, {});
      if (!Object.keys(result).length) {
        throw new Error('Allowed options are not provided');
      }
      return result;
    }
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      if (!settings) {
        throw new Error('Please provide settings');
      }
      var options = {};
      for (var _i = 0, _Object$entries = Object.entries(allowedApiSettings); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray__default["default"](_Object$entries[_i], 2),
          apiSetting = _Object$entries$_i[0],
          clientSetting = _Object$entries$_i[1];
        options[clientSetting] = settings[apiSetting];
      }
      if (Object.hasOwn(settings, 'disableCustomQuery')) {
        SettingsManager.disableCustomQuery = !!settings.disableCustomQuery;
      }
      return _classPrivateFieldGet__default["default"](this, _editor).setOptions(JSON.stringify(options));
    }
  }, {
    key: "getSmiles",
    value: function getSmiles() {
      var isExtended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (window.isPolymerEditorTurnedOn) {
        throw new Error('SMILES format is not available in macro mode');
      }
      var format = isExtended ? exports.SupportedFormat.smilesExt : exports.SupportedFormat.smiles;
      return getStructure(format, _classPrivateFieldGet__default["default"](this, _formatterFactory), this.editor.struct());
    }
  }, {
    key: "getMolfile",
    value: function () {
      var _getMolfile = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee(molfileFormat) {
        var _CoreEditor$provideEd;
        var formatPassed, format, molfile;
        return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.containsReaction()) {
                _context.next = 2;
                break;
              }
              throw Error('The structure cannot be saved as *.MOL due to reaction arrows.');
            case 2:
              formatPassed = molfileFormat === 'v3000' ? exports.SupportedFormat.molV3000 : exports.SupportedFormat.mol;
              format = molfileFormat ? formatPassed : exports.SupportedFormat.molAuto;
              _context.next = 6;
              return getStructure(format, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct(), (_CoreEditor$provideEd = CoreEditor.provideEditorInstance()) === null || _CoreEditor$provideEd === void 0 ? void 0 : _CoreEditor$provideEd.drawingEntitiesManager);
            case 6:
              molfile = _context.sent;
              return _context.abrupt("return", molfile);
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getMolfile(_x) {
        return _getMolfile.apply(this, arguments);
      }
      return getMolfile;
    }()
  }, {
    key: "getRxn",
    value: function () {
      var _getRxn = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee2() {
        var molfileFormat,
          format,
          rxnfile,
          _args2 = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              molfileFormat = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 'v2000';
              if (!window.isPolymerEditorTurnedOn) {
                _context2.next = 3;
                break;
              }
              throw new Error('RXN format is not available in macro mode');
            case 3:
              if (this.containsReaction()) {
                _context2.next = 5;
                break;
              }
              throw Error('The structure cannot be saved as *.RXN: there is no reaction arrows.');
            case 5:
              format = molfileFormat === 'v3000' ? exports.SupportedFormat.rxnV3000 : exports.SupportedFormat.rxn;
              _context2.next = 8;
              return getStructure(format, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct());
            case 8:
              rxnfile = _context2.sent;
              return _context2.abrupt("return", rxnfile);
            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getRxn() {
        return _getRxn.apply(this, arguments);
      }
      return getRxn;
    }()
  }, {
    key: "getKet",
    value: function getKet() {
      var _CoreEditor$provideEd2;
      return getStructure(exports.SupportedFormat.ket, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct(), (_CoreEditor$provideEd2 = CoreEditor.provideEditorInstance()) === null || _CoreEditor$provideEd2 === void 0 ? void 0 : _CoreEditor$provideEd2.drawingEntitiesManager);
    }
  }, {
    key: "getFasta",
    value: function getFasta() {
      var _CoreEditor$provideEd3;
      return getStructure(exports.SupportedFormat.fasta, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct(), (_CoreEditor$provideEd3 = CoreEditor.provideEditorInstance()) === null || _CoreEditor$provideEd3 === void 0 ? void 0 : _CoreEditor$provideEd3.drawingEntitiesManager);
    }
  }, {
    key: "getSequence",
    value: function getSequence() {
      var _CoreEditor$provideEd4;
      return getStructure(exports.SupportedFormat.sequence, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct(), (_CoreEditor$provideEd4 = CoreEditor.provideEditorInstance()) === null || _CoreEditor$provideEd4 === void 0 ? void 0 : _CoreEditor$provideEd4.drawingEntitiesManager);
    }
  }, {
    key: "getSmarts",
    value: function getSmarts() {
      if (window.isPolymerEditorTurnedOn) {
        throw new Error('SMARTS format is not available in macro mode');
      }
      return getStructure(exports.SupportedFormat.smarts, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct());
    }
  }, {
    key: "getCml",
    value: function getCml() {
      if (window.isPolymerEditorTurnedOn) {
        throw new Error('CML format is not available in macro mode');
      }
      return getStructure(exports.SupportedFormat.cml, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct());
    }
  }, {
    key: "getSdf",
    value: function getSdf() {
      var molfileFormat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'v2000';
      if (window.isPolymerEditorTurnedOn) {
        throw new Error('SDF format is not available in macro mode');
      }
      var format = molfileFormat === 'v2000' ? exports.SupportedFormat.sdf : exports.SupportedFormat.sdfV3000;
      return getStructure(format, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct());
    }
  }, {
    key: "getCDXml",
    value: function getCDXml() {
      if (window.isPolymerEditorTurnedOn) {
        throw new Error('CDXML format is not available in macro mode');
      }
      return getStructure(exports.SupportedFormat.cdxml, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct());
    }
  }, {
    key: "getCDX",
    value: function getCDX() {
      if (window.isPolymerEditorTurnedOn) {
        throw new Error('CDX format is not available in macro mode');
      }
      return getStructure(exports.SupportedFormat.cdx, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct());
    }
  }, {
    key: "getInchi",
    value: function getInchi() {
      var withAuxInfo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return getStructure(withAuxInfo ? exports.SupportedFormat.inChIAuxInfo : exports.SupportedFormat.inChI, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct());
    }
  }, {
    key: "getInChIKey",
    value: function () {
      var _getInChIKey = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee3() {
        var struct;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return getStructure(exports.SupportedFormat.ket, _classPrivateFieldGet__default["default"](this, _formatterFactory), _classPrivateFieldGet__default["default"](this, _editor).struct());
            case 2:
              struct = _context3.sent;
              return _context3.abrupt("return", _classPrivateFieldGet__default["default"](this, _structService).getInChIKey(struct));
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getInChIKey() {
        return _getInChIKey.apply(this, arguments);
      }
      return getInChIKey;
    }()
  }, {
    key: "containsReaction",
    value: function containsReaction() {
      var _editor$drawingEntiti;
      var editor = CoreEditor.provideEditorInstance();
      return this.editor.struct().hasRxnArrow() || (editor === null || editor === void 0 || (_editor$drawingEntiti = editor.drawingEntitiesManager) === null || _editor$drawingEntiti === void 0 ? void 0 : _editor$drawingEntiti.micromoleculesHiddenEntities.hasRxnArrow());
    }
  }, {
    key: "isQueryStructureSelected",
    value: function isQueryStructureSelected() {
      var structure = this.editor.struct();
      var selection = this.editor.selection();
      if (!selection) {
        return false;
      }
      var hasQueryAtoms = false;
      if (selection.atoms) {
        hasQueryAtoms = selection.atoms.some(function (atomId) {
          var atom = structure.atoms.get(atomId);
          assert__default["default"](atom);
          var sGroupIds = Array.from(atom.sgs.values());
          var isQueryComponentSGroup = sGroupIds.some(function (sGroupId) {
            var sGroup = structure.sgroups.get(sGroupId);
            assert__default["default"](sGroup);
            return SGroup.isQuerySGroup(sGroup);
          });
          return atom.isQuery() || isQueryComponentSGroup;
        });
      }
      var hasQueryBonds = false;
      if (selection.bonds) {
        hasQueryBonds = selection.bonds.some(function (bondId) {
          var bond = structure.bonds.get(bondId);
          assert__default["default"](bond);
          return bond.isQuery();
        });
      }
      return hasQueryAtoms || hasQueryBonds;
    }
  }, {
    key: "setMolecule",
    value: function () {
      var _setMolecule = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee5(structStr) {
        var _this = this;
        return _regeneratorRuntime__default["default"].wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              runAsyncAction( _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee4() {
                var struct;
                return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
                  while (1) switch (_context4.prev = _context4.next) {
                    case 0:
                      assert__default["default"](typeof structStr === 'string');
                      if (!window.isPolymerEditorTurnedOn) {
                        _context4.next = 7;
                        break;
                      }
                      deleteAllEntitiesOnCanvas();
                      _context4.next = 5;
                      return parseAndAddMacromoleculesOnCanvas(structStr, _classPrivateFieldGet__default["default"](_this, _structService));
                    case 5:
                      _context4.next = 14;
                      break;
                    case 7:
                      _context4.next = 9;
                      return prepareStructToRender(structStr, _classPrivateFieldGet__default["default"](_this, _structService), _this);
                    case 9:
                      struct = _context4.sent;
                      struct.rescale();
                      _classPrivateFieldGet__default["default"](_this, _editor).struct(struct);
                      _classPrivateFieldGet__default["default"](_this, _editor).zoomAccordingContent(struct);
                      _classPrivateFieldGet__default["default"](_this, _editor).centerStruct();
                    case 14:
                    case "end":
                      return _context4.stop();
                  }
                }, _callee4);
              })), this.eventBus);
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function setMolecule(_x2) {
        return _setMolecule.apply(this, arguments);
      }
      return setMolecule;
    }()
  }, {
    key: "addFragment",
    value: function () {
      var _addFragment = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee7(structStr) {
        var _this2 = this;
        return _regeneratorRuntime__default["default"].wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              runAsyncAction( _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee6() {
                var struct;
                return _regeneratorRuntime__default["default"].wrap(function _callee6$(_context6) {
                  while (1) switch (_context6.prev = _context6.next) {
                    case 0:
                      assert__default["default"](typeof structStr === 'string');
                      if (!window.isPolymerEditorTurnedOn) {
                        _context6.next = 6;
                        break;
                      }
                      _context6.next = 4;
                      return parseAndAddMacromoleculesOnCanvas(structStr, _classPrivateFieldGet__default["default"](_this2, _structService));
                    case 4:
                      _context6.next = 11;
                      break;
                    case 6:
                      _context6.next = 8;
                      return prepareStructToRender(structStr, _classPrivateFieldGet__default["default"](_this2, _structService), _this2);
                    case 8:
                      struct = _context6.sent;
                      struct.rescale();
                      _classPrivateFieldGet__default["default"](_this2, _editor).structToAddFragment(struct);
                    case 11:
                    case "end":
                      return _context6.stop();
                  }
                }, _callee6);
              })), this.eventBus);
            case 1:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function addFragment(_x3) {
        return _addFragment.apply(this, arguments);
      }
      return addFragment;
    }()
  }, {
    key: "layout",
    value: function () {
      var _layout = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee9() {
        var _this3 = this;
        return _regeneratorRuntime__default["default"].wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (!window.isPolymerEditorTurnedOn) {
                _context9.next = 2;
                break;
              }
              throw new Error('Layout is not available in macro mode');
            case 2:
              runAsyncAction( _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee8() {
                var struct, ketSerializer;
                return _regeneratorRuntime__default["default"].wrap(function _callee8$(_context8) {
                  while (1) switch (_context8.prev = _context8.next) {
                    case 0:
                      _context8.next = 2;
                      return _classPrivateFieldGet__default["default"](_this3, _indigo).layout(_classPrivateFieldGet__default["default"](_this3, _editor).struct());
                    case 2:
                      struct = _context8.sent;
                      ketSerializer = new KetSerializer();
                      _this3.setMolecule(ketSerializer.serialize(struct));
                    case 5:
                    case "end":
                      return _context8.stop();
                  }
                }, _callee8);
              })), this.eventBus);
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function layout() {
        return _layout.apply(this, arguments);
      }
      return layout;
    }()
  }, {
    key: "recognize",
    value: function recognize(image, version) {
      if (window.isPolymerEditorTurnedOn) {
        throw new Error('Recognize is not available in macro mode');
      }
      return _classPrivateFieldGet__default["default"](this, _indigo).recognize(image, {
        version: version
      });
    }
  }, {
    key: "generateImage",
    value: function () {
      var _generateImage = _asyncToGenerator__default["default"]( _regeneratorRuntime__default["default"].mark(function _callee10(data) {
        var options,
          meta,
          base64,
          byteCharacters,
          byteNumbers,
          i,
          byteArray,
          blob,
          _args10 = arguments;
        return _regeneratorRuntime__default["default"].wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {
                outputFormat: 'png',
                bondThickness: defaultBondThickness
              };
              meta = '';
              _context10.t0 = options.outputFormat;
              _context10.next = _context10.t0 === 'svg' ? 5 : _context10.t0 === 'png' ? 7 : 7;
              break;
            case 5:
              meta = 'image/svg+xml';
              return _context10.abrupt("break", 9);
            case 7:
              meta = 'image/png';
              options.outputFormat = 'png';
            case 9:
              _context10.next = 11;
              return _classPrivateFieldGet__default["default"](this, _structService).generateImageAsBase64(data, options);
            case 11:
              base64 = _context10.sent;
              byteCharacters = atob(base64);
              byteNumbers = new Array(byteCharacters.length);
              for (i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
              }
              byteArray = new Uint8Array(byteNumbers);
              blob = new Blob([byteArray], {
                type: meta
              });
              return _context10.abrupt("return", blob);
            case 18:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function generateImage(_x4) {
        return _generateImage.apply(this, arguments);
      }
      return generateImage;
    }()
  }]);
  return Ketcher;
}();

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty__default["default"](e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
var DefaultStructServiceOptions = {
  'smart-layout': true,
  'ignore-stereochemistry-errors': true,
  'mass-skip-error-on-pseudoatoms': false,
  'gross-formula-add-rsites': true,
  'aromatize-skip-superatoms': true,
  'dearomatize-on-load': false,
  'ignore-no-chiral-flag': false
};
var _structServiceProvider = new WeakMap();
var KetcherBuilder = function () {
  function KetcherBuilder() {
    _classCallCheck__default["default"](this, KetcherBuilder);
    _classPrivateFieldInitSpec(this, _structServiceProvider, {
      writable: true,
      value: void 0
    });
  }
  _createClass__default["default"](KetcherBuilder, [{
    key: "withStructServiceProvider",
    value: function withStructServiceProvider(structServiceProvider) {
      _classPrivateFieldSet__default["default"](this, _structServiceProvider, structServiceProvider);
      return this;
    }
  }, {
    key: "build",
    value: function build(editor, serviceOptions) {
      assert__default["default"](editor != null);
      assert__default["default"](_classPrivateFieldGet__default["default"](this, _structServiceProvider) != null);
      var mergedServiceOptions = _objectSpread(_objectSpread({}, DefaultStructServiceOptions), serviceOptions);
      var structService = _classPrivateFieldGet__default["default"](this, _structServiceProvider).createStructService(mergedServiceOptions);
      var ketcher = new Ketcher(editor, structService, new FormatterFactory(structService));
      ketcher[_classPrivateFieldGet__default["default"](this, _structServiceProvider).mode] = true;
      ketcherProvider.setKetcherInstance(ketcher);
      return ketcher;
    }
  }]);
  return KetcherBuilder;
}();

exports.ARROW_MAX_SNAPPING_ANGLE = ARROW_MAX_SNAPPING_ANGLE;
exports.Action = Action;
exports.AlignDescriptors = AlignDescriptors;
exports.Atom = Atom;
exports.AtomAdd = AtomAdd;
exports.AtomAttr = AtomAttr;
exports.AtomDelete = AtomDelete;
exports.AtomList = AtomList;
exports.AtomMove = AtomMove;
exports.BaseMonomer = BaseMonomer;
exports.BaseMonomerRenderer = BaseMonomerRenderer;
exports.BaseRenderer = BaseRenderer;
exports.Bond = Bond;
exports.BondAdd = BondAdd;
exports.BondAttr = BondAttr;
exports.BondDelete = BondDelete;
exports.BondMove = BondMove;
exports.Box2Abs = Box2Abs;
exports.CalcImplicitH = CalcImplicitH;
exports.CanvasLoad = CanvasLoad;
exports.Chem = Chem;
exports.ChemRenderer = ChemRenderer;
exports.CoordinateTransformation = CoordinateTransformation;
exports.Coordinates = Coordinates;
exports.CoreEditor = CoreEditor;
exports.DefaultStructServiceOptions = DefaultStructServiceOptions;
exports.EditorHistory = EditorHistory;
exports.ElementColor = ElementColor;
exports.Elements = Elements;
exports.EnhancedFlagMove = EnhancedFlagMove;
exports.FlexMode = FlexMode;
exports.FormatterFactory = FormatterFactory;
exports.Fragment = Fragment;
exports.FragmentAdd = FragmentAdd;
exports.FragmentAddStereoAtom = FragmentAddStereoAtom;
exports.FragmentDelete = FragmentDelete;
exports.FragmentDeleteStereoAtom = FragmentDeleteStereoAtom;
exports.FragmentSetProperties = FragmentSetProperties;
exports.FragmentStereoFlag = FragmentStereoFlag;
exports.FunctionalGroup = FunctionalGroup;
exports.FunctionalGroupsProvider = FunctionalGroupsProvider;
exports.Generics = Generics;
exports.HalfBond = HalfBond;
exports.Highlight = Highlight;
exports.KETCHER_SAVED_OPTIONS_KEY = KETCHER_SAVED_OPTIONS_KEY;
exports.KETCHER_SAVED_SETTINGS_KEY = KETCHER_SAVED_SETTINGS_KEY;
exports.KetSerializer = KetSerializer;
exports.Ketcher = Ketcher;
exports.KetcherBuilder = KetcherBuilder;
exports.KetcherLogger = KetcherLogger;
exports.Loop = Loop;
exports.LoopMove = LoopMove;
exports.MONOMER_CONST = MONOMER_CONST;
exports.MolSerializer = MolSerializer;
exports.MonomerCodeToGroup = MonomerCodeToGroup;
exports.MonomerMicromolecule = MonomerMicromolecule;
exports.Nucleoside = Nucleoside;
exports.Nucleotide = Nucleotide;
exports.OperationType = OperationType;
exports.Peptide = Peptide;
exports.PeptideRenderer = PeptideRenderer;
exports.Phosphate = Phosphate;
exports.PhosphateRenderer = PhosphateRenderer;
exports.Pile = Pile;
exports.PolymerBondRenderer = PolymerBondRenderer;
exports.Pool = Pool;
exports.RGroup = RGroup;
exports.RGroupAttachmentPoint = RGroupAttachmentPoint;
exports.RGroupAttachmentPointAdd = RGroupAttachmentPointAdd;
exports.RGroupAttachmentPointRemove = RGroupAttachmentPointRemove;
exports.RGroupAttr = RGroupAttr;
exports.RGroupFragment = RGroupFragment;
exports.RNABase = RNABase;
exports.RNABaseRenderer = RNABaseRenderer;
exports.ReAtom = ReAtom;
exports.ReBond = ReBond;
exports.ReEnhancedFlag = ReEnhancedFlag;
exports.ReFrag = ReFrag;
exports.ReObject = ReObject;
exports.ReRGroup = ReRGroup;
exports.ReRGroupAttachmentPoint = ReRGroupAttachmentPoint;
exports.ReRxnArrow = ReRxnArrow;
exports.ReRxnPlus = ReRxnPlus;
exports.ReSGroup = ReSGroup;
exports.ReSimpleObject = ReSimpleObject;
exports.ReStruct = ReStruct;
exports.ReText = ReText;
exports.RemoteStructService = RemoteStructService;
exports.RemoteStructServiceProvider = RemoteStructServiceProvider;
exports.Render = Render;
exports.RenderStruct = RenderStruct;
exports.RestoreDescriptorsPosition = RestoreDescriptorsPosition;
exports.RestoreIfThen = RestoreIfThen;
exports.RxnArrow = RxnArrow;
exports.RxnArrowAdd = RxnArrowAdd;
exports.RxnArrowDelete = RxnArrowDelete;
exports.RxnArrowMove = RxnArrowMove;
exports.RxnArrowResize = RxnArrowResize;
exports.RxnArrowRotate = RxnArrowRotate;
exports.RxnPlus = RxnPlus;
exports.RxnPlusAdd = RxnPlusAdd;
exports.RxnPlusDelete = RxnPlusDelete;
exports.RxnPlusMove = RxnPlusMove;
exports.SGroup = SGroup;
exports.SGroupAddToHierarchy = SGroupAddToHierarchy;
exports.SGroupAtomAdd = SGroupAtomAdd;
exports.SGroupAtomRemove = SGroupAtomRemove;
exports.SGroupAttachmentPoint = SGroupAttachmentPoint;
exports.SGroupAttr = SGroupAttr;
exports.SGroupBracketParams = SGroupBracketParams;
exports.SGroupCreate = SGroupCreate;
exports.SGroupDataMove = SGroupDataMove;
exports.SGroupDelete = SGroupDelete;
exports.SGroupForest = SGroupForest;
exports.SGroupRemoveFromHierarchy = SGroupRemoveFromHierarchy;
exports.SaltsAndSolventsProvider = SaltsAndSolventsProvider;
exports.Scale = Scale;
exports.ScrollbarContainer = ScrollbarContainer;
exports.SdfSerializer = SdfSerializer;
exports.SequenceMode = SequenceMode;
exports.SettingsManager = SettingsManager;
exports.SgContexts = SgContexts;
exports.SimpleObject = SimpleObject;
exports.SimpleObjectAdd = SimpleObjectAdd;
exports.SimpleObjectDelete = SimpleObjectDelete;
exports.SimpleObjectMove = SimpleObjectMove;
exports.SimpleObjectResize = SimpleObjectResize;
exports.SmiSerializer = SmiSerializer;
exports.SnakeMode = SnakeMode;
exports.StereoValidator = StereoValidator;
exports.Struct = Struct;
exports.Sugar = Sugar;
exports.SugarRenderer = SugarRenderer;
exports.Text = Text;
exports.TextCreate = TextCreate;
exports.TextDelete = TextDelete;
exports.TextMove = TextMove;
exports.TextUpdate = TextUpdate;
exports.UpdateIfThen = UpdateIfThen;
exports.Vec2 = Vec2;
exports.atomForNewBond = atomForNewBond;
exports.atomGetAttr = atomGetAttr;
exports.atomGetDegree = atomGetDegree;
exports.atomGetPos = atomGetPos;
exports.atomGetSGroups = atomGetSGroups;
exports.attachmentPointNames = attachmentPointNames;
exports.b64toBlob = b64toBlob;
exports.bondChangingAction = bondChangingAction;
exports.checkAtomValence = checkAtomValence;
exports.checkIsSmartPropertiesExist = checkIsSmartPropertiesExist;
exports.checkOverlapping = checkOverlapping;
exports.defaultBondThickness = defaultBondThickness;
exports.deleteAllEntitiesOnCanvas = deleteAllEntitiesOnCanvas;
exports.expandSGroupWithMultipleAttachmentPoint = expandSGroupWithMultipleAttachmentPoint;
exports.findStereoAtoms = findStereoAtoms;
exports.formatProperties = formatProperties;
exports.formatSelection = formatSelection;
exports.fromAromaticTemplateOnBond = fromAromaticTemplateOnBond;
exports.fromArrowAddition = fromArrowAddition;
exports.fromArrowDeletion = fromArrowDeletion;
exports.fromArrowResizing = fromArrowResizing;
exports.fromAtomAddition = fromAtomAddition;
exports.fromAtomMerge = fromAtomMerge;
exports.fromAtomsAttrs = fromAtomsAttrs;
exports.fromAtomsFragmentAttr = fromAtomsFragmentAttr;
exports.fromBondAddition = fromBondAddition;
exports.fromBondStereoUpdate = fromBondStereoUpdate;
exports.fromBondsAttrs = fromBondsAttrs;
exports.fromBondsMerge = fromBondsMerge;
exports.fromChain = fromChain;
exports.fromDescriptorsAlign = fromDescriptorsAlign;
exports.fromFlip = fromFlip;
exports.fromFragmentDeletion = fromFragmentDeletion;
exports.fromFragmentSplit = fromFragmentSplit;
exports.fromHighlightClear = fromHighlightClear;
exports.fromHighlightCreate = fromHighlightCreate;
exports.fromItemsFuse = fromItemsFuse;
exports.fromMultipleMove = fromMultipleMove;
exports.fromNewCanvas = fromNewCanvas;
exports.fromOneAtomDeletion = fromOneAtomDeletion;
exports.fromOneBondDeletion = fromOneBondDeletion;
exports.fromPaste = fromPaste;
exports.fromPlusAddition = fromPlusAddition;
exports.fromPlusDeletion = fromPlusDeletion;
exports.fromRGroupAttachmentPointAddition = fromRGroupAttachmentPointAddition;
exports.fromRGroupAttachmentPointDeletion = fromRGroupAttachmentPointDeletion;
exports.fromRGroupAttachmentPointUpdate = fromRGroupAttachmentPointUpdate;
exports.fromRGroupAttrs = fromRGroupAttrs;
exports.fromRGroupFragment = fromRGroupFragment;
exports.fromRotate = fromRotate;
exports.fromSeveralSgroupAddition = fromSeveralSgroupAddition;
exports.fromSgroupAction = fromSgroupAction;
exports.fromSgroupAddition = fromSgroupAddition;
exports.fromSgroupAttrs = fromSgroupAttrs;
exports.fromSgroupDeletion = fromSgroupDeletion;
exports.fromSimpleObjectAddition = fromSimpleObjectAddition;
exports.fromSimpleObjectDeletion = fromSimpleObjectDeletion;
exports.fromSimpleObjectResizing = fromSimpleObjectResizing;
exports.fromStereoAtomAttrs = fromStereoAtomAttrs;
exports.fromStereoFlagUpdate = fromStereoFlagUpdate;
exports.fromTemplateOnAtom = fromTemplateOnAtom;
exports.fromTemplateOnBondAction = fromTemplateOnBondAction;
exports.fromTemplateOnCanvas = fromTemplateOnCanvas;
exports.fromTextCreation = fromTextCreation;
exports.fromTextDeletion = fromTextDeletion;
exports.fromTextUpdating = fromTextUpdating;
exports.fromUpdateIfThen = fromUpdateIfThen;
exports.generateMenuShortcuts = generateMenuShortcuts;
exports.genericsList = genericsList;
exports.getAtomCustomQuery = getAtomCustomQuery;
exports.getAtomType = getAtomType;
exports.getColorFromStereoLabel = getColorFromStereoLabel;
exports.getCurrentCenterPointOfCanvas = getCurrentCenterPointOfCanvas;
exports.getFormatMimeTypeByFileName = getFormatMimeTypeByFileName;
exports.getHoverToFuse = getHoverToFuse;
exports.getItemsToFuse = getItemsToFuse;
exports.getLabelRenderModeForIndigo = getLabelRenderModeForIndigo;
exports.getPropertiesByFormat = getPropertiesByFormat;
exports.getPropertiesByImgFormat = getPropertiesByImgFormat;
exports.getRelSGroupsBySelection = getRelSGroupsBySelection;
exports.getSnappedArrowVector = getSnappedArrowVector;
exports.getStereoAtomsMap = getStereoAtomsMap;
exports.getStructure = getStructure;
exports.hotkeysConfiguration = hotkeysConfiguration;
exports.identifyStructFormat = identifyStructFormat;
exports.ifDef = ifDef;
exports.initHotKeys = initHotKeys;
exports.isAttachmentBond = isAttachmentBond;
exports.isControlKey = isControlKey;
exports.ketcherProvider = ketcherProvider;
exports.keyNorm = keyNorm;
exports.makeCircleFromEllipse = makeCircleFromEllipse;
exports.mergeFragmentsIfNeeded = mergeFragmentsIfNeeded;
exports.mergeMapOfItemsToSet = mergeMapOfItemsToSet;
exports.mergeSgroups = mergeSgroups;
exports.modesMap = modesMap;
exports.monomerFactory = monomerFactory;
exports.notifyItemsToMergeInitializationComplete = notifyItemsToMergeInitializationComplete;
exports.notifyRenderComplete = notifyRenderComplete;
exports.notifyRequestCompleted = notifyRequestCompleted;
exports.parseAndAddMacromoleculesOnCanvas = parseAndAddMacromoleculesOnCanvas;
exports.parseStruct = parseStruct;
exports.prepareStructToRender = prepareStructToRender;
exports.provideEditorSettings = provideEditorSettings;
exports.radicalElectrons = radicalElectrons;
exports.removeAtomFromSgroupIfNeeded = removeAtomFromSgroupIfNeeded;
exports.removeSgroupIfNeeded = removeSgroupIfNeeded;
exports.renderersEvents = renderersEvents;
exports.resetEditorEvents = resetEditorEvents;
exports.runAsyncAction = runAsyncAction;
exports.sGroupAttributeAction = sGroupAttributeAction;
exports.selectionKeys = selectionKeys;
exports.setExpandSGroup = setExpandSGroup;
exports.shortcutStr = shortcutStr;
exports.structSelection = structSelection;
exports.tfx = tfx;
exports.vectorUtils = vectorUtils;
//# sourceMappingURL=index.js.map
